package com.fr.swift.structure.lru;import java.util.Collection;import java.util.Map;import java.util.Set;import java.util.concurrent.ConcurrentHashMap;/** * Created by Hiram on 2015/4/21. */public class ConcurrentCacheHashMap<K, V> implements Map<K, V> {    ConcurrentHashMap<K, V> cache = new ConcurrentHashMap<K, V>();    private int cacheSize = 64;    public ConcurrentCacheHashMap() {    }    public ConcurrentCacheHashMap(int cacheSize) {        this.cacheSize = cacheSize;    }    @Override    public int size() {        return cache.size();    }    @Override    public boolean isEmpty() {        return cache.isEmpty();    }    @Override    public V get(Object key) {        return cache.get(key);    }    @Override    public boolean containsKey(Object key) {        return cache.containsKey(key);    }    @Override    public boolean containsValue(Object value) {        return cache.containsValue(value);    }    @Override    public V put(K key, V value) {        checkSize();        return cache.put(key, value);    }    private void checkSize() {        if (size() > cacheSize) {            clear();        }    }    @Override    public void putAll(Map<? extends K, ? extends V> m) {        checkSize();        cache.putAll(m);    }    @Override    public V remove(Object key) {        return cache.remove(key);    }    @Override    public void clear() {        cache.clear();    }    @Override    public Set<K> keySet() {        return cache.keySet();    }    @Override    public Collection<V> values() {        return cache.values();    }    @Override    public Set<Entry<K, V>> entrySet() {        return cache.entrySet();    }}