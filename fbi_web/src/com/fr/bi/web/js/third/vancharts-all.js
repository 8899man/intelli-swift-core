/**
 * Created by eason on 15/12/25.
 */

/**
 * Created by eason on 15/8/10.
 */
(function(){

    if (!window.Element) {
        Element = function() {};

        Element.prototype.matches = function(el, selector){
            var parent = el.parentNode
            var match = query(selector, parent)
            var len = match.length

            if (parent) {
                if (len) {
                    while (len--) {
                        if (match[len] == el) {
                            return true
                        }
                    }
                    return false
                } else {
                    return false
                }
            } else {
                var parent = document.createElement('div')
                parent.appendChild(el)
                match = query(selector, parent)
                parent.removeChild(el)
                return !!match.length
            }
        }
    }

    if(!window.CSSStyleDeclaration){
        window.CSSStyleDeclaration = function(){};

        CSSStyleDeclaration.prototype.getProperty = function(a) {
            return this.getAttribute(a);
        };

        CSSStyleDeclaration.prototype.setProperty = function(a,b) {
            return this.setAttribute(a,b);
        };

        CSSStyleDeclaration.prototype.removeProperty = function(a) {
            return this.removeAttribute(a);
        };
    }

    if (!Function.prototype.bind) {
        Function.prototype.bind = function() {
            if (typeof this !== 'function') {
                // closest thing possible to the ECMAScript 5
                // internal IsCallable function
                throw new TypeError('Function.prototype.bind - what is trying to be bound is not callable');
            }

            var __method = this;
            var args = Array.prototype.slice.call(arguments);
            var object=args.shift();
            return function() {
                return __method.apply(object,
                    args.concat(Array.prototype.slice.call(arguments)));
            }
        };
    }

    if(!Array.isArray){
        Array.isArray = function(value){
            return Object.prototype.toString.apply(value) === '[object Array]';
        }
    }

    // Production steps of ECMA-262, Edition 5, 15.4.4.19
    // Reference: http://es5.github.io/#x15.4.4.19
    if (!Array.prototype.map) {

        Array.prototype.map = function(callback, thisArg) {

            var T, A, k;

            if (this == null) {
                throw new TypeError(' this is null or not defined');
            }

            // 1. Let O be the result of calling ToObject passing the |this|
            //    value as the argument.
            var O = Object(this);

            // 2. Let lenValue be the result of calling the Get internal
            //    method of O with the argument "length".
            // 3. Let len be ToUint32(lenValue).
            var len = O.length >>> 0;

            // 4. If IsCallable(callback) is false, throw a TypeError exception.
            // See: http://es5.github.com/#x9.11
            if (typeof callback !== 'function') {
                throw new TypeError(callback + ' is not a function');
            }

            // 5. If thisArg was supplied, let T be thisArg; else let T be undefined.
            if (arguments.length > 1) {
                T = thisArg;
            }

            // 6. Let A be a new array created as if by the expression new Array(len)
            //    where Array is the standard built-in constructor with that name and
            //    len is the value of len.
            A = new Array(len);

            // 7. Let k be 0
            k = 0;

            // 8. Repeat, while k < len
            while (k < len) {

                var kValue, mappedValue;

                // a. Let Pk be ToString(k).
                //   This is implicit for LHS operands of the in operator
                // b. Let kPresent be the result of calling the HasProperty internal
                //    method of O with argument Pk.
                //   This step can be combined with c
                // c. If kPresent is true, then
                if (k in O) {

                    // i. Let kValue be the result of calling the Get internal
                    //    method of O with argument Pk.
                    kValue = O[k];

                    // ii. Let mappedValue be the result of calling the Call internal
                    //     method of callback with T as the this value and argument
                    //     list containing kValue, k, and O.
                    mappedValue = callback.call(T, kValue, k, O);

                    // iii. Call the DefineOwnProperty internal method of A with arguments
                    // Pk, Property Descriptor
                    // { Value: mappedValue,
                    //   Writable: true,
                    //   Enumerable: true,
                    //   Configurable: true },
                    // and false.

                    // In browsers that support Object.defineProperty, use the following:
                    // Object.defineProperty(A, k, {
                    //   value: mappedValue,
                    //   writable: true,
                    //   enumerable: true,
                    //   configurable: true
                    // });

                    // For best browser support, use the following:
                    A[k] = mappedValue;
                }
                // d. Increase k by 1.
                k++;
            }

            // 9. return A
            return A;
        };
    }

    if (!Array.prototype.reduce) {
        Array.prototype.reduce = function(callback /*, initialValue*/) {
            'use strict';
            if (this == null) {
                throw new TypeError('Array.prototype.reduce called on null or undefined');
            }
            if (typeof callback !== 'function') {
                throw new TypeError(callback + ' is not a function');
            }
            var t = Object(this), len = t.length >>> 0, k = 0, value;
            if (arguments.length == 2) {
                value = arguments[1];
            } else {
                while (k < len && !(k in t)) {
                    k++;
                }
                if (k >= len) {
                    throw new TypeError('Reduce of empty array with no initial value');
                }
                value = t[k++];
            }
            for (; k < len; k++) {
                if (k in t) {
                    value = callback(value, t[k], k, t);
                }
            }
            return value;
        };
    }

    if (!Array.prototype.filter) {
        Array.prototype.filter = function(fun/*, thisArg*/) {
            'use strict';

            if (this === void 0 || this === null) {
                throw new TypeError();
            }

            var t = Object(this);
            var len = t.length >>> 0;
            if (typeof fun !== 'function') {
                throw new TypeError();
            }

            var res = [];
            var thisArg = arguments.length >= 2 ? arguments[1] : void 0;
            for (var i = 0; i < len; i++) {
                if (i in t) {
                    var val = t[i];

                    // NOTE: Technically this should Object.defineProperty at
                    //       the next index, as push can be affected by
                    //       properties on Object.prototype and Array.prototype.
                    //       But that method's new, and collisions should be
                    //       rare, so use the more-compatible alternative.
                    if (fun.call(thisArg, val, i, t)) {
                        res.push(val);
                    }
                }
            }

            return res;
        };
    }

    if(!Array.prototype.forEach){
        if (!Array.prototype.forEach) {
            Array.prototype.forEach = function(callback, thisArg) {
                var T, k;
                if (this == null) {
                    throw new TypeError(' this is null or not defined');
                }
                var O = Object(this);
                var len = O.length >>> 0;

                if (typeof callback !== "function") {
                    throw new TypeError(callback + ' is not a function');
                }

                if (arguments.length > 1) {
                    T = thisArg;
                }

                k = 0;
                while (k < len) {
                    var kValue;
                    if (k in O) {
                        kValue = O[k];
                        callback.call(T, kValue, k, O);
                    }
                    k++;
                }
            };
        }
    }

    if (!Array.prototype.indexOf) {
        Array.prototype.indexOf = function(searchElement, fromIndex) {

            var k;

            if (this == null) {
                throw new TypeError('"this" is null or not defined');
            }

            var o = Object(this);

            var len = o.length >>> 0;

            if (len === 0) {
                return -1;
            }

            var n = +fromIndex || 0;

            if (Math.abs(n) === Infinity) {
                n = 0;
            }

            if (n >= len) {
                return -1;
            }

            k = Math.max(n >= 0 ? n : len - Math.abs(n), 0);

            while (k < len) {
                if (k in o && o[k] === searchElement) {
                    return k;
                }
                k++;
            }
            return -1;
        };
    }
}());

/*!
 * https://github.com/es-shims/es5-shim
 * @license es5-shim Copyright 2009-2015 by contributors, MIT License
 * see https://github.com/es-shims/es5-shim/blob/master/LICENSE
 */

// vim: ts=4 sts=4 sw=4 expandtab

// Add semicolon to prevent IIFE from being passed as argument to concatenated code.
;

// UMD (Universal Module Definition)
// see https://github.com/umdjs/umd/blob/master/returnExports.js
(function (root, factory) {
    'use strict';

    /* global define, exports, module */
    if (typeof define === 'function' && define.amd) {
        // AMD. Register as an anonymous module.
        define(factory);
    } else if (typeof exports === 'object') {
        // Node. Does not work with strict CommonJS, but
        // only CommonJS-like enviroments that support module.exports,
        // like Node.
        module.exports = factory();
    } else {
        // Browser globals (root is window)
        root.returnExports = factory();
    }
}(this, function () {

    var call = Function.prototype.call;
    var prototypeOfObject = Object.prototype;
    var owns = call.bind(prototypeOfObject.hasOwnProperty);
    var propertyIsEnumerable = call.bind(prototypeOfObject.propertyIsEnumerable);
    var toStr = call.bind(prototypeOfObject.toString);

// If JS engine supports accessors creating shortcuts.
    var defineGetter;
    var defineSetter;
    var lookupGetter;
    var lookupSetter;
    var supportsAccessors = owns(prototypeOfObject, '__defineGetter__');
    if (supportsAccessors) {
        /* eslint-disable no-underscore-dangle */
        defineGetter = call.bind(prototypeOfObject.__defineGetter__);
        defineSetter = call.bind(prototypeOfObject.__defineSetter__);
        lookupGetter = call.bind(prototypeOfObject.__lookupGetter__);
        lookupSetter = call.bind(prototypeOfObject.__lookupSetter__);
        /* eslint-enable no-underscore-dangle */
    }

// ES5 15.2.3.2
// http://es5.github.com/#x15.2.3.2
    if (!Object.getPrototypeOf) {
        // https://github.com/es-shims/es5-shim/issues#issue/2
        // http://ejohn.org/blog/objectgetprototypeof/
        // recommended by fschaefer on github
        //
        // sure, and webreflection says ^_^
        // ... this will nerever possibly return null
        // ... Opera Mini breaks here with infinite loops
        Object.getPrototypeOf = function getPrototypeOf(object) {
            /* eslint-disable no-proto */
            var proto = object.__proto__;
            /* eslint-enable no-proto */
            if (proto || proto === null) {
                return proto;
            } else if (toStr(object.constructor) === '[object Function]') {
                return object.constructor.prototype;
            } else if (!(object instanceof Object)) {
                // Correctly return null for Objects created with `Object.create(null)`
                // (shammed or native) or `{ __proto__: null}`.  Also returns null for
                // cross-realm objects on browsers that lack `__proto__` support (like
                // IE <11), but that's the best we can do.
                return null;
            } else {
                return prototypeOfObject;
            }
        };
    }

// ES5 15.2.3.3
// http://es5.github.com/#x15.2.3.3

    var doesGetOwnPropertyDescriptorWork = function doesGetOwnPropertyDescriptorWork(object) {
        try {
            object.sentinel = 0;
            return Object.getOwnPropertyDescriptor(object, 'sentinel').value === 0;
        } catch (exception) {
            return false;
        }
    };

// check whether getOwnPropertyDescriptor works if it's given. Otherwise, shim partially.
    if (Object.defineProperty) {
        var getOwnPropertyDescriptorWorksOnObject = doesGetOwnPropertyDescriptorWork({});
        var getOwnPropertyDescriptorWorksOnDom = typeof document === 'undefined' ||
            doesGetOwnPropertyDescriptorWork(document.createElement('div'));
        if (!getOwnPropertyDescriptorWorksOnDom || !getOwnPropertyDescriptorWorksOnObject) {
            var getOwnPropertyDescriptorFallback = Object.getOwnPropertyDescriptor;
        }
    }

    if (!Object.getOwnPropertyDescriptor || getOwnPropertyDescriptorFallback) {
        var ERR_NON_OBJECT = 'Object.getOwnPropertyDescriptor called on a non-object: ';

        /* eslint-disable no-proto */
        Object.getOwnPropertyDescriptor = function getOwnPropertyDescriptor(object, property) {
            if ((typeof object !== 'object' && typeof object !== 'function') || object === null) {
                throw new TypeError(ERR_NON_OBJECT + object);
            }

            // make a valiant attempt to use the real getOwnPropertyDescriptor
            // for I8's DOM elements.
            if (getOwnPropertyDescriptorFallback) {
                try {
                    return getOwnPropertyDescriptorFallback.call(Object, object, property);
                } catch (exception) {
                    // try the shim if the real one doesn't work
                }
            }

            var descriptor;

            // If object does not owns property return undefined immediately.
            if (!owns(object, property)) {
                return descriptor;
            }

            // If object has a property then it's for sure `configurable`, and
            // probably `enumerable`. Detect enumerability though.
            descriptor = {
                enumerable: propertyIsEnumerable(object, property),
                configurable: true
            };

            // If JS engine supports accessor properties then property may be a
            // getter or setter.
            if (supportsAccessors) {
                // Unfortunately `__lookupGetter__` will return a getter even
                // if object has own non getter property along with a same named
                // inherited getter. To avoid misbehavior we temporary remove
                // `__proto__` so that `__lookupGetter__` will return getter only
                // if it's owned by an object.
                var prototype = object.__proto__;
                var notPrototypeOfObject = object !== prototypeOfObject;
                // avoid recursion problem, breaking in Opera Mini when
                // Object.getOwnPropertyDescriptor(Object.prototype, 'toString')
                // or any other Object.prototype accessor
                if (notPrototypeOfObject) {
                    object.__proto__ = prototypeOfObject;
                }

                var getter = lookupGetter(object, property);
                var setter = lookupSetter(object, property);

                if (notPrototypeOfObject) {
                    // Once we have getter and setter we can put values back.
                    object.__proto__ = prototype;
                }

                if (getter || setter) {
                    if (getter) {
                        descriptor.get = getter;
                    }
                    if (setter) {
                        descriptor.set = setter;
                    }
                    // If it was accessor property we're done and return here
                    // in order to avoid adding `value` to the descriptor.
                    return descriptor;
                }
            }

            // If we got this far we know that object has an own property that is
            // not an accessor so we set it as a value and return descriptor.
            descriptor.value = object[property];
            descriptor.writable = true;
            return descriptor;
        };
        /* eslint-enable no-proto */
    }

// ES5 15.2.3.4
// http://es5.github.com/#x15.2.3.4
    if (!Object.getOwnPropertyNames) {
        Object.getOwnPropertyNames = function getOwnPropertyNames(object) {
            return Object.keys(object);
        };
    }

// ES5 15.2.3.5
// http://es5.github.com/#x15.2.3.5
    if (!Object.create) {

        // Contributed by Brandon Benvie, October, 2012
        var createEmpty;
        var supportsProto = !({ __proto__: null } instanceof Object);
        // the following produces false positives
        // in Opera Mini => not a reliable check
        // Object.prototype.__proto__ === null

        // Check for document.domain and active x support
        // No need to use active x approach when document.domain is not set
        // see https://github.com/es-shims/es5-shim/issues/150
        // variation of https://github.com/kitcambridge/es5-shim/commit/4f738ac066346
        /* global ActiveXObject */
        var shouldUseActiveX = function shouldUseActiveX() {
            // return early if document.domain not set
            if (!document.domain) {
                return false;
            }

            try {
                return !!new ActiveXObject('htmlfile');
            } catch (exception) {
                return false;
            }
        };

        // This supports IE8 when document.domain is used
        // see https://github.com/es-shims/es5-shim/issues/150
        // variation of https://github.com/kitcambridge/es5-shim/commit/4f738ac066346
        var getEmptyViaActiveX = function getEmptyViaActiveX() {
            var empty;
            var xDoc;

            xDoc = new ActiveXObject('htmlfile');

            xDoc.write('<script><\/script>');
            xDoc.close();

            empty = xDoc.parentWindow.Object.prototype;
            xDoc = null;

            return empty;
        };

        // The original implementation using an iframe
        // before the activex approach was added
        // see https://github.com/es-shims/es5-shim/issues/150
        var getEmptyViaIFrame = function getEmptyViaIFrame() {
            var iframe = document.createElement('iframe');
            var parent = document.body || document.documentElement;
            var empty;

            iframe.style.display = 'none';
            parent.appendChild(iframe);
            /* eslint-disable no-script-url */
            iframe.src = 'javascript:';
            /* eslint-enable no-script-url */

            empty = iframe.contentWindow.Object.prototype;
            parent.removeChild(iframe);
            iframe = null;

            return empty;
        };

        /* global document */
        if (supportsProto || typeof document === 'undefined') {
            createEmpty = function () {
                return { __proto__: null };
            };
        } else {
            // In old IE __proto__ can't be used to manually set `null`, nor does
            // any other method exist to make an object that inherits from nothing,
            // aside from Object.prototype itself. Instead, create a new global
            // object and *steal* its Object.prototype and strip it bare. This is
            // used as the prototype to create nullary objects.
            createEmpty = function () {
                // Determine which approach to use
                // see https://github.com/es-shims/es5-shim/issues/150
                var empty = shouldUseActiveX() ? getEmptyViaActiveX() : getEmptyViaIFrame();

                delete empty.constructor;
                delete empty.hasOwnProperty;
                delete empty.propertyIsEnumerable;
                delete empty.isPrototypeOf;
                delete empty.toLocaleString;
                delete empty.toString;
                delete empty.valueOf;

                var Empty = function Empty() {};
                Empty.prototype = empty;
                // short-circuit future calls
                createEmpty = function () {
                    return new Empty();
                };
                return new Empty();
            };
        }

        Object.create = function create(prototype, properties) {

            var object;
            var Type = function Type() {}; // An empty constructor.

            if (prototype === null) {
                object = createEmpty();
            } else {
                if (typeof prototype !== 'object' && typeof prototype !== 'function') {
                    // In the native implementation `parent` can be `null`
                    // OR *any* `instanceof Object`  (Object|Function|Array|RegExp|etc)
                    // Use `typeof` tho, b/c in old IE, DOM elements are not `instanceof Object`
                    // like they are in modern browsers. Using `Object.create` on DOM elements
                    // is...err...probably inappropriate, but the native version allows for it.
                    throw new TypeError('Object prototype may only be an Object or null'); // same msg as Chrome
                }
                Type.prototype = prototype;
                object = new Type();
                // IE has no built-in implementation of `Object.getPrototypeOf`
                // neither `__proto__`, but this manually setting `__proto__` will
                // guarantee that `Object.getPrototypeOf` will work as expected with
                // objects created using `Object.create`
                /* eslint-disable no-proto */
                object.__proto__ = prototype;
                /* eslint-enable no-proto */
            }

            if (properties !== void 0) {
                Object.defineProperties(object, properties);
            }

            return object;
        };
    }

// ES5 15.2.3.6
// http://es5.github.com/#x15.2.3.6

// Patch for WebKit and IE8 standard mode
// Designed by hax <hax.github.com>
// related issue: https://github.com/es-shims/es5-shim/issues#issue/5
// IE8 Reference:
//     http://msdn.microsoft.com/en-us/library/dd282900.aspx
//     http://msdn.microsoft.com/en-us/library/dd229916.aspx
// WebKit Bugs:
//     https://bugs.webkit.org/show_bug.cgi?id=36423

    var doesDefinePropertyWork = function doesDefinePropertyWork(object) {
        try {
            Object.defineProperty(object, 'sentinel', {});
            return 'sentinel' in object;
        } catch (exception) {
            return false;
        }
    };

// check whether defineProperty works if it's given. Otherwise,
// shim partially.
    if (Object.defineProperty) {
        var definePropertyWorksOnObject = doesDefinePropertyWork({});
        var definePropertyWorksOnDom = typeof document === 'undefined' ||
            doesDefinePropertyWork(document.createElement('div'));
        if (!definePropertyWorksOnObject || !definePropertyWorksOnDom) {
            var definePropertyFallback = Object.defineProperty,
                definePropertiesFallback = Object.defineProperties;
        }
    }

    if (!Object.defineProperty || definePropertyFallback) {
        var ERR_NON_OBJECT_DESCRIPTOR = 'Property description must be an object: ';
        var ERR_NON_OBJECT_TARGET = 'Object.defineProperty called on non-object: ';
        var ERR_ACCESSORS_NOT_SUPPORTED = 'getters & setters can not be defined on this javascript engine';

        Object.defineProperty = function defineProperty(object, property, descriptor) {
            if ((typeof object !== 'object' && typeof object !== 'function') || object === null) {
                throw new TypeError(ERR_NON_OBJECT_TARGET + object);
            }
            if ((typeof descriptor !== 'object' && typeof descriptor !== 'function') || descriptor === null) {
                throw new TypeError(ERR_NON_OBJECT_DESCRIPTOR + descriptor);
            }
            // make a valiant attempt to use the real defineProperty
            // for I8's DOM elements.
            if (definePropertyFallback) {
                try {
                    return definePropertyFallback.call(Object, object, property, descriptor);
                } catch (exception) {
                    // try the shim if the real one doesn't work
                }
            }

            // If it's a data property.
            if ('value' in descriptor) {
                // fail silently if 'writable', 'enumerable', or 'configurable'
                // are requested but not supported
                /*
                 // alternate approach:
                 if ( // can't implement these features; allow false but not true
                 ('writable' in descriptor && !descriptor.writable) ||
                 ('enumerable' in descriptor && !descriptor.enumerable) ||
                 ('configurable' in descriptor && !descriptor.configurable)
                 ))
                 throw new RangeError(
                 'This implementation of Object.defineProperty does not support configurable, enumerable, or writable.'
                 );
                 */

                if (supportsAccessors && (lookupGetter(object, property) || lookupSetter(object, property))) {
                    // As accessors are supported only on engines implementing
                    // `__proto__` we can safely override `__proto__` while defining
                    // a property to make sure that we don't hit an inherited
                    // accessor.
                    /* eslint-disable no-proto */
                    var prototype = object.__proto__;
                    object.__proto__ = prototypeOfObject;
                    // Deleting a property anyway since getter / setter may be
                    // defined on object itself.
                    delete object[property];
                    object[property] = descriptor.value;
                    // Setting original `__proto__` back now.
                    object.__proto__ = prototype;
                    /* eslint-enable no-proto */
                } else {
                    object[property] = descriptor.value;
                }
            } else {
                if (!supportsAccessors && (('get' in descriptor) || ('set' in descriptor))) {
                    throw new TypeError(ERR_ACCESSORS_NOT_SUPPORTED);
                }
                // If we got that far then getters and setters can be defined !!
                if ('get' in descriptor) {
                    defineGetter(object, property, descriptor.get);
                }
                if ('set' in descriptor) {
                    defineSetter(object, property, descriptor.set);
                }
            }
            return object;
        };
    }

// ES5 15.2.3.7
// http://es5.github.com/#x15.2.3.7
    if (!Object.defineProperties || definePropertiesFallback) {
        Object.defineProperties = function defineProperties(object, properties) {
            // make a valiant attempt to use the real defineProperties
            if (definePropertiesFallback) {
                try {
                    return definePropertiesFallback.call(Object, object, properties);
                } catch (exception) {
                    // try the shim if the real one doesn't work
                }
            }

            Object.keys(properties).forEach(function (property) {
                if (property !== '__proto__') {
                    Object.defineProperty(object, property, properties[property]);
                }
            });
            return object;
        };
    }

// ES5 15.2.3.8
// http://es5.github.com/#x15.2.3.8
    if (!Object.seal) {
        Object.seal = function seal(object) {
            if (Object(object) !== object) {
                throw new TypeError('Object.seal can only be called on Objects.');
            }
            // this is misleading and breaks feature-detection, but
            // allows "securable" code to "gracefully" degrade to working
            // but insecure code.
            return object;
        };
    }

// ES5 15.2.3.9
// http://es5.github.com/#x15.2.3.9
    if (!Object.freeze) {
        Object.freeze = function freeze(object) {
            if (Object(object) !== object) {
                throw new TypeError('Object.freeze can only be called on Objects.');
            }
            // this is misleading and breaks feature-detection, but
            // allows "securable" code to "gracefully" degrade to working
            // but insecure code.
            return object;
        };
    }

// detect a Rhino bug and patch it
    try {
        Object.freeze(function () {});
    } catch (exception) {
        Object.freeze = (function (freezeObject) {
            return function freeze(object) {
                if (typeof object === 'function') {
                    return object;
                } else {
                    return freezeObject(object);
                }
            };
        }(Object.freeze));
    }

// ES5 15.2.3.10
// http://es5.github.com/#x15.2.3.10
    if (!Object.preventExtensions) {
        Object.preventExtensions = function preventExtensions(object) {
            if (Object(object) !== object) {
                throw new TypeError('Object.preventExtensions can only be called on Objects.');
            }
            // this is misleading and breaks feature-detection, but
            // allows "securable" code to "gracefully" degrade to working
            // but insecure code.
            return object;
        };
    }

// ES5 15.2.3.11
// http://es5.github.com/#x15.2.3.11
    if (!Object.isSealed) {
        Object.isSealed = function isSealed(object) {
            if (Object(object) !== object) {
                throw new TypeError('Object.isSealed can only be called on Objects.');
            }
            return false;
        };
    }

// ES5 15.2.3.12
// http://es5.github.com/#x15.2.3.12
    if (!Object.isFrozen) {
        Object.isFrozen = function isFrozen(object) {
            if (Object(object) !== object) {
                throw new TypeError('Object.isFrozen can only be called on Objects.');
            }
            return false;
        };
    }

// ES5 15.2.3.13
// http://es5.github.com/#x15.2.3.13
    if (!Object.isExtensible) {
        Object.isExtensible = function isExtensible(object) {
            // 1. If Type(O) is not Object throw a TypeError exception.
            if (Object(object) !== object) {
                throw new TypeError('Object.isExtensible can only be called on Objects.');
            }
            // 2. Return the Boolean value of the [[Extensible]] internal property of O.
            var name = '';
            while (owns(object, name)) {
                name += '?';
            }
            object[name] = true;
            var returnValue = owns(object, name);
            delete object[name];
            return returnValue;
        };
    }

}));

// Copyright (c) 2013 Adobe Systems Incorporated. All rights reserved.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
// http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
// ┌────────────────────────────────────────────────────────────┐ \\
// │ Eve 0.4.2 - JavaScript Events Library                      │ \\
// ├────────────────────────────────────────────────────────────┤ \\
// │ Author Dmitry Baranovskiy (http://dmitry.baranovskiy.com/) │ \\
// └────────────────────────────────────────────────────────────┘ \\
(function (glob, factory) {
    if (typeof define === "function" && define.amd) {
        define("eve", function() {
            return factory();
        });
    } else if (typeof exports === "object") {
        module.exports = factory();
    } else {
        glob.eve = factory();
    }
}(this, function(){
    var version = "0.4.2",
        has = "hasOwnProperty",
        separator = /[\.\/]/,
        wildcard = "*",
        fun = function () {},
        numsort = function (a, b) {
            return a - b;
        },
        current_event,
        stop,
        events = {n: {}},
    /*\
     * eve
     [ method ]

     * Fires event with given `name`, given scope and other parameters.

     > Arguments

     - name (string) name of the *event*, dot (`.`) or slash (`/`) separated
     - scope (object) context for the event handlers
     - varargs (...) the rest of arguments will be sent to event handlers

     = (object) array of returned values from the listeners
     \*/
        eve = function (name, scope) {
            name = String(name);
            var e = events,
                oldstop = stop,
                args = Array.prototype.slice.call(arguments, 2),
                listeners = eve.listeners(name),
                z = 0,
                f = false,
                l,
                indexed = [],
                queue = {},
                out = [],
                ce = current_event,
                errors = [];
            current_event = name;
            stop = 0;
            for (var i = 0, ii = listeners.length; i < ii; i++) if ("zIndex" in listeners[i]) {
                indexed.push(listeners[i].zIndex);
                if (listeners[i].zIndex < 0) {
                    queue[listeners[i].zIndex] = listeners[i];
                }
            }
            indexed.sort(numsort);
            while (indexed[z] < 0) {
                l = queue[indexed[z++]];
                out.push(l.apply(scope, args));
                if (stop) {
                    stop = oldstop;
                    return out;
                }
            }
            for (i = 0; i < ii; i++) {
                l = listeners[i];
                if ("zIndex" in l) {
                    if (l.zIndex == indexed[z]) {
                        out.push(l.apply(scope, args));
                        if (stop) {
                            break;
                        }
                        do {
                            z++;
                            l = queue[indexed[z]];
                            l && out.push(l.apply(scope, args));
                            if (stop) {
                                break;
                            }
                        } while (l)
                    } else {
                        queue[l.zIndex] = l;
                    }
                } else {
                    out.push(l.apply(scope, args));
                    if (stop) {
                        break;
                    }
                }
            }
            stop = oldstop;
            current_event = ce;
            return out.length ? out : null;
        };
    // Undocumented. Debug only.
    eve._events = events;
    /*\
     * eve.listeners
     [ method ]

     * Internal method which gives you array of all event handlers that will be triggered by the given `name`.

     > Arguments

     - name (string) name of the event, dot (`.`) or slash (`/`) separated

     = (array) array of event handlers
     \*/
    eve.listeners = function (name) {
        var names = name.split(separator),
            e = events,
            item,
            items,
            k,
            i,
            ii,
            j,
            jj,
            nes,
            es = [e],
            out = [];
        for (i = 0, ii = names.length; i < ii; i++) {
            nes = [];
            for (j = 0, jj = es.length; j < jj; j++) {
                e = es[j].n;
                items = [e[names[i]], e[wildcard]];
                k = 2;
                while (k--) {
                    item = items[k];
                    if (item) {
                        nes.push(item);
                        out = out.concat(item.f || []);
                    }
                }
            }
            es = nes;
        }
        return out;
    };

    /*\
     * eve.on
     [ method ]
     **
     * Binds given event handler with a given name. You can use wildcards “`*`” for the names:
     | eve.on("*.under.*", f);
     | eve("mouse.under.floor"); // triggers f
     * Use @eve to trigger the listener.
     **
     > Arguments
     **
     - name (string) name of the event, dot (`.`) or slash (`/`) separated, with optional wildcards
     - f (function) event handler function
     **
     = (function) returned function accepts a single numeric parameter that represents z-index of the handler. It is an optional feature and only used when you need to ensure that some subset of handlers will be invoked in a given order, despite of the order of assignment.
     > Example:
     | eve.on("mouse", eatIt)(2);
     | eve.on("mouse", scream);
     | eve.on("mouse", catchIt)(1);
     * This will ensure that `catchIt()` function will be called before `eatIt()`.
     *
     * If you want to put your handler before non-indexed handlers, specify a negative value.
     * Note: I assume most of the time you don’t need to worry about z-index, but it’s nice to have this feature “just in case”.
     \*/
    eve.on = function (name, f) {
        name = String(name);
        if (typeof f != "function") {
            return function () {};
        }
        var names = name.split(separator),
            e = events;
        for (var i = 0, ii = names.length; i < ii; i++) {
            e = e.n;
            e = e.hasOwnProperty(names[i]) && e[names[i]] || (e[names[i]] = {n: {}});
        }
        e.f = e.f || [];
        for (i = 0, ii = e.f.length; i < ii; i++) if (e.f[i] == f) {
            return fun;
        }
        e.f.push(f);
        return function (zIndex) {
            if (+zIndex == +zIndex) {
                f.zIndex = +zIndex;
            }
        };
    };
    /*\
     * eve.f
     [ method ]
     **
     * Returns function that will fire given event with optional arguments.
     * Arguments that will be passed to the result function will be also
     * concated to the list of final arguments.
     | el.onclick = eve.f("click", 1, 2);
     | eve.on("click", function (a, b, c) {
     |     console.log(a, b, c); // 1, 2, [event object]
     | });
     > Arguments
     - event (string) event name
     - varargs (…) and any other arguments
     = (function) possible event handler function
     \*/
    eve.f = function (event) {
        var attrs = [].slice.call(arguments, 1);
        return function () {
            eve.apply(null, [event, null].concat(attrs).concat([].slice.call(arguments, 0)));
        };
    };
    /*\
     * eve.stop
     [ method ]
     **
     * Is used inside an event handler to stop the event, preventing any subsequent listeners from firing.
     \*/
    eve.stop = function () {
        stop = 1;
    };
    /*\
     * eve.nt
     [ method ]
     **
     * Could be used inside event handler to figure out actual name of the event.
     **
     > Arguments
     **
     - subname (string) #optional subname of the event
     **
     = (string) name of the event, if `subname` is not specified
     * or
     = (boolean) `true`, if current event’s name contains `subname`
     \*/
    eve.nt = function (subname) {
        if (subname) {
            return new RegExp("(?:\\.|\\/|^)" + subname + "(?:\\.|\\/|$)").test(current_event);
        }
        return current_event;
    };
    /*\
     * eve.nts
     [ method ]
     **
     * Could be used inside event handler to figure out actual name of the event.
     **
     **
     = (array) names of the event
     \*/
    eve.nts = function () {
        return current_event.split(separator);
    };
    /*\
     * eve.off
     [ method ]
     **
     * Removes given function from the list of event listeners assigned to given name.
     * If no arguments specified all the events will be cleared.
     **
     > Arguments
     **
     - name (string) name of the event, dot (`.`) or slash (`/`) separated, with optional wildcards
     - f (function) event handler function
     \*/
    /*\
     * eve.unbind
     [ method ]
     **
     * See @eve.off
     \*/
    eve.off = eve.unbind = function (name, f) {
        if (!name) {
            eve._events = events = {n: {}};
            return;
        }
        var names = name.split(separator),
            e,
            key,
            splice,
            i, ii, j, jj,
            cur = [events];
        for (i = 0, ii = names.length; i < ii; i++) {
            for (j = 0; j < cur.length; j += splice.length - 2) {
                splice = [j, 1];
                e = cur[j].n;
                if (names[i] != wildcard) {
                    if (e[names[i]]) {
                        splice.push(e[names[i]]);
                    }
                } else {
                    for (key in e) if (e[has](key)) {
                        splice.push(e[key]);
                    }
                }
                cur.splice.apply(cur, splice);
            }
        }
        for (i = 0, ii = cur.length; i < ii; i++) {
            e = cur[i];
            while (e.n) {
                if (f) {
                    if (e.f) {
                        for (j = 0, jj = e.f.length; j < jj; j++) if (e.f[j] == f) {
                            e.f.splice(j, 1);
                            break;
                        }
                        !e.f.length && delete e.f;
                    }
                    for (key in e.n) if (e.n[has](key) && e.n[key].f) {
                        var funcs = e.n[key].f;
                        for (j = 0, jj = funcs.length; j < jj; j++) if (funcs[j] == f) {
                            funcs.splice(j, 1);
                            break;
                        }
                        !funcs.length && delete e.n[key].f;
                    }
                } else {
                    delete e.f;
                    for (key in e.n) if (e.n[has](key) && e.n[key].f) {
                        delete e.n[key].f;
                    }
                }
                e = e.n;
            }
        }
    };
    /*\
     * eve.once
     [ method ]
     **
     * Binds given event handler with a given name to only run once then unbind itself.
     | eve.once("login", f);
     | eve("login"); // triggers f
     | eve("login"); // no listeners
     * Use @eve to trigger the listener.
     **
     > Arguments
     **
     - name (string) name of the event, dot (`.`) or slash (`/`) separated, with optional wildcards
     - f (function) event handler function
     **
     = (function) same return function as @eve.on
     \*/
    eve.once = function (name, f) {
        var f2 = function () {
            eve.unbind(name, f2);
            return f.apply(this, arguments);
        };
        return eve.on(name, f2);
    };
    /*\
     * eve.version
     [ property (string) ]
     **
     * Current version of the library.
     \*/
    eve.version = version;
    eve.toString = function () {
        return "You are running Eve " + version;
    };

    return eve;
}));

// ┌────────────────────────────────────────────────────────────────────┐ \\
// │ Raphaël 2.1.4 - JavaScript Vector Library                      │ \\
// ├────────────────────────────────────────────────────────────────────┤ \\
// │ Core Module                                                        │ \\
// ├────────────────────────────────────────────────────────────────────┤ \\
// │ Licensed under the MIT (http://raphaeljs.com/license.html) license.│ \\
// └────────────────────────────────────────────────────────────────────┘ \\

(function (glob, factory) {
    if (typeof define === "function" && define.amd) {
        define("raphael.core", ["eve"], function(eve) {
            return factory(eve);
        });
    } else if (typeof exports === "object") {
        module.exports = factory(require("eve"));
    } else {
        glob.Raphael = factory(glob.eve);
    }
}(this, function (eve) {
    /*\
     * Raphael
     [ method ]
     **
     * Creates a canvas object on which to draw.
     * You must do this first, as all future calls to drawing methods
     * from this instance will be bound to this canvas.
     > Parameters
     **
     - container (HTMLElement|string) DOM element or its ID which is going to be a parent for drawing surface
     - width (number)
     - height (number)
     - callback (function) #optional callback function which is going to be executed in the context of newly created paper
     * or
     - x (number)
     - y (number)
     - width (number)
     - height (number)
     - callback (function) #optional callback function which is going to be executed in the context of newly created paper
     * or
     - all (array) (first 3 or 4 elements in the array are equal to [containerID, width, height] or [x, y, width, height]. The rest are element descriptions in format {type: type, <attributes>}). See @Paper.add.
     - callback (function) #optional callback function which is going to be executed in the context of newly created paper
     * or
     - onReadyCallback (function) function that is going to be called on DOM ready event. You can also subscribe to this event via Eve’s “DOMLoad” event. In this case method returns `undefined`.
     = (object) @Paper
     > Usage
     | // Each of the following examples create a canvas
     | // that is 320px wide by 200px high.
     | // Canvas is created at the viewport’s 10,50 coordinate.
     | var paper = Raphael(10, 50, 320, 200);
     | // Canvas is created at the top left corner of the #notepad element
     | // (or its top right corner in dir="rtl" elements)
     | var paper = Raphael(document.getElementById("notepad"), 320, 200);
     | // Same as above
     | var paper = Raphael("notepad", 320, 200);
     | // Image dump
     | var set = Raphael(["notepad", 320, 200, {
     |     type: "rect",
     |     x: 10,
     |     y: 10,
     |     width: 25,
     |     height: 25,
     |     stroke: "#f00"
     | }, {
     |     type: "text",
     |     x: 30,
     |     y: 40,
     |     text: "Dump"
     | }]);
     \*/
    function R(first) {
        if (R.is(first, "function")) {
            return loaded ? first() : eve.on("raphael.DOMload", first);
        } else if (R.is(first, array)) {
            return R._engine.create[apply](R, first.splice(0, 3 + R.is(first[0], nu))).add(first);
        } else {
            var args = Array.prototype.slice.call(arguments, 0);
            if (R.is(args[args.length - 1], "function")) {
                var f = args.pop();
                return loaded ? f.call(R._engine.create[apply](R, args)) : eve.on("raphael.DOMload", function () {
                    f.call(R._engine.create[apply](R, args));
                });
            } else {
                return R._engine.create[apply](R, arguments);
            }
        }
    }
    R.version = "2.1.4";
    R.eve = eve;
    var loaded,
        separator = /[, ]+/,
        elements = {circle: 1, rect: 1, path: 1, ellipse: 1, text: 1, image: 1},
        formatrg = /\{(\d+)\}/g,
        proto = "prototype",
        has = "hasOwnProperty",
        g = {
            doc: document,
            win: window
        },
        oldRaphael = {
            was: Object.prototype[has].call(g.win, "Raphael"),
            is: g.win.Raphael
        },
        Paper = function () {
            /*\
             * Paper.ca
             [ property (object) ]
             **
             * Shortcut for @Paper.customAttributes
             \*/
            /*\
             * Paper.customAttributes
             [ property (object) ]
             **
             * If you have a set of attributes that you would like to represent
             * as a function of some number you can do it easily with custom attributes:
             > Usage
             | paper.customAttributes.hue = function (num) {
             |     num = num % 1;
             |     return {fill: "hsb(" + num + ", 0.75, 1)"};
             | };
             | // Custom attribute “hue” will change fill
             | // to be given hue with fixed saturation and brightness.
             | // Now you can use it like this:
             | var c = paper.circle(10, 10, 10).attr({hue: .45});
             | // or even like this:
             | c.animate({hue: 1}, 1e3);
             |
             | // You could also create custom attribute
             | // with multiple parameters:
             | paper.customAttributes.hsb = function (h, s, b) {
             |     return {fill: "hsb(" + [h, s, b].join(",") + ")"};
             | };
             | c.attr({hsb: "0.5 .8 1"});
             | c.animate({hsb: [1, 0, 0.5]}, 1e3);
             \*/
            this.ca = this.customAttributes = {};
        },
        paperproto,
        appendChild = "appendChild",
        apply = "apply",
        concat = "concat",
        supportsTouch = ('ontouchstart' in g.win) || g.win.DocumentTouch && g.doc instanceof DocumentTouch, //taken from Modernizr touch test
        E = "",
        S = " ",
        Str = String,
        split = "split",
        events = "click dblclick mousedown mousemove mouseout mouseover mouseup touchstart touchmove touchend touchcancel"[split](S),
        touchMap = {
            mousedown: "touchstart",
            mousemove: "touchmove",
            mouseup: "touchend"
        },
        lowerCase = Str.prototype.toLowerCase,
        math = Math,
        mmax = math.max,
        mmin = math.min,
        abs = math.abs,
        pow = math.pow,
        PI = math.PI,
        nu = "number",
        string = "string",
        array = "array",
        toString = "toString",
        fillString = "fill",
        objectToString = Object.prototype.toString,
        paper = {},
        push = "push",
        ISURL = R._ISURL = /^url\(['"]?(.+?)['"]?\)$/i,
        colourRegExp = /^\s*((#[a-f\d]{6})|(#[a-f\d]{3})|rgba?\(\s*([\d\.]+%?\s*,\s*[\d\.]+%?\s*,\s*[\d\.]+%?(?:\s*,\s*[\d\.]+%?)?)\s*\)|hsba?\(\s*([\d\.]+(?:deg|\xb0|%)?\s*,\s*[\d\.]+%?\s*,\s*[\d\.]+(?:%?\s*,\s*[\d\.]+)?)%?\s*\)|hsla?\(\s*([\d\.]+(?:deg|\xb0|%)?\s*,\s*[\d\.]+%?\s*,\s*[\d\.]+(?:%?\s*,\s*[\d\.]+)?)%?\s*\))\s*$/i,
        isnan = {"NaN": 1, "Infinity": 1, "-Infinity": 1},
        bezierrg = /^(?:cubic-)?bezier\(([^,]+),([^,]+),([^,]+),([^\)]+)\)/,
        round = math.round,
        setAttribute = "setAttribute",
        toFloat = parseFloat,
        toInt = parseInt,
        upperCase = Str.prototype.toUpperCase,
        availableAttrs = R._availableAttrs = {
            "arrow-end": "none",
            "arrow-start": "none",
            blur: 0,
            "clip-rect": "0 0 1e9 1e9",
            cursor: "default",
            cx: 0,
            cy: 0,
            fill: "#fff",
            "fill-opacity": 1,
            font: '10px "Arial"',
            "font-family": '"Arial"',
            "font-size": "10",
            "font-style": "normal",
            "font-weight": 400,
            gradient: 0,
            height: 0,
            href: "http://raphaeljs.com/",
            "letter-spacing": 0,
            opacity: 1,
            path: "M0,0",
            r: 0,
            rx: 0,
            ry: 0,
            src: "",
            stroke: "#000",
            "stroke-dasharray": "",
            "stroke-linecap": "butt",
            "stroke-linejoin": "butt",
            "stroke-miterlimit": 0,
            "stroke-opacity": 1,
            "stroke-width": 1,
            target: "_blank",
            "text-anchor": "middle",
            title: "Raphael",
            transform: "",
            width: 0,
            x: 0,
            y: 0
        },
        availableAnimAttrs = R._availableAnimAttrs = {
            blur: nu,
            "clip-rect": "csv",
            cx: nu,
            cy: nu,
            fill: "colour",
            "fill-opacity": nu,
            "font-size": nu,
            height: nu,
            opacity: nu,
            path: "path",
            r: nu,
            rx: nu,
            ry: nu,
            stroke: "colour",
            "stroke-opacity": nu,
            "stroke-width": nu,
            transform: "transform",
            width: nu,
            x: nu,
            y: nu
        },
        whitespace = /[\x09\x0a\x0b\x0c\x0d\x20\xa0\u1680\u180e\u2000\u2001\u2002\u2003\u2004\u2005\u2006\u2007\u2008\u2009\u200a\u202f\u205f\u3000\u2028\u2029]/g,
        commaSpaces = /[\x09\x0a\x0b\x0c\x0d\x20\xa0\u1680\u180e\u2000\u2001\u2002\u2003\u2004\u2005\u2006\u2007\u2008\u2009\u200a\u202f\u205f\u3000\u2028\u2029]*,[\x09\x0a\x0b\x0c\x0d\x20\xa0\u1680\u180e\u2000\u2001\u2002\u2003\u2004\u2005\u2006\u2007\u2008\u2009\u200a\u202f\u205f\u3000\u2028\u2029]*/,
        hsrg = {hs: 1, rg: 1},
        p2s = /,?([achlmqrstvxz]),?/gi,
        pathCommand = /([achlmrqstvz])[\x09\x0a\x0b\x0c\x0d\x20\xa0\u1680\u180e\u2000\u2001\u2002\u2003\u2004\u2005\u2006\u2007\u2008\u2009\u200a\u202f\u205f\u3000\u2028\u2029,]*((-?\d*\.?\d*(?:e[\-+]?\d+)?[\x09\x0a\x0b\x0c\x0d\x20\xa0\u1680\u180e\u2000\u2001\u2002\u2003\u2004\u2005\u2006\u2007\u2008\u2009\u200a\u202f\u205f\u3000\u2028\u2029]*,?[\x09\x0a\x0b\x0c\x0d\x20\xa0\u1680\u180e\u2000\u2001\u2002\u2003\u2004\u2005\u2006\u2007\u2008\u2009\u200a\u202f\u205f\u3000\u2028\u2029]*)+)/ig,
        tCommand = /([rstm])[\x09\x0a\x0b\x0c\x0d\x20\xa0\u1680\u180e\u2000\u2001\u2002\u2003\u2004\u2005\u2006\u2007\u2008\u2009\u200a\u202f\u205f\u3000\u2028\u2029,]*((-?\d*\.?\d*(?:e[\-+]?\d+)?[\x09\x0a\x0b\x0c\x0d\x20\xa0\u1680\u180e\u2000\u2001\u2002\u2003\u2004\u2005\u2006\u2007\u2008\u2009\u200a\u202f\u205f\u3000\u2028\u2029]*,?[\x09\x0a\x0b\x0c\x0d\x20\xa0\u1680\u180e\u2000\u2001\u2002\u2003\u2004\u2005\u2006\u2007\u2008\u2009\u200a\u202f\u205f\u3000\u2028\u2029]*)+)/ig,
        pathValues = /(-?\d*\.?\d*(?:e[\-+]?\d+)?)[\x09\x0a\x0b\x0c\x0d\x20\xa0\u1680\u180e\u2000\u2001\u2002\u2003\u2004\u2005\u2006\u2007\u2008\u2009\u200a\u202f\u205f\u3000\u2028\u2029]*,?[\x09\x0a\x0b\x0c\x0d\x20\xa0\u1680\u180e\u2000\u2001\u2002\u2003\u2004\u2005\u2006\u2007\u2008\u2009\u200a\u202f\u205f\u3000\u2028\u2029]*/ig,
        radial_gradient = R._radial_gradient = /^r(?:\(([^,]+?)[\x09\x0a\x0b\x0c\x0d\x20\xa0\u1680\u180e\u2000\u2001\u2002\u2003\u2004\u2005\u2006\u2007\u2008\u2009\u200a\u202f\u205f\u3000\u2028\u2029]*,[\x09\x0a\x0b\x0c\x0d\x20\xa0\u1680\u180e\u2000\u2001\u2002\u2003\u2004\u2005\u2006\u2007\u2008\u2009\u200a\u202f\u205f\u3000\u2028\u2029]*([^\)]+?)\))?/,
        eldata = {},
        sortByKey = function (a, b) {
            return a.key - b.key;
        },
        sortByNumber = function (a, b) {
            return toFloat(a) - toFloat(b);
        },
        fun = function () {},
        pipe = function (x) {
            return x;
        },
        rectPath = R._rectPath = function (x, y, w, h, r) {
            if (r) {
                return [["M", x + r, y], ["l", w - r * 2, 0], ["a", r, r, 0, 0, 1, r, r], ["l", 0, h - r * 2], ["a", r, r, 0, 0, 1, -r, r], ["l", r * 2 - w, 0], ["a", r, r, 0, 0, 1, -r, -r], ["l", 0, r * 2 - h], ["a", r, r, 0, 0, 1, r, -r], ["z"]];
            }
            return [["M", x, y], ["l", w, 0], ["l", 0, h], ["l", -w, 0], ["z"]];
        },
        ellipsePath = function (x, y, rx, ry) {
            if (ry == null) {
                ry = rx;
            }
            return [["M", x, y], ["m", 0, -ry], ["a", rx, ry, 0, 1, 1, 0, 2 * ry], ["a", rx, ry, 0, 1, 1, 0, -2 * ry], ["z"]];
        },
        getPath = R._getPath = {
            path: function (el) {
                return el.attr("path");
            },
            circle: function (el) {
                var a = el.attrs;
                return ellipsePath(a.cx, a.cy, a.r);
            },
            ellipse: function (el) {
                var a = el.attrs;
                return ellipsePath(a.cx, a.cy, a.rx, a.ry);
            },
            rect: function (el) {
                var a = el.attrs;
                return rectPath(a.x, a.y, a.width, a.height, a.r);
            },
            image: function (el) {
                var a = el.attrs;
                return rectPath(a.x, a.y, a.width, a.height);
            },
            text: function (el) {
                var bbox = el._getBBox();
                return rectPath(bbox.x, bbox.y, bbox.width, bbox.height);
            },
            set : function(el) {
                var bbox = el._getBBox();
                return rectPath(bbox.x, bbox.y, bbox.width, bbox.height);
            }
        },
    /*\
     * Raphael.mapPath
     [ method ]
     **
     * Transform the path string with given matrix.
     > Parameters
     - path (string) path string
     - matrix (object) see @Matrix
     = (string) transformed path string
     \*/
        mapPath = R.mapPath = function (path, matrix) {
            if (!matrix) {
                return path;
            }
            var x, y, i, j, ii, jj, pathi;
            path = path2curve(path);
            for (i = 0, ii = path.length; i < ii; i++) {
                pathi = path[i];
                for (j = 1, jj = pathi.length; j < jj; j += 2) {
                    x = matrix.x(pathi[j], pathi[j + 1]);
                    y = matrix.y(pathi[j], pathi[j + 1]);
                    pathi[j] = x;
                    pathi[j + 1] = y;
                }
            }
            return path;
        };

    R._g = g;
    /*\
     * Raphael.type
     [ property (string) ]
     **
     * Can be “SVG”, “VML” or empty, depending on browser support.
     \*/
    R.type = (g.win.SVGAngle || g.doc.implementation.hasFeature("http://www.w3.org/TR/SVG11/feature#BasicStructure", "1.1") ? "SVG" : "VML");
    if (R.type == "VML") {
        var d = g.doc.createElement("div"),
            b;
        d.innerHTML = '<v:shape adj="1"/>';
        b = d.firstChild;
        b.style.behavior = "url(#default#VML)";
        if (!(b && typeof b.adj == "object")) {
            return (R.type = E);
        }
        d = null;
    }
    /*\
     * Raphael.svg
     [ property (boolean) ]
     **
     * `true` if browser supports SVG.
     \*/
    /*\
     * Raphael.vml
     [ property (boolean) ]
     **
     * `true` if browser supports VML.
     \*/
    R.svg = !(R.vml = R.type == "VML");
    R._Paper = Paper;
    /*\
     * Raphael.fn
     [ property (object) ]
     **
     * You can add your own method to the canvas. For example if you want to draw a pie chart,
     * you can create your own pie chart function and ship it as a Raphaël plugin. To do this
     * you need to extend the `Raphael.fn` object. You should modify the `fn` object before a
     * Raphaël instance is created, otherwise it will take no effect. Please note that the
     * ability for namespaced plugins was removed in Raphael 2.0. It is up to the plugin to
     * ensure any namespacing ensures proper context.
     > Usage
     | Raphael.fn.arrow = function (x1, y1, x2, y2, size) {
     |     return this.path( ... );
     | };
     | // or create namespace
     | Raphael.fn.mystuff = {
     |     arrow: function () {…},
     |     star: function () {…},
     |     // etc…
     | };
     | var paper = Raphael(10, 10, 630, 480);
     | // then use it
     | paper.arrow(10, 10, 30, 30, 5).attr({fill: "#f00"});
     | paper.mystuff.arrow();
     | paper.mystuff.star();
     \*/
    R.fn = paperproto = Paper.prototype = R.prototype;
    R._id = 0;
    R._oid = 0;
    /*\
     * Raphael.is
     [ method ]
     **
     * Handful of replacements for `typeof` operator.
     > Parameters
     - o (…) any object or primitive
     - type (string) name of the type, i.e. “string”, “function”, “number”, etc.
     = (boolean) is given value is of given type
     \*/
    R.is = function (o, type) {
        type = lowerCase.call(type);
        if (type == "finite") {
            return !isnan[has](+o);
        }
        if (type == "array") {
            return o instanceof Array;
        }
        return  (type == "null" && o === null) ||
            (type == typeof o && o !== null) ||
            (type == "object" && o === Object(o)) ||
            (type == "array" && Array.isArray && Array.isArray(o)) ||
            objectToString.call(o).slice(8, -1).toLowerCase() == type;
    };

    function clone(obj) {
        if (typeof obj == "function" || Object(obj) !== obj) {
            return obj;
        }
        var res = new obj.constructor;
        for (var key in obj) if (obj[has](key)) {
            res[key] = clone(obj[key]);
        }
        return res;
    }

    /*\
     * Raphael.angle
     [ method ]
     **
     * Returns angle between two or three points
     > Parameters
     - x1 (number) x coord of first point
     - y1 (number) y coord of first point
     - x2 (number) x coord of second point
     - y2 (number) y coord of second point
     - x3 (number) #optional x coord of third point
     - y3 (number) #optional y coord of third point
     = (number) angle in degrees.
     \*/
    R.angle = function (x1, y1, x2, y2, x3, y3) {
        if (x3 == null) {
            var x = x1 - x2,
                y = y1 - y2;
            if (!x && !y) {
                return 0;
            }
            return (180 + math.atan2(-y, -x) * 180 / PI + 360) % 360;
        } else {
            return R.angle(x1, y1, x3, y3) - R.angle(x2, y2, x3, y3);
        }
    };
    /*\
     * Raphael.rad
     [ method ]
     **
     * Transform angle to radians
     > Parameters
     - deg (number) angle in degrees
     = (number) angle in radians.
     \*/
    R.rad = function (deg) {
        return deg % 360 * PI / 180;
    };
    /*\
     * Raphael.deg
     [ method ]
     **
     * Transform angle to degrees
     > Parameters
     - rad (number) angle in radians
     = (number) angle in degrees.
     \*/
    R.deg = function (rad) {
        return Math.round ((rad * 180 / PI% 360)* 1000) / 1000;
    };
    /*\
     * Raphael.snapTo
     [ method ]
     **
     * Snaps given value to given grid.
     > Parameters
     - values (array|number) given array of values or step of the grid
     - value (number) value to adjust
     - tolerance (number) #optional tolerance for snapping. Default is `10`.
     = (number) adjusted value.
     \*/
    R.snapTo = function (values, value, tolerance) {
        tolerance = R.is(tolerance, "finite") ? tolerance : 10;
        if (R.is(values, array)) {
            var i = values.length;
            while (i--) if (abs(values[i] - value) <= tolerance) {
                return values[i];
            }
        } else {
            values = +values;
            var rem = value % values;
            if (rem < tolerance) {
                return value - rem;
            }
            if (rem > values - tolerance) {
                return value - rem + values;
            }
        }
        return value;
    };

    /*\
     * Raphael.createUUID
     [ method ]
     **
     * Returns RFC4122, version 4 ID
     \*/
    var createUUID = R.createUUID = (function (uuidRegEx, uuidReplacer) {
        return function () {
            return "xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx".replace(uuidRegEx, uuidReplacer).toUpperCase();
        };
    })(/[xy]/g, function (c) {
        var r = math.random() * 16 | 0,
            v = c == "x" ? r : (r & 3 | 8);
        return v.toString(16);
    });

    /*\
     * Raphael.setWindow
     [ method ]
     **
     * Used when you need to draw in `&lt;iframe>`. Switched window to the iframe one.
     > Parameters
     - newwin (window) new window object
     \*/
    R.setWindow = function (newwin) {
        eve("raphael.setWindow", R, g.win, newwin);
        g.win = newwin;
        g.doc = g.win.document;
        if (R._engine.initWin) {
            R._engine.initWin(g.win);
        }
    };
    var toHex = function (color) {
            if (R.vml) {
                // http://dean.edwards.name/weblog/2009/10/convert-any-colour-value-to-hex-in-msie/
                var trim = /^\s+|\s+$/g;
                var bod;
                try {
                    var docum = new ActiveXObject("htmlfile");
                    docum.write("<body>");
                    docum.close();
                    bod = docum.body;
                } catch(e) {
                    bod = createPopup().document.body;
                }
                var range = bod.createTextRange();
                toHex = cacher(function (color) {
                    try {
                        bod.style.color = Str(color).replace(trim, E);
                        var value = range.queryCommandValue("ForeColor");
                        value = ((value & 255) << 16) | (value & 65280) | ((value & 16711680) >>> 16);
                        return "#" + ("000000" + value.toString(16)).slice(-6);
                    } catch(e) {
                        return "none";
                    }
                });
            } else {
                var i = g.doc.createElement("i");
                i.title = "Rapha\xebl Colour Picker";
                i.style.display = "none";
                g.doc.body.appendChild(i);
                toHex = cacher(function (color) {
                    i.style.color = color;
                    return g.doc.defaultView.getComputedStyle(i, E).getPropertyValue("color");
                });
            }
            return toHex(color);
        },
        hsbtoString = function () {
            return "hsb(" + [this.h, this.s, this.b] + ")";
        },
        hsltoString = function () {
            return "hsl(" + [this.h, this.s, this.l] + ")";
        },
        rgbtoString = function () {
            return this.hex;
        },
        prepareRGB = function (r, g, b) {
            if (g == null && R.is(r, "object") && "r" in r && "g" in r && "b" in r) {
                b = r.b;
                g = r.g;
                r = r.r;
            }
            if (g == null && R.is(r, string)) {
                var clr = R.getRGB(r);
                r = clr.r;
                g = clr.g;
                b = clr.b;
            }
            if (r > 1 || g > 1 || b > 1) {
                r /= 255;
                g /= 255;
                b /= 255;
            }

            return [r, g, b];
        },
        packageRGB = function (r, g, b, o) {
            r *= 255;
            g *= 255;
            b *= 255;
            var rgb = {
                r: r,
                g: g,
                b: b,
                hex: R.rgb(r, g, b),
                toString: rgbtoString
            };
            R.is(o, "finite") && (rgb.opacity = o);
            return rgb;
        };

    /*\
     * Raphael.color
     [ method ]
     **
     * Parses the color string and returns object with all values for the given color.
     > Parameters
     - clr (string) color string in one of the supported formats (see @Raphael.getRGB)
     = (object) Combined RGB & HSB object in format:
     o {
     o     r (number) red,
     o     g (number) green,
     o     b (number) blue,
     o     hex (string) color in HTML/CSS format: #••••••,
     o     error (boolean) `true` if string can’t be parsed,
     o     h (number) hue,
     o     s (number) saturation,
     o     v (number) value (brightness),
     o     l (number) lightness
     o }
     \*/
    R.color = function (clr) {
        var rgb;
        if (R.is(clr, "object") && "h" in clr && "s" in clr && "b" in clr) {
            rgb = R.hsb2rgb(clr);
            clr.r = rgb.r;
            clr.g = rgb.g;
            clr.b = rgb.b;
            clr.hex = rgb.hex;
        } else if (R.is(clr, "object") && "h" in clr && "s" in clr && "l" in clr) {
            rgb = R.hsl2rgb(clr);
            clr.r = rgb.r;
            clr.g = rgb.g;
            clr.b = rgb.b;
            clr.hex = rgb.hex;
        } else {
            if (R.is(clr, "string")) {
                clr = R.getRGB(clr);
            }
            if (R.is(clr, "object") && "r" in clr && "g" in clr && "b" in clr) {
                rgb = R.rgb2hsl(clr);
                clr.h = rgb.h;
                clr.s = rgb.s;
                clr.l = rgb.l;
                rgb = R.rgb2hsb(clr);
                clr.v = rgb.b;
            } else {
                clr = {hex: "none"};
                clr.r = clr.g = clr.b = clr.h = clr.s = clr.v = clr.l = -1;
            }
        }
        clr.toString = rgbtoString;
        return clr;
    };
    /*\
     * Raphael.hsb2rgb
     [ method ]
     **
     * Converts HSB values to RGB object.
     > Parameters
     - h (number) hue
     - s (number) saturation
     - v (number) value or brightness
     = (object) RGB object in format:
     o {
     o     r (number) red,
     o     g (number) green,
     o     b (number) blue,
     o     hex (string) color in HTML/CSS format: #••••••
     o }
     \*/
    R.hsb2rgb = function (h, s, v, o) {
        if (this.is(h, "object") && "h" in h && "s" in h && "b" in h) {
            v = h.b;
            s = h.s;
            o = h.o;
            h = h.h;
        }
        h *= 360;
        var R, G, B, X, C;
        h = (h % 360) / 60;
        C = v * s;
        X = C * (1 - abs(h % 2 - 1));
        R = G = B = v - C;

        h = ~~h;
        R += [C, X, 0, 0, X, C][h];
        G += [X, C, C, X, 0, 0][h];
        B += [0, 0, X, C, C, X][h];
        return packageRGB(R, G, B, o);
    };
    /*\
     * Raphael.hsl2rgb
     [ method ]
     **
     * Converts HSL values to RGB object.
     > Parameters
     - h (number) hue
     - s (number) saturation
     - l (number) luminosity
     = (object) RGB object in format:
     o {
     o     r (number) red,
     o     g (number) green,
     o     b (number) blue,
     o     hex (string) color in HTML/CSS format: #••••••
     o }
     \*/
    R.hsl2rgb = function (h, s, l, o) {
        if (this.is(h, "object") && "h" in h && "s" in h && "l" in h) {
            l = h.l;
            s = h.s;
            h = h.h;
        }
        if (h > 1 || s > 1 || l > 1) {
            h /= 360;
            s /= 100;
            l /= 100;
        }
        h *= 360;
        var R, G, B, X, C;
        h = (h % 360) / 60;
        C = 2 * s * (l < .5 ? l : 1 - l);
        X = C * (1 - abs(h % 2 - 1));
        R = G = B = l - C / 2;

        h = ~~h;
        R += [C, X, 0, 0, X, C][h];
        G += [X, C, C, X, 0, 0][h];
        B += [0, 0, X, C, C, X][h];
        return packageRGB(R, G, B, o);
    };
    /*\
     * Raphael.rgb2hsb
     [ method ]
     **
     * Converts RGB values to HSB object.
     > Parameters
     - r (number) red
     - g (number) green
     - b (number) blue
     = (object) HSB object in format:
     o {
     o     h (number) hue
     o     s (number) saturation
     o     b (number) brightness
     o }
     \*/
    R.rgb2hsb = function (r, g, b) {
        b = prepareRGB(r, g, b);
        r = b[0];
        g = b[1];
        b = b[2];

        var H, S, V, C;
        V = mmax(r, g, b);
        C = V - mmin(r, g, b);
        H = (C == 0 ? null :
                V == r ? (g - b) / C :
                    V == g ? (b - r) / C + 2 :
                    (r - g) / C + 4
        );
        H = ((H + 360) % 6) * 60 / 360;
        S = C == 0 ? 0 : C / V;
        return {h: H, s: S, b: V, toString: hsbtoString};
    };
    /*\
     * Raphael.rgb2hsl
     [ method ]
     **
     * Converts RGB values to HSL object.
     > Parameters
     - r (number) red
     - g (number) green
     - b (number) blue
     = (object) HSL object in format:
     o {
     o     h (number) hue
     o     s (number) saturation
     o     l (number) luminosity
     o }
     \*/
    R.rgb2hsl = function (r, g, b) {
        b = prepareRGB(r, g, b);
        r = b[0];
        g = b[1];
        b = b[2];

        var H, S, L, M, m, C;
        M = mmax(r, g, b);
        m = mmin(r, g, b);
        C = M - m;
        H = (C == 0 ? null :
            M == r ? (g - b) / C :
                M == g ? (b - r) / C + 2 :
                (r - g) / C + 4);
        H = ((H + 360) % 6) * 60 / 360;
        L = (M + m) / 2;
        S = (C == 0 ? 0 :
            L < .5 ? C / (2 * L) :
            C / (2 - 2 * L));
        return {h: H, s: S, l: L, toString: hsltoString};
    };
    R._path2string = function () {
        return this.join(",").replace(p2s, "$1");
    };
    function repush(array, item) {
        for (var i = 0, ii = array.length; i < ii; i++) if (array[i] === item) {
            return array.push(array.splice(i, 1)[0]);
        }
    }
    function cacher(f, scope, postprocessor) {
        function newf() {
            var arg = Array.prototype.slice.call(arguments, 0),
                args = arg.join("\u2400"),
                cache = newf.cache = newf.cache || {},
                count = newf.count = newf.count || [];
            if (cache[has](args)) {
                repush(count, args);
                return postprocessor ? postprocessor(cache[args]) : cache[args];
            }
            count.length >= 1e3 && delete cache[count.shift()];
            count.push(args);
            cache[args] = f[apply](scope, arg);
            return postprocessor ? postprocessor(cache[args]) : cache[args];
        }
        return newf;
    }

    var preload = R._preload = function (src, f) {
        var img = g.doc.createElement("img");
        img.style.cssText = "position:absolute;left:-9999em;top:-9999em";
        img.onload = function () {
            f.call(this);
            this.onload = null;
            g.doc.body.removeChild(this);
        };
        img.onerror = function () {
            g.doc.body.removeChild(this);
        };
        g.doc.body.appendChild(img);
        img.src = src;
    };

    function clrToString() {
        return this.hex;
    }

    /*\
     * Raphael.getRGB
     [ method ]
     **
     * Parses colour string as RGB object
     > Parameters
     - colour (string) colour string in one of formats:
     # <ul>
     #     <li>Colour name (“<code>red</code>”, “<code>green</code>”, “<code>cornflowerblue</code>”, etc)</li>
     #     <li>#••• — shortened HTML colour: (“<code>#000</code>”, “<code>#fc0</code>”, etc)</li>
     #     <li>#•••••• — full length HTML colour: (“<code>#000000</code>”, “<code>#bd2300</code>”)</li>
     #     <li>rgb(•••, •••, •••) — red, green and blue channels’ values: (“<code>rgb(200,&nbsp;100,&nbsp;0)</code>”)</li>
     #     <li>rgb(•••%, •••%, •••%) — same as above, but in %: (“<code>rgb(100%,&nbsp;175%,&nbsp;0%)</code>”)</li>
     #     <li>hsb(•••, •••, •••) — hue, saturation and brightness values: (“<code>hsb(0.5,&nbsp;0.25,&nbsp;1)</code>”)</li>
     #     <li>hsb(•••%, •••%, •••%) — same as above, but in %</li>
     #     <li>hsl(•••, •••, •••) — same as hsb</li>
     #     <li>hsl(•••%, •••%, •••%) — same as hsb</li>
     # </ul>
     = (object) RGB object in format:
     o {
     o     r (number) red,
     o     g (number) green,
     o     b (number) blue
     o     hex (string) color in HTML/CSS format: #••••••,
     o     error (boolean) true if string can’t be parsed
     o }
     \*/
    R.getRGB = cacher(function (colour) {
        if (!colour || !!((colour = Str(colour)).indexOf("-") + 1)) {
            return {r: -1, g: -1, b: -1, hex: "none", error: 1, toString: clrToString};
        }
        if (colour == "none") {
            return {r: -1, g: -1, b: -1, hex: "none", toString: clrToString};
        }
        !(hsrg[has](colour.toLowerCase().substring(0, 2)) || colour.charAt() == "#") && (colour = toHex(colour));
        var res,
            red,
            green,
            blue,
            opacity,
            t,
            values,
            rgb = colour.match(colourRegExp);
        if (rgb) {
            if (rgb[2]) {
                blue = toInt(rgb[2].substring(5), 16);
                green = toInt(rgb[2].substring(3, 5), 16);
                red = toInt(rgb[2].substring(1, 3), 16);
            }
            if (rgb[3]) {
                blue = toInt((t = rgb[3].charAt(3)) + t, 16);
                green = toInt((t = rgb[3].charAt(2)) + t, 16);
                red = toInt((t = rgb[3].charAt(1)) + t, 16);
            }
            if (rgb[4]) {
                values = rgb[4][split](commaSpaces);
                red = toFloat(values[0]);
                values[0].slice(-1) == "%" && (red *= 2.55);
                green = toFloat(values[1]);
                values[1].slice(-1) == "%" && (green *= 2.55);
                blue = toFloat(values[2]);
                values[2].slice(-1) == "%" && (blue *= 2.55);
                rgb[1].toLowerCase().slice(0, 4) == "rgba" && (opacity = toFloat(values[3]));
                values[3] && values[3].slice(-1) == "%" && (opacity /= 100);
            }
            if (rgb[5]) {
                values = rgb[5][split](commaSpaces);
                red = toFloat(values[0]);
                values[0].slice(-1) == "%" && (red *= 2.55);
                green = toFloat(values[1]);
                values[1].slice(-1) == "%" && (green *= 2.55);
                blue = toFloat(values[2]);
                values[2].slice(-1) == "%" && (blue *= 2.55);
                (values[0].slice(-3) == "deg" || values[0].slice(-1) == "\xb0") && (red /= 360);
                rgb[1].toLowerCase().slice(0, 4) == "hsba" && (opacity = toFloat(values[3]));
                values[3] && values[3].slice(-1) == "%" && (opacity /= 100);
                return R.hsb2rgb(red, green, blue, opacity);
            }
            if (rgb[6]) {
                values = rgb[6][split](commaSpaces);
                red = toFloat(values[0]);
                values[0].slice(-1) == "%" && (red *= 2.55);
                green = toFloat(values[1]);
                values[1].slice(-1) == "%" && (green *= 2.55);
                blue = toFloat(values[2]);
                values[2].slice(-1) == "%" && (blue *= 2.55);
                (values[0].slice(-3) == "deg" || values[0].slice(-1) == "\xb0") && (red /= 360);
                rgb[1].toLowerCase().slice(0, 4) == "hsla" && (opacity = toFloat(values[3]));
                values[3] && values[3].slice(-1) == "%" && (opacity /= 100);
                return R.hsl2rgb(red, green, blue, opacity);
            }
            rgb = {r: red, g: green, b: blue, toString: clrToString};
            rgb.hex = "#" + (16777216 | blue | (green << 8) | (red << 16)).toString(16).slice(1);
            R.is(opacity, "finite") && (rgb.opacity = opacity);
            return rgb;
        }
        return {r: -1, g: -1, b: -1, hex: "none", error: 1, toString: clrToString};
    }, R);
    /*\
     * Raphael.hsb
     [ method ]
     **
     * Converts HSB values to hex representation of the colour.
     > Parameters
     - h (number) hue
     - s (number) saturation
     - b (number) value or brightness
     = (string) hex representation of the colour.
     \*/
    R.hsb = cacher(function (h, s, b) {
        return R.hsb2rgb(h, s, b).hex;
    });
    /*\
     * Raphael.hsl
     [ method ]
     **
     * Converts HSL values to hex representation of the colour.
     > Parameters
     - h (number) hue
     - s (number) saturation
     - l (number) luminosity
     = (string) hex representation of the colour.
     \*/
    R.hsl = cacher(function (h, s, l) {
        return R.hsl2rgb(h, s, l).hex;
    });
    /*\
     * Raphael.rgb
     [ method ]
     **
     * Converts RGB values to hex representation of the colour.
     > Parameters
     - r (number) red
     - g (number) green
     - b (number) blue
     = (string) hex representation of the colour.
     \*/
    R.rgb = cacher(function (r, g, b) {
        function round(x) { return (x + 0.5) | 0; }
        return "#" + (16777216 | round(b) | (round(g) << 8) | (round(r) << 16)).toString(16).slice(1);
    });
    /*\
     * Raphael.getColor
     [ method ]
     **
     * On each call returns next colour in the spectrum. To reset it back to red call @Raphael.getColor.reset
     > Parameters
     - value (number) #optional brightness, default is `0.75`
     = (string) hex representation of the colour.
     \*/
    R.getColor = function (value) {
        var start = this.getColor.start = this.getColor.start || {h: 0, s: 1, b: value || .75},
            rgb = this.hsb2rgb(start.h, start.s, start.b);
        start.h += .075;
        if (start.h > 1) {
            start.h = 0;
            start.s -= .2;
            start.s <= 0 && (this.getColor.start = {h: 0, s: 1, b: start.b});
        }
        return rgb.hex;
    };
    /*\
     * Raphael.getColor.reset
     [ method ]
     **
     * Resets spectrum position for @Raphael.getColor back to red.
     \*/
    R.getColor.reset = function () {
        delete this.start;
    };

    // http://schepers.cc/getting-to-the-point
    function catmullRom2bezier(crp, z) {
        var d = [];
        for (var i = 0, iLen = crp.length; iLen - 2 * !z > i; i += 2) {
            var p = [
                {x: +crp[i - 2], y: +crp[i - 1]},
                {x: +crp[i],     y: +crp[i + 1]},
                {x: +crp[i + 2], y: +crp[i + 3]},
                {x: +crp[i + 4], y: +crp[i + 5]}
            ];
            if (z) {
                if (!i) {
                    p[0] = {x: +crp[iLen - 2], y: +crp[iLen - 1]};
                } else if (iLen - 4 == i) {
                    p[3] = {x: +crp[0], y: +crp[1]};
                } else if (iLen - 2 == i) {
                    p[2] = {x: +crp[0], y: +crp[1]};
                    p[3] = {x: +crp[2], y: +crp[3]};
                }
            } else {
                if (iLen - 4 == i) {
                    p[3] = p[2];
                } else if (!i) {
                    p[0] = {x: +crp[i], y: +crp[i + 1]};
                }
            }
            d.push(["C",
                (-p[0].x + 6 * p[1].x + p[2].x) / 6,
                (-p[0].y + 6 * p[1].y + p[2].y) / 6,
                (p[1].x + 6 * p[2].x - p[3].x) / 6,
                (p[1].y + 6*p[2].y - p[3].y) / 6,
                p[2].x,
                p[2].y
            ]);
        }

        return d;
    }
    /*\
     * Raphael.parsePathString
     [ method ]
     **
     * Utility method
     **
     * Parses given path string into an array of arrays of path segments.
     > Parameters
     - pathString (string|array) path string or array of segments (in the last case it will be returned straight away)
     = (array) array of segments.
     \*/
    R.parsePathString = function (pathString) {
        if (!pathString) {
            return null;
        }
        var pth = paths(pathString);
        if (pth.arr) {
            return pathClone(pth.arr);
        }

        var paramCounts = {a: 7, c: 6, h: 1, l: 2, m: 2, r: 4, q: 4, s: 4, t: 2, v: 1, z: 0},
            data = [];
        if (R.is(pathString, array) && R.is(pathString[0], array)) { // rough assumption
            data = pathClone(pathString);
        }
        if (!data.length) {
            Str(pathString).replace(pathCommand, function (a, b, c) {
                var params = [],
                    name = b.toLowerCase();
                c.replace(pathValues, function (a, b) {
                    b && params.push(+b);
                });
                if (name == "m" && params.length > 2) {
                    data.push([b][concat](params.splice(0, 2)));
                    name = "l";
                    b = b == "m" ? "l" : "L";
                }
                if (name == "r") {
                    data.push([b][concat](params));
                } else while (params.length >= paramCounts[name]) {
                    data.push([b][concat](params.splice(0, paramCounts[name])));
                    if (!paramCounts[name]) {
                        break;
                    }
                }
            });
        }
        data.toString = R._path2string;
        pth.arr = pathClone(data);
        return data;
    };
    /*\
     * Raphael.parseTransformString
     [ method ]
     **
     * Utility method
     **
     * Parses given path string into an array of transformations.
     > Parameters
     - TString (string|array) transform string or array of transformations (in the last case it will be returned straight away)
     = (array) array of transformations.
     \*/
    R.parseTransformString = cacher(function (TString) {
        if (!TString) {
            return null;
        }
        var paramCounts = {r: 3, s: 4, t: 2, m: 6},
            data = [];
        if (R.is(TString, array) && R.is(TString[0], array)) { // rough assumption
            data = pathClone(TString);
        }
        if (!data.length) {
            Str(TString).replace(tCommand, function (a, b, c) {
                var params = [],
                    name = lowerCase.call(b);
                c.replace(pathValues, function (a, b) {
                    b && params.push(+b);
                });
                data.push([b][concat](params));
            });
        }
        data.toString = R._path2string;
        return data;
    });
    // PATHS
    var paths = function (ps) {
        var p = paths.ps = paths.ps || {};
        if (p[ps]) {
            p[ps].sleep = 100;
        } else {
            p[ps] = {
                sleep: 100
            };
        }
        setTimeout(function () {
            for (var key in p) if (p[has](key) && key != ps) {
                p[key].sleep--;
                !p[key].sleep && delete p[key];
            }
        });
        return p[ps];
    };
    /*\
     * Raphael.findDotsAtSegment
     [ method ]
     **
     * Utility method
     **
     * Find dot coordinates on the given cubic bezier curve at the given t.
     > Parameters
     - p1x (number) x of the first point of the curve
     - p1y (number) y of the first point of the curve
     - c1x (number) x of the first anchor of the curve
     - c1y (number) y of the first anchor of the curve
     - c2x (number) x of the second anchor of the curve
     - c2y (number) y of the second anchor of the curve
     - p2x (number) x of the second point of the curve
     - p2y (number) y of the second point of the curve
     - t (number) position on the curve (0..1)
     = (object) point information in format:
     o {
     o     x: (number) x coordinate of the point
     o     y: (number) y coordinate of the point
     o     m: {
     o         x: (number) x coordinate of the left anchor
     o         y: (number) y coordinate of the left anchor
     o     }
     o     n: {
     o         x: (number) x coordinate of the right anchor
     o         y: (number) y coordinate of the right anchor
     o     }
     o     start: {
     o         x: (number) x coordinate of the start of the curve
     o         y: (number) y coordinate of the start of the curve
     o     }
     o     end: {
     o         x: (number) x coordinate of the end of the curve
     o         y: (number) y coordinate of the end of the curve
     o     }
     o     alpha: (number) angle of the curve derivative at the point
     o }
     \*/
    R.findDotsAtSegment = function (p1x, p1y, c1x, c1y, c2x, c2y, p2x, p2y, t) {
        var t1 = 1 - t,
            t13 = pow(t1, 3),
            t12 = pow(t1, 2),
            t2 = t * t,
            t3 = t2 * t,
            x = t13 * p1x + t12 * 3 * t * c1x + t1 * 3 * t * t * c2x + t3 * p2x,
            y = t13 * p1y + t12 * 3 * t * c1y + t1 * 3 * t * t * c2y + t3 * p2y,
            mx = p1x + 2 * t * (c1x - p1x) + t2 * (c2x - 2 * c1x + p1x),
            my = p1y + 2 * t * (c1y - p1y) + t2 * (c2y - 2 * c1y + p1y),
            nx = c1x + 2 * t * (c2x - c1x) + t2 * (p2x - 2 * c2x + c1x),
            ny = c1y + 2 * t * (c2y - c1y) + t2 * (p2y - 2 * c2y + c1y),
            ax = t1 * p1x + t * c1x,
            ay = t1 * p1y + t * c1y,
            cx = t1 * c2x + t * p2x,
            cy = t1 * c2y + t * p2y,
            alpha = (90 - math.atan2(mx - nx, my - ny) * 180 / PI);
        (mx > nx || my < ny) && (alpha += 180);
        return {
            x: x,
            y: y,
            m: {x: mx, y: my},
            n: {x: nx, y: ny},
            start: {x: ax, y: ay},
            end: {x: cx, y: cy},
            alpha: alpha
        };
    };
    /*\
     * Raphael.bezierBBox
     [ method ]
     **
     * Utility method
     **
     * Return bounding box of a given cubic bezier curve
     > Parameters
     - p1x (number) x of the first point of the curve
     - p1y (number) y of the first point of the curve
     - c1x (number) x of the first anchor of the curve
     - c1y (number) y of the first anchor of the curve
     - c2x (number) x of the second anchor of the curve
     - c2y (number) y of the second anchor of the curve
     - p2x (number) x of the second point of the curve
     - p2y (number) y of the second point of the curve
     * or
     - bez (array) array of six points for bezier curve
     = (object) point information in format:
     o {
     o     min: {
     o         x: (number) x coordinate of the left point
     o         y: (number) y coordinate of the top point
     o     }
     o     max: {
     o         x: (number) x coordinate of the right point
     o         y: (number) y coordinate of the bottom point
     o     }
     o }
     \*/
    R.bezierBBox = function (p1x, p1y, c1x, c1y, c2x, c2y, p2x, p2y) {
        if (!R.is(p1x, "array")) {
            p1x = [p1x, p1y, c1x, c1y, c2x, c2y, p2x, p2y];
        }
        var bbox = curveDim.apply(null, p1x);
        return {
            x: bbox.min.x,
            y: bbox.min.y,
            x2: bbox.max.x,
            y2: bbox.max.y,
            width: bbox.max.x - bbox.min.x,
            height: bbox.max.y - bbox.min.y
        };
    };
    /*\
     * Raphael.isPointInsideBBox
     [ method ]
     **
     * Utility method
     **
     * Returns `true` if given point is inside bounding boxes.
     > Parameters
     - bbox (string) bounding box
     - x (string) x coordinate of the point
     - y (string) y coordinate of the point
     = (boolean) `true` if point inside
     \*/
    R.isPointInsideBBox = function (bbox, x, y) {
        return x >= bbox.x && x <= bbox.x2 && y >= bbox.y && y <= bbox.y2;
    };
    /*\
     * Raphael.isBBoxIntersect
     [ method ]
     **
     * Utility method
     **
     * Returns `true` if two bounding boxes intersect
     > Parameters
     - bbox1 (string) first bounding box
     - bbox2 (string) second bounding box
     = (boolean) `true` if they intersect
     \*/
    R.isBBoxIntersect = function (bbox1, bbox2) {
        var i = R.isPointInsideBBox;
        return i(bbox2, bbox1.x, bbox1.y)
            || i(bbox2, bbox1.x2, bbox1.y)
            || i(bbox2, bbox1.x, bbox1.y2)
            || i(bbox2, bbox1.x2, bbox1.y2)
            || i(bbox1, bbox2.x, bbox2.y)
            || i(bbox1, bbox2.x2, bbox2.y)
            || i(bbox1, bbox2.x, bbox2.y2)
            || i(bbox1, bbox2.x2, bbox2.y2)
            || (bbox1.x < bbox2.x2 && bbox1.x > bbox2.x || bbox2.x < bbox1.x2 && bbox2.x > bbox1.x)
            && (bbox1.y < bbox2.y2 && bbox1.y > bbox2.y || bbox2.y < bbox1.y2 && bbox2.y > bbox1.y);
    };
    function base3(t, p1, p2, p3, p4) {
        var t1 = -3 * p1 + 9 * p2 - 9 * p3 + 3 * p4,
            t2 = t * t1 + 6 * p1 - 12 * p2 + 6 * p3;
        return t * t2 - 3 * p1 + 3 * p2;
    }
    function bezlen(x1, y1, x2, y2, x3, y3, x4, y4, z) {
        if (z == null) {
            z = 1;
        }
        z = z > 1 ? 1 : z < 0 ? 0 : z;
        var z2 = z / 2,
            n = 12,
            Tvalues = [-0.1252,0.1252,-0.3678,0.3678,-0.5873,0.5873,-0.7699,0.7699,-0.9041,0.9041,-0.9816,0.9816],
            Cvalues = [0.2491,0.2491,0.2335,0.2335,0.2032,0.2032,0.1601,0.1601,0.1069,0.1069,0.0472,0.0472],
            sum = 0;
        for (var i = 0; i < n; i++) {
            var ct = z2 * Tvalues[i] + z2,
                xbase = base3(ct, x1, x2, x3, x4),
                ybase = base3(ct, y1, y2, y3, y4),
                comb = xbase * xbase + ybase * ybase;
            sum += Cvalues[i] * math.sqrt(comb);
        }
        return z2 * sum;
    }
    function getTatLen(x1, y1, x2, y2, x3, y3, x4, y4, ll) {
        if (ll < 0 || bezlen(x1, y1, x2, y2, x3, y3, x4, y4) < ll) {
            return;
        }
        var t = 1,
            step = t / 2,
            t2 = t - step,
            l,
            e = .01;
        l = bezlen(x1, y1, x2, y2, x3, y3, x4, y4, t2);
        while (abs(l - ll) > e) {
            step /= 2;
            t2 += (l < ll ? 1 : -1) * step;
            l = bezlen(x1, y1, x2, y2, x3, y3, x4, y4, t2);
        }
        return t2;
    }
    function intersect(x1, y1, x2, y2, x3, y3, x4, y4) {
        if (
            mmax(x1, x2) < mmin(x3, x4) ||
            mmin(x1, x2) > mmax(x3, x4) ||
            mmax(y1, y2) < mmin(y3, y4) ||
            mmin(y1, y2) > mmax(y3, y4)
        ) {
            return;
        }
        var nx = (x1 * y2 - y1 * x2) * (x3 - x4) - (x1 - x2) * (x3 * y4 - y3 * x4),
            ny = (x1 * y2 - y1 * x2) * (y3 - y4) - (y1 - y2) * (x3 * y4 - y3 * x4),
            denominator = (x1 - x2) * (y3 - y4) - (y1 - y2) * (x3 - x4);

        if (!denominator) {
            return;
        }
        var px = nx / denominator,
            py = ny / denominator,
            px2 = +px.toFixed(2),
            py2 = +py.toFixed(2);
        if (
            px2 < +mmin(x1, x2).toFixed(2) ||
            px2 > +mmax(x1, x2).toFixed(2) ||
            px2 < +mmin(x3, x4).toFixed(2) ||
            px2 > +mmax(x3, x4).toFixed(2) ||
            py2 < +mmin(y1, y2).toFixed(2) ||
            py2 > +mmax(y1, y2).toFixed(2) ||
            py2 < +mmin(y3, y4).toFixed(2) ||
            py2 > +mmax(y3, y4).toFixed(2)
        ) {
            return;
        }
        return {x: px, y: py};
    }
    function inter(bez1, bez2) {
        return interHelper(bez1, bez2);
    }
    function interCount(bez1, bez2) {
        return interHelper(bez1, bez2, 1);
    }
    function interHelper(bez1, bez2, justCount) {
        var bbox1 = R.bezierBBox(bez1),
            bbox2 = R.bezierBBox(bez2);
        if (!R.isBBoxIntersect(bbox1, bbox2)) {
            return justCount ? 0 : [];
        }
        var l1 = bezlen.apply(0, bez1),
            l2 = bezlen.apply(0, bez2),
            n1 = mmax(~~(l1 / 5), 1),
            n2 = mmax(~~(l2 / 5), 1),
            dots1 = [],
            dots2 = [],
            xy = {},
            res = justCount ? 0 : [];
        for (var i = 0; i < n1 + 1; i++) {
            var p = R.findDotsAtSegment.apply(R, bez1.concat(i / n1));
            dots1.push({x: p.x, y: p.y, t: i / n1});
        }
        for (i = 0; i < n2 + 1; i++) {
            p = R.findDotsAtSegment.apply(R, bez2.concat(i / n2));
            dots2.push({x: p.x, y: p.y, t: i / n2});
        }
        for (i = 0; i < n1; i++) {
            for (var j = 0; j < n2; j++) {
                var di = dots1[i],
                    di1 = dots1[i + 1],
                    dj = dots2[j],
                    dj1 = dots2[j + 1],
                    ci = abs(di1.x - di.x) < .001 ? "y" : "x",
                    cj = abs(dj1.x - dj.x) < .001 ? "y" : "x",
                    is = intersect(di.x, di.y, di1.x, di1.y, dj.x, dj.y, dj1.x, dj1.y);
                if (is) {
                    if (xy[is.x.toFixed(4)] == is.y.toFixed(4)) {
                        continue;
                    }
                    xy[is.x.toFixed(4)] = is.y.toFixed(4);
                    var t1 = di.t + abs((is[ci] - di[ci]) / (di1[ci] - di[ci])) * (di1.t - di.t),
                        t2 = dj.t + abs((is[cj] - dj[cj]) / (dj1[cj] - dj[cj])) * (dj1.t - dj.t);
                    if (t1 >= 0 && t1 <= 1.001 && t2 >= 0 && t2 <= 1.001) {
                        if (justCount) {
                            res++;
                        } else {
                            res.push({
                                x: is.x,
                                y: is.y,
                                t1: mmin(t1, 1),
                                t2: mmin(t2, 1)
                            });
                        }
                    }
                }
            }
        }
        return res;
    }
    /*\
     * Raphael.pathIntersection
     [ method ]
     **
     * Utility method
     **
     * Finds intersections of two paths
     > Parameters
     - path1 (string) path string
     - path2 (string) path string
     = (array) dots of intersection
     o [
     o     {
     o         x: (number) x coordinate of the point
     o         y: (number) y coordinate of the point
     o         t1: (number) t value for segment of path1
     o         t2: (number) t value for segment of path2
     o         segment1: (number) order number for segment of path1
     o         segment2: (number) order number for segment of path2
     o         bez1: (array) eight coordinates representing beziér curve for the segment of path1
     o         bez2: (array) eight coordinates representing beziér curve for the segment of path2
     o     }
     o ]
     \*/
    R.pathIntersection = function (path1, path2) {
        return interPathHelper(path1, path2);
    };
    R.pathIntersectionNumber = function (path1, path2) {
        return interPathHelper(path1, path2, 1);
    };
    function interPathHelper(path1, path2, justCount) {
        path1 = R._path2curve(path1);
        path2 = R._path2curve(path2);
        var x1, y1, x2, y2, x1m, y1m, x2m, y2m, bez1, bez2,
            res = justCount ? 0 : [];
        for (var i = 0, ii = path1.length; i < ii; i++) {
            var pi = path1[i];
            if (pi[0] == "M") {
                x1 = x1m = pi[1];
                y1 = y1m = pi[2];
            } else {
                if (pi[0] == "C") {
                    bez1 = [x1, y1].concat(pi.slice(1));
                    x1 = bez1[6];
                    y1 = bez1[7];
                } else {
                    bez1 = [x1, y1, x1, y1, x1m, y1m, x1m, y1m];
                    x1 = x1m;
                    y1 = y1m;
                }
                for (var j = 0, jj = path2.length; j < jj; j++) {
                    var pj = path2[j];
                    if (pj[0] == "M") {
                        x2 = x2m = pj[1];
                        y2 = y2m = pj[2];
                    } else {
                        if (pj[0] == "C") {
                            bez2 = [x2, y2].concat(pj.slice(1));
                            x2 = bez2[6];
                            y2 = bez2[7];
                        } else {
                            bez2 = [x2, y2, x2, y2, x2m, y2m, x2m, y2m];
                            x2 = x2m;
                            y2 = y2m;
                        }
                        var intr = interHelper(bez1, bez2, justCount);
                        if (justCount) {
                            res += intr;
                        } else {
                            for (var k = 0, kk = intr.length; k < kk; k++) {
                                intr[k].segment1 = i;
                                intr[k].segment2 = j;
                                intr[k].bez1 = bez1;
                                intr[k].bez2 = bez2;
                            }
                            res = res.concat(intr);
                        }
                    }
                }
            }
        }
        return res;
    }
    /*\
     * Raphael.isPointInsidePath
     [ method ]
     **
     * Utility method
     **
     * Returns `true` if given point is inside a given closed path.
     > Parameters
     - path (string) path string
     - x (number) x of the point
     - y (number) y of the point
     = (boolean) true, if point is inside the path
     \*/
    R.isPointInsidePath = function (path, x, y) {
        var bbox = R.pathBBox(path);
        return R.isPointInsideBBox(bbox, x, y) &&
            interPathHelper(path, [["M", x, y], ["H", bbox.x2 + 10]], 1) % 2 == 1;
    };
    R._removedFactory = function (methodname) {
        return function () {
            eve("raphael.log", null, "Rapha\xebl: you are calling to method \u201c" + methodname + "\u201d of removed object", methodname);
        };
    };
    /*\
     * Raphael.pathBBox
     [ method ]
     **
     * Utility method
     **
     * Return bounding box of a given path
     > Parameters
     - path (string) path string
     = (object) bounding box
     o {
     o     x: (number) x coordinate of the left top point of the box
     o     y: (number) y coordinate of the left top point of the box
     o     x2: (number) x coordinate of the right bottom point of the box
     o     y2: (number) y coordinate of the right bottom point of the box
     o     width: (number) width of the box
     o     height: (number) height of the box
     o     cx: (number) x coordinate of the center of the box
     o     cy: (number) y coordinate of the center of the box
     o }
     \*/
    var pathDimensions = R.pathBBox = function (path) {
            var pth = paths(path);
            if (pth.bbox) {
                return clone(pth.bbox);
            }
            if (!path) {
                return {x: 0, y: 0, width: 0, height: 0, x2: 0, y2: 0};
            }
            path = path2curve(path);
            var x = 0,
                y = 0,
                X = [],
                Y = [],
                p;
            for (var i = 0, ii = path.length; i < ii; i++) {
                p = path[i];
                if (p[0] == "M") {
                    x = p[1];
                    y = p[2];
                    X.push(x);
                    Y.push(y);
                } else {
                    var dim = curveDim(x, y, p[1], p[2], p[3], p[4], p[5], p[6]);
                    X = X[concat](dim.min.x, dim.max.x);
                    Y = Y[concat](dim.min.y, dim.max.y);
                    x = p[5];
                    y = p[6];
                }
            }
            var xmin = mmin[apply](0, X),
                ymin = mmin[apply](0, Y),
                xmax = mmax[apply](0, X),
                ymax = mmax[apply](0, Y),
                width = xmax - xmin,
                height = ymax - ymin,
                bb = {
                    x: xmin,
                    y: ymin,
                    x2: xmax,
                    y2: ymax,
                    width: width,
                    height: height,
                    cx: xmin + width / 2,
                    cy: ymin + height / 2
                };
            pth.bbox = clone(bb);
            return bb;
        },
        pathClone = function (pathArray) {
            var res = clone(pathArray);
            res.toString = R._path2string;
            return res;
        },
        pathToRelative = R._pathToRelative = function (pathArray) {
            var pth = paths(pathArray);
            if (pth.rel) {
                return pathClone(pth.rel);
            }
            if (!R.is(pathArray, array) || !R.is(pathArray && pathArray[0], array)) { // rough assumption
                pathArray = R.parsePathString(pathArray);
            }
            var res = [],
                x = 0,
                y = 0,
                mx = 0,
                my = 0,
                start = 0;
            if (pathArray[0][0] == "M") {
                x = pathArray[0][1];
                y = pathArray[0][2];
                mx = x;
                my = y;
                start++;
                res.push(["M", x, y]);
            }
            for (var i = start, ii = pathArray.length; i < ii; i++) {
                var r = res[i] = [],
                    pa = pathArray[i];
                if (pa[0] != lowerCase.call(pa[0])) {
                    r[0] = lowerCase.call(pa[0]);
                    switch (r[0]) {
                        case "a":
                            r[1] = pa[1];
                            r[2] = pa[2];
                            r[3] = pa[3];
                            r[4] = pa[4];
                            r[5] = pa[5];
                            r[6] = +(pa[6] - x).toFixed(3);
                            r[7] = +(pa[7] - y).toFixed(3);
                            break;
                        case "v":
                            r[1] = +(pa[1] - y).toFixed(3);
                            break;
                        case "m":
                            mx = pa[1];
                            my = pa[2];
                        default:
                            for (var j = 1, jj = pa.length; j < jj; j++) {
                                r[j] = +(pa[j] - ((j % 2) ? x : y)).toFixed(3);
                            }
                    }
                } else {
                    r = res[i] = [];
                    if (pa[0] == "m") {
                        mx = pa[1] + x;
                        my = pa[2] + y;
                    }
                    for (var k = 0, kk = pa.length; k < kk; k++) {
                        res[i][k] = pa[k];
                    }
                }
                var len = res[i].length;
                switch (res[i][0]) {
                    case "z":
                        x = mx;
                        y = my;
                        break;
                    case "h":
                        x += +res[i][len - 1];
                        break;
                    case "v":
                        y += +res[i][len - 1];
                        break;
                    default:
                        x += +res[i][len - 2];
                        y += +res[i][len - 1];
                }
            }
            res.toString = R._path2string;
            pth.rel = pathClone(res);
            return res;
        },
        pathToAbsolute = R._pathToAbsolute = function (pathArray) {
            var pth = paths(pathArray);
            if (pth.abs) {
                return pathClone(pth.abs);
            }
            if (!R.is(pathArray, array) || !R.is(pathArray && pathArray[0], array)) { // rough assumption
                pathArray = R.parsePathString(pathArray);
            }
            if (!pathArray || !pathArray.length) {
                return [["M", 0, 0]];
            }
            var res = [],
                x = 0,
                y = 0,
                mx = 0,
                my = 0,
                start = 0;
            if (pathArray[0][0] == "M") {
                x = +pathArray[0][1];
                y = +pathArray[0][2];
                mx = x;
                my = y;
                start++;
                res[0] = ["M", x, y];
            }
            var crz = pathArray.length == 3 && pathArray[0][0] == "M" && pathArray[1][0].toUpperCase() == "R" && pathArray[2][0].toUpperCase() == "Z";
            for (var r, pa, i = start, ii = pathArray.length; i < ii; i++) {
                res.push(r = []);
                pa = pathArray[i];
                if (pa[0] != upperCase.call(pa[0])) {
                    r[0] = upperCase.call(pa[0]);
                    switch (r[0]) {
                        case "A":
                            r[1] = pa[1];
                            r[2] = pa[2];
                            r[3] = pa[3];
                            r[4] = pa[4];
                            r[5] = pa[5];
                            r[6] = +(pa[6] + x);
                            r[7] = +(pa[7] + y);
                            break;
                        case "V":
                            r[1] = +pa[1] + y;
                            break;
                        case "H":
                            r[1] = +pa[1] + x;
                            break;
                        case "R":
                            var dots = [x, y][concat](pa.slice(1));
                            for (var j = 2, jj = dots.length; j < jj; j++) {
                                dots[j] = +dots[j] + x;
                                dots[++j] = +dots[j] + y;
                            }
                            res.pop();
                            res = res[concat](catmullRom2bezier(dots, crz));
                            break;
                        case "M":
                            mx = +pa[1] + x;
                            my = +pa[2] + y;
                        default:
                            for (j = 1, jj = pa.length; j < jj; j++) {
                                r[j] = +pa[j] + ((j % 2) ? x : y);
                            }
                    }
                } else if (pa[0] == "R") {
                    dots = [x, y][concat](pa.slice(1));
                    res.pop();
                    res = res[concat](catmullRom2bezier(dots, crz));
                    r = ["R"][concat](pa.slice(-2));
                } else {
                    for (var k = 0, kk = pa.length; k < kk; k++) {
                        r[k] = pa[k];
                    }
                }
                switch (r[0]) {
                    case "Z":
                        x = mx;
                        y = my;
                        break;
                    case "H":
                        x = r[1];
                        break;
                    case "V":
                        y = r[1];
                        break;
                    case "M":
                        mx = r[r.length - 2];
                        my = r[r.length - 1];
                    default:
                        x = r[r.length - 2];
                        y = r[r.length - 1];
                }
            }
            res.toString = R._path2string;
            pth.abs = pathClone(res);
            return res;
        },
        l2c = function (x1, y1, x2, y2) {
            return [x1, y1, x2, y2, x2, y2];
        },
        q2c = function (x1, y1, ax, ay, x2, y2) {
            var _13 = 1 / 3,
                _23 = 2 / 3;
            return [
                _13 * x1 + _23 * ax,
                _13 * y1 + _23 * ay,
                _13 * x2 + _23 * ax,
                _13 * y2 + _23 * ay,
                x2,
                y2
            ];
        },
        a2c = function (x1, y1, rx, ry, angle, large_arc_flag, sweep_flag, x2, y2, recursive) {
            // for more information of where this math came from visit:
            // http://www.w3.org/TR/SVG11/implnote.html#ArcImplementationNotes
            var _120 = PI * 120 / 180,
                rad = PI / 180 * (+angle || 0),
                res = [],
                xy,
                rotate = cacher(function (x, y, rad) {
                    var X = x * math.cos(rad) - y * math.sin(rad),
                        Y = x * math.sin(rad) + y * math.cos(rad);
                    return {x: X, y: Y};
                });
            if (!recursive) {
                xy = rotate(x1, y1, -rad);
                x1 = xy.x;
                y1 = xy.y;
                xy = rotate(x2, y2, -rad);
                x2 = xy.x;
                y2 = xy.y;
                var cos = math.cos(PI / 180 * angle),
                    sin = math.sin(PI / 180 * angle),
                    x = (x1 - x2) / 2,
                    y = (y1 - y2) / 2;
                var h = (x * x) / (rx * rx) + (y * y) / (ry * ry);
                if (h > 1) {
                    h = math.sqrt(h);
                    rx = h * rx;
                    ry = h * ry;
                }
                var rx2 = rx * rx,
                    ry2 = ry * ry,
                    k = (large_arc_flag == sweep_flag ? -1 : 1) *
                        math.sqrt(abs((rx2 * ry2 - rx2 * y * y - ry2 * x * x) / (rx2 * y * y + ry2 * x * x))),
                    cx = k * rx * y / ry + (x1 + x2) / 2,
                    cy = k * -ry * x / rx + (y1 + y2) / 2,
                    f1 = math.asin(((y1 - cy) / ry).toFixed(9)),
                    f2 = math.asin(((y2 - cy) / ry).toFixed(9));

                f1 = x1 < cx ? PI - f1 : f1;
                f2 = x2 < cx ? PI - f2 : f2;
                f1 < 0 && (f1 = PI * 2 + f1);
                f2 < 0 && (f2 = PI * 2 + f2);
                if (sweep_flag && f1 > f2) {
                    f1 = f1 - PI * 2;
                }
                if (!sweep_flag && f2 > f1) {
                    f2 = f2 - PI * 2;
                }
            } else {
                f1 = recursive[0];
                f2 = recursive[1];
                cx = recursive[2];
                cy = recursive[3];
            }
            var df = f2 - f1;
            if (abs(df) > _120) {
                var f2old = f2,
                    x2old = x2,
                    y2old = y2;
                f2 = f1 + _120 * (sweep_flag && f2 > f1 ? 1 : -1);
                x2 = cx + rx * math.cos(f2);
                y2 = cy + ry * math.sin(f2);
                res = a2c(x2, y2, rx, ry, angle, 0, sweep_flag, x2old, y2old, [f2, f2old, cx, cy]);
            }
            df = f2 - f1;
            var c1 = math.cos(f1),
                s1 = math.sin(f1),
                c2 = math.cos(f2),
                s2 = math.sin(f2),
                t = math.tan(df / 4),
                hx = 4 / 3 * rx * t,
                hy = 4 / 3 * ry * t,
                m1 = [x1, y1],
                m2 = [x1 + hx * s1, y1 - hy * c1],
                m3 = [x2 + hx * s2, y2 - hy * c2],
                m4 = [x2, y2];
            m2[0] = 2 * m1[0] - m2[0];
            m2[1] = 2 * m1[1] - m2[1];
            if (recursive) {
                return [m2, m3, m4][concat](res);
            } else {
                res = [m2, m3, m4][concat](res).join()[split](",");
                var newres = [];
                for (var i = 0, ii = res.length; i < ii; i++) {
                    newres[i] = i % 2 ? rotate(res[i - 1], res[i], rad).y : rotate(res[i], res[i + 1], rad).x;
                }
                return newres;
            }
        },
        findDotAtSegment = function (p1x, p1y, c1x, c1y, c2x, c2y, p2x, p2y, t) {
            var t1 = 1 - t;
            return {
                x: pow(t1, 3) * p1x + pow(t1, 2) * 3 * t * c1x + t1 * 3 * t * t * c2x + pow(t, 3) * p2x,
                y: pow(t1, 3) * p1y + pow(t1, 2) * 3 * t * c1y + t1 * 3 * t * t * c2y + pow(t, 3) * p2y
            };
        },
        curveDim = cacher(function (p1x, p1y, c1x, c1y, c2x, c2y, p2x, p2y) {
            var a = (c2x - 2 * c1x + p1x) - (p2x - 2 * c2x + c1x),
                b = 2 * (c1x - p1x) - 2 * (c2x - c1x),
                c = p1x - c1x,
                t1 = (-b + math.sqrt(b * b - 4 * a * c)) / 2 / a,
                t2 = (-b - math.sqrt(b * b - 4 * a * c)) / 2 / a,
                y = [p1y, p2y],
                x = [p1x, p2x],
                dot;
            abs(t1) > "1e12" && (t1 = .5);
            abs(t2) > "1e12" && (t2 = .5);
            if (t1 > 0 && t1 < 1) {
                dot = findDotAtSegment(p1x, p1y, c1x, c1y, c2x, c2y, p2x, p2y, t1);
                x.push(dot.x);
                y.push(dot.y);
            }
            if (t2 > 0 && t2 < 1) {
                dot = findDotAtSegment(p1x, p1y, c1x, c1y, c2x, c2y, p2x, p2y, t2);
                x.push(dot.x);
                y.push(dot.y);
            }
            a = (c2y - 2 * c1y + p1y) - (p2y - 2 * c2y + c1y);
            b = 2 * (c1y - p1y) - 2 * (c2y - c1y);
            c = p1y - c1y;
            t1 = (-b + math.sqrt(b * b - 4 * a * c)) / 2 / a;
            t2 = (-b - math.sqrt(b * b - 4 * a * c)) / 2 / a;
            abs(t1) > "1e12" && (t1 = .5);
            abs(t2) > "1e12" && (t2 = .5);
            if (t1 > 0 && t1 < 1) {
                dot = findDotAtSegment(p1x, p1y, c1x, c1y, c2x, c2y, p2x, p2y, t1);
                x.push(dot.x);
                y.push(dot.y);
            }
            if (t2 > 0 && t2 < 1) {
                dot = findDotAtSegment(p1x, p1y, c1x, c1y, c2x, c2y, p2x, p2y, t2);
                x.push(dot.x);
                y.push(dot.y);
            }
            return {
                min: {x: mmin[apply](0, x), y: mmin[apply](0, y)},
                max: {x: mmax[apply](0, x), y: mmax[apply](0, y)}
            };
        }),
        path2curve = R._path2curve = cacher(function (path, path2) {
            var pth = !path2 && paths(path);
            if (!path2 && pth.curve) {
                return pathClone(pth.curve);
            }
            var p = pathToAbsolute(path),
                p2 = path2 && pathToAbsolute(path2),
                attrs = {x: 0, y: 0, bx: 0, by: 0, X: 0, Y: 0, qx: null, qy: null},
                attrs2 = {x: 0, y: 0, bx: 0, by: 0, X: 0, Y: 0, qx: null, qy: null},
                processPath = function (path, d, pcom) {
                    var nx, ny, tq = {T:1, Q:1};
                    if (!path) {
                        return ["C", d.x, d.y, d.x, d.y, d.x, d.y];
                    }
                    !(path[0] in tq) && (d.qx = d.qy = null);
                    switch (path[0]) {
                        case "M":
                            d.X = path[1];
                            d.Y = path[2];
                            break;
                        case "A":
                            path = ["C"][concat](a2c[apply](0, [d.x, d.y][concat](path.slice(1))));
                            break;
                        case "S":
                            if (pcom == "C" || pcom == "S") { // In "S" case we have to take into account, if the previous command is C/S.
                                nx = d.x * 2 - d.bx;          // And reflect the previous
                                ny = d.y * 2 - d.by;          // command's control point relative to the current point.
                            }
                            else {                            // or some else or nothing
                                nx = d.x;
                                ny = d.y;
                            }
                            path = ["C", nx, ny][concat](path.slice(1));
                            break;
                        case "T":
                            if (pcom == "Q" || pcom == "T") { // In "T" case we have to take into account, if the previous command is Q/T.
                                d.qx = d.x * 2 - d.qx;        // And make a reflection similar
                                d.qy = d.y * 2 - d.qy;        // to case "S".
                            }
                            else {                            // or something else or nothing
                                d.qx = d.x;
                                d.qy = d.y;
                            }
                            path = ["C"][concat](q2c(d.x, d.y, d.qx, d.qy, path[1], path[2]));
                            break;
                        case "Q":
                            d.qx = path[1];
                            d.qy = path[2];
                            path = ["C"][concat](q2c(d.x, d.y, path[1], path[2], path[3], path[4]));
                            break;
                        case "L":
                            path = ["C"][concat](l2c(d.x, d.y, path[1], path[2]));
                            break;
                        case "H":
                            path = ["C"][concat](l2c(d.x, d.y, path[1], d.y));
                            break;
                        case "V":
                            path = ["C"][concat](l2c(d.x, d.y, d.x, path[1]));
                            break;
                        case "Z":
                            path = ["C"][concat](l2c(d.x, d.y, d.X, d.Y));
                            break;
                    }
                    return path;
                },
                fixArc = function (pp, i) {
                    if (pp[i].length > 7) {
                        pp[i].shift();
                        var pi = pp[i];
                        while (pi.length) {
                            pcoms1[i]="A"; // if created multiple C:s, their original seg is saved
                            p2 && (pcoms2[i]="A"); // the same as above
                            pp.splice(i++, 0, ["C"][concat](pi.splice(0, 6)));
                        }
                        pp.splice(i, 1);
                        ii = mmax(p.length, p2 && p2.length || 0);
                    }
                },
                fixM = function (path1, path2, a1, a2, i) {
                    if (path1 && path2 && path1[i][0] == "M" && path2[i][0] != "M") {
                        path2.splice(i, 0, ["M", a2.x, a2.y]);
                        a1.bx = 0;
                        a1.by = 0;
                        a1.x = path1[i][1];
                        a1.y = path1[i][2];
                        ii = mmax(p.length, p2 && p2.length || 0);
                    }
                },
                pcoms1 = [], // path commands of original path p
                pcoms2 = [], // path commands of original path p2
                pfirst = "", // temporary holder for original path command
                pcom = ""; // holder for previous path command of original path
            for (var i = 0, ii = mmax(p.length, p2 && p2.length || 0); i < ii; i++) {
                p[i] && (pfirst = p[i][0]); // save current path command

                if (pfirst != "C") // C is not saved yet, because it may be result of conversion
                {
                    pcoms1[i] = pfirst; // Save current path command
                    i && ( pcom = pcoms1[i-1]); // Get previous path command pcom
                }
                p[i] = processPath(p[i], attrs, pcom); // Previous path command is inputted to processPath

                if (pcoms1[i] != "A" && pfirst == "C") pcoms1[i] = "C"; // A is the only command
                // which may produce multiple C:s
                // so we have to make sure that C is also C in original path

                fixArc(p, i); // fixArc adds also the right amount of A:s to pcoms1

                if (p2) { // the same procedures is done to p2
                    p2[i] && (pfirst = p2[i][0]);
                    if (pfirst != "C")
                    {
                        pcoms2[i] = pfirst;
                        i && (pcom = pcoms2[i-1]);
                    }
                    p2[i] = processPath(p2[i], attrs2, pcom);

                    if (pcoms2[i]!="A" && pfirst=="C") pcoms2[i]="C";

                    fixArc(p2, i);
                }
                fixM(p, p2, attrs, attrs2, i);
                fixM(p2, p, attrs2, attrs, i);
                var seg = p[i],
                    seg2 = p2 && p2[i],
                    seglen = seg.length,
                    seg2len = p2 && seg2.length;
                attrs.x = seg[seglen - 2];
                attrs.y = seg[seglen - 1];
                attrs.bx = toFloat(seg[seglen - 4]) || attrs.x;
                attrs.by = toFloat(seg[seglen - 3]) || attrs.y;
                attrs2.bx = p2 && (toFloat(seg2[seg2len - 4]) || attrs2.x);
                attrs2.by = p2 && (toFloat(seg2[seg2len - 3]) || attrs2.y);
                attrs2.x = p2 && seg2[seg2len - 2];
                attrs2.y = p2 && seg2[seg2len - 1];
            }
            if (!p2) {
                pth.curve = pathClone(p);
            }
            return p2 ? [p, p2] : p;
        }, null, pathClone),
        parseDots = R._parseDots = cacher(function (gradient) {
            var dots = [];
            for (var i = 0, ii = gradient.length; i < ii; i++) {
                var dot = {},
                    par = gradient[i].match(/^([^:]*):?([\d\.]*)/);
                dot.color = R.getRGB(par[1]);
                if (dot.color.error) {
                    return null;
                }
                dot.opacity = dot.color.opacity;
                dot.color = dot.color.hex;
                par[2] && (dot.offset = par[2] + "%");
                dots.push(dot);
            }
            for (i = 1, ii = dots.length - 1; i < ii; i++) {
                if (!dots[i].offset) {
                    var start = toFloat(dots[i - 1].offset || 0),
                        end = 0;
                    for (var j = i + 1; j < ii; j++) {
                        if (dots[j].offset) {
                            end = dots[j].offset;
                            break;
                        }
                    }
                    if (!end) {
                        end = 100;
                        j = ii;
                    }
                    end = toFloat(end);
                    var d = (end - start) / (j - i + 1);
                    for (; i < j; i++) {
                        start += d;
                        dots[i].offset = start + "%";
                    }
                }
            }
            return dots;
        }),
        tear = R._tear = function (el, paper) {
            el == paper.top && (paper.top = el.prev);
            el == paper.bottom && (paper.bottom = el.next);
            el.next && (el.next.prev = el.prev);
            el.prev && (el.prev.next = el.next);
        },
        tofront = R._tofront = function (el, paper) {
            if (paper.top === el) {
                return;
            }
            tear(el, paper);
            el.next = null;
            el.prev = paper.top;
            paper.top.next = el;
            paper.top = el;
        },
        toback = R._toback = function (el, paper) {
            if (paper.bottom === el) {
                return;
            }
            tear(el, paper);
            el.next = paper.bottom;
            el.prev = null;
            paper.bottom.prev = el;
            paper.bottom = el;
        },
        insertafter = R._insertafter = function (el, el2, paper) {
            tear(el, paper);
            el2 == paper.top && (paper.top = el);
            el2.next && (el2.next.prev = el);
            el.next = el2.next;
            el.prev = el2;
            el2.next = el;
        },
        insertbefore = R._insertbefore = function (el, el2, paper) {
            tear(el, paper);
            el2 == paper.bottom && (paper.bottom = el);
            el2.prev && (el2.prev.next = el);
            el.prev = el2.prev;
            el2.prev = el;
            el.next = el2;
        },
    /*\
     * Raphael.toMatrix
     [ method ]
     **
     * Utility method
     **
     * Returns matrix of transformations applied to a given path
     > Parameters
     - path (string) path string
     - transform (string|array) transformation string
     = (object) @Matrix
     \*/
        toMatrix = R.toMatrix = function (path, transform) {
            var bb = pathDimensions(path),
                el = {
                    _: {
                        transform: E
                    },
                    getBBox: function () {
                        return bb;
                    }
                };
            extractTransform(el, transform);
            return el.matrix;
        },
    /*\
     * Raphael.transformPath
     [ method ]
     **
     * Utility method
     **
     * Returns path transformed by a given transformation
     > Parameters
     - path (string) path string
     - transform (string|array) transformation string
     = (string) path
     \*/
        transformPath = R.transformPath = function (path, transform) {
            return mapPath(path, toMatrix(path, transform));
        },
        extractTransform = R._extractTransform = function (el, tstr) {
            if (tstr == null) {
                return el._.transform;
            }
            tstr = Str(tstr).replace(/\.{3}|\u2026/g, el._.transform || E);
            var tdata = R.parseTransformString(tstr),
                deg = 0,
                dx = 0,
                dy = 0,
                sx = 1,
                sy = 1,
                _ = el._,
                m = new Matrix;
            _.transform = tdata || [];
            if (tdata) {
                for (var i = 0, ii = tdata.length; i < ii; i++) {
                    var t = tdata[i],
                        tlen = t.length,
                        command = Str(t[0]).toLowerCase(),
                        absolute = t[0] != command,
                        inver = absolute ? m.invert() : 0,
                        x1,
                        y1,
                        x2,
                        y2,
                        bb;
                    if (command == "t" && tlen == 3) {
                        if (absolute) {
                            x1 = inver.x(0, 0);
                            y1 = inver.y(0, 0);
                            x2 = inver.x(t[1], t[2]);
                            y2 = inver.y(t[1], t[2]);
                            m.translate(x2 - x1, y2 - y1);
                        } else {
                            m.translate(t[1], t[2]);
                        }
                    } else if (command == "r") {
                        if (tlen == 2) {
                            bb = bb || el.getBBox(1);
                            m.rotate(t[1], bb.x + bb.width / 2, bb.y + bb.height / 2);
                            deg += t[1];
                        } else if (tlen == 4) {
                            if (absolute) {
                                x2 = inver.x(t[2], t[3]);
                                y2 = inver.y(t[2], t[3]);
                                m.rotate(t[1], x2, y2);
                            } else {
                                m.rotate(t[1], t[2], t[3]);
                            }
                            deg += t[1];
                        }
                    } else if (command == "s") {
                        if (tlen == 2 || tlen == 3) {
                            bb = bb || el.getBBox(1);
                            m.scale(t[1], t[tlen - 1], bb.x + bb.width / 2, bb.y + bb.height / 2);
                            sx *= t[1];
                            sy *= t[tlen - 1];
                        } else if (tlen == 5) {
                            if (absolute) {
                                x2 = inver.x(t[3], t[4]);
                                y2 = inver.y(t[3], t[4]);
                                m.scale(t[1], t[2], x2, y2);
                            } else {
                                m.scale(t[1], t[2], t[3], t[4]);
                            }
                            sx *= t[1];
                            sy *= t[2];
                        }
                    } else if (command == "m" && tlen == 7) {
                        m.add(t[1], t[2], t[3], t[4], t[5], t[6]);
                    }
                    _.dirtyT = 1;
                    el.matrix = m;
                }
            }

            /*\
             * Element.matrix
             [ property (object) ]
             **
             * Keeps @Matrix object, which represents element transformation
             \*/
            el.matrix = m;

            _.sx = sx;
            _.sy = sy;
            _.deg = deg;
            _.dx = dx = m.e;
            _.dy = dy = m.f;

            if (sx == 1 && sy == 1 && !deg && _.bbox) {
                _.bbox.x += +dx;
                _.bbox.y += +dy;
            } else {
                _.dirtyT = 1;
            }
        },
        getEmpty = function (item) {
            var l = item[0];
            switch (l.toLowerCase()) {
                case "t": return [l, 0, 0];
                case "m": return [l, 1, 0, 0, 1, 0, 0];
                case "r": if (item.length == 4) {
                    return [l, 0, item[2], item[3]];
                } else {
                    return [l, 0];
                }
                case "s": if (item.length == 5) {
                    return [l, 1, 1, item[3], item[4]];
                } else if (item.length == 3) {
                    return [l, 1, 1];
                } else {
                    return [l, 1];
                }
            }
        },
        equaliseTransform = R._equaliseTransform = function (t1, t2) {
            t2 = Str(t2).replace(/\.{3}|\u2026/g, t1);
            t1 = R.parseTransformString(t1) || [];
            t2 = R.parseTransformString(t2) || [];
            var maxlength = mmax(t1.length, t2.length),
                from = [],
                to = [],
                i = 0, j, jj,
                tt1, tt2;
            for (; i < maxlength; i++) {
                tt1 = t1[i] || getEmpty(t2[i]);
                tt2 = t2[i] || getEmpty(tt1);
                if ((tt1[0] != tt2[0]) ||
                    (tt1[0].toLowerCase() == "r" && (tt1[2] != tt2[2] || tt1[3] != tt2[3])) ||
                    (tt1[0].toLowerCase() == "s" && (tt1[3] != tt2[3] || tt1[4] != tt2[4]))
                ) {
                    return;
                }
                from[i] = [];
                to[i] = [];
                for (j = 0, jj = mmax(tt1.length, tt2.length); j < jj; j++) {
                    j in tt1 && (from[i][j] = tt1[j]);
                    j in tt2 && (to[i][j] = tt2[j]);
                }
            }
            return {
                from: from,
                to: to
            };
        };
    R._getContainer = function (x, y, w, h) {
        var container;
        container = h == null && !R.is(x, "object") ? g.doc.getElementById(x) : x;
        if (container == null) {
            return;
        }
        if (container.tagName) {
            if (y == null) {
                return {
                    container: container,
                    width: container.style.pixelWidth || container.offsetWidth,
                    height: container.style.pixelHeight || container.offsetHeight
                };
            } else {
                return {
                    container: container,
                    width: y,
                    height: w
                };
            }
        }
        return {
            container: 1,
            x: x,
            y: y,
            width: w,
            height: h
        };
    };
    /*\
     * Raphael.pathToRelative
     [ method ]
     **
     * Utility method
     **
     * Converts path to relative form
     > Parameters
     - pathString (string|array) path string or array of segments
     = (array) array of segments.
     \*/
    R.pathToRelative = pathToRelative;
    R._engine = {};
    /*\
     * Raphael.path2curve
     [ method ]
     **
     * Utility method
     **
     * Converts path to a new path where all segments are cubic bezier curves.
     > Parameters
     - pathString (string|array) path string or array of segments
     = (array) array of segments.
     \*/
    R.path2curve = path2curve;
    /*\
     * Raphael.matrix
     [ method ]
     **
     * Utility method
     **
     * Returns matrix based on given parameters.
     > Parameters
     - a (number)
     - b (number)
     - c (number)
     - d (number)
     - e (number)
     - f (number)
     = (object) @Matrix
     \*/
    R.matrix = function (a, b, c, d, e, f) {
        return new Matrix(a, b, c, d, e, f);
    };
    function Matrix(a, b, c, d, e, f) {
        if (a != null) {
            this.a = +a;
            this.b = +b;
            this.c = +c;
            this.d = +d;
            this.e = +e;
            this.f = +f;
        } else {
            this.a = 1;
            this.b = 0;
            this.c = 0;
            this.d = 1;
            this.e = 0;
            this.f = 0;
        }
    }
    (function (matrixproto) {
        /*\
         * Matrix.add
         [ method ]
         **
         * Adds given matrix to existing one.
         > Parameters
         - a (number)
         - b (number)
         - c (number)
         - d (number)
         - e (number)
         - f (number)
         or
         - matrix (object) @Matrix
         \*/
        matrixproto.add = function (a, b, c, d, e, f) {
            var out = [[], [], []],
                m = [[this.a, this.c, this.e], [this.b, this.d, this.f], [0, 0, 1]],
                matrix = [[a, c, e], [b, d, f], [0, 0, 1]],
                x, y, z, res;

            if (a && a instanceof Matrix) {
                matrix = [[a.a, a.c, a.e], [a.b, a.d, a.f], [0, 0, 1]];
            }

            for (x = 0; x < 3; x++) {
                for (y = 0; y < 3; y++) {
                    res = 0;
                    for (z = 0; z < 3; z++) {
                        res += m[x][z] * matrix[z][y];
                    }
                    out[x][y] = res;
                }
            }
            this.a = out[0][0];
            this.b = out[1][0];
            this.c = out[0][1];
            this.d = out[1][1];
            this.e = out[0][2];
            this.f = out[1][2];
        };
        /*\
         * Matrix.invert
         [ method ]
         **
         * Returns inverted version of the matrix
         = (object) @Matrix
         \*/
        matrixproto.invert = function () {
            var me = this,
                x = me.a * me.d - me.b * me.c;
            return new Matrix(me.d / x, -me.b / x, -me.c / x, me.a / x, (me.c * me.f - me.d * me.e) / x, (me.b * me.e - me.a * me.f) / x);
        };
        /*\
         * Matrix.clone
         [ method ]
         **
         * Returns copy of the matrix
         = (object) @Matrix
         \*/
        matrixproto.clone = function () {
            return new Matrix(this.a, this.b, this.c, this.d, this.e, this.f);
        };
        /*\
         * Matrix.translate
         [ method ]
         **
         * Translate the matrix
         > Parameters
         - x (number)
         - y (number)
         \*/
        matrixproto.translate = function (x, y) {
            this.add(1, 0, 0, 1, x, y);
        };
        /*\
         * Matrix.scale
         [ method ]
         **
         * Scales the matrix
         > Parameters
         - x (number)
         - y (number) #optional
         - cx (number) #optional
         - cy (number) #optional
         \*/
        matrixproto.scale = function (x, y, cx, cy) {
            y == null && (y = x);
            (cx || cy) && this.add(1, 0, 0, 1, cx, cy);
            this.add(x, 0, 0, y, 0, 0);
            (cx || cy) && this.add(1, 0, 0, 1, -cx, -cy);
        };
        /*\
         * Matrix.rotate
         [ method ]
         **
         * Rotates the matrix
         > Parameters
         - a (number)
         - x (number)
         - y (number)
         \*/
        matrixproto.rotate = function (a, x, y) {
            a = R.rad(a);
            x = x || 0;
            y = y || 0;
            var cos = +math.cos(a).toFixed(9),
                sin = +math.sin(a).toFixed(9);
            this.add(cos, sin, -sin, cos, x, y);
            this.add(1, 0, 0, 1, -x, -y);
        };
        /*\
         * Matrix.x
         [ method ]
         **
         * Return x coordinate for given point after transformation described by the matrix. See also @Matrix.y
         > Parameters
         - x (number)
         - y (number)
         = (number) x
         \*/
        matrixproto.x = function (x, y) {
            return x * this.a + y * this.c + this.e;
        };
        /*\
         * Matrix.y
         [ method ]
         **
         * Return y coordinate for given point after transformation described by the matrix. See also @Matrix.x
         > Parameters
         - x (number)
         - y (number)
         = (number) y
         \*/
        matrixproto.y = function (x, y) {
            return x * this.b + y * this.d + this.f;
        };
        matrixproto.get = function (i) {
            return +this[Str.fromCharCode(97 + i)].toFixed(4);
        };
        matrixproto.toString = function () {
            return R.svg ?
            "matrix(" + [this.get(0), this.get(1), this.get(2), this.get(3), this.get(4), this.get(5)].join() + ")" :
                [this.get(0), this.get(2), this.get(1), this.get(3), 0, 0].join();
        };
        matrixproto.toFilter = function () {
            return "progid:DXImageTransform.Microsoft.Matrix(M11=" + this.get(0) +
                ", M12=" + this.get(2) + ", M21=" + this.get(1) + ", M22=" + this.get(3) +
                ", Dx=" + this.get(4) + ", Dy=" + this.get(5) + ", sizingmethod='auto expand')";
        };
        matrixproto.offset = function () {
            return [this.e.toFixed(4), this.f.toFixed(4)];
        };
        function norm(a) {
            return a[0] * a[0] + a[1] * a[1];
        }
        function normalize(a) {
            var mag = math.sqrt(norm(a));
            a[0] && (a[0] /= mag);
            a[1] && (a[1] /= mag);
        }
        /*\
         * Matrix.split
         [ method ]
         **
         * Splits matrix into primitive transformations
         = (object) in format:
         o dx (number) translation by x
         o dy (number) translation by y
         o scalex (number) scale by x
         o scaley (number) scale by y
         o shear (number) shear
         o rotate (number) rotation in deg
         o isSimple (boolean) could it be represented via simple transformations
         \*/
        matrixproto.split = function () {
            var out = {};
            // translation
            out.dx = this.e;
            out.dy = this.f;

            // scale and shear
            var row = [[this.a, this.c], [this.b, this.d]];
            out.scalex = math.sqrt(norm(row[0]));
            normalize(row[0]);

            out.shear = row[0][0] * row[1][0] + row[0][1] * row[1][1];
            row[1] = [row[1][0] - row[0][0] * out.shear, row[1][1] - row[0][1] * out.shear];

            out.scaley = math.sqrt(norm(row[1]));
            normalize(row[1]);
            out.shear /= out.scaley;

            // rotation
            var sin = -row[0][1],
                cos = row[1][1];
            if (cos < 0) {
                out.rotate = R.deg(math.acos(cos));
                if (sin < 0) {
                    out.rotate = 360 - out.rotate;
                }
            } else {
                out.rotate = R.deg(math.asin(sin));
            }

            out.isSimple = !+out.shear.toFixed(9) && (out.scalex.toFixed(9) == out.scaley.toFixed(9) || !out.rotate);
            out.isSuperSimple = !+out.shear.toFixed(9) && out.scalex.toFixed(9) == out.scaley.toFixed(9) && !out.rotate;
            out.noRotation = !+out.shear.toFixed(9) && !out.rotate;
            return out;
        };
        /*\
         * Matrix.toTransformString
         [ method ]
         **
         * Return transform string that represents given matrix
         = (string) transform string
         \*/
        matrixproto.toTransformString = function (shorter) {
            var s = shorter || this[split]();
            if (s.isSimple) {
                s.scalex = +s.scalex.toFixed(4);
                s.scaley = +s.scaley.toFixed(4);
                s.rotate = +s.rotate.toFixed(4);
                return  (s.dx || s.dy ? "t" + [s.dx, s.dy] : E) +
                    (s.scalex != 1 || s.scaley != 1 ? "s" + [s.scalex, s.scaley, 0, 0] : E) +
                    (s.rotate ? "r" + [s.rotate, 0, 0] : E);
            } else {
                return "m" + [this.get(0), this.get(1), this.get(2), this.get(3), this.get(4), this.get(5)];
            }
        };
    })(Matrix.prototype);

    var preventDefault = function () {
            this.returnValue = false;
        },
        preventTouch = function () {
            return this.originalEvent.preventDefault();
        },
        stopPropagation = function () {
            this.cancelBubble = true;
        },
        stopTouch = function () {
            return this.originalEvent.stopPropagation();
        },
        getEventPosition = function (e) {
            var scrollY = g.doc.documentElement.scrollTop || g.doc.body.scrollTop,
                scrollX = g.doc.documentElement.scrollLeft || g.doc.body.scrollLeft;

            return {
                x: e.clientX + scrollX,
                y: e.clientY + scrollY
            };
        },
        addEvent = (function () {
            if (g.doc.addEventListener) {
                return function (obj, type, fn, element) {
                    var f = function (e) {
                        var pos = getEventPosition(e);
                        return fn.call(element, e, pos.x, pos.y);
                    };
                    obj.addEventListener(type, f, false);

                    if (supportsTouch && touchMap[type]) {
                        var _f = function (e) {
                            var pos = getEventPosition(e),
                                olde = e;

                            for (var i = 0, ii = e.targetTouches && e.targetTouches.length; i < ii; i++) {
                                if (e.targetTouches[i].target == obj) {
                                    e = e.targetTouches[i];
                                    e.originalEvent = olde;
                                    e.preventDefault = preventTouch;
                                    e.stopPropagation = stopTouch;
                                    break;
                                }
                            }

                            return fn.call(element, e, pos.x, pos.y);
                        };
                        obj.addEventListener(touchMap[type], _f, false);
                    }

                    return function () {
                        obj.removeEventListener(type, f, false);

                        if (supportsTouch && touchMap[type])
                            obj.removeEventListener(touchMap[type], _f, false);

                        return true;
                    };
                };
            } else if (g.doc.attachEvent) {
                return function (obj, type, fn, element) {
                    var f = function (e) {
                        e = e || g.win.event;
                        var scrollY = g.doc.documentElement.scrollTop || g.doc.body.scrollTop,
                            scrollX = g.doc.documentElement.scrollLeft || g.doc.body.scrollLeft,
                            x = e.clientX + scrollX,
                            y = e.clientY + scrollY;
                        e.preventDefault = e.preventDefault || preventDefault;
                        e.stopPropagation = e.stopPropagation || stopPropagation;
                        return fn.call(element, e, x, y);
                    };
                    obj.attachEvent("on" + type, f);
                    var detacher = function () {
                        obj.detachEvent("on" + type, f);
                        return true;
                    };
                    return detacher;
                };
            }
        })(),
        drag = [],
        dragMove = function (e) {
            var x = e.clientX,
                y = e.clientY,
                scrollY = g.doc.documentElement.scrollTop || g.doc.body.scrollTop,
                scrollX = g.doc.documentElement.scrollLeft || g.doc.body.scrollLeft,
                dragi,
                j = drag.length;
            while (j--) {
                dragi = drag[j];
                if (supportsTouch && e.touches) {
                    var i = e.touches.length,
                        touch;
                    while (i--) {
                        touch = e.touches[i];
                        if (touch.identifier == dragi.el._drag.id) {
                            x = touch.clientX;
                            y = touch.clientY;
                            (e.originalEvent ? e.originalEvent : e).preventDefault();
                            break;
                        }
                    }
                } else {
                    e.preventDefault();
                }
                var node = dragi.el.node,
                    o,
                    next = node.nextSibling,
                    parent = node.parentNode,
                    display = node.style.display;
                g.win.opera && parent.removeChild(node);
                node.style.display = "none";
                o = dragi.el.paper.getElementByPoint(x, y);
                node.style.display = display;
                g.win.opera && (next ? parent.insertBefore(node, next) : parent.appendChild(node));
                o && eve("raphael.drag.over." + dragi.el.id, dragi.el, o);
                x += scrollX;
                y += scrollY;
                eve("raphael.drag.move." + dragi.el.id, dragi.move_scope || dragi.el, x - dragi.el._drag.x, y - dragi.el._drag.y, x, y, e);
            }
        },
        dragUp = function (e) {
            R.unmousemove(dragMove).unmouseup(dragUp);
            var i = drag.length,
                dragi;
            while (i--) {
                dragi = drag[i];
                dragi.el._drag = {};
                eve("raphael.drag.end." + dragi.el.id, dragi.end_scope || dragi.start_scope || dragi.move_scope || dragi.el, e);
            }
            drag = [];
        },
    /*\
     * Raphael.el
     [ property (object) ]
     **
     * You can add your own method to elements. This is usefull when you want to hack default functionality or
     * want to wrap some common transformation or attributes in one method. In difference to canvas methods,
     * you can redefine element method at any time. Expending element methods wouldn’t affect set.
     > Usage
     | Raphael.el.red = function () {
     |     this.attr({fill: "#f00"});
     | };
     | // then use it
     | paper.circle(100, 100, 20).red();
     \*/
        elproto = R.el = {};
    /*\
     * Element.click
     [ method ]
     **
     * Adds event handler for click for the element.
     > Parameters
     - handler (function) handler for the event
     = (object) @Element
     \*/
    /*\
     * Element.unclick
     [ method ]
     **
     * Removes event handler for click for the element.
     > Parameters
     - handler (function) #optional handler for the event
     = (object) @Element
     \*/

    /*\
     * Element.dblclick
     [ method ]
     **
     * Adds event handler for double click for the element.
     > Parameters
     - handler (function) handler for the event
     = (object) @Element
     \*/
    /*\
     * Element.undblclick
     [ method ]
     **
     * Removes event handler for double click for the element.
     > Parameters
     - handler (function) #optional handler for the event
     = (object) @Element
     \*/

    /*\
     * Element.mousedown
     [ method ]
     **
     * Adds event handler for mousedown for the element.
     > Parameters
     - handler (function) handler for the event
     = (object) @Element
     \*/
    /*\
     * Element.unmousedown
     [ method ]
     **
     * Removes event handler for mousedown for the element.
     > Parameters
     - handler (function) #optional handler for the event
     = (object) @Element
     \*/

    /*\
     * Element.mousemove
     [ method ]
     **
     * Adds event handler for mousemove for the element.
     > Parameters
     - handler (function) handler for the event
     = (object) @Element
     \*/
    /*\
     * Element.unmousemove
     [ method ]
     **
     * Removes event handler for mousemove for the element.
     > Parameters
     - handler (function) #optional handler for the event
     = (object) @Element
     \*/

    /*\
     * Element.mouseout
     [ method ]
     **
     * Adds event handler for mouseout for the element.
     > Parameters
     - handler (function) handler for the event
     = (object) @Element
     \*/
    /*\
     * Element.unmouseout
     [ method ]
     **
     * Removes event handler for mouseout for the element.
     > Parameters
     - handler (function) #optional handler for the event
     = (object) @Element
     \*/

    /*\
     * Element.mouseover
     [ method ]
     **
     * Adds event handler for mouseover for the element.
     > Parameters
     - handler (function) handler for the event
     = (object) @Element
     \*/
    /*\
     * Element.unmouseover
     [ method ]
     **
     * Removes event handler for mouseover for the element.
     > Parameters
     - handler (function) #optional handler for the event
     = (object) @Element
     \*/

    /*\
     * Element.mouseup
     [ method ]
     **
     * Adds event handler for mouseup for the element.
     > Parameters
     - handler (function) handler for the event
     = (object) @Element
     \*/
    /*\
     * Element.unmouseup
     [ method ]
     **
     * Removes event handler for mouseup for the element.
     > Parameters
     - handler (function) #optional handler for the event
     = (object) @Element
     \*/

    /*\
     * Element.touchstart
     [ method ]
     **
     * Adds event handler for touchstart for the element.
     > Parameters
     - handler (function) handler for the event
     = (object) @Element
     \*/
    /*\
     * Element.untouchstart
     [ method ]
     **
     * Removes event handler for touchstart for the element.
     > Parameters
     - handler (function) #optional handler for the event
     = (object) @Element
     \*/

    /*\
     * Element.touchmove
     [ method ]
     **
     * Adds event handler for touchmove for the element.
     > Parameters
     - handler (function) handler for the event
     = (object) @Element
     \*/
    /*\
     * Element.untouchmove
     [ method ]
     **
     * Removes event handler for touchmove for the element.
     > Parameters
     - handler (function) #optional handler for the event
     = (object) @Element
     \*/

    /*\
     * Element.touchend
     [ method ]
     **
     * Adds event handler for touchend for the element.
     > Parameters
     - handler (function) handler for the event
     = (object) @Element
     \*/
    /*\
     * Element.untouchend
     [ method ]
     **
     * Removes event handler for touchend for the element.
     > Parameters
     - handler (function) #optional handler for the event
     = (object) @Element
     \*/

    /*\
     * Element.touchcancel
     [ method ]
     **
     * Adds event handler for touchcancel for the element.
     > Parameters
     - handler (function) handler for the event
     = (object) @Element
     \*/
    /*\
     * Element.untouchcancel
     [ method ]
     **
     * Removes event handler for touchcancel for the element.
     > Parameters
     - handler (function) #optional handler for the event
     = (object) @Element
     \*/
    for (var i = events.length; i--;) {
        (function (eventName) {
            R[eventName] = elproto[eventName] = function (fn, scope) {
                if (R.is(fn, "function")) {
                    this.events = this.events || [];
                    this.events.push({name: eventName, f: fn, unbind: addEvent(this.shape || this.node || g.doc, eventName, fn, scope || this)});
                }
                return this;
            };
            R["un" + eventName] = elproto["un" + eventName] = function (fn) {
                var events = this.events || [],
                    l = events.length;
                while (l--){
                    if (events[l].name == eventName && (R.is(fn, "undefined") || events[l].f == fn)) {
                        events[l].unbind();
                        events.splice(l, 1);
                        !events.length && delete this.events;
                    }
                }
                return this;
            };
        })(events[i]);
    }

    /*\
     * Element.data
     [ method ]
     **
     * Adds or retrieves given value asociated with given key.
     **
     * See also @Element.removeData
     > Parameters
     - key (string) key to store data
     - value (any) #optional value to store
     = (object) @Element
     * or, if value is not specified:
     = (any) value
     * or, if key and value are not specified:
     = (object) Key/value pairs for all the data associated with the element.
     > Usage
     | for (var i = 0, i < 5, i++) {
     |     paper.circle(10 + 15 * i, 10, 10)
     |          .attr({fill: "#000"})
     |          .data("i", i)
     |          .click(function () {
     |             alert(this.data("i"));
     |          });
     | }
     \*/
    elproto.data = function (key, value) {
        var data = eldata[this.id] = eldata[this.id] || {};
        if (arguments.length == 0) {
            return data;
        }
        if (arguments.length == 1) {
            if (R.is(key, "object")) {
                for (var i in key) if (key[has](i)) {
                    this.data(i, key[i]);
                }
                return this;
            }
            eve("raphael.data.get." + this.id, this, data[key], key);
            return data[key];
        }
        data[key] = value;
        eve("raphael.data.set." + this.id, this, value, key);
        return this;
    };

    elproto.datum = function(){
        return arguments.length == 0 ? this._bindData : ((this._bindData = arguments[0]), this);
    };

    /*\
     * Element.removeData
     [ method ]
     **
     * Removes value associated with an element by given key.
     * If key is not provided, removes all the data of the element.
     > Parameters
     - key (string) #optional key
     = (object) @Element
     \*/
    elproto.removeData = function (key) {
        if (key == null) {
            eldata[this.id] = {};
        } else {
            eldata[this.id] && delete eldata[this.id][key];
        }
        return this;
    };
    /*\
     * Element.getData
     [ method ]
     **
     * Retrieves the element data
     = (object) data
     \*/
    elproto.getData = function () {
        return clone(eldata[this.id] || {});
    };
    /*\
     * Element.hover
     [ method ]
     **
     * Adds event handlers for hover for the element.
     > Parameters
     - f_in (function) handler for hover in
     - f_out (function) handler for hover out
     - icontext (object) #optional context for hover in handler
     - ocontext (object) #optional context for hover out handler
     = (object) @Element
     \*/
    elproto.hover = function (f_in, f_out, scope_in, scope_out) {
        return this.mouseover(f_in, scope_in).mouseout(f_out, scope_out || scope_in);
    };
    /*\
     * Element.unhover
     [ method ]
     **
     * Removes event handlers for hover for the element.
     > Parameters
     - f_in (function) handler for hover in
     - f_out (function) handler for hover out
     = (object) @Element
     \*/
    elproto.unhover = function (f_in, f_out) {
        return this.unmouseover(f_in).unmouseout(f_out);
    };
    var draggable = [];
    /*\
     * Element.drag
     [ method ]
     **
     * Adds event handlers for drag of the element.
     > Parameters
     - onmove (function) handler for moving
     - onstart (function) handler for drag start
     - onend (function) handler for drag end
     - mcontext (object) #optional context for moving handler
     - scontext (object) #optional context for drag start handler
     - econtext (object) #optional context for drag end handler
     * Additionaly following `drag` events will be triggered: `drag.start.<id>` on start,
     * `drag.end.<id>` on end and `drag.move.<id>` on every move. When element will be dragged over another element
     * `drag.over.<id>` will be fired as well.
     *
     * Start event and start handler will be called in specified context or in context of the element with following parameters:
     o x (number) x position of the mouse
     o y (number) y position of the mouse
     o event (object) DOM event object
     * Move event and move handler will be called in specified context or in context of the element with following parameters:
     o dx (number) shift by x from the start point
     o dy (number) shift by y from the start point
     o x (number) x position of the mouse
     o y (number) y position of the mouse
     o event (object) DOM event object
     * End event and end handler will be called in specified context or in context of the element with following parameters:
     o event (object) DOM event object
     = (object) @Element
     \*/
    elproto.drag = function (onmove, onstart, onend, move_scope, start_scope, end_scope) {
        function start(e) {
            (e.originalEvent || e).preventDefault();
            var x = e.clientX,
                y = e.clientY,
                scrollY = g.doc.documentElement.scrollTop || g.doc.body.scrollTop,
                scrollX = g.doc.documentElement.scrollLeft || g.doc.body.scrollLeft;
            this._drag.id = e.identifier;
            if (supportsTouch && e.touches) {
                var i = e.touches.length, touch;
                while (i--) {
                    touch = e.touches[i];
                    this._drag.id = touch.identifier;
                    if (touch.identifier == this._drag.id) {
                        x = touch.clientX;
                        y = touch.clientY;
                        break;
                    }
                }
            }
            this._drag.x = x + scrollX;
            this._drag.y = y + scrollY;
            !drag.length && R.mousemove(dragMove).mouseup(dragUp);
            drag.push({el: this, move_scope: move_scope, start_scope: start_scope, end_scope: end_scope});
            onstart && eve.on("raphael.drag.start." + this.id, onstart);
            onmove && eve.on("raphael.drag.move." + this.id, onmove);
            onend && eve.on("raphael.drag.end." + this.id, onend);
            eve("raphael.drag.start." + this.id, start_scope || move_scope || this, e.clientX + scrollX, e.clientY + scrollY, e);
        }
        this._drag = {};
        draggable.push({el: this, start: start});
        this.mousedown(start);
        return this;
    };
    /*\
     * Element.onDragOver
     [ method ]
     **
     * Shortcut for assigning event handler for `drag.over.<id>` event, where id is id of the element (see @Element.id).
     > Parameters
     - f (function) handler for event, first argument would be the element you are dragging over
     \*/
    elproto.onDragOver = function (f) {
        f ? eve.on("raphael.drag.over." + this.id, f) : eve.unbind("raphael.drag.over." + this.id);
    };
    /*\
     * Element.undrag
     [ method ]
     **
     * Removes all drag event handlers from given element.
     \*/
    elproto.undrag = function () {
        var i = draggable.length;
        while (i--) if (draggable[i].el == this) {
            this.unmousedown(draggable[i].start);
            draggable.splice(i, 1);
            eve.unbind("raphael.drag.*." + this.id);
        }
        !draggable.length && R.unmousemove(dragMove).unmouseup(dragUp);
        drag = [];
    };
    /*\
     * Paper.circle
     [ method ]
     **
     * Draws a circle.
     **
     > Parameters
     **
     - x (number) x coordinate of the centre
     - y (number) y coordinate of the centre
     - r (number) radius
     = (object) Raphaël element object with type “circle”
     **
     > Usage
     | var c = paper.circle(50, 50, 40);
     \*/
    paperproto.circle = function (x, y, r) {
        var out = R._engine.circle(this, x || 0, y || 0, r || 0);
        this.__set__ && this.__set__.push(out);
        return out;
    };
    /*\
     * Paper.rect
     [ method ]
     *
     * Draws a rectangle.
     **
     > Parameters
     **
     - x (number) x coordinate of the top left corner
     - y (number) y coordinate of the top left corner
     - width (number) width
     - height (number) height
     - r (number) #optional radius for rounded corners, default is 0
     = (object) Raphaël element object with type “rect”
     **
     > Usage
     | // regular rectangle
     | var c = paper.rect(10, 10, 50, 50);
     | // rectangle with rounded corners
     | var c = paper.rect(40, 40, 50, 50, 10);
     \*/
    paperproto.rect = function (x, y, w, h, r) {
        var out = R._engine.rect(this, x || 0, y || 0, w || 0, h || 0, r || 0);
        this.__set__ && this.__set__.push(out);
        return out;
    };
    /*\
     * Paper.ellipse
     [ method ]
     **
     * Draws an ellipse.
     **
     > Parameters
     **
     - x (number) x coordinate of the centre
     - y (number) y coordinate of the centre
     - rx (number) horizontal radius
     - ry (number) vertical radius
     = (object) Raphaël element object with type “ellipse”
     **
     > Usage
     | var c = paper.ellipse(50, 50, 40, 20);
     \*/
    paperproto.ellipse = function (x, y, rx, ry) {
        var out = R._engine.ellipse(this, x || 0, y || 0, rx || 0, ry || 0);
        this.__set__ && this.__set__.push(out);
        return out;
    };
    /*\
     * Paper.path
     [ method ]
     **
     * Creates a path element by given path data string.
     > Parameters
     - pathString (string) #optional path string in SVG format.
     * Path string consists of one-letter commands, followed by comma seprarated arguments in numercal form. Example:
     | "M10,20L30,40"
     * Here we can see two commands: “M”, with arguments `(10, 20)` and “L” with arguments `(30, 40)`. Upper case letter mean command is absolute, lower case—relative.
     *
     # <p>Here is short list of commands available, for more details see <a href="http://www.w3.org/TR/SVG/paths.html#PathData" title="Details of a path's data attribute's format are described in the SVG specification.">SVG path string format</a>.</p>
     # <table><thead><tr><th>Command</th><th>Name</th><th>Parameters</th></tr></thead><tbody>
     # <tr><td>M</td><td>moveto</td><td>(x y)+</td></tr>
     # <tr><td>Z</td><td>closepath</td><td>(none)</td></tr>
     # <tr><td>L</td><td>lineto</td><td>(x y)+</td></tr>
     # <tr><td>H</td><td>horizontal lineto</td><td>x+</td></tr>
     # <tr><td>V</td><td>vertical lineto</td><td>y+</td></tr>
     # <tr><td>C</td><td>curveto</td><td>(x1 y1 x2 y2 x y)+</td></tr>
     # <tr><td>S</td><td>smooth curveto</td><td>(x2 y2 x y)+</td></tr>
     # <tr><td>Q</td><td>quadratic Bézier curveto</td><td>(x1 y1 x y)+</td></tr>
     # <tr><td>T</td><td>smooth quadratic Bézier curveto</td><td>(x y)+</td></tr>
     # <tr><td>A</td><td>elliptical arc</td><td>(rx ry x-axis-rotation large-arc-flag sweep-flag x y)+</td></tr>
     # <tr><td>R</td><td><a href="http://en.wikipedia.org/wiki/Catmull–Rom_spline#Catmull.E2.80.93Rom_spline">Catmull-Rom curveto</a>*</td><td>x1 y1 (x y)+</td></tr></tbody></table>
     * * “Catmull-Rom curveto” is a not standard SVG command and added in 2.0 to make life easier.
     * Note: there is a special case when path consist of just three commands: “M10,10R…z”. In this case path will smoothly connects to its beginning.
     > Usage
     | var c = paper.path("M10 10L90 90");
     | // draw a diagonal line:
     | // move to 10,10, line to 90,90
     * For example of path strings, check out these icons: http://raphaeljs.com/icons/
     \*/
    paperproto.path = function (pathString) {
        pathString && !R.is(pathString, string) && !R.is(pathString[0], array) && (pathString += E);
        var out = R._engine.path(R.format[apply](R, arguments), this);
        this.__set__ && this.__set__.push(out);
        return out;
    };
    /*\
     * Paper.image
     [ method ]
     **
     * Embeds an image into the surface.
     **
     > Parameters
     **
     - src (string) URI of the source image
     - x (number) x coordinate position
     - y (number) y coordinate position
     - width (number) width of the image
     - height (number) height of the image
     = (object) Raphaël element object with type “image”
     **
     > Usage
     | var c = paper.image("apple.png", 10, 10, 80, 80);
     \*/
    paperproto.image = function (src, x, y, w, h) {
        var out = R._engine.image(this, src || "about:blank", x || 0, y || 0, w || 0, h || 0);
        this.__set__ && this.__set__.push(out);
        return out;
    };
    /*\
     * Paper.text
     [ method ]
     **
     * Draws a text string. If you need line breaks, put “\n” in the string.
     **
     > Parameters
     **
     - x (number) x coordinate position
     - y (number) y coordinate position
     - text (string) The text string to draw
     = (object) Raphaël element object with type “text”
     **
     > Usage
     | var t = paper.text(50, 50, "Raphaël\nkicks\nbutt!");
     \*/
    paperproto.text = function (x, y, text) {
        var out = R._engine.text(this, x || 0, y || 0, Str(text));
        this.__set__ && this.__set__.push(out);
        return out;
    };
    /*\
     * Paper.set
     [ method ]
     **
     * Creates array-like object to keep and operate several elements at once.
     * Warning: it doesn’t create any elements for itself in the page, it just groups existing elements.
     * Sets act as pseudo elements — all methods available to an element can be used on a set.
     = (object) array-like object that represents set of elements
     **
     > Usage
     | var st = paper.set();
     | st.push(
     |     paper.circle(10, 10, 5),
     |     paper.circle(30, 10, 5)
     | );
     | st.attr({fill: "red"}); // changes the fill of both circles
     \*/
    paperproto.set = function (itemsArray) {
        !R.is(itemsArray, "array") && (itemsArray = Array.prototype.splice.call(arguments, 0, arguments.length));
        var out = new Set(itemsArray);
        this.__set__ && this.__set__.push(out);
        out["paper"] = this;
        out["type"] = "set";
        return out;
    };
    /*\
     * Paper.setStart
     [ method ]
     **
     * Creates @Paper.set. All elements that will be created after calling this method and before calling
     * @Paper.setFinish will be added to the set.
     **
     > Usage
     | paper.setStart();
     | paper.circle(10, 10, 5),
     | paper.circle(30, 10, 5)
     | var st = paper.setFinish();
     | st.attr({fill: "red"}); // changes the fill of both circles
     \*/
    paperproto.setStart = function (set) {
        this.__set__ = set || this.set();
    };
    /*\
     * Paper.setFinish
     [ method ]
     **
     * See @Paper.setStart. This method finishes catching and returns resulting set.
     **
     = (object) set
     \*/
    paperproto.setFinish = function (set) {
        var out = this.__set__;
        delete this.__set__;
        return out;
    };
    /*\
     * Paper.getSize
     [ method ]
     **
     * Obtains current paper actual size.
     **
     = (object)
     \*/
    paperproto.getSize = function () {
        var container = this.canvas.parentNode;
        return {
            width: container.offsetWidth,
            height: container.offsetHeight
        };
    };
    /*\
     * Paper.setSize
     [ method ]
     **
     * If you need to change dimensions of the canvas call this method
     **
     > Parameters
     **
     - width (number) new width of the canvas
     - height (number) new height of the canvas
     \*/
    paperproto.setSize = function (width, height) {
        return R._engine.setSize.call(this, width, height);
    };
    /*\
     * Paper.setViewBox
     [ method ]
     **
     * Sets the view box of the paper. Practically it gives you ability to zoom and pan whole paper surface by
     * specifying new boundaries.
     **
     > Parameters
     **
     - x (number) new x position, default is `0`
     - y (number) new y position, default is `0`
     - w (number) new width of the canvas
     - h (number) new height of the canvas
     - fit (boolean) `true` if you want graphics to fit into new boundary box
     \*/
    paperproto.setViewBox = function (x, y, w, h, fit) {
        return R._engine.setViewBox.call(this, x, y, w, h, fit);
    };
    /*\
     * Paper.top
     [ property ]
     **
     * Points to the topmost element on the paper
     \*/
    /*\
     * Paper.bottom
     [ property ]
     **
     * Points to the bottom element on the paper
     \*/
    paperproto.top = paperproto.bottom = null;
    /*\
     * Paper.raphael
     [ property ]
     **
     * Points to the @Raphael object/function
     \*/
    paperproto.raphael = R;
    var getOffset = function (elem) {
        var box = elem.getBoundingClientRect(),
            doc = elem.ownerDocument,
            body = doc.body,
            docElem = doc.documentElement,
            clientTop = docElem.clientTop || body.clientTop || 0, clientLeft = docElem.clientLeft || body.clientLeft || 0,
            top  = box.top  + (g.win.pageYOffset || docElem.scrollTop || body.scrollTop ) - clientTop,
            left = box.left + (g.win.pageXOffset || docElem.scrollLeft || body.scrollLeft) - clientLeft;
        return {
            y: top,
            x: left
        };
    };
    /*\
     * Paper.getElementByPoint
     [ method ]
     **
     * Returns you topmost element under given point.
     **
     = (object) Raphaël element object
     > Parameters
     **
     - x (number) x coordinate from the top left corner of the window
     - y (number) y coordinate from the top left corner of the window
     > Usage
     | paper.getElementByPoint(mouseX, mouseY).attr({stroke: "#f00"});
     \*/
    paperproto.getElementByPoint = function (x, y) {
        var paper = this,
            svg = paper.canvas,
            target = g.doc.elementFromPoint(x, y);
        if (g.win.opera && target.tagName == "svg") {
            var so = getOffset(svg),
                sr = svg.createSVGRect();
            sr.x = x - so.x;
            sr.y = y - so.y;
            sr.width = sr.height = 1;
            var hits = svg.getIntersectionList(sr, null);
            if (hits.length) {
                target = hits[hits.length - 1];
            }
        }
        if (!target) {
            return null;
        }
        while (target.parentNode && target != svg.parentNode && !target.raphael) {
            target = target.parentNode;
        }
        target == paper.canvas.parentNode && (target = svg);
        target = target && target.raphael ? paper.getById(target.raphaelid) : null;
        return target;
    };

    /*\
     * Paper.getElementsByBBox
     [ method ]
     **
     * Returns set of elements that have an intersecting bounding box
     **
     > Parameters
     **
     - bbox (object) bbox to check with
     = (object) @Set
     \*/
    paperproto.getElementsByBBox = function (bbox) {
        var set = this.set();
        this.forEach(function (el) {
            if (R.isBBoxIntersect(el.getBBox(), bbox)) {
                set.push(el);
            }
        });
        return set;
    };

    /*\
     * Paper.getById
     [ method ]
     **
     * Returns you element by its internal ID.
     **
     > Parameters
     **
     - id (number) id
     = (object) Raphaël element object
     \*/
    paperproto.getById = function (id) {
        var bot = this.bottom;
        while (bot) {
            if (bot.id == id) {
                return bot;
            }
            bot = bot.next;
        }
        return null;
    };
    /*\
     * Paper.forEach
     [ method ]
     **
     * Executes given function for each element on the paper
     *
     * If callback function returns `false` it will stop loop running.
     **
     > Parameters
     **
     - callback (function) function to run
     - thisArg (object) context object for the callback
     = (object) Paper object
     > Usage
     | paper.forEach(function (el) {
     |     el.attr({ stroke: "blue" });
     | });
     \*/
    paperproto.forEach = function (callback, thisArg) {
        var bot = this.bottom;
        while (bot) {
            if (callback.call(thisArg, bot) === false) {
                return this;
            }
            bot = bot.next;
        }
        return this;
    };
    /*\
     * Paper.getElementsByPoint
     [ method ]
     **
     * Returns set of elements that have common point inside
     **
     > Parameters
     **
     - x (number) x coordinate of the point
     - y (number) y coordinate of the point
     = (object) @Set
     \*/
    paperproto.getElementsByPoint = function (x, y) {
        var set = this.set();
        this.forEach(function (el) {
            if (el.isPointInside(x, y)) {
                set.push(el);
            }
        });
        return set;
    };
    function x_y() {
        return this.x + S + this.y;
    }
    function x_y_w_h() {
        return this.x + S + this.y + S + this.width + " \xd7 " + this.height;
    }
    /*\
     * Element.isPointInside
     [ method ]
     **
     * Determine if given point is inside this element’s shape
     **
     > Parameters
     **
     - x (number) x coordinate of the point
     - y (number) y coordinate of the point
     = (boolean) `true` if point inside the shape
     \*/
    elproto.isPointInside = function (x, y) {
        var rp = this.realPath = getPath[this.type](this);
        if (this.attr('transform') && this.attr('transform').length) {
            rp = R.transformPath(rp, this.attr('transform'));
        }
        return R.isPointInsidePath(rp, x, y);
    };
    /*\
     * Element.getBBox
     [ method ]
     **
     * Return bounding box for a given element
     **
     > Parameters
     **
     - isWithoutTransform (boolean) flag, `true` if you want to have bounding box before transformations. Default is `false`.
     = (object) Bounding box object:
     o {
     o     x: (number) top left corner x
     o     y: (number) top left corner y
     o     x2: (number) bottom right corner x
     o     y2: (number) bottom right corner y
     o     width: (number) width
     o     height: (number) height
     o }
     \*/
    elproto.getBBox = function (isWithoutTransform) {
        if (this.removed) {
            return {};
        }
        var _ = this._;
        if (isWithoutTransform) {
            if (_.dirty || !_.bboxwt) {
                this.realPath = getPath[this.type](this);
                _.bboxwt = pathDimensions(this.realPath);
                _.bboxwt.toString = x_y_w_h;
                _.dirty = 0;
            }
            return _.bboxwt;
        }
        if (_.dirty || _.dirtyT || !_.bbox) {
            if (_.dirty || !this.realPath) {
                _.bboxwt = 0;
                this.realPath = getPath[this.type](this);
            }
            _.bbox = pathDimensions(mapPath(this.realPath, this.matrix));
            _.bbox.toString = x_y_w_h;
            _.dirty = _.dirtyT = 0;
        }
        return _.bbox;
    };
    /*\
     * Element.clone
     [ method ]
     **
     = (object) clone of a given element
     **
     \*/
    elproto.clone = function () {
        if (this.removed) {
            return null;
        }
        var out = this.paper[this.type]().attr(this.attr());
        this.__set__ && this.__set__.push(out);
        return out;
    };
    /*\
     * Element.glow
     [ method ]
     **
     * Return set of elements that create glow-like effect around given element. See @Paper.set.
     *
     * Note: Glow is not connected to the element. If you change element attributes it won’t adjust itself.
     **
     > Parameters
     **
     - glow (object) #optional parameters object with all properties optional:
     o {
     o     width (number) size of the glow, default is `10`
     o     fill (boolean) will it be filled, default is `false`
     o     opacity (number) opacity, default is `0.5`
     o     offsetx (number) horizontal offset, default is `0`
     o     offsety (number) vertical offset, default is `0`
     o     color (string) glow colour, default is `black`
     o }
     = (object) @Paper.set of elements that represents glow
     \*/
    elproto.glow = function (glow) {
        if (this.type == "text") {
            return null;
        }
        glow = glow || {};
        var s = {
                width: (glow.width || 10) + (+this.attr("stroke-width") || 1),
                fill: glow.fill || false,
                opacity: glow.opacity == null ? .5 : glow.opacity,
                offsetx: glow.offsetx || 0,
                offsety: glow.offsety || 0,
                color: glow.color || "#000"
            },
            c = s.width / 2,
            r = this.paper,
            out = r.set(),
            path = this.realPath || getPath[this.type](this);
        path = this.matrix ? mapPath(path, this.matrix) : path;
        for (var i = 1; i < c + 1; i++) {
            out.push(r.path(path).attr({
                stroke: s.color,
                fill: s.fill ? s.color : "none",
                "stroke-linejoin": "round",
                "stroke-linecap": "round",
                "stroke-width": +(s.width / c * i).toFixed(3),
                opacity: +(s.opacity / c).toFixed(3)
            }));
        }
        return out.insertBefore(this).translate(s.offsetx, s.offsety);
    };
    var curveslengths = {},
        getPointAtSegmentLength = function (p1x, p1y, c1x, c1y, c2x, c2y, p2x, p2y, length) {
            if (length == null) {
                return bezlen(p1x, p1y, c1x, c1y, c2x, c2y, p2x, p2y);
            } else {
                return R.findDotsAtSegment(p1x, p1y, c1x, c1y, c2x, c2y, p2x, p2y, getTatLen(p1x, p1y, c1x, c1y, c2x, c2y, p2x, p2y, length));
            }
        },
        getLengthFactory = function (istotal, subpath) {
            return function (path, length, onlystart) {
                path = path2curve(path);
                var x, y, p, l, sp = "", subpaths = {}, point,
                    len = 0;
                for (var i = 0, ii = path.length; i < ii; i++) {
                    p = path[i];
                    if (p[0] == "M") {
                        x = +p[1];
                        y = +p[2];
                    } else {
                        l = getPointAtSegmentLength(x, y, p[1], p[2], p[3], p[4], p[5], p[6]);
                        if (len + l > length) {
                            if (subpath && !subpaths.start) {
                                point = getPointAtSegmentLength(x, y, p[1], p[2], p[3], p[4], p[5], p[6], length - len);
                                sp += ["C" + point.start.x, point.start.y, point.m.x, point.m.y, point.x, point.y];
                                if (onlystart) {return sp;}
                                subpaths.start = sp;
                                sp = ["M" + point.x, point.y + "C" + point.n.x, point.n.y, point.end.x, point.end.y, p[5], p[6]].join();
                                len += l;
                                x = +p[5];
                                y = +p[6];
                                continue;
                            }
                            if (!istotal && !subpath) {
                                point = getPointAtSegmentLength(x, y, p[1], p[2], p[3], p[4], p[5], p[6], length - len);
                                return {x: point.x, y: point.y, alpha: point.alpha};
                            }
                        }
                        len += l;
                        x = +p[5];
                        y = +p[6];
                    }
                    sp += p.shift() + p;
                }
                subpaths.end = sp;
                point = istotal ? len : subpath ? subpaths : R.findDotsAtSegment(x, y, p[0], p[1], p[2], p[3], p[4], p[5], 1);
                point.alpha && (point = {x: point.x, y: point.y, alpha: point.alpha});
                return point;
            };
        };
    var getTotalLength = getLengthFactory(1),
        getPointAtLength = getLengthFactory(),
        getSubpathsAtLength = getLengthFactory(0, 1);
    /*\
     * Raphael.getTotalLength
     [ method ]
     **
     * Returns length of the given path in pixels.
     **
     > Parameters
     **
     - path (string) SVG path string.
     **
     = (number) length.
     \*/
    R.getTotalLength = getTotalLength;
    /*\
     * Raphael.getPointAtLength
     [ method ]
     **
     * Return coordinates of the point located at the given length on the given path.
     **
     > Parameters
     **
     - path (string) SVG path string
     - length (number)
     **
     = (object) representation of the point:
     o {
     o     x: (number) x coordinate
     o     y: (number) y coordinate
     o     alpha: (number) angle of derivative
     o }
     \*/
    R.getPointAtLength = getPointAtLength;
    /*\
     * Raphael.getSubpath
     [ method ]
     **
     * Return subpath of a given path from given length to given length.
     **
     > Parameters
     **
     - path (string) SVG path string
     - from (number) position of the start of the segment
     - to (number) position of the end of the segment
     **
     = (string) pathstring for the segment
     \*/
    R.getSubpath = function (path, from, to) {
        if (this.getTotalLength(path) - to < 1e-6) {
            return getSubpathsAtLength(path, from).end;
        }
        var a = getSubpathsAtLength(path, to, 1);
        return from ? getSubpathsAtLength(a, from).end : a;
    };
    /*\
     * Element.getTotalLength
     [ method ]
     **
     * Returns length of the path in pixels. Only works for element of “path” type.
     = (number) length.
     \*/
    elproto.getTotalLength = function () {
        var path = this.getPath();
        if (!path) {
            return;
        }

        if (this.node.getTotalLength) {
            return this.node.getTotalLength();
        }

        return getTotalLength(path);
    };
    /*\
     * Element.getPointAtLength
     [ method ]
     **
     * Return coordinates of the point located at the given length on the given path. Only works for element of “path” type.
     **
     > Parameters
     **
     - length (number)
     **
     = (object) representation of the point:
     o {
     o     x: (number) x coordinate
     o     y: (number) y coordinate
     o     alpha: (number) angle of derivative
     o }
     \*/
    elproto.getPointAtLength = function (length) {
        var path = this.getPath();
        if (!path) {
            return;
        }

        return getPointAtLength(path, length);
    };
    /*\
     * Element.getPath
     [ method ]
     **
     * Returns path of the element. Only works for elements of “path” type and simple elements like circle.
     = (object) path
     **
     \*/
    elproto.getPath = function () {
        var path,
            getPath = R._getPath[this.type];

        if (this.type == "text" || this.type == "set") {
            return;
        }

        if (getPath) {
            path = getPath(this);
        }

        return path;
    };
    /*\
     * Element.getSubpath
     [ method ]
     **
     * Return subpath of a given element from given length to given length. Only works for element of “path” type.
     **
     > Parameters
     **
     - from (number) position of the start of the segment
     - to (number) position of the end of the segment
     **
     = (string) pathstring for the segment
     \*/
    elproto.getSubpath = function (from, to) {
        var path = this.getPath();
        if (!path) {
            return;
        }

        return R.getSubpath(path, from, to);
    };
    /*\
     * Raphael.easing_formulas
     [ property ]
     **
     * Object that contains easing formulas for animation. You could extend it with your own. By default it has following list of easing:
     # <ul>
     #     <li>“linear”</li>
     #     <li>“&lt;” or “easeIn” or “ease-in”</li>
     #     <li>“>” or “easeOut” or “ease-out”</li>
     #     <li>“&lt;>” or “easeInOut” or “ease-in-out”</li>
     #     <li>“backIn” or “back-in”</li>
     #     <li>“backOut” or “back-out”</li>
     #     <li>“elastic”</li>
     #     <li>“bounce”</li>
     # </ul>
     # <p>See also <a href="http://raphaeljs.com/easing.html">Easing demo</a>.</p>
     \*/
    var ef = R.easing_formulas = {
        linear: function (n) {
            return n;
        },
        "<": function (n) {
            return pow(n, 1.7);
        },
        ">": function (n) {
            return pow(n, .48);
        },
        "<>": function (n) {
            var q = .48 - n / 1.04,
                Q = math.sqrt(.1734 + q * q),
                x = Q - q,
                X = pow(abs(x), 1 / 3) * (x < 0 ? -1 : 1),
                y = -Q - q,
                Y = pow(abs(y), 1 / 3) * (y < 0 ? -1 : 1),
                t = X + Y + .5;
            return (1 - t) * 3 * t * t + t * t * t;
        },
        backIn: function (n) {
            var s = 1.70158;
            return n * n * ((s + 1) * n - s);
        },
        backOut: function (n) {
            n = n - 1;
            var s = 1.70158;
            return n * n * ((s + 1) * n + s) + 1;
        },
        elastic: function (n) {
            if (n == !!n) {
                return n;
            }
            return pow(2, -10 * n) * math.sin((n - .075) * (2 * PI) / .3) + 1;
        },
        bounce: function (n) {
            var s = 7.5625,
                p = 2.75,
                l;
            if (n < (1 / p)) {
                l = s * n * n;
            } else {
                if (n < (2 / p)) {
                    n -= (1.5 / p);
                    l = s * n * n + .75;
                } else {
                    if (n < (2.5 / p)) {
                        n -= (2.25 / p);
                        l = s * n * n + .9375;
                    } else {
                        n -= (2.625 / p);
                        l = s * n * n + .984375;
                    }
                }
            }
            return l;
        }
    };
    ef.easeIn = ef["ease-in"] = ef["<"];
    ef.easeOut = ef["ease-out"] = ef[">"];
    ef.easeInOut = ef["ease-in-out"] = ef["<>"];
    ef["back-in"] = ef.backIn;
    ef["back-out"] = ef.backOut;

    var animationElements = [],
        requestAnimFrame = window.requestAnimationFrame       ||
            window.webkitRequestAnimationFrame ||
            window.mozRequestAnimationFrame    ||
            window.oRequestAnimationFrame      ||
            window.msRequestAnimationFrame     ||
            function (callback) {
                setTimeout(callback, 16);
            },
        animation = function () {
            var Now = +new Date,
                l = 0;
            for (; l < animationElements.length; l++) {
                var e = animationElements[l];
                if (e.el.removed || e.paused) {
                    continue;
                }
                var time = Now - e.start,
                    ms = e.ms,
                    easing = e.easing,
                    from = e.from,
                    diff = e.diff,
                    to = e.to,
                    t = e.t,
                    that = e.el,
                    set = {},
                    now,
                    init = {},
                    key;
                if (e.initstatus) {
                    time = (e.initstatus * e.anim.top - e.prev) / (e.percent - e.prev) * ms;
                    e.status = e.initstatus;
                    delete e.initstatus;
                    e.stop && animationElements.splice(l--, 1);
                } else {
                    e.status = (e.prev + (e.percent - e.prev) * (time / ms)) / e.anim.top;
                }
                if (time < 0) {
                    continue;
                }
                if (time < ms) {
                    var pos = easing(time / ms);
                    for (var attr in from) if (from[has](attr)) {
                        switch (availableAnimAttrs[attr]) {
                            case nu:
                                now = +from[attr] + pos * ms * diff[attr];
                                break;
                            case "colour":
                                now = "rgb(" + [
                                        upto255(round(from[attr].r + pos * ms * diff[attr].r)),
                                        upto255(round(from[attr].g + pos * ms * diff[attr].g)),
                                        upto255(round(from[attr].b + pos * ms * diff[attr].b))
                                    ].join(",") + ")";
                                break;
                            case "path":
                                now = [];
                                for (var i = 0, ii = from[attr].length; i < ii; i++) {
                                    now[i] = [from[attr][i][0]];
                                    for (var j = 1, jj = from[attr][i].length; j < jj; j++) {
                                        now[i][j] = +from[attr][i][j] + pos * ms * diff[attr][i][j];
                                    }
                                    now[i] = now[i].join(S);
                                }
                                now = now.join(S);
                                break;
                            case "transform":
                                if (diff[attr].real) {
                                    now = [];
                                    for (i = 0, ii = from[attr].length; i < ii; i++) {
                                        now[i] = [from[attr][i][0]];
                                        for (j = 1, jj = from[attr][i].length; j < jj; j++) {
                                            now[i][j] = from[attr][i][j] + pos * ms * diff[attr][i][j];
                                        }
                                    }
                                } else {
                                    var get = function (i) {
                                        return +from[attr][i] + pos * ms * diff[attr][i];
                                    };
                                    // now = [["r", get(2), 0, 0], ["t", get(3), get(4)], ["s", get(0), get(1), 0, 0]];
                                    now = [["m", get(0), get(1), get(2), get(3), get(4), get(5)]];
                                }
                                break;
                            case "csv":
                                if (attr == "clip-rect") {
                                    now = [];
                                    i = 4;
                                    while (i--) {
                                        now[i] = +from[attr][i] + pos * ms * diff[attr][i];
                                    }
                                }
                                break;
                            default:
                                var from2 = [][concat](from[attr]);
                                now = [];
                                i = that.paper.customAttributes[attr].length;
                                while (i--) {
                                    now[i] = +from2[i] + pos * ms * diff[attr][i];
                                }
                                break;
                        }
                        set[attr] = now;
                    }
                    that.attr(set);
                    (function (id, that, anim) {
                        setTimeout(function () {
                            eve("raphael.anim.frame." + id, that, anim);
                        });
                    })(that.id, that, e.anim);
                } else {
                    (function(f, el, a) {
                        setTimeout(function() {
                            eve("raphael.anim.frame." + el.id, el, a);
                            eve("raphael.anim.finish." + el.id, el, a);
                            R.is(f, "function") && f.call(el);
                        });
                    })(e.callback, that, e.anim);
                    that.attr(to);
                    animationElements.splice(l--, 1);
                    if (e.repeat > 1 && !e.next) {
                        for (key in to) if (to[has](key)) {
                            init[key] = e.totalOrigin[key];
                        }
                        e.el.attr(init);
                        runAnimation(e.anim, e.el, e.anim.percents[0], null, e.totalOrigin, e.repeat - 1);
                    }
                    if (e.next && !e.stop) {
                        runAnimation(e.anim, e.el, e.next, null, e.totalOrigin, e.repeat);
                    }
                }
            }
            animationElements.length && requestAnimFrame(animation);
        },
        upto255 = function (color) {
            return color > 255 ? 255 : color < 0 ? 0 : color;
        };
    /*\
     * Element.animateWith
     [ method ]
     **
     * Acts similar to @Element.animate, but ensure that given animation runs in sync with another given element.
     **
     > Parameters
     **
     - el (object) element to sync with
     - anim (object) animation to sync with
     - params (object) #optional final attributes for the element, see also @Element.attr
     - ms (number) #optional number of milliseconds for animation to run
     - easing (string) #optional easing type. Accept on of @Raphael.easing_formulas or CSS format: `cubic&#x2010;bezier(XX,&#160;XX,&#160;XX,&#160;XX)`
     - callback (function) #optional callback function. Will be called at the end of animation.
     * or
     - element (object) element to sync with
     - anim (object) animation to sync with
     - animation (object) #optional animation object, see @Raphael.animation
     **
     = (object) original element
     \*/
    elproto.animateWith = function (el, anim, params, ms, easing, callback) {
        var element = this;
        if (element.removed) {
            callback && callback.call(element);
            return element;
        }
        var a = params instanceof Animation ? params : R.animation(params, ms, easing, callback),
            x, y;
        runAnimation(a, element, a.percents[0], null, element.attr());
        for (var i = 0, ii = animationElements.length; i < ii; i++) {
            if (animationElements[i].anim == anim && animationElements[i].el == el) {
                animationElements[ii - 1].start = animationElements[i].start;
                break;
            }
        }
        return element;
        //
        //
        // var a = params ? R.animation(params, ms, easing, callback) : anim,
        //     status = element.status(anim);
        // return this.animate(a).status(a, status * anim.ms / a.ms);
    };
    function CubicBezierAtTime(t, p1x, p1y, p2x, p2y, duration) {
        var cx = 3 * p1x,
            bx = 3 * (p2x - p1x) - cx,
            ax = 1 - cx - bx,
            cy = 3 * p1y,
            by = 3 * (p2y - p1y) - cy,
            ay = 1 - cy - by;
        function sampleCurveX(t) {
            return ((ax * t + bx) * t + cx) * t;
        }
        function solve(x, epsilon) {
            var t = solveCurveX(x, epsilon);
            return ((ay * t + by) * t + cy) * t;
        }
        function solveCurveX(x, epsilon) {
            var t0, t1, t2, x2, d2, i;
            for(t2 = x, i = 0; i < 8; i++) {
                x2 = sampleCurveX(t2) - x;
                if (abs(x2) < epsilon) {
                    return t2;
                }
                d2 = (3 * ax * t2 + 2 * bx) * t2 + cx;
                if (abs(d2) < 1e-6) {
                    break;
                }
                t2 = t2 - x2 / d2;
            }
            t0 = 0;
            t1 = 1;
            t2 = x;
            if (t2 < t0) {
                return t0;
            }
            if (t2 > t1) {
                return t1;
            }
            while (t0 < t1) {
                x2 = sampleCurveX(t2);
                if (abs(x2 - x) < epsilon) {
                    return t2;
                }
                if (x > x2) {
                    t0 = t2;
                } else {
                    t1 = t2;
                }
                t2 = (t1 - t0) / 2 + t0;
            }
            return t2;
        }
        return solve(t, 1 / (200 * duration));
    }
    elproto.onAnimation = function (f) {
        f ? eve.on("raphael.anim.frame." + this.id, f) : eve.unbind("raphael.anim.frame." + this.id);
        return this;
    };
    function Animation(anim, ms) {
        var percents = [],
            newAnim = {};
        this.ms = ms;
        this.times = 1;
        if (anim) {
            for (var attr in anim) if (anim[has](attr)) {
                newAnim[toFloat(attr)] = anim[attr];
                percents.push(toFloat(attr));
            }
            percents.sort(sortByNumber);
        }
        this.anim = newAnim;
        this.top = percents[percents.length - 1];
        this.percents = percents;
    }
    /*\
     * Animation.delay
     [ method ]
     **
     * Creates a copy of existing animation object with given delay.
     **
     > Parameters
     **
     - delay (number) number of ms to pass between animation start and actual animation
     **
     = (object) new altered Animation object
     | var anim = Raphael.animation({cx: 10, cy: 20}, 2e3);
     | circle1.animate(anim); // run the given animation immediately
     | circle2.animate(anim.delay(500)); // run the given animation after 500 ms
     \*/
    Animation.prototype.delay = function (delay) {
        var a = new Animation(this.anim, this.ms);
        a.times = this.times;
        a.del = +delay || 0;
        return a;
    };
    /*\
     * Animation.repeat
     [ method ]
     **
     * Creates a copy of existing animation object with given repetition.
     **
     > Parameters
     **
     - repeat (number) number iterations of animation. For infinite animation pass `Infinity`
     **
     = (object) new altered Animation object
     \*/
    Animation.prototype.repeat = function (times) {
        var a = new Animation(this.anim, this.ms);
        a.del = this.del;
        a.times = math.floor(mmax(times, 0)) || 1;
        return a;
    };
    function runAnimation(anim, element, percent, status, totalOrigin, times) {
        percent = toFloat(percent);
        var params,
            isInAnim,
            isInAnimSet,
            percents = [],
            next,
            prev,
            timestamp,
            ms = anim.ms,
            from = {},
            to = {},
            diff = {};
        if (status) {
            for (i = 0, ii = animationElements.length; i < ii; i++) {
                var e = animationElements[i];
                if (e.el.id == element.id && e.anim == anim) {
                    if (e.percent != percent) {
                        animationElements.splice(i, 1);
                        isInAnimSet = 1;
                    } else {
                        isInAnim = e;
                    }
                    element.attr(e.totalOrigin);
                    break;
                }
            }
        } else {
            status = +to; // NaN
        }
        for (var i = 0, ii = anim.percents.length; i < ii; i++) {
            if (anim.percents[i] == percent || anim.percents[i] > status * anim.top) {
                percent = anim.percents[i];
                prev = anim.percents[i - 1] || 0;
                ms = ms / anim.top * (percent - prev);
                next = anim.percents[i + 1];
                params = anim.anim[percent];
                break;
            } else if (status) {
                element.attr(anim.anim[anim.percents[i]]);
            }
        }
        if (!params) {
            return;
        }
        if (!isInAnim) {
            for (var attr in params) if (params[has](attr)) {
                if (availableAnimAttrs[has](attr) || element.paper.customAttributes[has](attr)) {
                    from[attr] = element.attr(attr);
                    (from[attr] == null) && (from[attr] = availableAttrs[attr]);
                    to[attr] = params[attr];
                    switch (availableAnimAttrs[attr]) {
                        case nu:
                            diff[attr] = (to[attr] - from[attr]) / ms;
                            break;
                        case "colour":
                            from[attr] = R.getRGB(from[attr]);
                            var toColour = R.getRGB(to[attr]);
                            diff[attr] = {
                                r: (toColour.r - from[attr].r) / ms,
                                g: (toColour.g - from[attr].g) / ms,
                                b: (toColour.b - from[attr].b) / ms
                            };
                            break;
                        case "path":
                            var pathes = path2curve(from[attr], to[attr]),
                                toPath = pathes[1];
                            from[attr] = pathes[0];
                            diff[attr] = [];
                            for (i = 0, ii = from[attr].length; i < ii; i++) {
                                diff[attr][i] = [0];
                                for (var j = 1, jj = from[attr][i].length; j < jj; j++) {
                                    diff[attr][i][j] = (toPath[i][j] - from[attr][i][j]) / ms;
                                }
                            }
                            break;
                        case "transform":
                            var _ = element._,
                                eq = equaliseTransform(_[attr], to[attr]);
                            if (eq) {
                                from[attr] = eq.from;
                                to[attr] = eq.to;
                                diff[attr] = [];
                                diff[attr].real = true;
                                for (i = 0, ii = from[attr].length; i < ii; i++) {
                                    diff[attr][i] = [from[attr][i][0]];
                                    for (j = 1, jj = from[attr][i].length; j < jj; j++) {
                                        diff[attr][i][j] = (to[attr][i][j] - from[attr][i][j]) / ms;
                                    }
                                }
                            } else {
                                var m = (element.matrix || new Matrix),
                                    to2 = {
                                        _: {transform: _.transform},
                                        getBBox: function () {
                                            return element.getBBox(1);
                                        }
                                    };
                                from[attr] = [
                                    m.a,
                                    m.b,
                                    m.c,
                                    m.d,
                                    m.e,
                                    m.f
                                ];
                                extractTransform(to2, to[attr]);
                                to[attr] = to2._.transform;
                                diff[attr] = [
                                    (to2.matrix.a - m.a) / ms,
                                    (to2.matrix.b - m.b) / ms,
                                    (to2.matrix.c - m.c) / ms,
                                    (to2.matrix.d - m.d) / ms,
                                    (to2.matrix.e - m.e) / ms,
                                    (to2.matrix.f - m.f) / ms
                                ];
                                // from[attr] = [_.sx, _.sy, _.deg, _.dx, _.dy];
                                // var to2 = {_:{}, getBBox: function () { return element.getBBox(); }};
                                // extractTransform(to2, to[attr]);
                                // diff[attr] = [
                                //     (to2._.sx - _.sx) / ms,
                                //     (to2._.sy - _.sy) / ms,
                                //     (to2._.deg - _.deg) / ms,
                                //     (to2._.dx - _.dx) / ms,
                                //     (to2._.dy - _.dy) / ms
                                // ];
                            }
                            break;
                        case "csv":
                            var values = Str(params[attr])[split](separator),
                                from2 = Str(from[attr])[split](separator);
                            if (attr == "clip-rect") {
                                from[attr] = from2;
                                diff[attr] = [];
                                i = from2.length;
                                while (i--) {
                                    diff[attr][i] = (values[i] - from[attr][i]) / ms;
                                }
                            }
                            to[attr] = values;
                            break;
                        default:
                            values = [][concat](params[attr]);
                            from2 = [][concat](from[attr]);
                            diff[attr] = [];
                            i = element.paper.customAttributes[attr].length;
                            while (i--) {
                                diff[attr][i] = ((values[i] || 0) - (from2[i] || 0)) / ms;
                            }
                            break;
                    }
                }
            }
            var easing = params.easing,
                easyeasy = R.easing_formulas[easing];
            if (!easyeasy) {
                easyeasy = Str(easing).match(bezierrg);
                if (easyeasy && easyeasy.length == 5) {
                    var curve = easyeasy;
                    easyeasy = function (t) {
                        return CubicBezierAtTime(t, +curve[1], +curve[2], +curve[3], +curve[4], ms);
                    };
                } else {
                    easyeasy = pipe;
                }
            }
            timestamp = params.start || anim.start || +new Date;
            e = {
                anim: anim,
                percent: percent,
                timestamp: timestamp,
                start: timestamp + (anim.del || 0),
                status: 0,
                initstatus: status || 0,
                stop: false,
                ms: ms,
                easing: easyeasy,
                from: from,
                diff: diff,
                to: to,
                el: element,
                callback: params.callback,
                prev: prev,
                next: next,
                repeat: times || anim.times,
                origin: element.attr(),
                totalOrigin: totalOrigin
            };
            animationElements.push(e);
            if (status && !isInAnim && !isInAnimSet) {
                e.stop = true;
                e.start = new Date - ms * status;
                if (animationElements.length == 1) {
                    return animation();
                }
            }
            if (isInAnimSet) {
                e.start = new Date - e.ms * status;
            }
            animationElements.length == 1 && requestAnimFrame(animation);
        } else {
            isInAnim.initstatus = status;
            isInAnim.start = new Date - isInAnim.ms * status;
        }
        eve("raphael.anim.start." + element.id, element, anim);
    }
    /*\
     * Raphael.animation
     [ method ]
     **
     * Creates an animation object that can be passed to the @Element.animate or @Element.animateWith methods.
     * See also @Animation.delay and @Animation.repeat methods.
     **
     > Parameters
     **
     - params (object) final attributes for the element, see also @Element.attr
     - ms (number) number of milliseconds for animation to run
     - easing (string) #optional easing type. Accept one of @Raphael.easing_formulas or CSS format: `cubic&#x2010;bezier(XX,&#160;XX,&#160;XX,&#160;XX)`
     - callback (function) #optional callback function. Will be called at the end of animation.
     **
     = (object) @Animation
     \*/
    R.animation = function (params, ms, easing, callback) {
        if (params instanceof Animation) {
            return params;
        }
        if (R.is(easing, "function") || !easing) {
            callback = callback || easing || null;
            easing = null;
        }
        params = Object(params);
        ms = +ms || 0;
        var p = {},
            json,
            attr;
        for (attr in params) if (params[has](attr) && toFloat(attr) != attr && toFloat(attr) + "%" != attr) {
            json = true;
            p[attr] = params[attr];
        }
        if (!json) {
            // if percent-like syntax is used and end-of-all animation callback used
            if(callback){
                // find the last one
                var lastKey = 0;
                for(var i in params){
                    var percent = toInt(i);
                    if(params[has](i) && percent > lastKey){
                        lastKey = percent;
                    }
                }
                lastKey += '%';
                // if already defined callback in the last keyframe, skip
                !params[lastKey].callback && (params[lastKey].callback = callback);
            }
            return new Animation(params, ms);
        } else {
            easing && (p.easing = easing);
            callback && (p.callback = callback);
            return new Animation({100: p}, ms);
        }
    };
    /*\
     * Element.animate
     [ method ]
     **
     * Creates and starts animation for given element.
     **
     > Parameters
     **
     - params (object) final attributes for the element, see also @Element.attr
     - ms (number) number of milliseconds for animation to run
     - easing (string) #optional easing type. Accept one of @Raphael.easing_formulas or CSS format: `cubic&#x2010;bezier(XX,&#160;XX,&#160;XX,&#160;XX)`
     - callback (function) #optional callback function. Will be called at the end of animation.
     * or
     - animation (object) animation object, see @Raphael.animation
     **
     = (object) original element
     \*/
    elproto.animate = function (params, ms, easing, callback) {
        var element = this;
        if (element.removed) {
            callback && callback.call(element);
            return element;
        }
        var anim = params instanceof Animation ? params : R.animation(params, ms, easing, callback);
        runAnimation(anim, element, anim.percents[0], null, element.attr());
        return element;
    };
    /*\
     * Element.setTime
     [ method ]
     **
     * Sets the status of animation of the element in milliseconds. Similar to @Element.status method.
     **
     > Parameters
     **
     - anim (object) animation object
     - value (number) number of milliseconds from the beginning of the animation
     **
     = (object) original element if `value` is specified
     * Note, that during animation following events are triggered:
     *
     * On each animation frame event `anim.frame.<id>`, on start `anim.start.<id>` and on end `anim.finish.<id>`.
     \*/
    elproto.setTime = function (anim, value) {
        if (anim && value != null) {
            this.status(anim, mmin(value, anim.ms) / anim.ms);
        }
        return this;
    };
    /*\
     * Element.status
     [ method ]
     **
     * Gets or sets the status of animation of the element.
     **
     > Parameters
     **
     - anim (object) #optional animation object
     - value (number) #optional 0 – 1. If specified, method works like a setter and sets the status of a given animation to the value. This will cause animation to jump to the given position.
     **
     = (number) status
     * or
     = (array) status if `anim` is not specified. Array of objects in format:
     o {
     o     anim: (object) animation object
     o     status: (number) status
     o }
     * or
     = (object) original element if `value` is specified
     \*/
    elproto.status = function (anim, value) {
        var out = [],
            i = 0,
            len,
            e;
        if (value != null) {
            runAnimation(anim, this, -1, mmin(value, 1));
            return this;
        } else {
            len = animationElements.length;
            for (; i < len; i++) {
                e = animationElements[i];
                if (e.el.id == this.id && (!anim || e.anim == anim)) {
                    if (anim) {
                        return e.status;
                    }
                    out.push({
                        anim: e.anim,
                        status: e.status
                    });
                }
            }
            if (anim) {
                return 0;
            }
            return out;
        }
    };
    /*\
     * Element.pause
     [ method ]
     **
     * Stops animation of the element with ability to resume it later on.
     **
     > Parameters
     **
     - anim (object) #optional animation object
     **
     = (object) original element
     \*/
    elproto.pause = function (anim) {
        for (var i = 0; i < animationElements.length; i++) if (animationElements[i].el.id == this.id && (!anim || animationElements[i].anim == anim)) {
            if (eve("raphael.anim.pause." + this.id, this, animationElements[i].anim) !== false) {
                animationElements[i].paused = true;
            }
        }
        return this;
    };
    /*\
     * Element.resume
     [ method ]
     **
     * Resumes animation if it was paused with @Element.pause method.
     **
     > Parameters
     **
     - anim (object) #optional animation object
     **
     = (object) original element
     \*/
    elproto.resume = function (anim) {
        for (var i = 0; i < animationElements.length; i++) if (animationElements[i].el.id == this.id && (!anim || animationElements[i].anim == anim)) {
            var e = animationElements[i];
            if (eve("raphael.anim.resume." + this.id, this, e.anim) !== false) {
                delete e.paused;
                this.status(e.anim, e.status);
            }
        }
        return this;
    };
    /*\
     * Element.stop
     [ method ]
     **
     * Stops animation of the element.
     **
     > Parameters
     **
     - anim (object) #optional animation object
     **
     = (object) original element
     \*/
    elproto.stop = function (anim) {
        for (var i = 0; i < animationElements.length; i++) if (animationElements[i].el.id == this.id && (!anim || animationElements[i].anim == anim)) {
            if (eve("raphael.anim.stop." + this.id, this, animationElements[i].anim) !== false) {
                animationElements.splice(i--, 1);
            }
        }
        return this;
    };
    function stopAnimation(paper) {
        for (var i = 0; i < animationElements.length; i++) if (animationElements[i].el.paper == paper) {
            animationElements.splice(i--, 1);
        }
    }
    eve.on("raphael.remove", stopAnimation);
    eve.on("raphael.clear", stopAnimation);
    elproto.toString = function () {
        return "Rapha\xebl\u2019s object";
    };

    // Set
    var Set = function (items) {
            this.items = [];
            this.length = 0;
            this.type = "set";
            if (items) {
                for (var i = 0, ii = items.length; i < ii; i++) {
                    if (items[i] && (items[i].constructor == elproto.constructor || items[i].constructor == Set)) {
                        this[this.items.length] = this.items[this.items.length] = items[i];
                        this.length++;
                    }
                }
            }
        },
        setproto = Set.prototype;
    /*\
     * Set.push
     [ method ]
     **
     * Adds each argument to the current set.
     = (object) original element
     \*/
    setproto.push = function () {
        var item,
            len;
        for (var i = 0, ii = arguments.length; i < ii; i++) {
            item = arguments[i];
            if (item && (item.constructor == elproto.constructor || item.constructor == Set)) {
                len = this.items.length;
                this[len] = this.items[len] = item;
                this.length++;
            }
        }
        return this;
    };
    /*\
     * Set.pop
     [ method ]
     **
     * Removes last element and returns it.
     = (object) element
     \*/
    setproto.pop = function () {
        this.length && delete this[this.length--];
        return this.items.pop();
    };
    /*\
     * Set.forEach
     [ method ]
     **
     * Executes given function for each element in the set.
     *
     * If function returns `false` it will stop loop running.
     **
     > Parameters
     **
     - callback (function) function to run
     - thisArg (object) context object for the callback
     = (object) Set object
     \*/
    setproto.forEach = function (callback, thisArg) {
        for (var i = 0, ii = this.items.length; i < ii; i++) {
            if (callback.call(thisArg, this.items[i], i) === false) {
                return this;
            }
        }
        return this;
    };
    for (var method in elproto) if (elproto[has](method)) {
        setproto[method] = (function (methodname) {
            return function () {
                var arg = arguments;
                return this.forEach(function (el) {
                    el[methodname][apply](el, arg);
                });
            };
        })(method);
    }
    setproto.attr = function (name, value) {
        if (name && R.is(name, array) && R.is(name[0], "object")) {
            for (var j = 0, jj = name.length; j < jj; j++) {
                this.items[j].attr(name[j]);
            }
        } else {
            for (var i = 0, ii = this.items.length; i < ii; i++) {
                this.items[i].attr(name, value);
            }
        }
        return this;
    };
    /*\
     * Set.clear
     [ method ]
     **
     * Removes all elements from the set
     \*/
    setproto.clear = function () {
        while (this.length) {
            this.pop();
        }
    };
    /*\
     * Set.splice
     [ method ]
     **
     * Removes given element from the set
     **
     > Parameters
     **
     - index (number) position of the deletion
     - count (number) number of element to remove
     - insertion… (object) #optional elements to insert
     = (object) set elements that were deleted
     \*/
    setproto.splice = function (index, count, insertion) {
        index = index < 0 ? mmax(this.length + index, 0) : index;
        count = mmax(0, mmin(this.length - index, count));
        var tail = [],
            todel = [],
            args = [],
            i;
        for (i = 2; i < arguments.length; i++) {
            args.push(arguments[i]);
        }
        for (i = 0; i < count; i++) {
            todel.push(this[index + i]);
        }
        for (; i < this.length - index; i++) {
            tail.push(this[index + i]);
        }
        var arglen = args.length;
        for (i = 0; i < arglen + tail.length; i++) {
            this.items[index + i] = this[index + i] = i < arglen ? args[i] : tail[i - arglen];
        }
        i = this.items.length = this.length -= count - arglen;
        while (this[i]) {
            delete this[i++];
        }
        return new Set(todel);
    };
    /*\
     * Set.exclude
     [ method ]
     **
     * Removes given element from the set
     **
     > Parameters
     **
     - element (object) element to remove
     = (boolean) `true` if object was found & removed from the set
     \*/
    setproto.exclude = function (el) {
        for (var i = 0, ii = this.length; i < ii; i++) if (this[i] == el) {
            this.splice(i, 1);
            return true;
        }
    };
    setproto.animate = function (params, ms, easing, callback) {
        (R.is(easing, "function") || !easing) && (callback = easing || null);
        var len = this.items.length,
            i = len,
            item,
            set = this,
            collector;
        if (!len) {
            return this;
        }
        callback && (collector = function () {
            !--len && callback.call(set);
        });
        easing = R.is(easing, string) ? easing : collector;
        var anim = R.animation(params, ms, easing, collector);
        item = this.items[--i].animate(anim);
        while (i--) {
            this.items[i] && !this.items[i].removed && this.items[i].animateWith(item, anim, anim);
            (this.items[i] && !this.items[i].removed) || len--;
        }
        return this;
    };
    setproto.insertAfter = function (el) {
        var i = this.items.length;
        while (i--) {
            this.items[i].insertAfter(el);
        }
        return this;
    };
    setproto.getBBox = function () {
        var x = [],
            y = [],
            x2 = [],
            y2 = [];
        for (var i = this.items.length; i--;) if (!this.items[i].removed) {
            var box = this.items[i].getBBox();
            x.push(box.x);
            y.push(box.y);
            x2.push(box.x + box.width);
            y2.push(box.y + box.height);
        }
        x = mmin[apply](0, x);
        y = mmin[apply](0, y);
        x2 = mmax[apply](0, x2);
        y2 = mmax[apply](0, y2);
        return {
            x: x,
            y: y,
            x2: x2,
            y2: y2,
            width: x2 - x,
            height: y2 - y
        };
    };
    setproto.clone = function (s) {
        s = this.paper.set();
        for (var i = 0, ii = this.items.length; i < ii; i++) {
            s.push(this.items[i].clone());
        }
        return s;
    };
    setproto.toString = function () {
        return "Rapha\xebl\u2018s set";
    };

    setproto.glow = function(glowConfig) {
        var ret = this.paper.set();
        this.forEach(function(shape, index){
            var g = shape.glow(glowConfig);
            if(g != null){
                g.forEach(function(shape2, index2){
                    ret.push(shape2);
                });
            }
        });
        return ret;
    };


    /*\
     * Set.isPointInside
     [ method ]
     **
     * Determine if given point is inside this set’s elements
     **
     > Parameters
     **
     - x (number) x coordinate of the point
     - y (number) y coordinate of the point
     = (boolean) `true` if point is inside any of the set's elements
     \*/
    setproto.isPointInside = function (x, y) {
        var isPointInside = false;
        this.forEach(function (el) {
            if (el.isPointInside(x, y)) {
                isPointInside = true;
                return false; // stop loop
            }
        });
        return isPointInside;
    };

    /*\
     * Raphael.registerFont
     [ method ]
     **
     * Adds given font to the registered set of fonts for Raphaël. Should be used as an internal call from within Cufón’s font file.
     * Returns original parameter, so it could be used with chaining.
     # <a href="http://wiki.github.com/sorccu/cufon/about">More about Cufón and how to convert your font form TTF, OTF, etc to JavaScript file.</a>
     **
     > Parameters
     **
     - font (object) the font to register
     = (object) the font you passed in
     > Usage
     | Cufon.registerFont(Raphael.registerFont({…}));
     \*/
    R.registerFont = function (font) {
        if (!font.face) {
            return font;
        }
        this.fonts = this.fonts || {};
        var fontcopy = {
                w: font.w,
                face: {},
                glyphs: {}
            },
            family = font.face["font-family"];
        for (var prop in font.face) if (font.face[has](prop)) {
            fontcopy.face[prop] = font.face[prop];
        }
        if (this.fonts[family]) {
            this.fonts[family].push(fontcopy);
        } else {
            this.fonts[family] = [fontcopy];
        }
        if (!font.svg) {
            fontcopy.face["units-per-em"] = toInt(font.face["units-per-em"], 10);
            for (var glyph in font.glyphs) if (font.glyphs[has](glyph)) {
                var path = font.glyphs[glyph];
                fontcopy.glyphs[glyph] = {
                    w: path.w,
                    k: {},
                    d: path.d && "M" + path.d.replace(/[mlcxtrv]/g, function (command) {
                        return {l: "L", c: "C", x: "z", t: "m", r: "l", v: "c"}[command] || "M";
                    }) + "z"
                };
                if (path.k) {
                    for (var k in path.k) if (path[has](k)) {
                        fontcopy.glyphs[glyph].k[k] = path.k[k];
                    }
                }
            }
        }
        return font;
    };
    /*\
     * Paper.getFont
     [ method ]
     **
     * Finds font object in the registered fonts by given parameters. You could specify only one word from the font name, like “Myriad” for “Myriad Pro”.
     **
     > Parameters
     **
     - family (string) font family name or any word from it
     - weight (string) #optional font weight
     - style (string) #optional font style
     - stretch (string) #optional font stretch
     = (object) the font object
     > Usage
     | paper.print(100, 100, "Test string", paper.getFont("Times", 800), 30);
     \*/
    paperproto.getFont = function (family, weight, style, stretch) {
        stretch = stretch || "normal";
        style = style || "normal";
        weight = +weight || {normal: 400, bold: 700, lighter: 300, bolder: 800}[weight] || 400;
        if (!R.fonts) {
            return;
        }
        var font = R.fonts[family];
        if (!font) {
            var name = new RegExp("(^|\\s)" + family.replace(/[^\w\d\s+!~.:_-]/g, E) + "(\\s|$)", "i");
            for (var fontName in R.fonts) if (R.fonts[has](fontName)) {
                if (name.test(fontName)) {
                    font = R.fonts[fontName];
                    break;
                }
            }
        }
        var thefont;
        if (font) {
            for (var i = 0, ii = font.length; i < ii; i++) {
                thefont = font[i];
                if (thefont.face["font-weight"] == weight && (thefont.face["font-style"] == style || !thefont.face["font-style"]) && thefont.face["font-stretch"] == stretch) {
                    break;
                }
            }
        }
        return thefont;
    };
    /*\
     * Paper.print
     [ method ]
     **
     * Creates path that represent given text written using given font at given position with given size.
     * Result of the method is path element that contains whole text as a separate path.
     **
     > Parameters
     **
     - x (number) x position of the text
     - y (number) y position of the text
     - string (string) text to print
     - font (object) font object, see @Paper.getFont
     - size (number) #optional size of the font, default is `16`
     - origin (string) #optional could be `"baseline"` or `"middle"`, default is `"middle"`
     - letter_spacing (number) #optional number in range `-1..1`, default is `0`
     - line_spacing (number) #optional number in range `1..3`, default is `1`
     = (object) resulting path element, which consist of all letters
     > Usage
     | var txt = r.print(10, 50, "print", r.getFont("Museo"), 30).attr({fill: "#fff"});
     \*/
    paperproto.print = function (x, y, string, font, size, origin, letter_spacing, line_spacing) {
        origin = origin || "middle"; // baseline|middle
        letter_spacing = mmax(mmin(letter_spacing || 0, 1), -1);
        line_spacing = mmax(mmin(line_spacing || 1, 3), 1);
        var letters = Str(string)[split](E),
            shift = 0,
            notfirst = 0,
            path = E,
            scale;
        R.is(font, "string") && (font = this.getFont(font));
        if (font) {
            scale = (size || 16) / font.face["units-per-em"];
            var bb = font.face.bbox[split](separator),
                top = +bb[0],
                lineHeight = bb[3] - bb[1],
                shifty = 0,
                height = +bb[1] + (origin == "baseline" ? lineHeight + (+font.face.descent) : lineHeight / 2);
            for (var i = 0, ii = letters.length; i < ii; i++) {
                if (letters[i] == "\n") {
                    shift = 0;
                    curr = 0;
                    notfirst = 0;
                    shifty += lineHeight * line_spacing;
                } else {
                    var prev = notfirst && font.glyphs[letters[i - 1]] || {},
                        curr = font.glyphs[letters[i]];
                    shift += notfirst ? (prev.w || font.w) + (prev.k && prev.k[letters[i]] || 0) + (font.w * letter_spacing) : 0;
                    notfirst = 1;
                }
                if (curr && curr.d) {
                    path += R.transformPath(curr.d, ["t", shift * scale, shifty * scale, "s", scale, scale, top, height, "t", (x - top) / scale, (y - height) / scale]);
                }
            }
        }
        return this.path(path).attr({
            fill: "#000",
            stroke: "none"
        });
    };

    /*\
     * Paper.add
     [ method ]
     **
     * Imports elements in JSON array in format `{type: type, <attributes>}`
     **
     > Parameters
     **
     - json (array)
     = (object) resulting set of imported elements
     > Usage
     | paper.add([
     |     {
     |         type: "circle",
     |         cx: 10,
     |         cy: 10,
     |         r: 5
     |     },
     |     {
     |         type: "rect",
     |         x: 10,
     |         y: 10,
     |         width: 10,
     |         height: 10,
     |         fill: "#fc0"
     |     }
     | ]);
     \*/
    paperproto.add = function (json) {
        if (R.is(json, "array")) {
            var res = this.set(),
                i = 0,
                ii = json.length,
                j;
            for (; i < ii; i++) {
                j = json[i] || {};
                elements[has](j.type) && res.push(this[j.type]().attr(j));
            }
        }
        return res;
    };

    /*\
     * Raphael.format
     [ method ]
     **
     * Simple format function. Replaces construction of type “`{<number>}`” to the corresponding argument.
     **
     > Parameters
     **
     - token (string) string to format
     - … (string) rest of arguments will be treated as parameters for replacement
     = (string) formated string
     > Usage
     | var x = 10,
     |     y = 20,
     |     width = 40,
     |     height = 50;
     | // this will draw a rectangular shape equivalent to "M10,20h40v50h-40z"
     | paper.path(Raphael.format("M{0},{1}h{2}v{3}h{4}z", x, y, width, height, -width));
     \*/
    R.format = function (token, params) {
        var args = R.is(params, array) ? [0][concat](params) : arguments;
        token && R.is(token, string) && args.length - 1 && (token = token.replace(formatrg, function (str, i) {
            return args[++i] == null ? E : args[i];
        }));
        return token || E;
    };
    /*\
     * Raphael.fullfill
     [ method ]
     **
     * A little bit more advanced format function than @Raphael.format. Replaces construction of type “`{<name>}`” to the corresponding argument.
     **
     > Parameters
     **
     - token (string) string to format
     - json (object) object which properties will be used as a replacement
     = (string) formated string
     > Usage
     | // this will draw a rectangular shape equivalent to "M10,20h40v50h-40z"
     | paper.path(Raphael.fullfill("M{x},{y}h{dim.width}v{dim.height}h{dim['negative width']}z", {
     |     x: 10,
     |     y: 20,
     |     dim: {
     |         width: 40,
     |         height: 50,
     |         "negative width": -40
     |     }
     | }));
     \*/
    R.fullfill = (function () {
        var tokenRegex = /\{([^\}]+)\}/g,
            objNotationRegex = /(?:(?:^|\.)(.+?)(?=\[|\.|$|\()|\[('|")(.+?)\2\])(\(\))?/g, // matches .xxxxx or ["xxxxx"] to run over object properties
            replacer = function (all, key, obj) {
                var res = obj;
                key.replace(objNotationRegex, function (all, name, quote, quotedName, isFunc) {
                    name = name || quotedName;
                    if (res) {
                        if (name in res) {
                            res = res[name];
                        }
                        typeof res == "function" && isFunc && (res = res());
                    }
                });
                res = (res == null || res == obj ? all : res) + "";
                return res;
            };
        return function (str, obj) {
            return String(str).replace(tokenRegex, function (all, key) {
                return replacer(all, key, obj);
            });
        };
    })();
    /*\
     * Raphael.ninja
     [ method ]
     **
     * If you want to leave no trace of Raphaël (Well, Raphaël creates only one global variable `Raphael`, but anyway.) You can use `ninja` method.
     * Beware, that in this case plugins could stop working, because they are depending on global variable existence.
     **
     = (object) Raphael object
     > Usage
     | (function (local_raphael) {
     |     var paper = local_raphael(10, 10, 320, 200);
     |     …
     | })(Raphael.ninja());
     \*/
    R.ninja = function () {
        oldRaphael.was ? (g.win.Raphael = oldRaphael.is) : delete Raphael;
        return R;
    };
    /*\
     * Raphael.st
     [ property (object) ]
     **
     * You can add your own method to elements and sets. It is wise to add a set method for each element method
     * you added, so you will be able to call the same method on sets too.
     **
     * See also @Raphael.el.
     > Usage
     | Raphael.el.red = function () {
     |     this.attr({fill: "#f00"});
     | };
     | Raphael.st.red = function () {
     |     this.forEach(function (el) {
     |         el.red();
     |     });
     | };
     | // then use it
     | paper.set(paper.circle(100, 100, 20), paper.circle(110, 100, 20)).red();
     \*/
    R.st = setproto;

    eve.on("raphael.DOMload", function () {
        loaded = true;
    });

    // Firefox <3.6 fix: http://webreflection.blogspot.com/2009/11/195-chars-to-help-lazy-loading.html
    (function (doc, loaded, f) {
        if (doc.readyState == null && doc.addEventListener){
            doc.addEventListener(loaded, f = function () {
                doc.removeEventListener(loaded, f, false);
                doc.readyState = "complete";
            }, false);
            doc.readyState = "loading";
        }
        function isLoaded() {
            (/in/).test(doc.readyState) ? setTimeout(isLoaded, 9) : R.eve("raphael.DOMload");
        }
        isLoaded();
    })(document, "DOMContentLoaded");

    return R;
}));

// ┌─────────────────────────────────────────────────────────────────────┐ \\
// │ Raphaël 2.1.4 - JavaScript Vector Library                       │ \\
// ├─────────────────────────────────────────────────────────────────────┤ \\
// │ SVG Module                                                          │ \\
// ├─────────────────────────────────────────────────────────────────────┤ \\
// │ Copyright (c) 2008-2011 Dmitry Baranovskiy (http://raphaeljs.com)   │ \\
// │ Copyright (c) 2008-2011 Sencha Labs (http://sencha.com)             │ \\
// │ Licensed under the MIT (http://raphaeljs.com/license.html) license. │ \\
// └─────────────────────────────────────────────────────────────────────┘ \\

(function (glob, factory) {
    if (typeof define === "function" && define.amd) {
        define("raphael.svg", ["raphael.core"], function(raphael) {
            return factory(raphael);
        });
    } else if (typeof exports === "object") {
        factory(require("raphael.core"));
    } else {
        factory(glob.Raphael);
    }
}(this, function(R) {
    if (R && !R.svg) {
        return;
    }

    var has = "hasOwnProperty",
        Str = String,
        toFloat = parseFloat,
        toInt = parseInt,
        math = Math,
        mmax = math.max,
        abs = math.abs,
        pow = math.pow,
        separator = /[, ]+/,
        eve = R.eve,
        E = "",
        S = " ";
    var xlink = "http://www.w3.org/1999/xlink",
        markers = {
            block: "M5,0 0,2.5 5,5z",
            classic: "M5,0 0,2.5 5,5 3.5,3 3.5,2z",
            diamond: "M2.5,0 5,2.5 2.5,5 0,2.5z",
            open: "M6,1 1,3.5 6,6",
            oval: "M2.5,0A2.5,2.5,0,0,1,2.5,5 2.5,2.5,0,0,1,2.5,0z"
        },
        markerCounter = {};
    R.toString = function () {
        return  "Your browser supports SVG.\nYou are running Rapha\xebl " + this.version;
    };
    var $ = function (el, attr) {
            if (attr) {
                if (typeof el == "string") {
                    el = $(el);
                }
                for (var key in attr) if (attr[has](key)) {
                    if (key.substring(0, 6) == "xlink:") {
                        el.setAttributeNS(xlink, key.substring(6), Str(attr[key]));
                    } else {
                        el.setAttribute(key, Str(attr[key]));
                    }
                }
            } else {
                el = R._g.doc.createElementNS("http://www.w3.org/2000/svg", el);
                el.style && (el.style.webkitTapHighlightColor = "rgba(0,0,0,0)");
            }
            return el;
        },
        addGradientFill = function (element, gradient) {
            var type = "linear",
                id = element.id + gradient,
                fx = .5, fy = .5,
                o = element.node,
                SVG = element.paper,
                s = o.style,
                el = R._g.doc.getElementById(id);
            if (!el) {
                gradient = Str(gradient).replace(R._radial_gradient, function (all, _fx, _fy) {
                    type = "radial";
                    if (_fx && _fy) {
                        fx = toFloat(_fx);
                        fy = toFloat(_fy);
                        var dir = ((fy > .5) * 2 - 1);
                        pow(fx - .5, 2) + pow(fy - .5, 2) > .25 &&
                        (fy = math.sqrt(.25 - pow(fx - .5, 2)) * dir + .5) &&
                        fy != .5 &&
                        (fy = fy.toFixed(5) - 1e-5 * dir);
                    }
                    return E;
                });
                gradient = gradient.split(/\s*\-\s*/);
                if (type == "linear") {
                    var angle = gradient.shift();
                    angle = -toFloat(angle);
                    if (isNaN(angle)) {
                        return null;
                    }
                    var vector = [0, 0, math.cos(R.rad(angle)), math.sin(R.rad(angle))],
                        max = 1 / (mmax(abs(vector[2]), abs(vector[3])) || 1);
                    vector[2] *= max;
                    vector[3] *= max;
                    if (vector[2] < 0) {
                        vector[0] = -vector[2];
                        vector[2] = 0;
                    }
                    if (vector[3] < 0) {
                        vector[1] = -vector[3];
                        vector[3] = 0;
                    }
                }
                var dots = R._parseDots(gradient);
                if (!dots) {
                    return null;
                }
                id = id.replace(/[\(\)\s,\xb0#]/g, "_");

                if (element.gradient && id != element.gradient.id) {
                    SVG.defs.removeChild(element.gradient);
                    delete element.gradient;
                }

                if (!element.gradient) {
                    el = $(type + "Gradient", {id: id});
                    element.gradient = el;
                    $(el, type == "radial" ? {
                        fx: fx,
                        fy: fy
                    } : {
                        x1: vector[0],
                        y1: vector[1],
                        x2: vector[2],
                        y2: vector[3],
                        gradientTransform: element.matrix.invert()
                    });
                    SVG.defs.appendChild(el);
                    for (var i = 0, ii = dots.length; i < ii; i++) {
                        el.appendChild($("stop", {
                            offset: dots[i].offset ? dots[i].offset : i ? "100%" : "0%",
                            "stop-color": dots[i].color || "#fff",
                            "stop-opacity": isFinite(dots[i].opacity) ? dots[i].opacity : 1
                        }));
                    }
                }
            }
            $(o, {
                fill: "url('" + document.location.origin + document.location.pathname + "#" + id + "')",
                opacity: 1,
                "fill-opacity": 1
            });
            s.fill = E;
            s.opacity = 1;
            s.fillOpacity = 1;
            return 1;
        },
        updatePosition = function (o) {
            var bbox = o.getBBox(1);
            $(o.pattern, {patternTransform: o.matrix.invert() + " translate(" + bbox.x + "," + bbox.y + ")"});
        },
        addArrow = function (o, value, isEnd) {
            if (o.type == "path") {
                var values = Str(value).toLowerCase().split("-"),
                    p = o.paper,
                    se = isEnd ? "end" : "start",
                    node = o.node,
                    attrs = o.attrs,
                    stroke = attrs["stroke-width"],
                    i = values.length,
                    type = "classic",
                    from,
                    to,
                    dx,
                    refX,
                    attr,
                    w = 3,
                    h = 3,
                    t = 5;
                while (i--) {
                    switch (values[i]) {
                        case "block":
                        case "classic":
                        case "oval":
                        case "diamond":
                        case "open":
                        case "none":
                            type = values[i];
                            break;
                        case "wide": h = 5; break;
                        case "narrow": h = 2; break;
                        case "long": w = 5; break;
                        case "short": w = 2; break;
                    }
                }
                if (type == "open") {
                    w += 2;
                    h += 2;
                    t += 2;
                    dx = 1;
                    refX = isEnd ? 4 : 1;
                    attr = {
                        fill: "none",
                        stroke: attrs.stroke
                    };
                } else {
                    refX = dx = w / 2;
                    attr = {
                        fill: attrs.stroke,
                        stroke: "none"
                    };
                }
                if (o._.arrows) {
                    if (isEnd) {
                        o._.arrows.endPath && markerCounter[o._.arrows.endPath]--;
                        o._.arrows.endMarker && markerCounter[o._.arrows.endMarker]--;
                    } else {
                        o._.arrows.startPath && markerCounter[o._.arrows.startPath]--;
                        o._.arrows.startMarker && markerCounter[o._.arrows.startMarker]--;
                    }
                } else {
                    o._.arrows = {};
                }
                if (type != "none") {
                    var pathId = "raphael-marker-" + type,
                        markerId = "raphael-marker-" + se + type + w + h + "-obj" + o.id;
                    if (!R._g.doc.getElementById(pathId)) {
                        p.defs.appendChild($($("path"), {
                            "stroke-linecap": "round",
                            d: markers[type],
                            id: pathId
                        }));
                        markerCounter[pathId] = 1;
                    } else {
                        markerCounter[pathId]++;
                    }
                    var marker = R._g.doc.getElementById(markerId),
                        use;
                    if (!marker) {
                        marker = $($("marker"), {
                            id: markerId,
                            markerHeight: h,
                            markerWidth: w,
                            orient: "auto",
                            refX: refX,
                            refY: h / 2
                        });
                        use = $($("use"), {
                            "xlink:href": "#" + pathId,
                            transform: (isEnd ? "rotate(180 " + w / 2 + " " + h / 2 + ") " : E) + "scale(" + w / t + "," + h / t + ")",
                            "stroke-width": (1 / ((w / t + h / t) / 2)).toFixed(4)
                        });
                        marker.appendChild(use);
                        p.defs.appendChild(marker);
                        markerCounter[markerId] = 1;
                    } else {
                        markerCounter[markerId]++;
                        use = marker.getElementsByTagName("use")[0];
                    }
                    $(use, attr);
                    var delta = dx * (type != "diamond" && type != "oval");
                    if (isEnd) {
                        from = o._.arrows.startdx * stroke || 0;
                        to = R.getTotalLength(attrs.path) - delta * stroke;
                    } else {
                        from = delta * stroke;
                        to = R.getTotalLength(attrs.path) - (o._.arrows.enddx * stroke || 0);
                    }
                    attr = {};
                    attr["marker-" + se] = "url(#" + markerId + ")";
                    if (to || from) {
                        attr.d = R.getSubpath(attrs.path, from, to);
                    }
                    $(node, attr);
                    o._.arrows[se + "Path"] = pathId;
                    o._.arrows[se + "Marker"] = markerId;
                    o._.arrows[se + "dx"] = delta;
                    o._.arrows[se + "Type"] = type;
                    o._.arrows[se + "String"] = value;
                } else {
                    if (isEnd) {
                        from = o._.arrows.startdx * stroke || 0;
                        to = R.getTotalLength(attrs.path) - from;
                    } else {
                        from = 0;
                        to = R.getTotalLength(attrs.path) - (o._.arrows.enddx * stroke || 0);
                    }
                    o._.arrows[se + "Path"] && $(node, {d: R.getSubpath(attrs.path, from, to)});
                    delete o._.arrows[se + "Path"];
                    delete o._.arrows[se + "Marker"];
                    delete o._.arrows[se + "dx"];
                    delete o._.arrows[se + "Type"];
                    delete o._.arrows[se + "String"];
                }
                for (attr in markerCounter) if (markerCounter[has](attr) && !markerCounter[attr]) {
                    var item = R._g.doc.getElementById(attr);
                    item && item.parentNode.removeChild(item);
                }
            }
        },
        dasharray = {
            "-": [3, 1],
            ".": [1, 1],
            "-.": [3, 1, 1, 1],
            "-..": [3, 1, 1, 1, 1, 1],
            ". ": [1, 3],
            "- ": [4, 3],
            "--": [8, 3],
            "- .": [4, 3, 1, 3],
            "--.": [8, 3, 1, 3],
            "--..": [8, 3, 1, 3, 1, 3]
        },
        addDashes = function (o, value, params) {
            value = dasharray[Str(value).toLowerCase()];
            if (value) {
                var width = o.attrs["stroke-width"] || "1",
                    butt = {round: width, square: width, butt: 0}[o.attrs["stroke-linecap"] || params["stroke-linecap"]] || 0,
                    dashes = [],
                    i = value.length;
                while (i--) {
                    dashes[i] = value[i] * width + ((i % 2) ? 1 : -1) * butt;
                }
                $(o.node, {"stroke-dasharray": dashes.join(",")});
            }
            else {
                $(o.node, {"stroke-dasharray": "none"});
            }
        },
        setFillAndStroke = function (o, params) {
            var node = o.node,
                attrs = o.attrs,
                vis = node.style.visibility;
            node.style.visibility = "hidden";
            for (var att in params) {
                if (params[has](att)) {
                    if (!R._availableAttrs[has](att)) {
                        continue;
                    }
                    var value = params[att];
                    attrs[att] = value;
                    switch (att) {
                        case "blur":
                            o.blur(value);
                            break;
                        case "title":
                            var title = node.getElementsByTagName("title");

                            // Use the existing <title>.
                            if (title.length && (title = title[0])) {
                                title.firstChild.nodeValue = value;
                            } else {
                                title = $("title");
                                var val = R._g.doc.createTextNode(value);
                                title.appendChild(val);
                                node.appendChild(title);
                            }
                            break;
                        case "href":
                        case "target":
                            var pn = node.parentNode;
                            if (pn.tagName.toLowerCase() != "a") {
                                var hl = $("a");
                                pn.insertBefore(hl, node);
                                hl.appendChild(node);
                                pn = hl;
                            }
                            if (att == "target") {
                                pn.setAttributeNS(xlink, "show", value == "blank" ? "new" : value);
                            } else {
                                pn.setAttributeNS(xlink, att, value);
                            }
                            break;
                        case "cursor":
                            node.style.cursor = value;
                            break;
                        case "transform":
                            o.transform(value);
                            break;
                        case "arrow-start":
                            addArrow(o, value);
                            break;
                        case "arrow-end":
                            addArrow(o, value, 1);
                            break;
                        case "clip-rect":
                            var rect = Str(value).split(separator);
                            if (rect.length == 4) {
                                o.clip && o.clip.parentNode.parentNode.removeChild(o.clip.parentNode);
                                var el = $("clipPath"),
                                    rc = $("rect");
                                el.id = R.createUUID();
                                $(rc, {
                                    x: rect[0],
                                    y: rect[1],
                                    width: rect[2],
                                    height: rect[3]
                                });
                                el.appendChild(rc);
                                o.paper.defs.appendChild(el);
                                $(node, {"clip-path": "url(#" + el.id + ")"});
                                o.clip = rc;
                            }
                            if (!value) {
                                var path = node.getAttribute("clip-path");
                                if (path) {
                                    var clip = R._g.doc.getElementById(path.replace(/(^url\(#|\)$)/g, E));
                                    clip && clip.parentNode.removeChild(clip);
                                    $(node, {"clip-path": E});
                                    delete o.clip;
                                }
                            }
                            break;
                        case "path":
                            if (o.type == "path") {
                                $(node, {d: value ? attrs.path = R._pathToAbsolute(value) : "M0,0"});
                                o._.dirty = 1;
                                if (o._.arrows) {
                                    "startString" in o._.arrows && addArrow(o, o._.arrows.startString);
                                    "endString" in o._.arrows && addArrow(o, o._.arrows.endString, 1);
                                }
                            }
                            break;
                        case "width":
                            node.setAttribute(att, value);
                            o._.dirty = 1;
                            if (attrs.fx) {
                                att = "x";
                                value = attrs.x;
                            } else {
                                break;
                            }
                        case "x":
                            if (attrs.fx) {
                                value = -attrs.x - (attrs.width || 0);
                            }
                        case "rx":
                            if (att == "rx" && o.type == "rect") {
                                break;
                            }
                        case "cx":
                            node.setAttribute(att, value);
                            o.pattern && updatePosition(o);
                            o._.dirty = 1;
                            break;
                        case "height":
                            node.setAttribute(att, value);
                            o._.dirty = 1;
                            if (attrs.fy) {
                                att = "y";
                                value = attrs.y;
                            } else {
                                break;
                            }
                        case "y":
                            if (attrs.fy) {
                                value = -attrs.y - (attrs.height || 0);
                            }
                        case "ry":
                            if (att == "ry" && o.type == "rect") {
                                break;
                            }
                        case "cy":
                            node.setAttribute(att, value);
                            o.pattern && updatePosition(o);
                            o._.dirty = 1;
                            break;
                        case "r":
                            if (o.type == "rect") {
                                $(node, {rx: value, ry: value});
                            } else {
                                node.setAttribute(att, value);
                            }
                            o._.dirty = 1;
                            break;
                        case "src":
                            if (o.type == "image") {
                                node.setAttributeNS(xlink, "href", value);
                            }
                            break;
                        case "stroke-width":
                            if (o._.sx != 1 || o._.sy != 1) {
                                value /= mmax(abs(o._.sx), abs(o._.sy)) || 1;
                            }
                            node.setAttribute(att, value);
                            if (attrs["stroke-dasharray"]) {
                                addDashes(o, attrs["stroke-dasharray"], params);
                            }
                            if (o._.arrows) {
                                "startString" in o._.arrows && addArrow(o, o._.arrows.startString);
                                "endString" in o._.arrows && addArrow(o, o._.arrows.endString, 1);
                            }
                            break;
                        case "stroke-dasharray":
                            addDashes(o, value, params);
                            break;
                        case "fill":
                            var isURL = Str(value).match(R._ISURL);
                            if (isURL) {
                                el = $("pattern");
                                var ig = $("image");
                                el.id = R.createUUID();
                                $(el, {x: 0, y: 0, patternUnits: "userSpaceOnUse", height: 1, width: 1});
                                $(ig, {x: 0, y: 0, "xlink:href": isURL[1]});
                                el.appendChild(ig);

                                (function (el) {
                                    R._preload(isURL[1], function () {
                                        var w = this.offsetWidth,
                                            h = this.offsetHeight;
                                        $(el, {width: w, height: h});
                                        $(ig, {width: w, height: h});
                                    });
                                })(el);
                                o.paper.defs.appendChild(el);
                                $(node, {fill: "url(#" + el.id + ")"});
                                o.pattern = el;
                                o.pattern && updatePosition(o);
                                break;
                            }
                            var clr = R.getRGB(value);
                            if (!clr.error) {
                                delete params.gradient;
                                delete attrs.gradient;
                                !R.is(attrs.opacity, "undefined") &&
                                R.is(params.opacity, "undefined") &&
                                $(node, {opacity: attrs.opacity});
                                !R.is(attrs["fill-opacity"], "undefined") &&
                                R.is(params["fill-opacity"], "undefined") &&
                                $(node, {"fill-opacity": attrs["fill-opacity"]});
                            } else if ((o.type == "circle" || o.type == "ellipse" || Str(value).charAt() != "r") && addGradientFill(o, value)) {
                                if ("opacity" in attrs || "fill-opacity" in attrs) {
                                    var gradient = R._g.doc.getElementById(node.getAttribute("fill").replace(/^url\(#|\)$/g, E));
                                    if (gradient) {
                                        var stops = gradient.getElementsByTagName("stop");
                                        $(stops[stops.length - 1], {"stop-opacity": ("opacity" in attrs ? attrs.opacity : 1) * ("fill-opacity" in attrs ? attrs["fill-opacity"] : 1)});
                                    }
                                }
                                attrs.gradient = value;
                                attrs.fill = "none";
                                break;
                            }
                            clr[has]("opacity") && $(node, {"fill-opacity": clr.opacity > 1 ? clr.opacity / 100 : clr.opacity});
                        case "stroke":
                            clr = R.getRGB(value);
                            node.setAttribute(att, clr.hex);
                            att == "stroke" && clr[has]("opacity") && $(node, {"stroke-opacity": clr.opacity > 1 ? clr.opacity / 100 : clr.opacity});
                            if (att == "stroke" && o._.arrows) {
                                "startString" in o._.arrows && addArrow(o, o._.arrows.startString);
                                "endString" in o._.arrows && addArrow(o, o._.arrows.endString, 1);
                            }
                            break;
                        case "gradient":
                            (o.type == "circle" || o.type == "ellipse" || Str(value).charAt() != "r") && addGradientFill(o, value);
                            break;
                        case "opacity":
                            if (attrs.gradient && !attrs[has]("stroke-opacity")) {
                                $(node, {"stroke-opacity": value > 1 ? value / 100 : value});
                            }
                        // fall
                        case "fill-opacity":
                            if (attrs.gradient) {
                                gradient = R._g.doc.getElementById(node.getAttribute("fill").replace(/^url\(#|\)$/g, E));
                                if (gradient) {
                                    stops = gradient.getElementsByTagName("stop");
                                    $(stops[stops.length - 1], {"stop-opacity": value});
                                }
                                break;
                            }
                        default:
                            att == "font-size" && (value = toInt(value, 10) + "px");
                            var cssrule = att.replace(/(\-.)/g, function (w) {
                                return w.substring(1).toUpperCase();
                            });
                            node.style[cssrule] = value;
                            o._.dirty = 1;
                            node.setAttribute(att, value);
                            break;
                    }
                }
            }

            tuneText(o, params);
            node.style.visibility = vis;
        },
        leading = 1.2,
        tuneText = function (el, params) {
            if (el.type != "text" || !(params[has]("text") || params[has]("font") || params[has]("font-size") || params[has]("x") || params[has]("y"))) {
                return;
            }
            var a = el.attrs,
                node = el.node,
                fontSize = node.firstChild ? toInt(R._g.doc.defaultView.getComputedStyle(node.firstChild, E).getPropertyValue("font-size"), 10) : 10;

            if (params[has]("text")) {
                a.text = params.text;
                while (node.firstChild) {
                    node.removeChild(node.firstChild);
                }
                var texts = Str(params.text).split("\n"),
                    tspans = [],
                    tspan;
                for (var i = 0, ii = texts.length; i < ii; i++) {
                    tspan = $("tspan");
                    i && $(tspan, {dy: fontSize * leading, x: a.x});
                    tspan.appendChild(R._g.doc.createTextNode(texts[i]));
                    node.appendChild(tspan);
                    tspans[i] = tspan;
                }
            } else {
                tspans = node.getElementsByTagName("tspan");
                for (i = 0, ii = tspans.length; i < ii; i++) if (i) {
                    $(tspans[i], {dy: fontSize * leading, x: a.x});
                } else {
                    $(tspans[0], {dy: 0});
                }
            }
            $(node, {x: a.x, y: a.y});
            el._.dirty = 1;
            var bb = el._getBBox(),
                dif = a.y - (bb.y + bb.height / 2);
            dif && R.is(dif, "finite") && $(tspans[0], {dy: dif});
        },
        getRealNode = function (node) {
            if (node.parentNode && node.parentNode.tagName.toLowerCase() === "a") {
                return node.parentNode;
            } else {
                return node;
            }
        },
        Element = function (node, svg) {
            var X = 0,
                Y = 0;
            /*\
             * Element.node
             [ property (object) ]
             **
             * Gives you a reference to the DOM object, so you can assign event handlers or just mess around.
             **
             * Note: Don’t mess with it.
             > Usage
             | // draw a circle at coordinate 10,10 with radius of 10
             | var c = paper.circle(10, 10, 10);
             | c.node.onclick = function () {
             |     c.attr("fill", "red");
             | };
             \*/
            this[0] = this.node = node;
            /*\
             * Element.raphael
             [ property (object) ]
             **
             * Internal reference to @Raphael object. In case it is not available.
             > Usage
             | Raphael.el.red = function () {
             |     var hsb = this.paper.raphael.rgb2hsb(this.attr("fill"));
             |     hsb.h = 1;
             |     this.attr({fill: this.paper.raphael.hsb2rgb(hsb).hex});
             | }
             \*/
            node.raphael = true;
            /*\
             * Element.id
             [ property (number) ]
             **
             * Unique id of the element. Especially useful when you want to listen to events of the element,
             * because all events are fired in format `<module>.<action>.<id>`. Also useful for @Paper.getById method.
             \*/
            this.id = R._oid++;
            node.raphaelid = this.id;
            this.matrix = R.matrix();
            this.realPath = null;
            /*\
             * Element.paper
             [ property (object) ]
             **
             * Internal reference to “paper” where object drawn. Mainly for use in plugins and element extensions.
             > Usage
             | Raphael.el.cross = function () {
             |     this.attr({fill: "red"});
             |     this.paper.path("M10,10L50,50M50,10L10,50")
             |         .attr({stroke: "red"});
             | }
             \*/
            this.paper = svg;
            this.attrs = this.attrs || {};
            this._ = {
                transform: [],
                sx: 1,
                sy: 1,
                deg: 0,
                dx: 0,
                dy: 0,
                dirty: 1
            };
            !svg.bottom && (svg.bottom = this);
            /*\
             * Element.prev
             [ property (object) ]
             **
             * Reference to the previous element in the hierarchy.
             \*/
            this.prev = svg.top;
            svg.top && (svg.top.next = this);
            svg.top = this;
            /*\
             * Element.next
             [ property (object) ]
             **
             * Reference to the next element in the hierarchy.
             \*/
            this.next = null;
        },
        elproto = R.el;

    Element.prototype = elproto;
    elproto.constructor = Element;

    R._engine.path = function (pathString, SVG) {
        var el = $("path");
        SVG.canvas && SVG.canvas.appendChild(el);
        var p = new Element(el, SVG);
        p.type = "path";
        setFillAndStroke(p, {
            fill: "none",
            stroke: "#000",
            path: pathString
        });
        return p;
    };
    /*\
     * Element.rotate
     [ method ]
     **
     * Deprecated! Use @Element.transform instead.
     * Adds rotation by given angle around given point to the list of
     * transformations of the element.
     > Parameters
     - deg (number) angle in degrees
     - cx (number) #optional x coordinate of the centre of rotation
     - cy (number) #optional y coordinate of the centre of rotation
     * If cx & cy aren’t specified centre of the shape is used as a point of rotation.
     = (object) @Element
     \*/
    elproto.rotate = function (deg, cx, cy) {
        if (this.removed) {
            return this;
        }
        deg = Str(deg).split(separator);
        if (deg.length - 1) {
            cx = toFloat(deg[1]);
            cy = toFloat(deg[2]);
        }
        deg = toFloat(deg[0]);
        (cy == null) && (cx = cy);
        if (cx == null || cy == null) {
            var bbox = this.getBBox(1);
            cx = bbox.x + bbox.width / 2;
            cy = bbox.y + bbox.height / 2;
        }
        this.transform(this._.transform.concat([["r", deg, cx, cy]]));
        return this;
    };
    /*\
     * Element.scale
     [ method ]
     **
     * Deprecated! Use @Element.transform instead.
     * Adds scale by given amount relative to given point to the list of
     * transformations of the element.
     > Parameters
     - sx (number) horisontal scale amount
     - sy (number) vertical scale amount
     - cx (number) #optional x coordinate of the centre of scale
     - cy (number) #optional y coordinate of the centre of scale
     * If cx & cy aren’t specified centre of the shape is used instead.
     = (object) @Element
     \*/
    elproto.scale = function (sx, sy, cx, cy) {
        if (this.removed) {
            return this;
        }
        sx = Str(sx).split(separator);
        if (sx.length - 1) {
            sy = toFloat(sx[1]);
            cx = toFloat(sx[2]);
            cy = toFloat(sx[3]);
        }
        sx = toFloat(sx[0]);
        (sy == null) && (sy = sx);
        (cy == null) && (cx = cy);
        if (cx == null || cy == null) {
            var bbox = this.getBBox(1);
        }
        cx = cx == null ? bbox.x + bbox.width / 2 : cx;
        cy = cy == null ? bbox.y + bbox.height / 2 : cy;
        this.transform(this._.transform.concat([["s", sx, sy, cx, cy]]));
        return this;
    };
    /*\
     * Element.translate
     [ method ]
     **
     * Deprecated! Use @Element.transform instead.
     * Adds translation by given amount to the list of transformations of the element.
     > Parameters
     - dx (number) horisontal shift
     - dy (number) vertical shift
     = (object) @Element
     \*/
    elproto.translate = function (dx, dy) {
        if (this.removed) {
            return this;
        }
        dx = Str(dx).split(separator);
        if (dx.length - 1) {
            dy = toFloat(dx[1]);
        }
        dx = toFloat(dx[0]) || 0;
        dy = +dy || 0;
        this.transform(this._.transform.concat([["t", dx, dy]]));
        return this;
    };
    /*\
     * Element.transform
     [ method ]
     **
     * Adds transformation to the element which is separate to other attributes,
     * i.e. translation doesn’t change `x` or `y` of the rectange. The format
     * of transformation string is similar to the path string syntax:
     | "t100,100r30,100,100s2,2,100,100r45s1.5"
     * Each letter is a command. There are four commands: `t` is for translate, `r` is for rotate, `s` is for
     * scale and `m` is for matrix.
     *
     * There are also alternative “absolute” translation, rotation and scale: `T`, `R` and `S`. They will not take previous transformation into account. For example, `...T100,0` will always move element 100 px horisontally, while `...t100,0` could move it vertically if there is `r90` before. Just compare results of `r90t100,0` and `r90T100,0`.
     *
     * So, the example line above could be read like “translate by 100, 100; rotate 30° around 100, 100; scale twice around 100, 100;
     * rotate 45° around centre; scale 1.5 times relative to centre”. As you can see rotate and scale commands have origin
     * coordinates as optional parameters, the default is the centre point of the element.
     * Matrix accepts six parameters.
     > Usage
     | var el = paper.rect(10, 20, 300, 200);
     | // translate 100, 100, rotate 45°, translate -100, 0
     | el.transform("t100,100r45t-100,0");
     | // if you want you can append or prepend transformations
     | el.transform("...t50,50");
     | el.transform("s2...");
     | // or even wrap
     | el.transform("t50,50...t-50-50");
     | // to reset transformation call method with empty string
     | el.transform("");
     | // to get current value call it without parameters
     | console.log(el.transform());
     > Parameters
     - tstr (string) #optional transformation string
     * If tstr isn’t specified
     = (string) current transformation string
     * else
     = (object) @Element
     \*/
    elproto.transform = function (tstr) {
        var _ = this._;
        if (tstr == null) {
            return _.transform;
        }
        R._extractTransform(this, tstr);

        this.clip && $(this.clip, {transform: this.matrix.invert()});
        this.pattern && updatePosition(this);
        this.node && $(this.node, {transform: this.matrix});

        if (_.sx != 1 || _.sy != 1) {
            var sw = this.attrs[has]("stroke-width") ? this.attrs["stroke-width"] : 1;
            this.attr({"stroke-width": sw});
        }

        return this;
    };
    /*\
     * Element.hide
     [ method ]
     **
     * Makes element invisible. See @Element.show.
     = (object) @Element
     \*/
    elproto.hide = function () {
        if(!this.removed) this.node.style.display = "none";
        return this;
    };
    /*\
     * Element.show
     [ method ]
     **
     * Makes element visible. See @Element.hide.
     = (object) @Element
     \*/
    elproto.show = function () {
        if(!this.removed) this.node.style.display = "";
        return this;
    };
    /*\
     * Element.remove
     [ method ]
     **
     * Removes element from the paper.
     \*/
    elproto.remove = function () {
        var node = getRealNode(this.node);
        if (this.removed || !node.parentNode) {
            return;
        }
        var paper = this.paper;
        paper.__set__ && paper.__set__.exclude(this);
        eve.unbind("raphael.*.*." + this.id);
        if (this.gradient) {
            paper.defs.removeChild(this.gradient);
        }
        R._tear(this, paper);

        node.parentNode.removeChild(node);

        // Remove custom data for element
        this.removeData();

        for (var i in this) {
            this[i] = typeof this[i] == "function" ? R._removedFactory(i) : null;
        }
        this.removed = true;
    };
    elproto._getBBox = function () {
        if (this.node.style.display == "none") {
            this.show();
            var hide = true;
        }
        var canvasHidden = false,
            containerStyle;
        if (this.paper.canvas.parentElement) {
            containerStyle = this.paper.canvas.parentElement.style;
        } //IE10+ can't find parentElement
        else if (this.paper.canvas.parentNode) {
            containerStyle = this.paper.canvas.parentNode.style;
        }

        if(containerStyle && containerStyle.display == "none") {
            canvasHidden = true;
            containerStyle.display = "";
        }
        var bbox = {};
        try {
            bbox = this.node.getBBox();
        } catch(e) {
            // Firefox 3.0.x, 25.0.1 (probably more versions affected) play badly here - possible fix
            bbox = {
                x: this.node.clientLeft,
                y: this.node.clientTop,
                width: this.node.clientWidth,
                height: this.node.clientHeight
            }
        } finally {
            bbox = bbox || {};
            if(canvasHidden){
                containerStyle.display = "none";
            }
        }
        hide && this.hide();
        return bbox;
    };
    /*\
     * Element.attr
     [ method ]
     **
     * Sets the attributes of the element.
     > Parameters
     - attrName (string) attribute’s name
     - value (string) value
     * or
     - params (object) object of name/value pairs
     * or
     - attrName (string) attribute’s name
     * or
     - attrNames (array) in this case method returns array of current values for given attribute names
     = (object) @Element if attrsName & value or params are passed in.
     = (...) value of the attribute if only attrsName is passed in.
     = (array) array of values of the attribute if attrsNames is passed in.
     = (object) object of attributes if nothing is passed in.
     > Possible parameters
     # <p>Please refer to the <a href="http://www.w3.org/TR/SVG/" title="The W3C Recommendation for the SVG language describes these properties in detail.">SVG specification</a> for an explanation of these parameters.</p>
     o arrow-end (string) arrowhead on the end of the path. The format for string is `<type>[-<width>[-<length>]]`. Possible types: `classic`, `block`, `open`, `oval`, `diamond`, `none`, width: `wide`, `narrow`, `medium`, length: `long`, `short`, `midium`.
     o clip-rect (string) comma or space separated values: x, y, width and height
     o cursor (string) CSS type of the cursor
     o cx (number) the x-axis coordinate of the center of the circle, or ellipse
     o cy (number) the y-axis coordinate of the center of the circle, or ellipse
     o fill (string) colour, gradient or image
     o fill-opacity (number)
     o font (string)
     o font-family (string)
     o font-size (number) font size in pixels
     o font-weight (string)
     o height (number)
     o href (string) URL, if specified element behaves as hyperlink
     o opacity (number)
     o path (string) SVG path string format
     o r (number) radius of the circle, ellipse or rounded corner on the rect
     o rx (number) horisontal radius of the ellipse
     o ry (number) vertical radius of the ellipse
     o src (string) image URL, only works for @Element.image element
     o stroke (string) stroke colour
     o stroke-dasharray (string) [“”, “none”, “`-`”, “`.`”, “`-.`”, “`-..`”, “`. `”, “`- `”, “`--`”, “`- .`”, “`--.`”, “`--..`”]
     o stroke-linecap (string) [“`butt`”, “`square`”, “`round`”]
     o stroke-linejoin (string) [“`bevel`”, “`round`”, “`miter`”]
     o stroke-miterlimit (number)
     o stroke-opacity (number)
     o stroke-width (number) stroke width in pixels, default is '1'
     o target (string) used with href
     o text (string) contents of the text element. Use `\n` for multiline text
     o text-anchor (string) [“`start`”, “`middle`”, “`end`”], default is “`middle`”
     o title (string) will create tooltip with a given text
     o transform (string) see @Element.transform
     o width (number)
     o x (number)
     o y (number)
     > Gradients
     * Linear gradient format: “`‹angle›-‹colour›[-‹colour›[:‹offset›]]*-‹colour›`”, example: “`90-#fff-#000`” – 90°
     * gradient from white to black or “`0-#fff-#f00:20-#000`” – 0° gradient from white via red (at 20%) to black.
     *
     * radial gradient: “`r[(‹fx›, ‹fy›)]‹colour›[-‹colour›[:‹offset›]]*-‹colour›`”, example: “`r#fff-#000`” –
     * gradient from white to black or “`r(0.25, 0.75)#fff-#000`” – gradient from white to black with focus point
     * at 0.25, 0.75. Focus point coordinates are in 0..1 range. Radial gradients can only be applied to circles and ellipses.
     > Path String
     # <p>Please refer to <a href="http://www.w3.org/TR/SVG/paths.html#PathData" title="Details of a path’s data attribute’s format are described in the SVG specification.">SVG documentation regarding path string</a>. Raphaël fully supports it.</p>
     > Colour Parsing
     # <ul>
     #     <li>Colour name (“<code>red</code>”, “<code>green</code>”, “<code>cornflowerblue</code>”, etc)</li>
     #     <li>#••• — shortened HTML colour: (“<code>#000</code>”, “<code>#fc0</code>”, etc)</li>
     #     <li>#•••••• — full length HTML colour: (“<code>#000000</code>”, “<code>#bd2300</code>”)</li>
     #     <li>rgb(•••, •••, •••) — red, green and blue channels’ values: (“<code>rgb(200,&nbsp;100,&nbsp;0)</code>”)</li>
     #     <li>rgb(•••%, •••%, •••%) — same as above, but in %: (“<code>rgb(100%,&nbsp;175%,&nbsp;0%)</code>”)</li>
     #     <li>rgba(•••, •••, •••, •••) — red, green and blue channels’ values: (“<code>rgba(200,&nbsp;100,&nbsp;0, .5)</code>”)</li>
     #     <li>rgba(•••%, •••%, •••%, •••%) — same as above, but in %: (“<code>rgba(100%,&nbsp;175%,&nbsp;0%, 50%)</code>”)</li>
     #     <li>hsb(•••, •••, •••) — hue, saturation and brightness values: (“<code>hsb(0.5,&nbsp;0.25,&nbsp;1)</code>”)</li>
     #     <li>hsb(•••%, •••%, •••%) — same as above, but in %</li>
     #     <li>hsba(•••, •••, •••, •••) — same as above, but with opacity</li>
     #     <li>hsl(•••, •••, •••) — almost the same as hsb, see <a href="http://en.wikipedia.org/wiki/HSL_and_HSV" title="HSL and HSV - Wikipedia, the free encyclopedia">Wikipedia page</a></li>
     #     <li>hsl(•••%, •••%, •••%) — same as above, but in %</li>
     #     <li>hsla(•••, •••, •••, •••) — same as above, but with opacity</li>
     #     <li>Optionally for hsb and hsl you could specify hue as a degree: “<code>hsl(240deg,&nbsp;1,&nbsp;.5)</code>” or, if you want to go fancy, “<code>hsl(240°,&nbsp;1,&nbsp;.5)</code>”</li>
     # </ul>
     \*/
    elproto.attr = function (name, value) {
        if (this.removed) {
            return this;
        }
        if (name == null) {
            var res = {};
            for (var a in this.attrs) if (this.attrs[has](a)) {
                res[a] = this.attrs[a];
            }
            res.gradient && res.fill == "none" && (res.fill = res.gradient) && delete res.gradient;
            res.transform = this._.transform;
            return res;
        }
        if (value == null && R.is(name, "string")) {
            if (name == "fill" && this.attrs.fill == "none" && this.attrs.gradient) {
                return this.attrs.gradient;
            }
            if (name == "transform") {
                return this._.transform;
            }
            var names = name.split(separator),
                out = {};
            for (var i = 0, ii = names.length; i < ii; i++) {
                name = names[i];
                if (name in this.attrs) {
                    out[name] = this.attrs[name];
                } else if (R.is(this.paper.customAttributes[name], "function")) {
                    out[name] = this.paper.customAttributes[name].def;
                } else {
                    out[name] = R._availableAttrs[name];
                }
            }
            return ii - 1 ? out : out[names[0]];
        }
        if (value == null && R.is(name, "array")) {
            out = {};
            for (i = 0, ii = name.length; i < ii; i++) {
                out[name[i]] = this.attr(name[i]);
            }
            return out;
        }
        if (value != null) {
            var params = {};
            params[name] = value;
        } else if (name != null && R.is(name, "object")) {
            params = name;
        }
        for (var key in params) {
            eve("raphael.attr." + key + "." + this.id, this, params[key]);
        }
        for (key in this.paper.customAttributes) if (this.paper.customAttributes[has](key) && params[has](key) && R.is(this.paper.customAttributes[key], "function")) {
            var par = this.paper.customAttributes[key].apply(this, [].concat(params[key]));
            this.attrs[key] = params[key];
            for (var subkey in par) if (par[has](subkey)) {
                params[subkey] = par[subkey];
            }
        }
        setFillAndStroke(this, params);
        return this;
    };
    /*\
     * Element.toFront
     [ method ]
     **
     * Moves the element so it is the closest to the viewer’s eyes, on top of other elements.
     = (object) @Element
     \*/
    elproto.toFront = function () {
        if (this.removed) {
            return this;
        }
        var node = getRealNode(this.node);
        node.parentNode.appendChild(node);
        var svg = this.paper;
        svg.top != this && R._tofront(this, svg);
        return this;
    };
    /*\
     * Element.toBack
     [ method ]
     **
     * Moves the element so it is the furthest from the viewer’s eyes, behind other elements.
     = (object) @Element
     \*/
    elproto.toBack = function () {
        if (this.removed) {
            return this;
        }
        var node = getRealNode(this.node);
        var parentNode = node.parentNode;
        parentNode.insertBefore(node, parentNode.firstChild);
        R._toback(this, this.paper);
        var svg = this.paper;
        return this;
    };
    /*\
     * Element.insertAfter
     [ method ]
     **
     * Inserts current object after the given one.
     = (object) @Element
     \*/
    elproto.insertAfter = function (element) {
        if (this.removed || !element) {
            return this;
        }

        var node = getRealNode(this.node);
        var afterNode = getRealNode(element.node || element[element.length - 1].node);
        if (afterNode.nextSibling) {
            afterNode.parentNode.insertBefore(node, afterNode.nextSibling);
        } else {
            afterNode.parentNode.appendChild(node);
        }
        R._insertafter(this, element, this.paper);
        return this;
    };
    /*\
     * Element.insertBefore
     [ method ]
     **
     * Inserts current object before the given one.
     = (object) @Element
     \*/
    elproto.insertBefore = function (element) {
        if (this.removed || !element) {
            return this;
        }

        var node = getRealNode(this.node);
        var beforeNode = getRealNode(element.node || element[0].node);
        beforeNode.parentNode.insertBefore(node, beforeNode);
        R._insertbefore(this, element, this.paper);
        return this;
    };
    elproto.blur = function (size) {
        // Experimental. No Safari support. Use it on your own risk.
        var t = this;
        if (+size !== 0) {
            var fltr = $("filter"),
                blur = $("feGaussianBlur");
            t.attrs.blur = size;
            fltr.id = R.createUUID();
            $(blur, {stdDeviation: +size || 1.5});
            fltr.appendChild(blur);
            t.paper.defs.appendChild(fltr);
            t._blur = fltr;
            $(t.node, {filter: "url(#" + fltr.id + ")"});
        } else {
            if (t._blur) {
                t._blur.parentNode.removeChild(t._blur);
                delete t._blur;
                delete t.attrs.blur;
            }
            t.node.removeAttribute("filter");
        }
        return t;
    };
    R._engine.circle = function (svg, x, y, r) {
        var el = $("circle");
        svg.canvas && svg.canvas.appendChild(el);
        var res = new Element(el, svg);
        res.attrs = {cx: x, cy: y, r: r, fill: "none", stroke: "#000"};
        res.type = "circle";
        $(el, res.attrs);
        return res;
    };
    R._engine.rect = function (svg, x, y, w, h, r) {
        var el = $("rect");
        svg.canvas && svg.canvas.appendChild(el);
        var res = new Element(el, svg);
        res.attrs = {x: x, y: y, width: w, height: h, rx: r || 0, ry: r || 0, fill: "none", stroke: "#000"};
        res.type = "rect";
        $(el, res.attrs);
        return res;
    };
    R._engine.ellipse = function (svg, x, y, rx, ry) {
        var el = $("ellipse");
        svg.canvas && svg.canvas.appendChild(el);
        var res = new Element(el, svg);
        res.attrs = {cx: x, cy: y, rx: rx, ry: ry, fill: "none", stroke: "#000"};
        res.type = "ellipse";
        $(el, res.attrs);
        return res;
    };
    R._engine.image = function (svg, src, x, y, w, h) {
        var el = $("image");
        $(el, {x: x, y: y, width: w, height: h, preserveAspectRatio: "none"});
        el.setAttributeNS(xlink, "href", src);
        svg.canvas && svg.canvas.appendChild(el);
        var res = new Element(el, svg);
        res.attrs = {x: x, y: y, width: w, height: h, src: src};
        res.type = "image";
        return res;
    };
    R._engine.text = function (svg, x, y, text) {
        var el = $("text");
        svg.canvas && svg.canvas.appendChild(el);
        var res = new Element(el, svg);
        res.attrs = {
            x: x,
            y: y,
            "text-anchor": "middle",
            text: text,
            "font-family": R._availableAttrs["font-family"],
            "font-size": R._availableAttrs["font-size"],
            stroke: "none",
            fill: "#000"
        };
        res.type = "text";
        setFillAndStroke(res, res.attrs);
        return res;
    };
    R._engine.setSize = function (width, height) {
        this.width = width || this.width;
        this.height = height || this.height;
        this.canvas.setAttribute("width", this.width);
        this.canvas.setAttribute("height", this.height);
        if (this._viewBox) {
            this.setViewBox.apply(this, this._viewBox);
        }
        return this;
    };
    R._engine.create = function () {
        var con = R._getContainer.apply(0, arguments),
            container = con && con.container,
            x = con.x,
            y = con.y,
            width = con.width,
            height = con.height;
        if (!container) {
            throw new Error("SVG container not found.");
        }
        var cnvs = $("svg"),
            css = "overflow:hidden;",
            isFloating;
        x = x || 0;
        y = y || 0;
        width = width || 512;
        height = height || 342;
        $(cnvs, {
            height: height,
            version: 1.1,
            width: width,
            xmlns: "http://www.w3.org/2000/svg",
            "xmlns:xlink": "http://www.w3.org/1999/xlink"
        });
        if (container == 1) {
            cnvs.style.cssText = css + "position:absolute;left:" + x + "px;top:" + y + "px";
            R._g.doc.body.appendChild(cnvs);
            isFloating = 1;
        } else {
            cnvs.style.cssText = css + "position:relative";
            if (container.firstChild) {
                container.insertBefore(cnvs, container.firstChild);
            } else {
                container.appendChild(cnvs);
            }
        }
        container = new R._Paper;
        container.width = width;
        container.height = height;
        container.canvas = cnvs;
        container.clear();
        container._left = container._top = 0;
        isFloating && (container.renderfix = function () {});
        container.renderfix();
        return container;
    };
    R._engine.setViewBox = function (x, y, w, h, fit) {
        eve("raphael.setViewBox", this, this._viewBox, [x, y, w, h, fit]);
        var paperSize = this.getSize(),
            size = mmax(w / paperSize.width, h / paperSize.height),
            top = this.top,
            aspectRatio = fit ? "xMidYMid meet" : "xMinYMin",
            vb,
            sw;
        if (x == null) {
            if (this._vbSize) {
                size = 1;
            }
            delete this._vbSize;
            vb = "0 0 " + this.width + S + this.height;
        } else {
            this._vbSize = size;
            vb = x + S + y + S + w + S + h;
        }
        $(this.canvas, {
            viewBox: vb,
            preserveAspectRatio: aspectRatio
        });
        while (size && top) {
            sw = "stroke-width" in top.attrs ? top.attrs["stroke-width"] : 1;
            top.attr({"stroke-width": sw});
            top._.dirty = 1;
            top._.dirtyT = 1;
            top = top.prev;
        }
        this._viewBox = [x, y, w, h, !!fit];
        return this;
    };
    /*\
     * Paper.renderfix
     [ method ]
     **
     * Fixes the issue of Firefox and IE9 regarding subpixel rendering. If paper is dependant
     * on other elements after reflow it could shift half pixel which cause for lines to lost their crispness.
     * This method fixes the issue.
     **
     Special thanks to Mariusz Nowak (http://www.medikoo.com/) for this method.
     \*/
    R.prototype.renderfix = function () {
        var cnvs = this.canvas,
            s = cnvs.style,
            pos;
        try {
            pos = cnvs.getScreenCTM() || cnvs.createSVGMatrix();
        } catch (e) {
            pos = cnvs.createSVGMatrix();
        }
        var left = -pos.e % 1,
            top = -pos.f % 1;
        if (left || top) {
            if (left) {
                this._left = (this._left + left) % 1;
                s.left = this._left + "px";
            }
            if (top) {
                this._top = (this._top + top) % 1;
                s.top = this._top + "px";
            }
        }
    };
    /*\
     * Paper.clear
     [ method ]
     **
     * Clears the paper, i.e. removes all the elements.
     \*/
    R.prototype.clear = function () {
        R.eve("raphael.clear", this);
        var c = this.canvas;
        while (c.firstChild) {
            c.removeChild(c.firstChild);
        }
        this.bottom = this.top = null;
        (this.desc = $("desc")).appendChild(R._g.doc.createTextNode("Created with Rapha\xebl " + R.version));
        c.appendChild(this.desc);
        c.appendChild(this.defs = $("defs"));
    };
    /*\
     * Paper.remove
     [ method ]
     **
     * Removes the paper from the DOM.
     \*/
    R.prototype.remove = function () {
        eve("raphael.remove", this);
        this.canvas.parentNode && this.canvas.parentNode.removeChild(this.canvas);
        for (var i in this) {
            this[i] = typeof this[i] == "function" ? R._removedFactory(i) : null;
        }
    };
    var setproto = R.st;
    for (var method in elproto) if (elproto[has](method) && !setproto[has](method)) {
        setproto[method] = (function (methodname) {
            return function () {
                var arg = arguments;
                return this.forEach(function (el) {
                    el[methodname].apply(el, arg);
                });
            };
        })(method);
    }
}));

// ┌─────────────────────────────────────────────────────────────────────┐ \\
// │ Raphaël 2.1.4 - JavaScript Vector Library                       │ \\
// ├─────────────────────────────────────────────────────────────────────┤ \\
// │ VML Module                                                          │ \\
// ├─────────────────────────────────────────────────────────────────────┤ \\
// │ Copyright (c) 2008-2011 Dmitry Baranovskiy (http://raphaeljs.com)   │ \\
// │ Copyright (c) 2008-2011 Sencha Labs (http://sencha.com)             │ \\
// │ Licensed under the MIT (http://raphaeljs.com/license.html) license. │ \\
// └─────────────────────────────────────────────────────────────────────┘ \\

(function (glob, factory) {
    if (typeof define === "function" && define.amd) {
        define("raphael.vml", ["raphael.core"], function(raphael) {
            return factory(raphael);
        });
    } else if (typeof exports === "object") {
        factory(require("raphael"));
    } else {
        factory(glob.Raphael);
    }
}(this, function(R) {
    if (R && !R.vml) {
        return;
    }

    var has = "hasOwnProperty",
        Str = String,
        toFloat = parseFloat,
        math = Math,
        round = math.round,
        mmax = math.max,
        mmin = math.min,
        abs = math.abs,
        fillString = "fill",
        separator = /[, ]+/,
        eve = R.eve,
        ms = " progid:DXImageTransform.Microsoft",
        S = " ",
        E = "",
        map = {M: "m", L: "l", C: "c", Z: "x", m: "t", l: "r", c: "v", z: "x"},
        bites = /([clmz]),?([^clmz]*)/gi,
        blurregexp = / progid:\S+Blur\([^\)]+\)/g,
        val = /-?[^,\s-]+/g,
        cssDot = "position:absolute;left:0;top:0;width:1px;height:1px;behavior:url(#default#VML)",
        zoom = 21600,
        pathTypes = {path: 1, rect: 1, image: 1},
        ovalTypes = {circle: 1, ellipse: 1},
        path2vml = function (path) {
            var total =  /[ahqstv]/ig,
                command = R._pathToAbsolute;
            Str(path).match(total) && (command = R._path2curve);
            total = /[clmz]/g;
            if (command == R._pathToAbsolute && !Str(path).match(total)) {
                var res = Str(path).replace(bites, function (all, command, args) {
                    var vals = [],
                        isMove = command.toLowerCase() == "m",
                        res = map[command];
                    args.replace(val, function (value) {
                        if (isMove && vals.length == 2) {
                            res += vals + map[command == "m" ? "l" : "L"];
                            vals = [];
                        }
                        vals.push(round(value * zoom));
                    });
                    return res + vals;
                });
                return res;
            }
            var pa = command(path), p, r;
            res = [];
            for (var i = 0, ii = pa.length; i < ii; i++) {
                p = pa[i];
                r = pa[i][0].toLowerCase();
                r == "z" && (r = "x");
                for (var j = 1, jj = p.length; j < jj; j++) {
                    r += round(p[j] * zoom) + (j != jj - 1 ? "," : E);
                }
                res.push(r);
            }
            return res.join(S);
        },
        compensation = function (deg, dx, dy) {
            var m = R.matrix();
            m.rotate(-deg, .5, .5);
            return {
                dx: m.x(dx, dy),
                dy: m.y(dx, dy)
            };
        },
        setCoords = function (p, sx, sy, dx, dy, deg) {
            var _ = p._,
                m = p.matrix,
                fillpos = _.fillpos,
                o = p.node,
                s = o.style,
                y = 1,
                flip = "",
                dxdy,
                kx = zoom / sx,
                ky = zoom / sy;
            s.visibility = "hidden";
            if (!sx || !sy) {
                return;
            }
            o.coordsize = abs(kx) + S + abs(ky);
            s.rotation = deg * (sx * sy < 0 ? -1 : 1);
            if (deg) {
                var c = compensation(deg, dx, dy);
                dx = c.dx;
                dy = c.dy;
            }
            sx < 0 && (flip += "x");
            sy < 0 && (flip += " y") && (y = -1);
            s.flip = flip;
            o.coordorigin = (dx * -kx) + S + (dy * -ky);
            if (fillpos || _.fillsize) {
                var fill = o.getElementsByTagName(fillString);
                fill = fill && fill[0];
                o.removeChild(fill);
                if (fillpos) {
                    c = compensation(deg, m.x(fillpos[0], fillpos[1]), m.y(fillpos[0], fillpos[1]));
                    fill.position = c.dx * y + S + c.dy * y;
                }
                if (_.fillsize) {
                    fill.size = _.fillsize[0] * abs(sx) + S + _.fillsize[1] * abs(sy);
                }
                o.appendChild(fill);
            }
            s.visibility = "visible";
        };
    R.toString = function () {
        return  "Your browser doesn\u2019t support SVG. Falling down to VML.\nYou are running Rapha\xebl " + this.version;
    };
    var addArrow = function (o, value, isEnd) {
            var values = Str(value).toLowerCase().split("-"),
                se = isEnd ? "end" : "start",
                i = values.length,
                type = "classic",
                w = "medium",
                h = "medium";
            while (i--) {
                switch (values[i]) {
                    case "block":
                    case "classic":
                    case "oval":
                    case "diamond":
                    case "open":
                    case "none":
                        type = values[i];
                        break;
                    case "wide":
                    case "narrow": h = values[i]; break;
                    case "long":
                    case "short": w = values[i]; break;
                }
            }
            var stroke = o.node.getElementsByTagName("stroke")[0];
            stroke[se + "arrow"] = type;
            stroke[se + "arrowlength"] = w;
            stroke[se + "arrowwidth"] = h;
        },
        setFillAndStroke = function (o, params) {
            // o.paper.canvas.style.display = "none";
            o.attrs = o.attrs || {};
            var node = o.node,
                a = o.attrs,
                s = node.style,
                xy,
                newpath = pathTypes[o.type] && (params.x != a.x || params.y != a.y || params.width != a.width || params.height != a.height || params.cx != a.cx || params.cy != a.cy || params.rx != a.rx || params.ry != a.ry || params.r != a.r),
                isOval = ovalTypes[o.type] && (a.cx != params.cx || a.cy != params.cy || a.r != params.r || a.rx != params.rx || a.ry != params.ry),
                res = o;


            for (var par in params) if (params[has](par)) {
                a[par] = params[par];
            }
            if (newpath) {
                a.path = R._getPath[o.type](o);
                o._.dirty = 1;
            }
            params.href && (node.href = params.href);
            params.title && (node.title = params.title);
            params.target && (node.target = params.target);
            params.cursor && (s.cursor = params.cursor);
            "blur" in params && o.blur(params.blur);
            if (params.path && o.type == "path" || newpath) {
                node.path = path2vml(~Str(a.path).toLowerCase().indexOf("r") ? R._pathToAbsolute(a.path) : a.path);
                o._.dirty = 1;
                if (o.type == "image") {
                    o._.fillpos = [a.x, a.y];
                    o._.fillsize = [a.width, a.height];
                    setCoords(o, 1, 1, 0, 0, 0);
                }
            }
            "transform" in params && o.transform(params.transform);
            if (isOval) {
                var cx = +a.cx,
                    cy = +a.cy,
                    rx = +a.rx || +a.r || 0,
                    ry = +a.ry || +a.r || 0;
                node.path = R.format("ar{0},{1},{2},{3},{4},{1},{4},{1}x", round((cx - rx) * zoom), round((cy - ry) * zoom), round((cx + rx) * zoom), round((cy + ry) * zoom), round(cx * zoom));
                o._.dirty = 1;
            }
            if ("clip-rect" in params) {
                var rect = Str(params["clip-rect"]).split(separator);
                if (rect.length == 4) {
                    rect[2] = +rect[2] + (+rect[0]);
                    rect[3] = +rect[3] + (+rect[1]);
                    var div = node.clipRect || R._g.doc.createElement("div"),
                        dstyle = div.style;
                    dstyle.clip = R.format("rect({1}px {2}px {3}px {0}px)", rect);
                    if (!node.clipRect) {
                        dstyle.position = "absolute";
                        dstyle.top = 0;
                        dstyle.left = 0;
                        dstyle.width = o.paper.width + "px";
                        dstyle.height = o.paper.height + "px";
                        node.parentNode.insertBefore(div, node);
                        div.appendChild(node);
                        node.clipRect = div;
                    }
                }
                if (!params["clip-rect"]) {
                    node.clipRect && (node.clipRect.style.clip = "auto");
                }
            }
            if (o.textpath) {
                var textpathStyle = o.textpath.style;
                params.font && (textpathStyle.font = params.font);
                params["font-family"] && (textpathStyle.fontFamily = '"' + params["font-family"].split(",")[0].replace(/^['"]+|['"]+$/g, E) + '"');
                params["font-size"] && (textpathStyle.fontSize = params["font-size"]);
                params["font-weight"] && (textpathStyle.fontWeight = params["font-weight"]);
                params["font-style"] && (textpathStyle.fontStyle = params["font-style"]);
            }
            if ("arrow-start" in params) {
                addArrow(res, params["arrow-start"]);
            }
            if ("arrow-end" in params) {
                addArrow(res, params["arrow-end"], 1);
            }
            if (params.opacity != null ||
                params["stroke-width"] != null ||
                params.fill != null ||
                params.src != null ||
                params.stroke != null ||
                params["stroke-width"] != null ||
                params["stroke-opacity"] != null ||
                params["fill-opacity"] != null ||
                params["stroke-dasharray"] != null ||
                params["stroke-miterlimit"] != null ||
                params["stroke-linejoin"] != null ||
                params["stroke-linecap"] != null) {
                var fill = node.getElementsByTagName(fillString),
                    newfill = false;
                fill = fill && fill[0];
                !fill && (newfill = fill = createNode(fillString));
                if (o.type == "image" && params.src) {
                    fill.src = params.src;
                }
                params.fill && (fill.on = true);
                if (fill.on == null || params.fill == "none" || params.fill === null) {
                    fill.on = false;
                }
                if (fill.on && params.fill) {
                    var isURL = Str(params.fill).match(R._ISURL);
                    if (isURL) {
                        fill.parentNode == node && node.removeChild(fill);
                        fill.rotate = true;
                        fill.src = isURL[1];
                        fill.type = "tile";
                        var bbox = o.getBBox(1);
                        fill.position = bbox.x + S + bbox.y;
                        o._.fillpos = [bbox.x, bbox.y];

                        R._preload(isURL[1], function () {
                            o._.fillsize = [this.offsetWidth, this.offsetHeight];
                        });
                    } else {
                        fill.color = R.getRGB(params.fill).hex;
                        fill.src = E;
                        fill.type = "solid";
                        if (R.getRGB(params.fill).error && (res.type in {circle: 1, ellipse: 1} || Str(params.fill).charAt() != "r") && addGradientFill(res, params.fill, fill)) {
                            a.fill = "none";
                            a.gradient = params.fill;
                            fill.rotate = false;
                        }
                    }
                }
                if ("fill-opacity" in params || "opacity" in params) {
                    var opacity = ((+a["fill-opacity"] + 1 || 2) - 1) * ((+a.opacity + 1 || 2) - 1) * ((+R.getRGB(params.fill).o + 1 || 2) - 1);
                    opacity = mmin(mmax(opacity, 0), 1);
                    fill.opacity = opacity;
                    if (fill.src) {
                        fill.color = "none";
                    }
                }
                node.appendChild(fill);
                var stroke = (node.getElementsByTagName("stroke") && node.getElementsByTagName("stroke")[0]),
                    newstroke = false;
                !stroke && (newstroke = stroke = createNode("stroke"));
                if ((params.stroke && params.stroke != "none") ||
                    params["stroke-width"] ||
                    params["stroke-opacity"] != null ||
                    params["stroke-dasharray"] ||
                    params["stroke-miterlimit"] ||
                    params["stroke-linejoin"] ||
                    params["stroke-linecap"]) {
                    stroke.on = true;
                }
                (params.stroke == "none" || params.stroke === null || stroke.on == null || params.stroke == 0 || params["stroke-width"] == 0) && (stroke.on = false);
                var strokeColor = R.getRGB(params.stroke);
                stroke.on && params.stroke && (stroke.color = strokeColor.hex);
                opacity = ((+a["stroke-opacity"] + 1 || 2) - 1) * ((+a.opacity + 1 || 2) - 1) * ((+strokeColor.o + 1 || 2) - 1);
                var width = (toFloat(params["stroke-width"]) || 1) * .75;
                opacity = mmin(mmax(opacity, 0), 1);
                params["stroke-width"] == null && (width = a["stroke-width"]);
                params["stroke-width"] && (stroke.weight = width);
                width && width < 1 && (opacity *= width) && (stroke.weight = 1);
                stroke.opacity = opacity;

                params["stroke-linejoin"] && (stroke.joinstyle = params["stroke-linejoin"] || "miter");
                stroke.miterlimit = params["stroke-miterlimit"] || 8;
                params["stroke-linecap"] && (stroke.endcap = params["stroke-linecap"] == "butt" ? "flat" : params["stroke-linecap"] == "square" ? "square" : "round");
                if ("stroke-dasharray" in params) {
                    var dasharray = {
                        "-": "shortdash",
                        ".": "shortdot",
                        "-.": "shortdashdot",
                        "-..": "shortdashdotdot",
                        ". ": "dot",
                        "- ": "dash",
                        "--": "longdash",
                        "- .": "dashdot",
                        "--.": "longdashdot",
                        "--..": "longdashdotdot"
                    };
                    stroke.dashstyle = dasharray[has](params["stroke-dasharray"]) ? dasharray[params["stroke-dasharray"]] : E;
                }
                newstroke && node.appendChild(stroke);
            }
            if (res.type == "text") {
                res.paper.canvas.style.display = E;
                var span = res.paper.span,
                    m = 100,
                    fontSize = a.font && a.font.match(/\d+(?:\.\d*)?(?=px)/);
                s = span.style;
                a.font && (s.font = a.font);
                a["font-family"] && (s.fontFamily = a["font-family"]);
                a["font-weight"] && (s.fontWeight = a["font-weight"]);
                a["font-style"] && (s.fontStyle = a["font-style"]);
                fontSize = toFloat(a["font-size"] || fontSize && fontSize[0]) || 10;
                s.fontSize = fontSize * m + "px";
                res.textpath.string && (span.innerHTML = Str(res.textpath.string).replace(/</g, "&#60;").replace(/&/g, "&#38;").replace(/\n/g, "<br>"));
                var brect = span.getBoundingClientRect();
                res.W = a.w = (brect.right - brect.left) / m;
                res.H = a.h = (brect.bottom - brect.top) / m;
                // res.paper.canvas.style.display = "none";
                res.X = a.x;
                res.Y = a.y + res.H / 2;

                ("x" in params || "y" in params) && (res.path.v = R.format("m{0},{1}l{2},{1}", round(a.x * zoom), round(a.y * zoom), round(a.x * zoom) + 1));
                var dirtyattrs = ["x", "y", "text", "font", "font-family", "font-weight", "font-style", "font-size"];
                for (var d = 0, dd = dirtyattrs.length; d < dd; d++) if (dirtyattrs[d] in params) {
                    res._.dirty = 1;
                    break;
                }

                // text-anchor emulation
                switch (a["text-anchor"]) {
                    case "start":
                        res.textpath.style["v-text-align"] = "left";
                        res.bbx = res.W / 2;
                        break;
                    case "end":
                        res.textpath.style["v-text-align"] = "right";
                        res.bbx = -res.W / 2;
                        break;
                    default:
                        res.textpath.style["v-text-align"] = "center";
                        res.bbx = 0;
                        break;
                }
                res.textpath.style["v-text-kern"] = true;
            }
            // res.paper.canvas.style.display = E;
        },
        addGradientFill = function (o, gradient, fill) {
            o.attrs = o.attrs || {};
            var attrs = o.attrs,
                pow = Math.pow,
                opacity,
                oindex,
                type = "linear",
                fxfy = ".5 .5";
            o.attrs.gradient = gradient;
            gradient = Str(gradient).replace(R._radial_gradient, function (all, fx, fy) {
                type = "radial";
                if (fx && fy) {
                    fx = toFloat(fx);
                    fy = toFloat(fy);
                    pow(fx - .5, 2) + pow(fy - .5, 2) > .25 && (fy = math.sqrt(.25 - pow(fx - .5, 2)) * ((fy > .5) * 2 - 1) + .5);
                    fxfy = fx + S + fy;
                }
                return E;
            });
            gradient = gradient.split(/\s*\-\s*/);
            if (type == "linear") {
                var angle = gradient.shift();
                angle = -toFloat(angle);
                if (isNaN(angle)) {
                    return null;
                }
            }
            var dots = R._parseDots(gradient);
            if (!dots) {
                return null;
            }
            o = o.shape || o.node;
            if (dots.length) {
                o.removeChild(fill);
                fill.on = true;
                fill.method = "none";
                fill.color = dots[0].color;
                fill.color2 = dots[dots.length - 1].color;
                var clrs = [];
                for (var i = 0, ii = dots.length; i < ii; i++) {
                    dots[i].offset && clrs.push(dots[i].offset + S + dots[i].color);
                }
                fill.colors = clrs.length ? clrs.join() : "0% " + fill.color;
                if (type == "radial") {
                    fill.type = "gradientTitle";
                    fill.focus = "100%";
                    fill.focussize = "0 0";
                    fill.focusposition = fxfy;
                    fill.angle = 0;
                } else {
                    // fill.rotate= true;
                    fill.type = "gradient";
                    fill.angle = (270 - angle) % 360;
                }
                o.appendChild(fill);
            }
            return 1;
        },
        Element = function (node, vml) {
            this[0] = this.node = node;
            node.raphael = true;
            this.id = R._oid++;
            node.raphaelid = this.id;
            this.X = 0;
            this.Y = 0;
            this.attrs = {};
            this.paper = vml;
            this.matrix = R.matrix();
            this._ = {
                transform: [],
                sx: 1,
                sy: 1,
                dx: 0,
                dy: 0,
                deg: 0,
                dirty: 1,
                dirtyT: 1
            };
            !vml.bottom && (vml.bottom = this);
            this.prev = vml.top;
            vml.top && (vml.top.next = this);
            vml.top = this;
            this.next = null;
        };
    var elproto = R.el;

    Element.prototype = elproto;
    elproto.constructor = Element;
    elproto.transform = function (tstr) {
        if (tstr == null) {
            return this._.transform;
        }
        var vbs = this.paper._viewBoxShift,
            vbt = vbs ? "s" + [vbs.scale, vbs.scale] + "-1-1t" + [vbs.dx, vbs.dy] : E,
            oldt;
        if (vbs) {
            oldt = tstr = Str(tstr).replace(/\.{3}|\u2026/g, this._.transform || E);
        }
        R._extractTransform(this, vbt + tstr);
        var matrix = this.matrix.clone(),
            skew = this.skew,
            o = this.node,
            split,
            isGrad = ~Str(this.attrs.fill).indexOf("-"),
            isPatt = !Str(this.attrs.fill).indexOf("url(");
        matrix.translate(1, 1);
        if (isPatt || isGrad || this.type == "image") {
            skew.matrix = "1 0 0 1";
            skew.offset = "0 0";
            split = matrix.split();
            if ((isGrad && split.noRotation) || !split.isSimple) {
                o.style.filter = matrix.toFilter();
                var bb = this.getBBox(),
                    bbt = this.getBBox(1),
                    dx = bb.x - bbt.x,
                    dy = bb.y - bbt.y;
                o.coordorigin = (dx * -zoom) + S + (dy * -zoom);
                setCoords(this, 1, 1, dx, dy, 0);
            } else {
                o.style.filter = E;
                setCoords(this, split.scalex, split.scaley, split.dx, split.dy, split.rotate);
            }
        } else {
            o.style.filter = E;
            skew.matrix = Str(matrix);
            skew.offset = matrix.offset();
        }
        if (oldt !== null) { // empty string value is true as well
            this._.transform = oldt;
            R._extractTransform(this, oldt);
        }
        return this;
    };
    elproto.rotate = function (deg, cx, cy) {
        if (this.removed) {
            return this;
        }
        if (deg == null) {
            return;
        }
        deg = Str(deg).split(separator);
        if (deg.length - 1) {
            cx = toFloat(deg[1]);
            cy = toFloat(deg[2]);
        }
        deg = toFloat(deg[0]);
        (cy == null) && (cx = cy);
        if (cx == null || cy == null) {
            var bbox = this.getBBox(1);
            cx = bbox.x + bbox.width / 2;
            cy = bbox.y + bbox.height / 2;
        }
        this._.dirtyT = 1;
        this.transform(this._.transform.concat([["r", deg, cx, cy]]));
        return this;
    };
    elproto.translate = function (dx, dy) {
        if (this.removed) {
            return this;
        }
        dx = Str(dx).split(separator);
        if (dx.length - 1) {
            dy = toFloat(dx[1]);
        }
        dx = toFloat(dx[0]) || 0;
        dy = +dy || 0;
        if (this._.bbox) {
            this._.bbox.x += dx;
            this._.bbox.y += dy;
        }
        this.transform(this._.transform.concat([["t", dx, dy]]));
        return this;
    };
    elproto.scale = function (sx, sy, cx, cy) {
        if (this.removed) {
            return this;
        }
        sx = Str(sx).split(separator);
        if (sx.length - 1) {
            sy = toFloat(sx[1]);
            cx = toFloat(sx[2]);
            cy = toFloat(sx[3]);
            isNaN(cx) && (cx = null);
            isNaN(cy) && (cy = null);
        }
        sx = toFloat(sx[0]);
        (sy == null) && (sy = sx);
        (cy == null) && (cx = cy);
        if (cx == null || cy == null) {
            var bbox = this.getBBox(1);
        }
        cx = cx == null ? bbox.x + bbox.width / 2 : cx;
        cy = cy == null ? bbox.y + bbox.height / 2 : cy;

        this.transform(this._.transform.concat([["s", sx, sy, cx, cy]]));
        this._.dirtyT = 1;
        return this;
    };
    elproto.hide = function () {
        !this.removed && (this.node.style.display = "none");
        return this;
    };
    elproto.show = function () {
        !this.removed && (this.node.style.display = E);
        return this;
    };
    // Needed to fix the vml setViewBox issues
    elproto.auxGetBBox = R.el.getBBox;
    elproto.getBBox = function(){
        var b = this.auxGetBBox();
        if (this.paper && this.paper._viewBoxShift)
        {
            var c = {};
            var z = 1/this.paper._viewBoxShift.scale;
            c.x = b.x - this.paper._viewBoxShift.dx;
            c.x *= z;
            c.y = b.y - this.paper._viewBoxShift.dy;
            c.y *= z;
            c.width  = b.width  * z;
            c.height = b.height * z;
            c.x2 = c.x + c.width;
            c.y2 = c.y + c.height;
            return c;
        }
        return b;
    };
    elproto._getBBox = function () {
        if (this.removed) {
            return {};
        }
        return {
            x: this.X + (this.bbx || 0) - this.W / 2,
            y: this.Y - this.H,
            width: this.W,
            height: this.H
        };
    };
    elproto.remove = function () {
        if (this.removed || !this.node.parentNode) {
            return;
        }
        this.paper.__set__ && this.paper.__set__.exclude(this);
        R.eve.unbind("raphael.*.*." + this.id);
        R._tear(this, this.paper);
        this.node.parentNode.removeChild(this.node);
        this.shape && this.shape.parentNode.removeChild(this.shape);
        for (var i in this) {
            this[i] = typeof this[i] == "function" ? R._removedFactory(i) : null;
        }
        this.removed = true;
    };
    elproto.attr = function (name, value) {
        if (this.removed) {
            return this;
        }
        if (name == null) {
            var res = {};
            for (var a in this.attrs) if (this.attrs[has](a)) {
                res[a] = this.attrs[a];
            }
            res.gradient && res.fill == "none" && (res.fill = res.gradient) && delete res.gradient;
            res.transform = this._.transform;
            return res;
        }
        if (value == null && R.is(name, "string")) {
            if (name == fillString && this.attrs.fill == "none" && this.attrs.gradient) {
                return this.attrs.gradient;
            }
            var names = name.split(separator),
                out = {};
            for (var i = 0, ii = names.length; i < ii; i++) {
                name = names[i];
                if (name in this.attrs) {
                    out[name] = this.attrs[name];
                } else if (R.is(this.paper.customAttributes[name], "function")) {
                    out[name] = this.paper.customAttributes[name].def;
                } else {
                    out[name] = R._availableAttrs[name];
                }
            }
            return ii - 1 ? out : out[names[0]];
        }
        if (this.attrs && value == null && R.is(name, "array")) {
            out = {};
            for (i = 0, ii = name.length; i < ii; i++) {
                out[name[i]] = this.attr(name[i]);
            }
            return out;
        }
        var params;
        if (value != null) {
            params = {};
            params[name] = value;
        }
        value == null && R.is(name, "object") && (params = name);
        for (var key in params) {
            eve("raphael.attr." + key + "." + this.id, this, params[key]);
        }
        if (params) {
            for (key in this.paper.customAttributes) if (this.paper.customAttributes[has](key) && params[has](key) && R.is(this.paper.customAttributes[key], "function")) {
                var par = this.paper.customAttributes[key].apply(this, [].concat(params[key]));
                this.attrs[key] = params[key];
                for (var subkey in par) if (par[has](subkey)) {
                    params[subkey] = par[subkey];
                }
            }
            // this.paper.canvas.style.display = "none";
            if (params.text && this.type == "text") {
                this.textpath.string = params.text;
            }
            setFillAndStroke(this, params);
            // this.paper.canvas.style.display = E;
        }
        return this;
    };
    elproto.toFront = function () {
        !this.removed && this.node.parentNode.appendChild(this.node);
        this.paper && this.paper.top != this && R._tofront(this, this.paper);
        return this;
    };
    elproto.toBack = function () {
        if (this.removed) {
            return this;
        }
        if (this.node.parentNode.firstChild != this.node) {
            this.node.parentNode.insertBefore(this.node, this.node.parentNode.firstChild);
            R._toback(this, this.paper);
        }
        return this;
    };
    elproto.insertAfter = function (element) {
        if (this.removed) {
            return this;
        }
        if (element.constructor == R.st.constructor) {
            element = element[element.length - 1];
        }
        if (element.node.nextSibling) {
            element.node.parentNode.insertBefore(this.node, element.node.nextSibling);
        } else {
            element.node.parentNode.appendChild(this.node);
        }
        R._insertafter(this, element, this.paper);
        return this;
    };
    elproto.insertBefore = function (element) {
        if (this.removed) {
            return this;
        }
        if (element.constructor == R.st.constructor) {
            element = element[0];
        }
        element.node.parentNode.insertBefore(this.node, element.node);
        R._insertbefore(this, element, this.paper);
        return this;
    };
    elproto.blur = function (size) {
        var s = this.node.runtimeStyle,
            f = s.filter;
        f = f.replace(blurregexp, E);
        if (+size !== 0) {
            this.attrs.blur = size;
            s.filter = f + S + ms + ".Blur(pixelradius=" + (+size || 1.5) + ")";
            s.margin = R.format("-{0}px 0 0 -{0}px", round(+size || 1.5));
        } else {
            s.filter = f;
            s.margin = 0;
            delete this.attrs.blur;
        }
        return this;
    };

    R._engine.path = function (pathString, vml) {
        var el = createNode("shape");
        el.style.cssText = cssDot;
        el.coordsize = zoom + S + zoom;
        el.coordorigin = vml.coordorigin;
        var p = new Element(el, vml),
            attr = {fill: "none", stroke: "#000"};
        pathString && (attr.path = pathString);
        p.type = "path";
        p.path = [];
        p.Path = E;
        setFillAndStroke(p, attr);
        vml.canvas.appendChild(el);
        var skew = createNode("skew");
        skew.on = true;
        el.appendChild(skew);
        p.skew = skew;
        p.transform(E);
        return p;
    };
    R._engine.rect = function (vml, x, y, w, h, r) {
        var path = R._rectPath(x, y, w, h, r),
            res = vml.path(path),
            a = res.attrs;
        res.X = a.x = x;
        res.Y = a.y = y;
        res.W = a.width = w;
        res.H = a.height = h;
        a.r = r;
        a.path = path;
        res.type = "rect";
        return res;
    };
    R._engine.ellipse = function (vml, x, y, rx, ry) {
        var res = vml.path(),
            a = res.attrs;
        res.X = x - rx;
        res.Y = y - ry;
        res.W = rx * 2;
        res.H = ry * 2;
        res.type = "ellipse";
        setFillAndStroke(res, {
            cx: x,
            cy: y,
            rx: rx,
            ry: ry
        });
        return res;
    };
    R._engine.circle = function (vml, x, y, r) {
        var res = vml.path(),
            a = res.attrs;
        res.X = x - r;
        res.Y = y - r;
        res.W = res.H = r * 2;
        res.type = "circle";
        setFillAndStroke(res, {
            cx: x,
            cy: y,
            r: r
        });
        return res;
    };
    R._engine.image = function (vml, src, x, y, w, h) {
        var path = R._rectPath(x, y, w, h),
            res = vml.path(path).attr({stroke: "none"}),
            a = res.attrs,
            node = res.node,
            fill = node.getElementsByTagName(fillString)[0];
        a.src = src;
        res.X = a.x = x;
        res.Y = a.y = y;
        res.W = a.width = w;
        res.H = a.height = h;
        a.path = path;
        res.type = "image";
        fill.parentNode == node && node.removeChild(fill);
        fill.rotate = true;
        fill.src = src;
        fill.type = "tile";
        res._.fillpos = [x, y];
        res._.fillsize = [w, h];
        node.appendChild(fill);
        setCoords(res, 1, 1, 0, 0, 0);
        return res;
    };
    R._engine.text = function (vml, x, y, text) {
        var el = createNode("shape"),
            path = createNode("path"),
            o = createNode("textpath");
        x = x || 0;
        y = y || 0;
        text = text || "";
        path.v = R.format("m{0},{1}l{2},{1}", round(x * zoom), round(y * zoom), round(x * zoom) + 1);
        path.textpathok = true;
        o.string = Str(text);
        o.on = true;
        el.style.cssText = cssDot;
        el.coordsize = zoom + S + zoom;
        el.coordorigin = "0 0";
        var p = new Element(el, vml),
            attr = {
                fill: "#000",
                stroke: "none",
                font: R._availableAttrs.font,
                text: text
            };
        p.shape = el;
        p.path = path;
        p.textpath = o;
        p.type = "text";
        p.attrs.text = Str(text);
        p.attrs.x = x;
        p.attrs.y = y;
        p.attrs.w = 1;
        p.attrs.h = 1;
        setFillAndStroke(p, attr);
        el.appendChild(o);
        el.appendChild(path);
        vml.canvas.appendChild(el);
        var skew = createNode("skew");
        skew.on = true;
        el.appendChild(skew);
        p.skew = skew;
        p.transform(E);
        return p;
    };
    R._engine.setSize = function (width, height) {
        var cs = this.canvas.style;
        this.width = width;
        this.height = height;
        width == +width && (width += "px");
        height == +height && (height += "px");
        cs.width = width;
        cs.height = height;
        cs.clip = "rect(0 " + width + " " + height + " 0)";
        if (this._viewBox) {
            R._engine.setViewBox.apply(this, this._viewBox);
        }
        return this;
    };
    R._engine.setViewBox = function (x, y, w, h, fit) {
        R.eve("raphael.setViewBox", this, this._viewBox, [x, y, w, h, fit]);
        var paperSize = this.getSize(),
            width = paperSize.width,
            height = paperSize.height,
            H, W;
        if (fit) {
            H = height / h;
            W = width / w;
            if (w * H < width) {
                x -= (width - w * H) / 2 / H;
            }
            if (h * W < height) {
                y -= (height - h * W) / 2 / W;
            }
        }
        this._viewBox = [x, y, w, h, !!fit];
        this._viewBoxShift = {
            dx: -x,
            dy: -y,
            scale: paperSize
        };
        this.forEach(function (el) {
            el.transform("...");
        });
        return this;
    };
    var createNode;
    R._engine.initWin = function (win) {
        var doc = win.document;
        if (doc.styleSheets.length < 31) {
            doc.createStyleSheet().addRule(".rvml", "behavior:url(#default#VML)");
        } else {
            // no more room, add to the existing one
            // http://msdn.microsoft.com/en-us/library/ms531194%28VS.85%29.aspx
            doc.styleSheets[0].addRule(".rvml", "behavior:url(#default#VML)");
        }
        try {
            !doc.namespaces.rvml && doc.namespaces.add("rvml", "urn:schemas-microsoft-com:vml");
            createNode = function (tagName) {
                return doc.createElement('<rvml:' + tagName + ' class="rvml">');
            };
        } catch (e) {
            createNode = function (tagName) {
                return doc.createElement('<' + tagName + ' xmlns="urn:schemas-microsoft.com:vml" class="rvml">');
            };
        }
    };
    R._engine.initWin(R._g.win);
    R._engine.create = function () {
        var con = R._getContainer.apply(0, arguments),
            container = con.container,
            height = con.height,
            s,
            width = con.width,
            x = con.x,
            y = con.y;
        if (!container) {
            throw new Error("VML container not found.");
        }
        var res = new R._Paper,
            c = res.canvas = R._g.doc.createElement("div"),
            cs = c.style;
        x = x || 0;
        y = y || 0;
        width = width || 512;
        height = height || 342;
        res.width = width;
        res.height = height;
        width == +width && (width += "px");
        height == +height && (height += "px");
        res.coordsize = zoom * 1e3 + S + zoom * 1e3;
        res.coordorigin = "0 0";
        res.span = R._g.doc.createElement("span");
        res.span.style.cssText = "position:absolute;left:-9999em;top:-9999em;padding:0;margin:0;line-height:1;";
        c.appendChild(res.span);
        cs.cssText = R.format("top:0;left:0;width:{0};height:{1};display:inline-block;position:relative;clip:rect(0 {0} {1} 0);overflow:hidden", width, height);
        if (container == 1) {
            R._g.doc.body.appendChild(c);
            cs.left = x + "px";
            cs.top = y + "px";
            cs.position = "absolute";
        } else {
            if (container.firstChild) {
                container.insertBefore(c, container.firstChild);
            } else {
                container.appendChild(c);
            }
        }
        res.renderfix = function () {};
        return res;
    };
    R.prototype.clear = function () {
        R.eve("raphael.clear", this);
        this.canvas.innerHTML = E;
        this.span = R._g.doc.createElement("span");
        this.span.style.cssText = "position:absolute;left:-9999em;top:-9999em;padding:0;margin:0;line-height:1;display:inline;";
        this.canvas.appendChild(this.span);
        this.bottom = this.top = null;
    };
    R.prototype.remove = function () {
        R.eve("raphael.remove", this);
        this.canvas.parentNode.removeChild(this.canvas);
        for (var i in this) {
            this[i] = typeof this[i] == "function" ? R._removedFactory(i) : null;
        }
        return true;
    };

    var setproto = R.st;
    for (var method in elproto) if (elproto[has](method) && !setproto[has](method)) {
        setproto[method] = (function (methodname) {
            return function () {
                var arg = arguments;
                return this.forEach(function (el) {
                    el[methodname].apply(el, arg);
                });
            };
        })(method);
    }
}));

// ┌────────────────────────────────────────────────────────────────────┐ \\
// │ Raphaël 2.1.4 - JavaScript Vector Library                      │ \\
// ├────────────────────────────────────────────────────────────────────┤ \\
// │ Copyright © 2008-2012 Dmitry Baranovskiy (http://raphaeljs.com)    │ \\
// │ Copyright © 2008-2012 Sencha Labs (http://sencha.com)              │ \\
// ├────────────────────────────────────────────────────────────────────┤ \\
// │ Licensed under the MIT (http://raphaeljs.com/license.html) license.│ \\
// └────────────────────────────────────────────────────────────────────┘ \\

(function (glob, factory) {
    if (typeof define === "function" && define.amd) {
        define("raphael", ["raphael.core", "raphael.svg", "raphael.vml"], function(Raphael) {
            return factory(Raphael);
        });
    } else if (typeof exports === "object") {
        var raphael = require("raphael.core");

        require("raphael.svg");
        require("raphael.vml");

        module.exports = factory(raphael);
    } else {
        //glob.Raphael = factory(glob.Raphael);
    }
}(this, function (Raphael) {
    return Raphael.ninja();
}));

!function() {
    var d3 = {
        version: "3.5.5"
    };
    var d3_arraySlice = [].slice, d3_array = function(list) {
        return d3_arraySlice.call(list);
    };
    var d3_document = this.document;
    function d3_documentElement(node) {
        return node && (node.ownerDocument || node.document || node).documentElement;
    }
    function d3_window(node) {
        return node && (node.ownerDocument && node.ownerDocument.defaultView || node.document && node || node.defaultView);
    }
    if (d3_document) {
        try {
            d3_array(d3_document.documentElement.childNodes)[0].nodeType;
        } catch (e) {
            d3_array = function(list) {
                var i = list.length, array = new Array(i);
                while (i--) array[i] = list[i];
                return array;
            };
        }
    }
    if (!Date.now) Date.now = function() {
        return +new Date();
    };
    if (d3_document) {
        try {
            d3_document.createElement("DIV").style.setProperty("opacity", 0, "");
        } catch (error) {
            var d3_element_prototype = this.Element.prototype, d3_element_setAttribute = d3_element_prototype.setAttribute, d3_element_setAttributeNS = d3_element_prototype.setAttributeNS, d3_style_prototype = this.CSSStyleDeclaration.prototype, d3_style_setProperty = d3_style_prototype.setProperty;
            d3_element_prototype.setAttribute = function(name, value) {
                d3_element_setAttribute.call(this, name, value + "");
            };
            d3_element_prototype.setAttributeNS = function(space, local, value) {
                d3_element_setAttributeNS.call(this, space, local, value + "");
            };
            d3_style_prototype.setProperty = function(name, value, priority) {
                d3_style_setProperty.call(this, name, value + "", priority);
            };
        }
    }
    d3.ascending = d3_ascending;
    function d3_ascending(a, b) {
        return a < b ? -1 : a > b ? 1 : a >= b ? 0 : NaN;
    }
    d3.descending = function(a, b) {
        return b < a ? -1 : b > a ? 1 : b >= a ? 0 : NaN;
    };
    d3.min = function(array, f) {
        var i = -1, n = array.length, a, b;
        if (arguments.length === 1) {
            while (++i < n) if ((b = array[i]) != null && b >= b) {
                a = b;
                break;
            }
            while (++i < n) if ((b = array[i]) != null && a > b) a = b;
        } else {
            while (++i < n) if ((b = f.call(array, array[i], i)) != null && b >= b) {
                a = b;
                break;
            }
            while (++i < n) if ((b = f.call(array, array[i], i)) != null && a > b) a = b;
        }
        return a;
    };
    d3.max = function(array, f) {
        var i = -1, n = array.length, a, b;
        if (arguments.length === 1) {
            while (++i < n) if ((b = array[i]) != null && b >= b) {
                a = b;
                break;
            }
            while (++i < n) if ((b = array[i]) != null && b > a) a = b;
        } else {
            while (++i < n) if ((b = f.call(array, array[i], i)) != null && b >= b) {
                a = b;
                break;
            }
            while (++i < n) if ((b = f.call(array, array[i], i)) != null && b > a) a = b;
        }
        return a;
    };
    d3.extent = function(array, f) {
        var i = -1, n = array.length, a, b, c;
        if (arguments.length === 1) {
            while (++i < n) if ((b = array[i]) != null && b >= b) {
                a = c = b;
                break;
            }
            while (++i < n) if ((b = array[i]) != null) {
                if (a > b) a = b;
                if (c < b) c = b;
            }
        } else {
            while (++i < n) if ((b = f.call(array, array[i], i)) != null && b >= b) {
                a = c = b;
                break;
            }
            while (++i < n) if ((b = f.call(array, array[i], i)) != null) {
                if (a > b) a = b;
                if (c < b) c = b;
            }
        }
        return [ a, c ];
    };
    function d3_number(x) {
        return x === null ? NaN : +x;
    }
    function d3_numeric(x) {
        return !isNaN(x);
    }
    d3.sum = function(array, f) {
        var s = 0, n = array.length, a, i = -1;
        if (arguments.length === 1) {
            while (++i < n) if (d3_numeric(a = +array[i])) s += a;
        } else {
            while (++i < n) if (d3_numeric(a = +f.call(array, array[i], i))) s += a;
        }
        return s;
    };
    d3.mean = function(array, f) {
        var s = 0, n = array.length, a, i = -1, j = n;
        if (arguments.length === 1) {
            while (++i < n) if (d3_numeric(a = d3_number(array[i]))) s += a; else --j;
        } else {
            while (++i < n) if (d3_numeric(a = d3_number(f.call(array, array[i], i)))) s += a; else --j;
        }
        if (j) return s / j;
    };
    d3.quantile = function(values, p) {
        var H = (values.length - 1) * p + 1, h = Math.floor(H), v = +values[h - 1], e = H - h;
        return e ? v + e * (values[h] - v) : v;
    };
    d3.median = function(array, f) {
        var numbers = [], n = array.length, a, i = -1;
        if (arguments.length === 1) {
            while (++i < n) if (d3_numeric(a = d3_number(array[i]))) numbers.push(a);
        } else {
            while (++i < n) if (d3_numeric(a = d3_number(f.call(array, array[i], i)))) numbers.push(a);
        }
        if (numbers.length) return d3.quantile(numbers.sort(d3_ascending), .5);
    };
    d3.variance = function(array, f) {
        var n = array.length, m = 0, a, d, s = 0, i = -1, j = 0;
        if (arguments.length === 1) {
            while (++i < n) {
                if (d3_numeric(a = d3_number(array[i]))) {
                    d = a - m;
                    m += d / ++j;
                    s += d * (a - m);
                }
            }
        } else {
            while (++i < n) {
                if (d3_numeric(a = d3_number(f.call(array, array[i], i)))) {
                    d = a - m;
                    m += d / ++j;
                    s += d * (a - m);
                }
            }
        }
        if (j > 1) return s / (j - 1);
    };
    d3.deviation = function() {
        var v = d3.variance.apply(this, arguments);
        return v ? Math.sqrt(v) : v;
    };
    function d3_bisector(compare) {
        return {
            left: function(a, x, lo, hi) {
                if (arguments.length < 3) lo = 0;
                if (arguments.length < 4) hi = a.length;
                while (lo < hi) {
                    var mid = lo + hi >>> 1;
                    if (compare(a[mid], x) < 0) lo = mid + 1; else hi = mid;
                }
                return lo;
            },
            right: function(a, x, lo, hi) {
                if (arguments.length < 3) lo = 0;
                if (arguments.length < 4) hi = a.length;
                while (lo < hi) {
                    var mid = lo + hi >>> 1;
                    if (compare(a[mid], x) > 0) hi = mid; else lo = mid + 1;
                }
                return lo;
            }
        };
    }
    var d3_bisect = d3_bisector(d3_ascending);
    d3.bisectLeft = d3_bisect.left;
    d3.bisect = d3.bisectRight = d3_bisect.right;
    d3.bisector = function(f) {
        return d3_bisector(f.length === 1 ? function(d, x) {
            return d3_ascending(f(d), x);
        } : f);
    };
    d3.shuffle = function(array, i0, i1) {
        if ((m = arguments.length) < 3) {
            i1 = array.length;
            if (m < 2) i0 = 0;
        }
        var m = i1 - i0, t, i;
        while (m) {
            i = Math.random() * m-- | 0;
            t = array[m + i0], array[m + i0] = array[i + i0], array[i + i0] = t;
        }
        return array;
    };
    d3.permute = function(array, indexes) {
        var i = indexes.length, permutes = new Array(i);
        while (i--) permutes[i] = array[indexes[i]];
        return permutes;
    };
    d3.pairs = function(array) {
        var i = 0, n = array.length - 1, p0, p1 = array[0], pairs = new Array(n < 0 ? 0 : n);
        while (i < n) pairs[i] = [ p0 = p1, p1 = array[++i] ];
        return pairs;
    };
    d3.zip = function() {
        if (!(n = arguments.length)) return [];
        for (var i = -1, m = d3.min(arguments, d3_zipLength), zips = new Array(m); ++i < m; ) {
            for (var j = -1, n, zip = zips[i] = new Array(n); ++j < n; ) {
                zip[j] = arguments[j][i];
            }
        }
        return zips;
    };
    function d3_zipLength(d) {
        return d.length;
    }
    d3.transpose = function(matrix) {
        return d3.zip.apply(d3, matrix);
    };
    d3.keys = function(map) {
        var keys = [];
        for (var key in map) keys.push(key);
        return keys;
    };
    d3.values = function(map) {
        var values = [];
        for (var key in map) values.push(map[key]);
        return values;
    };
    d3.entries = function(map) {
        var entries = [];
        for (var key in map) entries.push({
            key: key,
            value: map[key]
        });
        return entries;
    };
    d3.merge = function(arrays) {
        var n = arrays.length, m, i = -1, j = 0, merged, array;
        while (++i < n) j += arrays[i].length;
        merged = new Array(j);
        while (--n >= 0) {
            array = arrays[n];
            m = array.length;
            while (--m >= 0) {
                merged[--j] = array[m];
            }
        }
        return merged;
    };
    var abs = Math.abs;
    d3.range = function(start, stop, step) {
        if (arguments.length < 3) {
            step = 1;
            if (arguments.length < 2) {
                stop = start;
                start = 0;
            }
        }
        if ((stop - start) / step === Infinity) throw new Error("infinite range");
        var range = [], k = d3_range_integerScale(abs(step)), i = -1, j;
        start *= k, stop *= k, step *= k;
        if (step < 0) while ((j = start + step * ++i) > stop) range.push(j / k); else while ((j = start + step * ++i) < stop) range.push(j / k);
        return range;
    };
    function d3_range_integerScale(x) {
        var k = 1;
        while (x * k % 1) k *= 10;
        return k;
    }
    function d3_class(ctor, properties) {
        for (var key in properties) {
            Object.defineProperty(ctor.prototype, key, {
                value: properties[key],
                enumerable: false
            });
        }
    }
    d3.map = function(object, f) {
        var map = new d3_Map();
        if (object instanceof d3_Map) {
            object.forEach(function(key, value) {
                map.set(key, value);
            });
        } else if (Array.isArray(object)) {
            var i = -1, n = object.length, o;
            if (arguments.length === 1) while (++i < n) map.set(i, object[i]); else while (++i < n) map.set(f.call(object, o = object[i], i), o);
        } else {
            for (var key in object) map.set(key, object[key]);
        }
        return map;
    };
    function d3_Map() {
        this._ = Object.create(null);
    }
    var d3_map_proto = "__proto__", d3_map_zero = "\x00";
    d3_class(d3_Map, {
        has: d3_map_has,
        get: function(key) {
            return this._[d3_map_escape(key)];
        },
        set: function(key, value) {
            return this._[d3_map_escape(key)] = value;
        },
        remove: d3_map_remove,
        keys: d3_map_keys,
        values: function() {
            var values = [];
            for (var key in this._) values.push(this._[key]);
            return values;
        },
        entries: function() {
            var entries = [];
            for (var key in this._) entries.push({
                key: d3_map_unescape(key),
                value: this._[key]
            });
            return entries;
        },
        size: d3_map_size,
        empty: d3_map_empty,
        forEach: function(f) {
            for (var key in this._) f.call(this, d3_map_unescape(key), this._[key]);
        }
    });
    function d3_map_escape(key) {
        return (key += "") === d3_map_proto || key[0] === d3_map_zero ? d3_map_zero + key : key;
    }
    function d3_map_unescape(key) {
        return (key += "")[0] === d3_map_zero ? key.slice(1) : key;
    }
    function d3_map_has(key) {
        return d3_map_escape(key) in this._;
    }
    function d3_map_remove(key) {
        return (key = d3_map_escape(key)) in this._ && delete this._[key];
    }
    function d3_map_keys() {
        var keys = [];
        for (var key in this._) keys.push(d3_map_unescape(key));
        return keys;
    }
    function d3_map_size() {
        var size = 0;
        for (var key in this._) ++size;
        return size;
    }
    function d3_map_empty() {
        for (var key in this._) return false;
        return true;
    }
    d3.nest = function() {
        var nest = {}, keys = [], sortKeys = [], sortValues, rollup;
        function map(mapType, array, depth) {
            if (depth >= keys.length) return rollup ? rollup.call(nest, array) : sortValues ? array.sort(sortValues) : array;
            var i = -1, n = array.length, key = keys[depth++], keyValue, object, setter, valuesByKey = new d3_Map(), values;
            while (++i < n) {
                if (values = valuesByKey.get(keyValue = key(object = array[i]))) {
                    values.push(object);
                } else {
                    valuesByKey.set(keyValue, [ object ]);
                }
            }
            if (mapType) {
                object = mapType();
                setter = function(keyValue, values) {
                    object.set(keyValue, map(mapType, values, depth));
                };
            } else {
                object = {};
                setter = function(keyValue, values) {
                    object[keyValue] = map(mapType, values, depth);
                };
            }
            valuesByKey.forEach(setter);
            return object;
        }
        function entries(map, depth) {
            if (depth >= keys.length) return map;
            var array = [], sortKey = sortKeys[depth++];
            map.forEach(function(key, keyMap) {
                array.push({
                    key: key,
                    values: entries(keyMap, depth)
                });
            });
            return sortKey ? array.sort(function(a, b) {
                return sortKey(a.key, b.key);
            }) : array;
        }
        nest.map = function(array, mapType) {
            return map(mapType, array, 0);
        };
        nest.entries = function(array) {
            return entries(map(d3.map, array, 0), 0);
        };
        nest.key = function(d) {
            keys.push(d);
            return nest;
        };
        nest.sortKeys = function(order) {
            sortKeys[keys.length - 1] = order;
            return nest;
        };
        nest.sortValues = function(order) {
            sortValues = order;
            return nest;
        };
        nest.rollup = function(f) {
            rollup = f;
            return nest;
        };
        return nest;
    };
    d3.set = function(array) {
        var set = new d3_Set();
        if (array) for (var i = 0, n = array.length; i < n; ++i) set.add(array[i]);
        return set;
    };
    function d3_Set() {
        this._ = Object.create(null);
    }
    d3_class(d3_Set, {
        has: d3_map_has,
        add: function(key) {
            this._[d3_map_escape(key += "")] = true;
            return key;
        },
        remove: d3_map_remove,
        values: d3_map_keys,
        size: d3_map_size,
        empty: d3_map_empty,
        forEach: function(f) {
            for (var key in this._) f.call(this, d3_map_unescape(key));
        }
    });
    d3.behavior = {};
    function d3_identity(d) {
        return d;
    }
    d3.rebind = function(target, source) {
        var i = 1, n = arguments.length, method;
        while (++i < n) target[method = arguments[i]] = d3_rebind(target, source, source[method]);
        return target;
    };
    function d3_rebind(target, source, method) {
        return function() {
            var value = method.apply(source, arguments);
            return value === source ? target : value;
        };
    }
    function d3_vendorSymbol(object, name) {
        if (name in object) return name;
        name = name.charAt(0).toUpperCase() + name.slice(1);
        for (var i = 0, n = d3_vendorPrefixes.length; i < n; ++i) {
            var prefixName = d3_vendorPrefixes[i] + name;
            if (prefixName in object) return prefixName;
        }
    }
    var d3_vendorPrefixes = [ "webkit", "ms", "moz", "Moz", "o", "O" ];
    function d3_noop() {}
    d3.dispatch = function() {
        var dispatch = new d3_dispatch(), i = -1, n = arguments.length;
        while (++i < n) dispatch[arguments[i]] = d3_dispatch_event(dispatch);
        return dispatch;
    };
    function d3_dispatch() {}
    d3_dispatch.prototype.on = function(type, listener) {
        var i = type.indexOf("."), name = "";
        if (i >= 0) {
            name = type.slice(i + 1);
            type = type.slice(0, i);
        }
        if (type) return arguments.length < 2 ? this[type].on(name) : this[type].on(name, listener);
        if (arguments.length === 2) {
            if (listener == null) for (type in this) {
                if (this.hasOwnProperty(type)) this[type].on(name, null);
            }
            return this;
        }
    };
    function d3_dispatch_event(dispatch) {
        var listeners = [], listenerByName = new d3_Map();
        function event() {
            var z = listeners, i = -1, n = z.length, l;
            while (++i < n) if (l = z[i].on) l.apply(this, arguments);
            return dispatch;
        }
        event.on = function(name, listener) {
            var l = listenerByName.get(name), i;
            if (arguments.length < 2) return l && l.on;
            if (l) {
                l.on = null;
                listeners = listeners.slice(0, i = listeners.indexOf(l)).concat(listeners.slice(i + 1));
                listenerByName.remove(name);
            }
            if (listener) listeners.push(listenerByName.set(name, {
                on: listener
            }));
            return dispatch;
        };
        return event;
    }
    d3.event = null;
    function d3_eventPreventDefault() {
        d3.event.preventDefault();
    }
    function d3_eventSource() {
        var e = d3.event, s;
        while (s = e.sourceEvent) e = s;
        return e;
    }
    function d3_eventDispatch(target) {
        var dispatch = new d3_dispatch(), i = 0, n = arguments.length;
        while (++i < n) dispatch[arguments[i]] = d3_dispatch_event(dispatch);
        dispatch.of = function(thiz, argumentz) {
            return function(e1) {
                try {
                    var e0 = e1.sourceEvent = d3.event;
                    e1.target = target;
                    d3.event = e1;
                    dispatch[e1.type].apply(thiz, argumentz);
                } finally {
                    d3.event = e0;
                }
            };
        };
        return dispatch;
    }
    d3.requote = function(s) {
        return s.replace(d3_requote_re, "\\$&");
    };
    var d3_requote_re = /[\\\^\$\*\+\?\|\[\]\(\)\.\{\}]/g;
    var d3_subclass = {}.__proto__ ? function(object, prototype) {
        object.__proto__ = prototype;
    } : function(object, prototype) {
        for (var property in prototype) object[property] = prototype[property];
    };
    function d3_selection(groups) {
        d3_subclass(groups, d3_selectionPrototype);
        return groups;
    }
    var d3_select = function(s, n) {
        return n.querySelector(s);
    }, d3_selectAll = function(s, n) {
        return n.querySelectorAll(s);
    }, d3_selectMatches = function(n, s) {
        var d3_selectMatcher = n.matches || n[d3_vendorSymbol(n, "matchesSelector")];
        d3_selectMatches = function(n, s) {
            return d3_selectMatcher.call(n, s);
        };
        return d3_selectMatches(n, s);
    };
    if (typeof Sizzle === "function") {
        d3_select = function(s, n) {
            return Sizzle(s, n)[0] || null;
        };
        d3_selectAll = Sizzle;
        d3_selectMatches = Sizzle.matchesSelector;
    }
    d3.selection = function() {
        return d3.select(d3_document.documentElement);
    };
    var d3_selectionPrototype = d3.selection.prototype = [];
    d3_selectionPrototype.select = function(selector) {
        var subgroups = [], subgroup, subnode, group, node;
        selector = d3_selection_selector(selector);
        for (var j = -1, m = this.length; ++j < m; ) {
            subgroups.push(subgroup = []);
            subgroup.parentNode = (group = this[j]).parentNode;
            for (var i = -1, n = group.length; ++i < n; ) {
                if (node = group[i]) {
                    subgroup.push(subnode = selector.call(node, node.__data__, i, j));
                    if (subnode && "__data__" in node) subnode.__data__ = node.__data__;
                } else {
                    subgroup.push(null);
                }
            }
        }
        return d3_selection(subgroups);
    };
    function d3_selection_selector(selector) {
        return typeof selector === "function" ? selector : function() {
            return d3_select(selector, this);
        };
    }
    d3_selectionPrototype.selectAll = function(selector) {
        var subgroups = [], subgroup, node;
        selector = d3_selection_selectorAll(selector);
        for (var j = -1, m = this.length; ++j < m; ) {
            for (var group = this[j], i = -1, n = group.length; ++i < n; ) {
                if (node = group[i]) {
                    subgroups.push(subgroup = d3_array(selector.call(node, node.__data__, i, j)));
                    subgroup.parentNode = node;
                }
            }
        }
        return d3_selection(subgroups);
    };
    function d3_selection_selectorAll(selector) {
        return typeof selector === "function" ? selector : function() {
            return d3_selectAll(selector, this);
        };
    }
    var d3_nsPrefix = {
        svg: "http://www.w3.org/2000/svg",
        xhtml: "http://www.w3.org/1999/xhtml",
        xlink: "http://www.w3.org/1999/xlink",
        xml: "http://www.w3.org/XML/1998/namespace",
        xmlns: "http://www.w3.org/2000/xmlns/"
    };
    d3.ns = {
        prefix: d3_nsPrefix,
        qualify: function(name) {
            var i = name.indexOf(":"), prefix = name;
            if (i >= 0) {
                prefix = name.slice(0, i);
                name = name.slice(i + 1);
            }
            return d3_nsPrefix.hasOwnProperty(prefix) ? {
                space: d3_nsPrefix[prefix],
                local: name
            } : name;
        }
    };
    d3_selectionPrototype.attr = function(name, value) {
        if (arguments.length < 2) {
            if (typeof name === "string") {
                var node = this.node();
                name = d3.ns.qualify(name);
                return name.local ? node.getAttributeNS(name.space, name.local) : node.getAttribute(name);
            }
            for (value in name) this.each(d3_selection_attr(value, name[value]));
            return this;
        }
        return this.each(d3_selection_attr(name, value));
    };
    function d3_selection_attr(name, value) {
        name = d3.ns.qualify(name);
        function attrNull() {
            this.removeAttribute(name);
        }
        function attrNullNS() {
            this.removeAttributeNS(name.space, name.local);
        }
        function attrConstant() {
            this.setAttribute(name, value);
        }
        function attrConstantNS() {
            this.setAttributeNS(name.space, name.local, value);
        }
        function attrFunction() {
            var x = value.apply(this, arguments);
            if (x == null) this.removeAttribute(name); else this.setAttribute(name, x);
        }
        function attrFunctionNS() {
            var x = value.apply(this, arguments);
            if (x == null) this.removeAttributeNS(name.space, name.local); else this.setAttributeNS(name.space, name.local, x);
        }
        return value == null ? name.local ? attrNullNS : attrNull : typeof value === "function" ? name.local ? attrFunctionNS : attrFunction : name.local ? attrConstantNS : attrConstant;
    }
    function d3_collapse(s) {
        return s.trim().replace(/\s+/g, " ");
    }
    d3_selectionPrototype.classed = function(name, value) {
        if (arguments.length < 2) {
            if (typeof name === "string") {
                var node = this.node(), n = (name = d3_selection_classes(name)).length, i = -1;
                if (value = node.classList) {
                    while (++i < n) if (!value.contains(name[i])) return false;
                } else {
                    value = node.getAttribute("class");
                    while (++i < n) if (!d3_selection_classedRe(name[i]).test(value)) return false;
                }
                return true;
            }
            for (value in name) this.each(d3_selection_classed(value, name[value]));
            return this;
        }
        return this.each(d3_selection_classed(name, value));
    };
    function d3_selection_classedRe(name) {
        return new RegExp("(?:^|\\s+)" + d3.requote(name) + "(?:\\s+|$)", "g");
    }
    function d3_selection_classes(name) {
        return (name + "").trim().split(/^|\s+/);
    }
    function d3_selection_classed(name, value) {
        name = d3_selection_classes(name).map(d3_selection_classedName);
        var n = name.length;
        function classedConstant() {
            var i = -1;
            while (++i < n) name[i](this, value);
        }
        function classedFunction() {
            var i = -1, x = value.apply(this, arguments);
            while (++i < n) name[i](this, x);
        }
        return typeof value === "function" ? classedFunction : classedConstant;
    }
    function d3_selection_classedName(name) {
        var re = d3_selection_classedRe(name);
        return function(node, value) {
            if (c = node.classList) return value ? c.add(name) : c.remove(name);
            var c = node.getAttribute("class") || "";
            if (value) {
                re.lastIndex = 0;
                if (!re.test(c)) node.setAttribute("class", d3_collapse(c + " " + name));
            } else {
                node.setAttribute("class", d3_collapse(c.replace(re, " ")));
            }
        };
    }
    d3_selectionPrototype.style = function(name, value, priority) {
        var n = arguments.length;
        if (n < 3) {
            if (typeof name !== "string") {
                if (n < 2) value = "";
                for (priority in name) this.each(d3_selection_style(priority, name[priority], value));
                return this;
            }
            if (n < 2) {
                var node = this.node();
                return d3_window(node).getComputedStyle(node, null).getPropertyValue(name);
            }
            priority = "";
        }
        return this.each(d3_selection_style(name, value, priority));
    };
    function d3_selection_style(name, value, priority) {
        function styleNull() {
            this.style.removeProperty(name);
        }
        function styleConstant() {
            this.style.setProperty(name, value, priority);
        }
        function styleFunction() {
            var x = value.apply(this, arguments);
            if (x == null) this.style.removeProperty(name); else this.style.setProperty(name, x, priority);
        }
        return value == null ? styleNull : typeof value === "function" ? styleFunction : styleConstant;
    }
    d3_selectionPrototype.property = function(name, value) {
        if (arguments.length < 2) {
            if (typeof name === "string") return this.node()[name];
            for (value in name) this.each(d3_selection_property(value, name[value]));
            return this;
        }
        return this.each(d3_selection_property(name, value));
    };
    function d3_selection_property(name, value) {
        function propertyNull() {
            delete this[name];
        }
        function propertyConstant() {
            this[name] = value;
        }
        function propertyFunction() {
            var x = value.apply(this, arguments);
            if (x == null) delete this[name]; else this[name] = x;
        }
        return value == null ? propertyNull : typeof value === "function" ? propertyFunction : propertyConstant;
    }
    d3_selectionPrototype.text = function(value) {
        return arguments.length ? this.each(typeof value === "function" ? function() {
            var v = value.apply(this, arguments);
            this.textContent = v == null ? "" : v;
        } : value == null ? function() {
            this.textContent = "";
        } : function() {
            this.textContent = value;
        }) : this.node().textContent;
    };
    d3_selectionPrototype.html = function(value) {
        return arguments.length ? this.each(typeof value === "function" ? function() {
            var v = value.apply(this, arguments);
            this.innerHTML = v == null ? "" : v;
        } : value == null ? function() {
            this.innerHTML = "";
        } : function() {
            this.innerHTML = value;
        }) : this.node().innerHTML;
    };
    d3_selectionPrototype.append = function(name) {
        name = d3_selection_creator(name);
        return this.select(function() {
            return this.appendChild(name.apply(this, arguments));
        });
    };
    function d3_selection_creator(name) {
        function create() {
            var document = this.ownerDocument, namespace = this.namespaceURI;
            return namespace ? document.createElementNS(namespace, name) : document.createElement(name);
        }
        function createNS() {
            return this.ownerDocument.createElementNS(name.space, name.local);
        }
        return typeof name === "function" ? name : (name = d3.ns.qualify(name)).local ? createNS : create;
    }
    d3_selectionPrototype.insert = function(name, before) {
        name = d3_selection_creator(name);
        before = d3_selection_selector(before);
        return this.select(function() {
            return this.insertBefore(name.apply(this, arguments), before.apply(this, arguments) || null);
        });
    };
    d3_selectionPrototype.remove = function() {
        return this.each(d3_selectionRemove);
    };
    function d3_selectionRemove() {
        var parent = this.parentNode;
        if (parent) parent.removeChild(this);
    }
    d3_selectionPrototype.data = function(value, key) {
        var i = -1, n = this.length, group, node;
        if (!arguments.length) {
            value = new Array(n = (group = this[0]).length);
            while (++i < n) {
                if (node = group[i]) {
                    value[i] = node.__data__;
                }
            }
            return value;
        }
        function bind(group, groupData) {
            var i, n = group.length, m = groupData.length, n0 = Math.min(n, m), updateNodes = new Array(m), enterNodes = new Array(m), exitNodes = new Array(n), node, nodeData;
            if (key) {
                var nodeByKeyValue = new d3_Map(), keyValues = new Array(n), keyValue;
                for (i = -1; ++i < n; ) {
                    if (nodeByKeyValue.has(keyValue = key.call(node = group[i], node.__data__, i))) {
                        exitNodes[i] = node;
                    } else {
                        nodeByKeyValue.set(keyValue, node);
                    }
                    keyValues[i] = keyValue;
                }
                for (i = -1; ++i < m; ) {
                    if (!(node = nodeByKeyValue.get(keyValue = key.call(groupData, nodeData = groupData[i], i)))) {
                        enterNodes[i] = d3_selection_dataNode(nodeData);
                    } else if (node !== true) {
                        updateNodes[i] = node;
                        node.__data__ = nodeData;
                    }
                    nodeByKeyValue.set(keyValue, true);
                }
                for (i = -1; ++i < n; ) {
                    if (nodeByKeyValue.get(keyValues[i]) !== true) {
                        exitNodes[i] = group[i];
                    }
                }
            } else {
                for (i = -1; ++i < n0; ) {
                    node = group[i];
                    nodeData = groupData[i];
                    if (node) {
                        node.__data__ = nodeData;
                        updateNodes[i] = node;
                    } else {
                        enterNodes[i] = d3_selection_dataNode(nodeData);
                    }
                }
                for (;i < m; ++i) {
                    enterNodes[i] = d3_selection_dataNode(groupData[i]);
                }
                for (;i < n; ++i) {
                    exitNodes[i] = group[i];
                }
            }
            enterNodes.update = updateNodes;
            enterNodes.parentNode = updateNodes.parentNode = exitNodes.parentNode = group.parentNode;
            enter.push(enterNodes);
            update.push(updateNodes);
            exit.push(exitNodes);
        }
        var enter = d3_selection_enter([]), update = d3_selection([]), exit = d3_selection([]);
        if (typeof value === "function") {
            while (++i < n) {
                bind(group = this[i], value.call(group, group.parentNode.__data__, i));
            }
        } else {
            while (++i < n) {
                bind(group = this[i], value);
            }
        }
        update.enter = function() {
            return enter;
        };
        update.exit = function() {
            return exit;
        };
        return update;
    };
    function d3_selection_dataNode(data) {
        return {
            __data__: data
        };
    }
    d3_selectionPrototype.datum = function(value) {
        return arguments.length ? this.property("__data__", value) : this.property("__data__");
    };
    d3_selectionPrototype.filter = function(filter) {
        var subgroups = [], subgroup, group, node;
        if (typeof filter !== "function") filter = d3_selection_filter(filter);
        for (var j = 0, m = this.length; j < m; j++) {
            subgroups.push(subgroup = []);
            subgroup.parentNode = (group = this[j]).parentNode;
            for (var i = 0, n = group.length; i < n; i++) {
                if ((node = group[i]) && filter.call(node, node.__data__, i, j)) {
                    subgroup.push(node);
                }
            }
        }
        return d3_selection(subgroups);
    };
    function d3_selection_filter(selector) {
        return function() {
            return d3_selectMatches(this, selector);
        };
    }
    d3_selectionPrototype.order = function() {
        for (var j = -1, m = this.length; ++j < m; ) {
            for (var group = this[j], i = group.length - 1, next = group[i], node; --i >= 0; ) {
                if (node = group[i]) {
                    if (next && next !== node.nextSibling) next.parentNode.insertBefore(node, next);
                    next = node;
                }
            }
        }
        return this;
    };
    d3_selectionPrototype.sort = function(comparator) {
        comparator = d3_selection_sortComparator.apply(this, arguments);
        for (var j = -1, m = this.length; ++j < m; ) this[j].sort(comparator);
        return this.order();
    };
    function d3_selection_sortComparator(comparator) {
        if (!arguments.length) comparator = d3_ascending;
        return function(a, b) {
            return a && b ? comparator(a.__data__, b.__data__) : !a - !b;
        };
    }
    d3_selectionPrototype.each = function(callback) {
        return d3_selection_each(this, function(node, i, j) {
            callback.call(node, node.__data__, i, j);
        });
    };
    function d3_selection_each(groups, callback) {
        for (var j = 0, m = groups.length; j < m; j++) {
            for (var group = groups[j], i = 0, n = group.length, node; i < n; i++) {
                if (node = group[i]) callback(node, i, j);
            }
        }
        return groups;
    }
    d3_selectionPrototype.call = function(callback) {
        var args = d3_array(arguments);
        callback.apply(args[0] = this, args);
        return this;
    };
    d3_selectionPrototype.empty = function() {
        return !this.node();
    };
    d3_selectionPrototype.node = function() {
        for (var j = 0, m = this.length; j < m; j++) {
            for (var group = this[j], i = 0, n = group.length; i < n; i++) {
                var node = group[i];
                if (node) return node;
            }
        }
        return null;
    };
    d3_selectionPrototype.size = function() {
        var n = 0;
        d3_selection_each(this, function() {
            ++n;
        });
        return n;
    };
    function d3_selection_enter(selection) {
        d3_subclass(selection, d3_selection_enterPrototype);
        return selection;
    }
    var d3_selection_enterPrototype = [];
    d3.selection.enter = d3_selection_enter;
    d3.selection.enter.prototype = d3_selection_enterPrototype;
    d3_selection_enterPrototype.append = d3_selectionPrototype.append;
    d3_selection_enterPrototype.empty = d3_selectionPrototype.empty;
    d3_selection_enterPrototype.node = d3_selectionPrototype.node;
    d3_selection_enterPrototype.call = d3_selectionPrototype.call;
    d3_selection_enterPrototype.size = d3_selectionPrototype.size;
    d3_selection_enterPrototype.select = function(selector) {
        var subgroups = [], subgroup, subnode, upgroup, group, node;
        for (var j = -1, m = this.length; ++j < m; ) {
            upgroup = (group = this[j]).update;
            subgroups.push(subgroup = []);
            subgroup.parentNode = group.parentNode;
            for (var i = -1, n = group.length; ++i < n; ) {
                if (node = group[i]) {
                    subgroup.push(upgroup[i] = subnode = selector.call(group.parentNode, node.__data__, i, j));
                    subnode.__data__ = node.__data__;
                } else {
                    subgroup.push(null);
                }
            }
        }
        return d3_selection(subgroups);
    };
    d3_selection_enterPrototype.insert = function(name, before) {
        if (arguments.length < 2) before = d3_selection_enterInsertBefore(this);
        return d3_selectionPrototype.insert.call(this, name, before);
    };
    function d3_selection_enterInsertBefore(enter) {
        var i0, j0;
        return function(d, i, j) {
            var group = enter[j].update, n = group.length, node;
            if (j != j0) j0 = j, i0 = 0;
            if (i >= i0) i0 = i + 1;
            while (!(node = group[i0]) && ++i0 < n) ;
            return node;
        };
    }
    d3.select = function(node) {
        var group;
        if (typeof node === "string") {
            group = [ d3_select(node, d3_document) ];
            group.parentNode = d3_document.documentElement;
        } else {
            group = [ node ];
            group.parentNode = d3_documentElement(node);
        }
        return d3_selection([ group ]);
    };
    d3.selectAll = function(nodes) {
        var group;
        if (typeof nodes === "string") {
            group = d3_array(d3_selectAll(nodes, d3_document));
            group.parentNode = d3_document.documentElement;
        } else {
            group = nodes;
            group.parentNode = null;
        }
        return d3_selection([ group ]);
    };
    d3_selectionPrototype.on = function(type, listener, capture) {
        var n = arguments.length;
        if (n < 3) {
            if (typeof type !== "string") {
                if (n < 2) listener = false;
                for (capture in type) this.each(d3_selection_on(capture, type[capture], listener));
                return this;
            }
            if (n < 2) return (n = this.node()["__on" + type]) && n._;
            capture = false;
        }
        return this.each(d3_selection_on(type, listener, capture));
    };
    function d3_selection_on(type, listener, capture) {
        var name = "__on" + type, i = type.indexOf("."), wrap = d3_selection_onListener;
        if (i > 0) type = type.slice(0, i);
        var filter = d3_selection_onFilters.get(type);
        if (filter) type = filter, wrap = d3_selection_onFilter;
        function onRemove() {
            var l = this[name];
            if (l) {
                this.removeEventListener(type, l, l.$);
                delete this[name];
            }
        }
        function onAdd() {
            var l = wrap(listener, d3_array(arguments));
            onRemove.call(this);
            this.addEventListener(type, this[name] = l, l.$ = capture);
            l._ = listener;
        }
        function removeAll() {
            var re = new RegExp("^__on([^.]+)" + d3.requote(type) + "$"), match;
            for (var name in this) {
                if (match = name.match(re)) {
                    var l = this[name];
                    this.removeEventListener(match[1], l, l.$);
                    delete this[name];
                }
            }
        }
        return i ? listener ? onAdd : onRemove : listener ? d3_noop : removeAll;
    }
    var d3_selection_onFilters = d3.map({
        mouseenter: "mouseover",
        mouseleave: "mouseout"
    });
    if (d3_document) {
        d3_selection_onFilters.forEach(function(k) {
            if ("on" + k in d3_document) d3_selection_onFilters.remove(k);
        });
    }
    function d3_selection_onListener(listener, argumentz) {
        return function(e) {
            var o = d3.event;
            d3.event = e;
            argumentz[0] = this.__data__;
            try {
                listener.apply(this, argumentz);
            } finally {
                d3.event = o;
            }
        };
    }
    function d3_selection_onFilter(listener, argumentz) {
        var l = d3_selection_onListener(listener, argumentz);
        return function(e) {
            var target = this, related = e.relatedTarget;
            if (!related || related !== target && !(related.compareDocumentPosition(target) & 8)) {
                l.call(target, e);
            }
        };
    }
    var d3_event_dragSelect, d3_event_dragId = 0;
    function d3_event_dragSuppress(node) {
        var name = ".dragsuppress-" + ++d3_event_dragId, click = "click" + name, w = d3.select(d3_window(node)).on("touchmove" + name, d3_eventPreventDefault).on("dragstart" + name, d3_eventPreventDefault).on("selectstart" + name, d3_eventPreventDefault);
        if (d3_event_dragSelect == null) {
            d3_event_dragSelect = "onselectstart" in node ? false : d3_vendorSymbol(node.style, "userSelect");
        }
        if (d3_event_dragSelect) {
            var style = d3_documentElement(node).style, select = style[d3_event_dragSelect];
            style[d3_event_dragSelect] = "none";
        }
        return function(suppressClick) {
            w.on(name, null);
            if (d3_event_dragSelect) style[d3_event_dragSelect] = select;
            if (suppressClick) {
                var off = function() {
                    w.on(click, null);
                };
                w.on(click, function() {
                    d3_eventPreventDefault();
                    off();
                }, true);
                setTimeout(off, 0);
            }
        };
    }
    d3.mouse = function(container) {
        return d3_mousePoint(container, d3_eventSource());
    };
    var d3_mouse_bug44083 = this.navigator && /WebKit/.test(this.navigator.userAgent) ? -1 : 0;
    function d3_mousePoint(container, e) {
        if (e.changedTouches) e = e.changedTouches[0];
        var svg = container.ownerSVGElement || container;
        if (svg.createSVGPoint) {
            var point = svg.createSVGPoint();
            if (d3_mouse_bug44083 < 0) {
                var window = d3_window(container);
                if (window.scrollX || window.scrollY) {
                    svg = d3.select("body").append("svg").style({
                        position: "absolute",
                        top: 0,
                        left: 0,
                        margin: 0,
                        padding: 0,
                        border: "none"
                    }, "important");
                    var ctm = svg[0][0].getScreenCTM();
                    d3_mouse_bug44083 = !(ctm.f || ctm.e);
                    svg.remove();
                }
            }
            if (d3_mouse_bug44083) point.x = e.pageX, point.y = e.pageY; else point.x = e.clientX,
                point.y = e.clientY;
            point = point.matrixTransform(container.getScreenCTM().inverse());
            return [ point.x, point.y ];
        }
        var rect = container.getBoundingClientRect();
        return [ e.clientX - rect.left - container.clientLeft, e.clientY - rect.top - container.clientTop ];
    }
    d3.touch = function(container, touches, identifier) {
        if (arguments.length < 3) identifier = touches, touches = d3_eventSource().changedTouches;
        if (touches) for (var i = 0, n = touches.length, touch; i < n; ++i) {
            if ((touch = touches[i]).identifier === identifier) {
                return d3_mousePoint(container, touch);
            }
        }
    };
    d3.behavior.drag = function() {
        var event = d3_eventDispatch(drag, "drag", "dragstart", "dragend"), origin = null, mousedown = dragstart(d3_noop, d3.mouse, d3_window, "mousemove", "mouseup"), touchstart = dragstart(d3_behavior_dragTouchId, d3.touch, d3_identity, "touchmove", "touchend");
        function drag() {
            this.on("mousedown.drag", mousedown).on("touchstart.drag", touchstart);
        }
        function dragstart(id, position, subject, move, end) {
            return function() {
                var that = this, target = d3.event.target, parent = that.parentNode, dispatch = event.of(that, arguments), dragged = 0, dragId = id(), dragName = ".drag" + (dragId == null ? "" : "-" + dragId), dragOffset, dragSubject = d3.select(subject(target)).on(move + dragName, moved).on(end + dragName, ended), dragRestore = d3_event_dragSuppress(target), position0 = position(parent, dragId);
                if (origin) {
                    dragOffset = origin.apply(that, arguments);
                    dragOffset = [ dragOffset.x - position0[0], dragOffset.y - position0[1] ];
                } else {
                    dragOffset = [ 0, 0 ];
                }
                dispatch({
                    type: "dragstart"
                });
                function moved() {
                    var position1 = position(parent, dragId), dx, dy;
                    if (!position1) return;
                    dx = position1[0] - position0[0];
                    dy = position1[1] - position0[1];
                    dragged |= dx | dy;
                    position0 = position1;
                    dispatch({
                        type: "drag",
                        x: position1[0] + dragOffset[0],
                        y: position1[1] + dragOffset[1],
                        dx: dx,
                        dy: dy
                    });
                }
                function ended() {
                    if (!position(parent, dragId)) return;
                    dragSubject.on(move + dragName, null).on(end + dragName, null);
                    dragRestore(dragged && d3.event.target === target);
                    dispatch({
                        type: "dragend"
                    });
                }
            };
        }
        drag.origin = function(x) {
            if (!arguments.length) return origin;
            origin = x;
            return drag;
        };
        return d3.rebind(drag, event, "on");
    };
    function d3_behavior_dragTouchId() {
        return d3.event.changedTouches[0].identifier;
    }
    d3.touches = function(container, touches) {
        if (arguments.length < 2) touches = d3_eventSource().touches;
        return touches ? d3_array(touches).map(function(touch) {
            var point = d3_mousePoint(container, touch);
            point.identifier = touch.identifier;
            return point;
        }) : [];
    };
    var ε = 1e-6, ε2 = ε * ε, π = Math.PI, τ = 2 * π, τε = τ - ε, halfπ = π / 2, d3_radians = π / 180, d3_degrees = 180 / π;
    function d3_sgn(x) {
        return x > 0 ? 1 : x < 0 ? -1 : 0;
    }
    function d3_cross2d(a, b, c) {
        return (b[0] - a[0]) * (c[1] - a[1]) - (b[1] - a[1]) * (c[0] - a[0]);
    }
    function d3_acos(x) {
        return x > 1 ? 0 : x < -1 ? π : Math.acos(x);
    }
    function d3_asin(x) {
        return x > 1 ? halfπ : x < -1 ? -halfπ : Math.asin(x);
    }
    function d3_sinh(x) {
        return ((x = Math.exp(x)) - 1 / x) / 2;
    }
    function d3_cosh(x) {
        return ((x = Math.exp(x)) + 1 / x) / 2;
    }
    function d3_tanh(x) {
        return ((x = Math.exp(2 * x)) - 1) / (x + 1);
    }
    function d3_haversin(x) {
        return (x = Math.sin(x / 2)) * x;
    }
    var ρ = Math.SQRT2, ρ2 = 2, ρ4 = 4;
    d3.interpolateZoom = function(p0, p1) {
        var ux0 = p0[0], uy0 = p0[1], w0 = p0[2], ux1 = p1[0], uy1 = p1[1], w1 = p1[2];
        var dx = ux1 - ux0, dy = uy1 - uy0, d2 = dx * dx + dy * dy, d1 = Math.sqrt(d2), b0 = (w1 * w1 - w0 * w0 + ρ4 * d2) / (2 * w0 * ρ2 * d1), b1 = (w1 * w1 - w0 * w0 - ρ4 * d2) / (2 * w1 * ρ2 * d1), r0 = Math.log(Math.sqrt(b0 * b0 + 1) - b0), r1 = Math.log(Math.sqrt(b1 * b1 + 1) - b1), dr = r1 - r0, S = (dr || Math.log(w1 / w0)) / ρ;
        function interpolate(t) {
            var s = t * S;
            if (dr) {
                var coshr0 = d3_cosh(r0), u = w0 / (ρ2 * d1) * (coshr0 * d3_tanh(ρ * s + r0) - d3_sinh(r0));
                return [ ux0 + u * dx, uy0 + u * dy, w0 * coshr0 / d3_cosh(ρ * s + r0) ];
            }
            return [ ux0 + t * dx, uy0 + t * dy, w0 * Math.exp(ρ * s) ];
        }
        interpolate.duration = S * 1e3;
        return interpolate;
    };
    d3.behavior.zoom = function() {
        var view = {
            x: 0,
            y: 0,
            k: 1
        }, translate0, center0, center, size = [ 960, 500 ], scaleExtent = d3_behavior_zoomInfinity, duration = 250, zooming = 0, mousedown = "mousedown.zoom", mousemove = "mousemove.zoom", mouseup = "mouseup.zoom", mousewheelTimer, touchstart = "touchstart.zoom", touchtime, event = d3_eventDispatch(zoom, "zoomstart", "zoom", "zoomend"), x0, x1, y0, y1;
        if (!d3_behavior_zoomWheel) {
            d3_behavior_zoomWheel = "onwheel" in d3_document ? (d3_behavior_zoomDelta = function() {
                return -d3.event.deltaY * (d3.event.deltaMode ? 120 : 1);
            }, "wheel") : "onmousewheel" in d3_document ? (d3_behavior_zoomDelta = function() {
                return d3.event.wheelDelta;
            }, "mousewheel") : (d3_behavior_zoomDelta = function() {
                return -d3.event.detail;
            }, "MozMousePixelScroll");
        }
        function zoom(g) {
            g.on(mousedown, mousedowned).on(d3_behavior_zoomWheel + ".zoom", mousewheeled).on("dblclick.zoom", dblclicked).on(touchstart, touchstarted);
        }
        zoom.event = function(g) {
            g.each(function() {
                var dispatch = event.of(this, arguments), view1 = view;
                if (d3_transitionInheritId) {
                    d3.select(this).transition().each("start.zoom", function() {
                        view = this.__chart__ || {
                                x: 0,
                                y: 0,
                                k: 1
                            };
                        zoomstarted(dispatch);
                    }).tween("zoom:zoom", function() {
                        var dx = size[0], dy = size[1], cx = center0 ? center0[0] : dx / 2, cy = center0 ? center0[1] : dy / 2, i = d3.interpolateZoom([ (cx - view.x) / view.k, (cy - view.y) / view.k, dx / view.k ], [ (cx - view1.x) / view1.k, (cy - view1.y) / view1.k, dx / view1.k ]);
                        return function(t) {
                            var l = i(t), k = dx / l[2];
                            this.__chart__ = view = {
                                x: cx - l[0] * k,
                                y: cy - l[1] * k,
                                k: k
                            };
                            zoomed(dispatch);
                        };
                    }).each("interrupt.zoom", function() {
                        zoomended(dispatch);
                    }).each("end.zoom", function() {
                        zoomended(dispatch);
                    });
                } else {
                    this.__chart__ = view;
                    zoomstarted(dispatch);
                    zoomed(dispatch);
                    zoomended(dispatch);
                }
            });
        };
        zoom.translate = function(_) {
            if (!arguments.length) return [ view.x, view.y ];
            view = {
                x: +_[0],
                y: +_[1],
                k: view.k
            };
            rescale();
            return zoom;
        };
        zoom.scale = function(_) {
            if (!arguments.length) return view.k;
            view = {
                x: view.x,
                y: view.y,
                k: +_
            };
            rescale();
            return zoom;
        };
        zoom.scaleExtent = function(_) {
            if (!arguments.length) return scaleExtent;
            scaleExtent = _ == null ? d3_behavior_zoomInfinity : [ +_[0], +_[1] ];
            return zoom;
        };
        zoom.center = function(_) {
            if (!arguments.length) return center;
            center = _ && [ +_[0], +_[1] ];
            return zoom;
        };
        zoom.size = function(_) {
            if (!arguments.length) return size;
            size = _ && [ +_[0], +_[1] ];
            return zoom;
        };
        zoom.duration = function(_) {
            if (!arguments.length) return duration;
            duration = +_;
            return zoom;
        };
        zoom.x = function(z) {
            if (!arguments.length) return x1;
            x1 = z;
            x0 = z.copy();
            view = {
                x: 0,
                y: 0,
                k: 1
            };
            return zoom;
        };
        zoom.y = function(z) {
            if (!arguments.length) return y1;
            y1 = z;
            y0 = z.copy();
            view = {
                x: 0,
                y: 0,
                k: 1
            };
            return zoom;
        };
        function location(p) {
            return [ (p[0] - view.x) / view.k, (p[1] - view.y) / view.k ];
        }
        function point(l) {
            return [ l[0] * view.k + view.x, l[1] * view.k + view.y ];
        }
        function scaleTo(s) {
            view.k = Math.max(scaleExtent[0], Math.min(scaleExtent[1], s));
        }
        function translateTo(p, l) {
            l = point(l);
            view.x += p[0] - l[0];
            view.y += p[1] - l[1];
        }
        function zoomTo(that, p, l, k) {
            that.__chart__ = {
                x: view.x,
                y: view.y,
                k: view.k
            };
            scaleTo(Math.pow(2, k));
            translateTo(center0 = p, l);
            that = d3.select(that);
            if (duration > 0) that = that.transition().duration(duration);
            that.call(zoom.event);
        }
        function rescale() {
            if (x1) x1.domain(x0.range().map(function(x) {
                return (x - view.x) / view.k;
            }).map(x0.invert));
            if (y1) y1.domain(y0.range().map(function(y) {
                return (y - view.y) / view.k;
            }).map(y0.invert));
        }
        function zoomstarted(dispatch) {
            if (!zooming++) dispatch({
                type: "zoomstart"
            });
        }
        function zoomed(dispatch) {
            rescale();
            dispatch({
                type: "zoom",
                scale: view.k,
                translate: [ view.x, view.y ]
            });
        }
        function zoomended(dispatch) {
            if (!--zooming) dispatch({
                type: "zoomend"
            });
            center0 = null;
        }
        function mousedowned() {
            var that = this, target = d3.event.target, dispatch = event.of(that, arguments), dragged = 0, subject = d3.select(d3_window(that)).on(mousemove, moved).on(mouseup, ended), location0 = location(d3.mouse(that)), dragRestore = d3_event_dragSuppress(that);
            d3_selection_interrupt.call(that);
            zoomstarted(dispatch);
            function moved() {
                dragged = 1;
                translateTo(d3.mouse(that), location0);
                zoomed(dispatch);
            }
            function ended() {
                subject.on(mousemove, null).on(mouseup, null);
                dragRestore(dragged && d3.event.target === target);
                zoomended(dispatch);
            }
        }
        function touchstarted() {
            var that = this, dispatch = event.of(that, arguments), locations0 = {}, distance0 = 0, scale0, zoomName = ".zoom-" + d3.event.changedTouches[0].identifier, touchmove = "touchmove" + zoomName, touchend = "touchend" + zoomName, targets = [], subject = d3.select(that), dragRestore = d3_event_dragSuppress(that);
            started();
            zoomstarted(dispatch);
            subject.on(mousedown, null).on(touchstart, started);
            function relocate() {
                var touches = d3.touches(that);
                scale0 = view.k;
                touches.forEach(function(t) {
                    if (t.identifier in locations0) locations0[t.identifier] = location(t);
                });
                return touches;
            }
            function started() {
                var target = d3.event.target;
                d3.select(target).on(touchmove, moved).on(touchend, ended);
                targets.push(target);
                var changed = d3.event.changedTouches;
                for (var i = 0, n = changed.length; i < n; ++i) {
                    locations0[changed[i].identifier] = null;
                }
                var touches = relocate(), now = Date.now();
                if (touches.length === 1) {
                    if (now - touchtime < 500) {
                        var p = touches[0];
                        zoomTo(that, p, locations0[p.identifier], Math.floor(Math.log(view.k) / Math.LN2) + 1);
                        d3_eventPreventDefault();
                    }
                    touchtime = now;
                } else if (touches.length > 1) {
                    var p = touches[0], q = touches[1], dx = p[0] - q[0], dy = p[1] - q[1];
                    distance0 = dx * dx + dy * dy;
                }
            }
            function moved() {
                var touches = d3.touches(that), p0, l0, p1, l1;
                d3_selection_interrupt.call(that);
                for (var i = 0, n = touches.length; i < n; ++i, l1 = null) {
                    p1 = touches[i];
                    if (l1 = locations0[p1.identifier]) {
                        if (l0) break;
                        p0 = p1, l0 = l1;
                    }
                }
                if (l1) {
                    var distance1 = (distance1 = p1[0] - p0[0]) * distance1 + (distance1 = p1[1] - p0[1]) * distance1, scale1 = distance0 && Math.sqrt(distance1 / distance0);
                    p0 = [ (p0[0] + p1[0]) / 2, (p0[1] + p1[1]) / 2 ];
                    l0 = [ (l0[0] + l1[0]) / 2, (l0[1] + l1[1]) / 2 ];
                    scaleTo(scale1 * scale0);
                }
                touchtime = null;
                translateTo(p0, l0);
                zoomed(dispatch);
            }
            function ended() {
                if (d3.event.touches.length) {
                    var changed = d3.event.changedTouches;
                    for (var i = 0, n = changed.length; i < n; ++i) {
                        delete locations0[changed[i].identifier];
                    }
                    for (var identifier in locations0) {
                        return void relocate();
                    }
                }
                d3.selectAll(targets).on(zoomName, null);
                subject.on(mousedown, mousedowned).on(touchstart, touchstarted);
                dragRestore();
                zoomended(dispatch);
            }
        }
        function mousewheeled() {
            var dispatch = event.of(this, arguments);
            if (mousewheelTimer) clearTimeout(mousewheelTimer); else translate0 = location(center0 = center || d3.mouse(this)),
                d3_selection_interrupt.call(this), zoomstarted(dispatch);
            mousewheelTimer = setTimeout(function() {
                mousewheelTimer = null;
                zoomended(dispatch);
            }, 50);
            d3_eventPreventDefault();
            scaleTo(Math.pow(2, d3_behavior_zoomDelta() * .002) * view.k);
            translateTo(center0, translate0);
            zoomed(dispatch);
        }
        function dblclicked() {
            var p = d3.mouse(this), k = Math.log(view.k) / Math.LN2;
            zoomTo(this, p, location(p), d3.event.shiftKey ? Math.ceil(k) - 1 : Math.floor(k) + 1);
        }
        return d3.rebind(zoom, event, "on");
    };
    var d3_behavior_zoomInfinity = [ 0, Infinity ], d3_behavior_zoomDelta, d3_behavior_zoomWheel;
    d3.color = d3_color;
    function d3_color() {}
    d3_color.prototype.toString = function() {
        return this.rgb() + "";
    };
    d3.hsl = d3_hsl;
    function d3_hsl(h, s, l) {
        return this instanceof d3_hsl ? void (this.h = +h, this.s = +s, this.l = +l) : arguments.length < 2 ? h instanceof d3_hsl ? new d3_hsl(h.h, h.s, h.l) : d3_rgb_parse("" + h, d3_rgb_hsl, d3_hsl) : new d3_hsl(h, s, l);
    }
    var d3_hslPrototype = d3_hsl.prototype = new d3_color();
    d3_hslPrototype.brighter = function(k) {
        k = Math.pow(.7, arguments.length ? k : 1);
        return new d3_hsl(this.h, this.s, this.l / k);
    };
    d3_hslPrototype.darker = function(k) {
        k = Math.pow(.7, arguments.length ? k : 1);
        return new d3_hsl(this.h, this.s, k * this.l);
    };
    d3_hslPrototype.rgb = function() {
        return d3_hsl_rgb(this.h, this.s, this.l);
    };
    function d3_hsl_rgb(h, s, l) {
        var m1, m2;
        h = isNaN(h) ? 0 : (h %= 360) < 0 ? h + 360 : h;
        s = isNaN(s) ? 0 : s < 0 ? 0 : s > 1 ? 1 : s;
        l = l < 0 ? 0 : l > 1 ? 1 : l;
        m2 = l <= .5 ? l * (1 + s) : l + s - l * s;
        m1 = 2 * l - m2;
        function v(h) {
            if (h > 360) h -= 360; else if (h < 0) h += 360;
            if (h < 60) return m1 + (m2 - m1) * h / 60;
            if (h < 180) return m2;
            if (h < 240) return m1 + (m2 - m1) * (240 - h) / 60;
            return m1;
        }
        function vv(h) {
            return Math.round(v(h) * 255);
        }
        return new d3_rgb(vv(h + 120), vv(h), vv(h - 120));
    }
    d3.hcl = d3_hcl;
    function d3_hcl(h, c, l) {
        return this instanceof d3_hcl ? void (this.h = +h, this.c = +c, this.l = +l) : arguments.length < 2 ? h instanceof d3_hcl ? new d3_hcl(h.h, h.c, h.l) : h instanceof d3_lab ? d3_lab_hcl(h.l, h.a, h.b) : d3_lab_hcl((h = d3_rgb_lab((h = d3.rgb(h)).r, h.g, h.b)).l, h.a, h.b) : new d3_hcl(h, c, l);
    }
    var d3_hclPrototype = d3_hcl.prototype = new d3_color();
    d3_hclPrototype.brighter = function(k) {
        return new d3_hcl(this.h, this.c, Math.min(100, this.l + d3_lab_K * (arguments.length ? k : 1)));
    };
    d3_hclPrototype.darker = function(k) {
        return new d3_hcl(this.h, this.c, Math.max(0, this.l - d3_lab_K * (arguments.length ? k : 1)));
    };
    d3_hclPrototype.rgb = function() {
        return d3_hcl_lab(this.h, this.c, this.l).rgb();
    };
    function d3_hcl_lab(h, c, l) {
        if (isNaN(h)) h = 0;
        if (isNaN(c)) c = 0;
        return new d3_lab(l, Math.cos(h *= d3_radians) * c, Math.sin(h) * c);
    }
    d3.lab = d3_lab;
    function d3_lab(l, a, b) {
        return this instanceof d3_lab ? void (this.l = +l, this.a = +a, this.b = +b) : arguments.length < 2 ? l instanceof d3_lab ? new d3_lab(l.l, l.a, l.b) : l instanceof d3_hcl ? d3_hcl_lab(l.h, l.c, l.l) : d3_rgb_lab((l = d3_rgb(l)).r, l.g, l.b) : new d3_lab(l, a, b);
    }
    var d3_lab_K = 18;
    var d3_lab_X = .95047, d3_lab_Y = 1, d3_lab_Z = 1.08883;
    var d3_labPrototype = d3_lab.prototype = new d3_color();
    d3_labPrototype.brighter = function(k) {
        return new d3_lab(Math.min(100, this.l + d3_lab_K * (arguments.length ? k : 1)), this.a, this.b);
    };
    d3_labPrototype.darker = function(k) {
        return new d3_lab(Math.max(0, this.l - d3_lab_K * (arguments.length ? k : 1)), this.a, this.b);
    };
    d3_labPrototype.rgb = function() {
        return d3_lab_rgb(this.l, this.a, this.b);
    };
    function d3_lab_rgb(l, a, b) {
        var y = (l + 16) / 116, x = y + a / 500, z = y - b / 200;
        x = d3_lab_xyz(x) * d3_lab_X;
        y = d3_lab_xyz(y) * d3_lab_Y;
        z = d3_lab_xyz(z) * d3_lab_Z;
        return new d3_rgb(d3_xyz_rgb(3.2404542 * x - 1.5371385 * y - .4985314 * z), d3_xyz_rgb(-.969266 * x + 1.8760108 * y + .041556 * z), d3_xyz_rgb(.0556434 * x - .2040259 * y + 1.0572252 * z));
    }
    function d3_lab_hcl(l, a, b) {
        return l > 0 ? new d3_hcl(Math.atan2(b, a) * d3_degrees, Math.sqrt(a * a + b * b), l) : new d3_hcl(NaN, NaN, l);
    }
    function d3_lab_xyz(x) {
        return x > .206893034 ? x * x * x : (x - 4 / 29) / 7.787037;
    }
    function d3_xyz_lab(x) {
        return x > .008856 ? Math.pow(x, 1 / 3) : 7.787037 * x + 4 / 29;
    }
    function d3_xyz_rgb(r) {
        return Math.round(255 * (r <= .00304 ? 12.92 * r : 1.055 * Math.pow(r, 1 / 2.4) - .055));
    }
    d3.rgb = d3_rgb;
    function d3_rgb(r, g, b) {
        return this instanceof d3_rgb ? void (this.r = ~~r, this.g = ~~g, this.b = ~~b) : arguments.length < 2 ? r instanceof d3_rgb ? new d3_rgb(r.r, r.g, r.b) : d3_rgb_parse("" + r, d3_rgb, d3_hsl_rgb) : new d3_rgb(r, g, b);
    }
    function d3_rgbNumber(value) {
        return new d3_rgb(value >> 16, value >> 8 & 255, value & 255);
    }
    function d3_rgbString(value) {
        return d3_rgbNumber(value) + "";
    }
    var d3_rgbPrototype = d3_rgb.prototype = new d3_color();
    d3_rgbPrototype.brighter = function(k) {
        k = Math.pow(.7, arguments.length ? k : 1);
        var r = this.r, g = this.g, b = this.b, i = 30;
        if (!r && !g && !b) return new d3_rgb(i, i, i);
        if (r && r < i) r = i;
        if (g && g < i) g = i;
        if (b && b < i) b = i;
        return new d3_rgb(Math.min(255, r / k), Math.min(255, g / k), Math.min(255, b / k));
    };
    d3_rgbPrototype.darker = function(k) {
        k = Math.pow(.7, arguments.length ? k : 1);
        return new d3_rgb(k * this.r, k * this.g, k * this.b);
    };
    d3_rgbPrototype.hsl = function() {
        return d3_rgb_hsl(this.r, this.g, this.b);
    };
    d3_rgbPrototype.toString = function() {
        return "#" + d3_rgb_hex(this.r) + d3_rgb_hex(this.g) + d3_rgb_hex(this.b);
    };
    function d3_rgb_hex(v) {
        return v < 16 ? "0" + Math.max(0, v).toString(16) : Math.min(255, v).toString(16);
    }
    function d3_rgb_parse(format, rgb, hsl) {
        var r = 0, g = 0, b = 0, m1, m2, color;
        m1 = /([a-z]+)\((.*)\)/i.exec(format);
        if (m1) {
            m2 = m1[2].split(",");
            switch (m1[1]) {
                case "hsl":
                {
                    return hsl(parseFloat(m2[0]), parseFloat(m2[1]) / 100, parseFloat(m2[2]) / 100);
                }

                case "rgb":
                {
                    return rgb(d3_rgb_parseNumber(m2[0]), d3_rgb_parseNumber(m2[1]), d3_rgb_parseNumber(m2[2]));
                }
            }
        }
        if (color = d3_rgb_names.get(format.toLowerCase())) {
            return rgb(color.r, color.g, color.b);
        }
        if (format != null && format.charAt(0) === "#" && !isNaN(color = parseInt(format.slice(1), 16))) {
            if (format.length === 4) {
                r = (color & 3840) >> 4;
                r = r >> 4 | r;
                g = color & 240;
                g = g >> 4 | g;
                b = color & 15;
                b = b << 4 | b;
            } else if (format.length === 7) {
                r = (color & 16711680) >> 16;
                g = (color & 65280) >> 8;
                b = color & 255;
            }
        }
        return rgb(r, g, b);
    }
    function d3_rgb_hsl(r, g, b) {
        var min = Math.min(r /= 255, g /= 255, b /= 255), max = Math.max(r, g, b), d = max - min, h, s, l = (max + min) / 2;
        if (d) {
            s = l < .5 ? d / (max + min) : d / (2 - max - min);
            if (r == max) h = (g - b) / d + (g < b ? 6 : 0); else if (g == max) h = (b - r) / d + 2; else h = (r - g) / d + 4;
            h *= 60;
        } else {
            h = NaN;
            s = l > 0 && l < 1 ? 0 : h;
        }
        return new d3_hsl(h, s, l);
    }
    function d3_rgb_lab(r, g, b) {
        r = d3_rgb_xyz(r);
        g = d3_rgb_xyz(g);
        b = d3_rgb_xyz(b);
        var x = d3_xyz_lab((.4124564 * r + .3575761 * g + .1804375 * b) / d3_lab_X), y = d3_xyz_lab((.2126729 * r + .7151522 * g + .072175 * b) / d3_lab_Y), z = d3_xyz_lab((.0193339 * r + .119192 * g + .9503041 * b) / d3_lab_Z);
        return d3_lab(116 * y - 16, 500 * (x - y), 200 * (y - z));
    }
    function d3_rgb_xyz(r) {
        return (r /= 255) <= .04045 ? r / 12.92 : Math.pow((r + .055) / 1.055, 2.4);
    }
    function d3_rgb_parseNumber(c) {
        var f = parseFloat(c);
        return c.charAt(c.length - 1) === "%" ? Math.round(f * 2.55) : f;
    }
    var d3_rgb_names = d3.map({
        aliceblue: 15792383,
        antiquewhite: 16444375,
        aqua: 65535,
        aquamarine: 8388564,
        azure: 15794175,
        beige: 16119260,
        bisque: 16770244,
        black: 0,
        blanchedalmond: 16772045,
        blue: 255,
        blueviolet: 9055202,
        brown: 10824234,
        burlywood: 14596231,
        cadetblue: 6266528,
        chartreuse: 8388352,
        chocolate: 13789470,
        coral: 16744272,
        cornflowerblue: 6591981,
        cornsilk: 16775388,
        crimson: 14423100,
        cyan: 65535,
        darkblue: 139,
        darkcyan: 35723,
        darkgoldenrod: 12092939,
        darkgray: 11119017,
        darkgreen: 25600,
        darkgrey: 11119017,
        darkkhaki: 12433259,
        darkmagenta: 9109643,
        darkolivegreen: 5597999,
        darkorange: 16747520,
        darkorchid: 10040012,
        darkred: 9109504,
        darksalmon: 15308410,
        darkseagreen: 9419919,
        darkslateblue: 4734347,
        darkslategray: 3100495,
        darkslategrey: 3100495,
        darkturquoise: 52945,
        darkviolet: 9699539,
        deeppink: 16716947,
        deepskyblue: 49151,
        dimgray: 6908265,
        dimgrey: 6908265,
        dodgerblue: 2003199,
        firebrick: 11674146,
        floralwhite: 16775920,
        forestgreen: 2263842,
        fuchsia: 16711935,
        gainsboro: 14474460,
        ghostwhite: 16316671,
        gold: 16766720,
        goldenrod: 14329120,
        gray: 8421504,
        green: 32768,
        greenyellow: 11403055,
        grey: 8421504,
        honeydew: 15794160,
        hotpink: 16738740,
        indianred: 13458524,
        indigo: 4915330,
        ivory: 16777200,
        khaki: 15787660,
        lavender: 15132410,
        lavenderblush: 16773365,
        lawngreen: 8190976,
        lemonchiffon: 16775885,
        lightblue: 11393254,
        lightcoral: 15761536,
        lightcyan: 14745599,
        lightgoldenrodyellow: 16448210,
        lightgray: 13882323,
        lightgreen: 9498256,
        lightgrey: 13882323,
        lightpink: 16758465,
        lightsalmon: 16752762,
        lightseagreen: 2142890,
        lightskyblue: 8900346,
        lightslategray: 7833753,
        lightslategrey: 7833753,
        lightsteelblue: 11584734,
        lightyellow: 16777184,
        lime: 65280,
        limegreen: 3329330,
        linen: 16445670,
        magenta: 16711935,
        maroon: 8388608,
        mediumaquamarine: 6737322,
        mediumblue: 205,
        mediumorchid: 12211667,
        mediumpurple: 9662683,
        mediumseagreen: 3978097,
        mediumslateblue: 8087790,
        mediumspringgreen: 64154,
        mediumturquoise: 4772300,
        mediumvioletred: 13047173,
        midnightblue: 1644912,
        mintcream: 16121850,
        mistyrose: 16770273,
        moccasin: 16770229,
        navajowhite: 16768685,
        navy: 128,
        oldlace: 16643558,
        olive: 8421376,
        olivedrab: 7048739,
        orange: 16753920,
        orangered: 16729344,
        orchid: 14315734,
        palegoldenrod: 15657130,
        palegreen: 10025880,
        paleturquoise: 11529966,
        palevioletred: 14381203,
        papayawhip: 16773077,
        peachpuff: 16767673,
        peru: 13468991,
        pink: 16761035,
        plum: 14524637,
        powderblue: 11591910,
        purple: 8388736,
        rebeccapurple: 6697881,
        red: 16711680,
        rosybrown: 12357519,
        royalblue: 4286945,
        saddlebrown: 9127187,
        salmon: 16416882,
        sandybrown: 16032864,
        seagreen: 3050327,
        seashell: 16774638,
        sienna: 10506797,
        silver: 12632256,
        skyblue: 8900331,
        slateblue: 6970061,
        slategray: 7372944,
        slategrey: 7372944,
        snow: 16775930,
        springgreen: 65407,
        steelblue: 4620980,
        tan: 13808780,
        teal: 32896,
        thistle: 14204888,
        tomato: 16737095,
        turquoise: 4251856,
        violet: 15631086,
        wheat: 16113331,
        white: 16777215,
        whitesmoke: 16119285,
        yellow: 16776960,
        yellowgreen: 10145074
    });
    d3_rgb_names.forEach(function(key, value) {
        d3_rgb_names.set(key, d3_rgbNumber(value));
    });
    function d3_functor(v) {
        return typeof v === "function" ? v : function() {
            return v;
        };
    }
    d3.functor = d3_functor;
    d3.xhr = d3_xhrType(d3_identity);
    function d3_xhrType(response) {
        return function(url, mimeType, callback) {
            if (arguments.length === 2 && typeof mimeType === "function") callback = mimeType,
                mimeType = null;
            return d3_xhr(url, mimeType, response, callback);
        };
    }
    function d3_xhr(url, mimeType, response, callback) {
        var xhr = {}, dispatch = d3.dispatch("beforesend", "progress", "load", "error"), headers = {}, request = new XMLHttpRequest(), responseType = null;
        if (this.XDomainRequest && !("withCredentials" in request) && /^(http(s)?:)?\/\//.test(url)) request = new XDomainRequest();
        "onload" in request ? request.onload = request.onerror = respond : request.onreadystatechange = function() {
            request.readyState > 3 && respond();
        };
        function respond() {
            var status = request.status, result;
            if (!status && d3_xhrHasResponse(request) || status >= 200 && status < 300 || status === 304) {
                try {
                    result = response.call(xhr, request);
                } catch (e) {
                    dispatch.error.call(xhr, e);
                    return;
                }
                dispatch.load.call(xhr, result);
            } else {
                dispatch.error.call(xhr, request);
            }
        }
        request.onprogress = function(event) {
            var o = d3.event;
            d3.event = event;
            try {
                dispatch.progress.call(xhr, request);
            } finally {
                d3.event = o;
            }
        };
        xhr.header = function(name, value) {
            name = (name + "").toLowerCase();
            if (arguments.length < 2) return headers[name];
            if (value == null) delete headers[name]; else headers[name] = value + "";
            return xhr;
        };
        xhr.mimeType = function(value) {
            if (!arguments.length) return mimeType;
            mimeType = value == null ? null : value + "";
            return xhr;
        };
        xhr.responseType = function(value) {
            if (!arguments.length) return responseType;
            responseType = value;
            return xhr;
        };
        xhr.response = function(value) {
            response = value;
            return xhr;
        };
        [ "get", "post" ].forEach(function(method) {
            xhr[method] = function() {
                return xhr.send.apply(xhr, [ method ].concat(d3_array(arguments)));
            };
        });
        xhr.send = function(method, data, callback) {
            if (arguments.length === 2 && typeof data === "function") callback = data, data = null;
            request.open(method, url, false);
            if (mimeType != null && !("accept" in headers)) headers["accept"] = mimeType + ",*/*";
            if (request.setRequestHeader) for (var name in headers) request.setRequestHeader(name, headers[name]);
            if (mimeType != null && request.overrideMimeType) request.overrideMimeType(mimeType);
            if (responseType != null) request.responseType = responseType;
            if (callback != null) xhr.on("error", callback).on("load", function(request) {
                callback(null, request);
            });
            dispatch.beforesend.call(xhr, request);
            request.send(data == null ? null : data);
            return xhr;
        };
        xhr.abort = function() {
            request.abort();
            return xhr;
        };
        d3.rebind(xhr, dispatch, "on");
        return callback == null ? xhr : xhr.get(d3_xhr_fixCallback(callback));
    }
    function d3_xhr_fixCallback(callback) {
        return callback.length === 1 ? function(error, request) {
            callback(error == null ? request : null);
        } : callback;
    }
    function d3_xhrHasResponse(request) {
        var type = request.responseType;
        return type && type !== "text" ? request.response : request.responseText;
    }
    d3.dsv = function(delimiter, mimeType) {
        var reFormat = new RegExp('["' + delimiter + "\n]"), delimiterCode = delimiter.charCodeAt(0);
        function dsv(url, row, callback) {
            if (arguments.length < 3) callback = row, row = null;
            var xhr = d3_xhr(url, mimeType, row == null ? response : typedResponse(row), callback);
            xhr.row = function(_) {
                return arguments.length ? xhr.response((row = _) == null ? response : typedResponse(_)) : row;
            };
            return xhr;
        }
        function response(request) {
            return dsv.parse(request.responseText);
        }
        function typedResponse(f) {
            return function(request) {
                return dsv.parse(request.responseText, f);
            };
        }
        dsv.parse = function(text, f) {
            var o;
            return dsv.parseRows(text, function(row, i) {
                if (o) return o(row, i - 1);
                var a = new Function("d", "return {" + row.map(function(name, i) {
                        return JSON.stringify(name) + ": d[" + i + "]";
                    }).join(",") + "}");
                o = f ? function(row, i) {
                    return f(a(row), i);
                } : a;
            });
        };
        dsv.parseRows = function(text, f) {
            var EOL = {}, EOF = {}, rows = [], N = text.length, I = 0, n = 0, t, eol;
            function token() {
                if (I >= N) return EOF;
                if (eol) return eol = false, EOL;
                var j = I;
                if (text.charCodeAt(j) === 34) {
                    var i = j;
                    while (i++ < N) {
                        if (text.charCodeAt(i) === 34) {
                            if (text.charCodeAt(i + 1) !== 34) break;
                            ++i;
                        }
                    }
                    I = i + 2;
                    var c = text.charCodeAt(i + 1);
                    if (c === 13) {
                        eol = true;
                        if (text.charCodeAt(i + 2) === 10) ++I;
                    } else if (c === 10) {
                        eol = true;
                    }
                    return text.slice(j + 1, i).replace(/""/g, '"');
                }
                while (I < N) {
                    var c = text.charCodeAt(I++), k = 1;
                    if (c === 10) eol = true; else if (c === 13) {
                        eol = true;
                        if (text.charCodeAt(I) === 10) ++I, ++k;
                    } else if (c !== delimiterCode) continue;
                    return text.slice(j, I - k);
                }
                return text.slice(j);
            }
            while ((t = token()) !== EOF) {
                var a = [];
                while (t !== EOL && t !== EOF) {
                    a.push(t);
                    t = token();
                }
                if (f && (a = f(a, n++)) == null) continue;
                rows.push(a);
            }
            return rows;
        };
        dsv.format = function(rows) {
            if (Array.isArray(rows[0])) return dsv.formatRows(rows);
            var fieldSet = new d3_Set(), fields = [];
            rows.forEach(function(row) {
                for (var field in row) {
                    if (!fieldSet.has(field)) {
                        fields.push(fieldSet.add(field));
                    }
                }
            });
            return [ fields.map(formatValue).join(delimiter) ].concat(rows.map(function(row) {
                return fields.map(function(field) {
                    return formatValue(row[field]);
                }).join(delimiter);
            })).join("\n");
        };
        dsv.formatRows = function(rows) {
            return rows.map(formatRow).join("\n");
        };
        function formatRow(row) {
            return row.map(formatValue).join(delimiter);
        }
        function formatValue(text) {
            return reFormat.test(text) ? '"' + text.replace(/\"/g, '""') + '"' : text;
        }
        return dsv;
    };
    d3.csv = d3.dsv(",", "text/csv");
    d3.tsv = d3.dsv("	", "text/tab-separated-values");
    var d3_timer_queueHead, d3_timer_queueTail, d3_timer_interval, d3_timer_timeout, d3_timer_active, d3_timer_frame = this[d3_vendorSymbol(this, "requestAnimationFrame")] || function(callback) {
            setTimeout(callback, 17);
        };
    d3.timer = function(callback, delay, then) {
        var n = arguments.length;
        if (n < 2) delay = 0;
        if (n < 3) then = Date.now();
        var time = then + delay, timer = {
            c: callback,
            t: time,
            f: false,
            n: null
        };
        if (d3_timer_queueTail) d3_timer_queueTail.n = timer; else d3_timer_queueHead = timer;
        d3_timer_queueTail = timer;
        if (!d3_timer_interval) {
            d3_timer_timeout = clearTimeout(d3_timer_timeout);
            d3_timer_interval = 1;
            d3_timer_frame(d3_timer_step);
        }
    };
    function d3_timer_step() {
        var now = d3_timer_mark(), delay = d3_timer_sweep() - now;
        if (delay > 24) {
            if (isFinite(delay)) {
                clearTimeout(d3_timer_timeout);
                d3_timer_timeout = setTimeout(d3_timer_step, delay);
            }
            d3_timer_interval = 0;
        } else {
            d3_timer_interval = 1;
            d3_timer_frame(d3_timer_step);
        }
    }
    d3.timer.flush = function() {
        d3_timer_mark();
        d3_timer_sweep();
    };
    function d3_timer_mark() {
        var now = Date.now();
        d3_timer_active = d3_timer_queueHead;
        while (d3_timer_active) {
            if (now >= d3_timer_active.t) d3_timer_active.f = d3_timer_active.c(now - d3_timer_active.t);
            d3_timer_active = d3_timer_active.n;
        }
        return now;
    }
    function d3_timer_sweep() {
        var t0, t1 = d3_timer_queueHead, time = Infinity;
        while (t1) {
            if (t1.f) {
                t1 = t0 ? t0.n = t1.n : d3_timer_queueHead = t1.n;
            } else {
                if (t1.t < time) time = t1.t;
                t1 = (t0 = t1).n;
            }
        }
        d3_timer_queueTail = t0;
        return time;
    }
    function d3_format_precision(x, p) {
        return p - (x ? Math.ceil(Math.log(x) / Math.LN10) : 1);
    }
    d3.round = function(x, n) {
        return n ? Math.round(x * (n = Math.pow(10, n))) / n : Math.round(x);
    };
    var d3_formatPrefixes = [ "y", "z", "a", "f", "p", "n", "?", "m", "", "k", "M", "G", "T", "P", "E", "Z", "Y" ].map(d3_formatPrefix);
    d3.formatPrefix = function(value, precision) {
        var i = 0;
        if (value) {
            if (value < 0) value *= -1;
            if (precision) value = d3.round(value, d3_format_precision(value, precision));
            i = 1 + Math.floor(1e-12 + Math.log(value) / Math.LN10);
            i = Math.max(-24, Math.min(24, Math.floor((i - 1) / 3) * 3));
        }
        return d3_formatPrefixes[8 + i / 3];
    };
    function d3_formatPrefix(d, i) {
        var k = Math.pow(10, abs(8 - i) * 3);
        return {
            scale: i > 8 ? function(d) {
                return d / k;
            } : function(d) {
                return d * k;
            },
            symbol: d
        };
    }
    function d3_locale_numberFormat(locale) {
        var locale_decimal = locale.decimal, locale_thousands = locale.thousands, locale_grouping = locale.grouping, locale_currency = locale.currency, formatGroup = locale_grouping && locale_thousands ? function(value, width) {
            var i = value.length, t = [], j = 0, g = locale_grouping[0], length = 0;
            while (i > 0 && g > 0) {
                if (length + g + 1 > width) g = Math.max(1, width - length);
                t.push(value.substring(i -= g, i + g));
                if ((length += g + 1) > width) break;
                g = locale_grouping[j = (j + 1) % locale_grouping.length];
            }
            return t.reverse().join(locale_thousands);
        } : d3_identity;
        return function(specifier) {
            var match = d3_format_re.exec(specifier), fill = match[1] || " ", align = match[2] || ">", sign = match[3] || "-", symbol = match[4] || "", zfill = match[5], width = +match[6], comma = match[7], precision = match[8], type = match[9], scale = 1, prefix = "", suffix = "", integer = false, exponent = true;
            if (precision) precision = +precision.substring(1);
            if (zfill || fill === "0" && align === "=") {
                zfill = fill = "0";
                align = "=";
            }
            switch (type) {
                case "n":
                    comma = true;
                    type = "g";
                    break;

                case "%":
                    scale = 100;
                    suffix = "%";
                    type = "f";
                    break;

                case "p":
                    scale = 100;
                    suffix = "%";
                    type = "r";
                    break;

                case "b":
                case "o":
                case "x":
                case "X":
                    if (symbol === "#") prefix = "0" + type.toLowerCase();

                case "c":
                    exponent = false;

                case "d":
                    integer = true;
                    precision = 0;
                    break;

                case "s":
                    scale = -1;
                    type = "r";
                    break;
            }
            if (symbol === "$") prefix = locale_currency[0], suffix = locale_currency[1];
            if (type == "r" && !precision) type = "g";
            if (precision != null) {
                if (type == "g") precision = Math.max(1, Math.min(21, precision)); else if (type == "e" || type == "f") precision = Math.max(0, Math.min(20, precision));
            }
            type = d3_format_types.get(type) || d3_format_typeDefault;
            var zcomma = zfill && comma;
            return function(value) {
                var fullSuffix = suffix;
                if (integer && value % 1) return "";
                var negative = value < 0 || value === 0 && 1 / value < 0 ? (value = -value, "-") : sign === "-" ? "" : sign;
                if (scale < 0) {
                    var unit = d3.formatPrefix(value, precision);
                    value = unit.scale(value);
                    fullSuffix = unit.symbol + suffix;
                } else {
                    value *= scale;
                }
                value = type(value, precision);
                var i = value.lastIndexOf("."), before, after;
                if (i < 0) {
                    var j = exponent ? value.lastIndexOf("e") : -1;
                    if (j < 0) before = value, after = ""; else before = value.substring(0, j), after = value.substring(j);
                } else {
                    before = value.substring(0, i);
                    after = locale_decimal + value.substring(i + 1);
                }
                if (!zfill && comma) before = formatGroup(before, Infinity);
                var length = prefix.length + before.length + after.length + (zcomma ? 0 : negative.length), padding = length < width ? new Array(length = width - length + 1).join(fill) : "";
                if (zcomma) before = formatGroup(padding + before, padding.length ? width - after.length : Infinity);
                negative += prefix;
                value = before + after;
                return (align === "<" ? negative + value + padding : align === ">" ? padding + negative + value : align === "^" ? padding.substring(0, length >>= 1) + negative + value + padding.substring(length) : negative + (zcomma ? value : padding + value)) + fullSuffix;
            };
        };
    }
    var d3_format_re = /(?:([^{])?([<>=^]))?([+\- ])?([$#])?(0)?(\d+)?(,)?(\.-?\d+)?([a-z%])?/i;
    var d3_format_types = d3.map({
        b: function(x) {
            return x.toString(2);
        },
        c: function(x) {
            return String.fromCharCode(x);
        },
        o: function(x) {
            return x.toString(8);
        },
        x: function(x) {
            return x.toString(16);
        },
        X: function(x) {
            return x.toString(16).toUpperCase();
        },
        g: function(x, p) {
            return x.toPrecision(p);
        },
        e: function(x, p) {
            return x.toExponential(p);
        },
        f: function(x, p) {
            return x.toFixed(p);
        },
        r: function(x, p) {
            return (x = d3.round(x, d3_format_precision(x, p))).toFixed(Math.max(0, Math.min(20, d3_format_precision(x * (1 + 1e-15), p))));
        }
    });
    function d3_format_typeDefault(x) {
        return x + "";
    }
    var d3_time = d3.time = {}, d3_date = Date;
    function d3_date_utc() {
        this._ = new Date(arguments.length > 1 ? Date.UTC.apply(this, arguments) : arguments[0]);
    }
    d3_date_utc.prototype = {
        getDate: function() {
            return this._.getUTCDate();
        },
        getDay: function() {
            return this._.getUTCDay();
        },
        getFullYear: function() {
            return this._.getUTCFullYear();
        },
        getHours: function() {
            return this._.getUTCHours();
        },
        getMilliseconds: function() {
            return this._.getUTCMilliseconds();
        },
        getMinutes: function() {
            return this._.getUTCMinutes();
        },
        getMonth: function() {
            return this._.getUTCMonth();
        },
        getSeconds: function() {
            return this._.getUTCSeconds();
        },
        getTime: function() {
            return this._.getTime();
        },
        getTimezoneOffset: function() {
            return 0;
        },
        valueOf: function() {
            return this._.valueOf();
        },
        setDate: function() {
            d3_time_prototype.setUTCDate.apply(this._, arguments);
        },
        setDay: function() {
            d3_time_prototype.setUTCDay.apply(this._, arguments);
        },
        setFullYear: function() {
            d3_time_prototype.setUTCFullYear.apply(this._, arguments);
        },
        setHours: function() {
            d3_time_prototype.setUTCHours.apply(this._, arguments);
        },
        setMilliseconds: function() {
            d3_time_prototype.setUTCMilliseconds.apply(this._, arguments);
        },
        setMinutes: function() {
            d3_time_prototype.setUTCMinutes.apply(this._, arguments);
        },
        setMonth: function() {
            d3_time_prototype.setUTCMonth.apply(this._, arguments);
        },
        setSeconds: function() {
            d3_time_prototype.setUTCSeconds.apply(this._, arguments);
        },
        setTime: function() {
            d3_time_prototype.setTime.apply(this._, arguments);
        }
    };
    var d3_time_prototype = Date.prototype;
    function d3_time_interval(local, step, number) {
        function round(date) {
            var d0 = local(date), d1 = offset(d0, 1);
            return date - d0 < d1 - date ? d0 : d1;
        }
        function ceil(date) {
            step(date = local(new d3_date(date - 1)), 1);
            return date;
        }
        function offset(date, k) {
            step(date = new d3_date(+date), k);
            return date;
        }
        function range(t0, t1, dt) {
            var time = ceil(t0), times = [];
            if (dt > 1) {
                while (time < t1) {
                    if (!(number(time) % dt)) times.push(new Date(+time));
                    step(time, 1);
                }
            } else {
                while (time < t1) times.push(new Date(+time)), step(time, 1);
            }
            return times;
        }
        function range_utc(t0, t1, dt) {
            try {
                d3_date = d3_date_utc;
                var utc = new d3_date_utc();
                utc._ = t0;
                return range(utc, t1, dt);
            } finally {
                d3_date = Date;
            }
        }
        local.floor = local;
        local.round = round;
        local.ceil = ceil;
        local.offset = offset;
        local.range = range;
        var utc = local.utc = d3_time_interval_utc(local);
        utc.floor = utc;
        utc.round = d3_time_interval_utc(round);
        utc.ceil = d3_time_interval_utc(ceil);
        utc.offset = d3_time_interval_utc(offset);
        utc.range = range_utc;
        return local;
    }
    function d3_time_interval_utc(method) {
        return function(date, k) {
            try {
                d3_date = d3_date_utc;
                var utc = new d3_date_utc();
                utc._ = date;
                return method(utc, k)._;
            } finally {
                d3_date = Date;
            }
        };
    }
    d3_time.year = d3_time_interval(function(date) {
        date = d3_time.day(date);
        date.setMonth(0, 1);
        return date;
    }, function(date, offset) {
        date.setFullYear(date.getFullYear() + offset);
    }, function(date) {
        return date.getFullYear();
    });
    d3_time.years = d3_time.year.range;
    d3_time.years.utc = d3_time.year.utc.range;
    d3_time.day = d3_time_interval(function(date) {
        var day = new d3_date(2e3, 0);
        day.setFullYear(date.getFullYear(), date.getMonth(), date.getDate());
        return day;
    }, function(date, offset) {
        date.setDate(date.getDate() + offset);
    }, function(date) {
        return date.getDate() - 1;
    });
    d3_time.days = d3_time.day.range;
    d3_time.days.utc = d3_time.day.utc.range;
    d3_time.dayOfYear = function(date) {
        var year = d3_time.year(date);
        return Math.floor((date - year - (date.getTimezoneOffset() - year.getTimezoneOffset()) * 6e4) / 864e5);
    };
    [ "sunday", "monday", "tuesday", "wednesday", "thursday", "friday", "saturday" ].forEach(function(day, i) {
        i = 7 - i;
        var interval = d3_time[day] = d3_time_interval(function(date) {
            (date = d3_time.day(date)).setDate(date.getDate() - (date.getDay() + i) % 7);
            return date;
        }, function(date, offset) {
            date.setDate(date.getDate() + Math.floor(offset) * 7);
        }, function(date) {
            var day = d3_time.year(date).getDay();
            return Math.floor((d3_time.dayOfYear(date) + (day + i) % 7) / 7) - (day !== i);
        });
        d3_time[day + "s"] = interval.range;
        d3_time[day + "s"].utc = interval.utc.range;
        d3_time[day + "OfYear"] = function(date) {
            var day = d3_time.year(date).getDay();
            return Math.floor((d3_time.dayOfYear(date) + (day + i) % 7) / 7);
        };
    });
    d3_time.week = d3_time.sunday;
    d3_time.weeks = d3_time.sunday.range;
    d3_time.weeks.utc = d3_time.sunday.utc.range;
    d3_time.weekOfYear = d3_time.sundayOfYear;
    function d3_locale_timeFormat(locale) {
        var locale_dateTime = locale.dateTime, locale_date = locale.date, locale_time = locale.time, locale_periods = locale.periods, locale_days = locale.days, locale_shortDays = locale.shortDays, locale_months = locale.months, locale_shortMonths = locale.shortMonths;
        function d3_time_format(template) {
            var n = template.length;
            function format(date) {
                var string = [], i = -1, j = 0, c, p, f;
                while (++i < n) {
                    if (template.charCodeAt(i) === 37) {
                        string.push(template.slice(j, i));
                        if ((p = d3_time_formatPads[c = template.charAt(++i)]) != null) c = template.charAt(++i);
                        if (f = d3_time_formats[c]) c = f(date, p == null ? c === "e" ? " " : "0" : p);
                        string.push(c);
                        j = i + 1;
                    }
                }
                string.push(template.slice(j, i));
                return string.join("");
            }
            format.parse = function(string) {
                var d = {
                    y: 1900,
                    m: 0,
                    d: 1,
                    H: 0,
                    M: 0,
                    S: 0,
                    L: 0,
                    Z: null
                }, i = d3_time_parse(d, template, string, 0);
                if (i != string.length) return null;
                if ("p" in d) d.H = d.H % 12 + d.p * 12;
                var localZ = d.Z != null && d3_date !== d3_date_utc, date = new (localZ ? d3_date_utc : d3_date)();
                if ("j" in d) date.setFullYear(d.y, 0, d.j); else if ("w" in d && ("W" in d || "U" in d)) {
                    date.setFullYear(d.y, 0, 1);
                    date.setFullYear(d.y, 0, "W" in d ? (d.w + 6) % 7 + d.W * 7 - (date.getDay() + 5) % 7 : d.w + d.U * 7 - (date.getDay() + 6) % 7);
                } else date.setFullYear(d.y, d.m, d.d);
                date.setHours(d.H + (d.Z / 100 | 0), d.M + d.Z % 100, d.S, d.L);
                return localZ ? date._ : date;
            };
            format.toString = function() {
                return template;
            };
            return format;
        }
        function d3_time_parse(date, template, string, j) {
            var c, p, t, i = 0, n = template.length, m = string.length;
            while (i < n) {
                if (j >= m) return -1;
                c = template.charCodeAt(i++);
                if (c === 37) {
                    t = template.charAt(i++);
                    p = d3_time_parsers[t in d3_time_formatPads ? template.charAt(i++) : t];
                    if (!p || (j = p(date, string, j)) < 0) return -1;
                } else if (c != string.charCodeAt(j++)) {
                    return -1;
                }
            }
            return j;
        }
        d3_time_format.utc = function(template) {
            var local = d3_time_format(template);
            function format(date) {
                try {
                    d3_date = d3_date_utc;
                    var utc = new d3_date();
                    utc._ = date;
                    return local(utc);
                } finally {
                    d3_date = Date;
                }
            }
            format.parse = function(string) {
                try {
                    d3_date = d3_date_utc;
                    var date = local.parse(string);
                    return date && date._;
                } finally {
                    d3_date = Date;
                }
            };
            format.toString = local.toString;
            return format;
        };
        d3_time_format.multi = d3_time_format.utc.multi = d3_time_formatMulti;
        var d3_time_periodLookup = d3.map(), d3_time_dayRe = d3_time_formatRe(locale_days), d3_time_dayLookup = d3_time_formatLookup(locale_days), d3_time_dayAbbrevRe = d3_time_formatRe(locale_shortDays), d3_time_dayAbbrevLookup = d3_time_formatLookup(locale_shortDays), d3_time_monthRe = d3_time_formatRe(locale_months), d3_time_monthLookup = d3_time_formatLookup(locale_months), d3_time_monthAbbrevRe = d3_time_formatRe(locale_shortMonths), d3_time_monthAbbrevLookup = d3_time_formatLookup(locale_shortMonths);
        locale_periods.forEach(function(p, i) {
            d3_time_periodLookup.set(p.toLowerCase(), i);
        });
        var d3_time_formats = {
            a: function(d) {
                return locale_shortDays[d.getDay()];
            },
            A: function(d) {
                return locale_days[d.getDay()];
            },
            b: function(d) {
                return locale_shortMonths[d.getMonth()];
            },
            B: function(d) {
                return locale_months[d.getMonth()];
            },
            c: d3_time_format(locale_dateTime),
            d: function(d, p) {
                return d3_time_formatPad(d.getDate(), p, 2);
            },
            e: function(d, p) {
                return d3_time_formatPad(d.getDate(), p, 2);
            },
            H: function(d, p) {
                return d3_time_formatPad(d.getHours(), p, 2);
            },
            I: function(d, p) {
                return d3_time_formatPad(d.getHours() % 12 || 12, p, 2);
            },
            j: function(d, p) {
                return d3_time_formatPad(1 + d3_time.dayOfYear(d), p, 3);
            },
            L: function(d, p) {
                return d3_time_formatPad(d.getMilliseconds(), p, 3);
            },
            m: function(d, p) {
                return d3_time_formatPad(d.getMonth() + 1, p, 2);
            },
            M: function(d, p) {
                return d3_time_formatPad(d.getMinutes(), p, 2);
            },
            p: function(d) {
                return locale_periods[+(d.getHours() >= 12)];
            },
            S: function(d, p) {
                return d3_time_formatPad(d.getSeconds(), p, 2);
            },
            U: function(d, p) {
                return d3_time_formatPad(d3_time.sundayOfYear(d), p, 2);
            },
            w: function(d) {
                return d.getDay();
            },
            W: function(d, p) {
                return d3_time_formatPad(d3_time.mondayOfYear(d), p, 2);
            },
            x: d3_time_format(locale_date),
            X: d3_time_format(locale_time),
            y: function(d, p) {
                return d3_time_formatPad(d.getFullYear() % 100, p, 2);
            },
            Y: function(d, p) {
                return d3_time_formatPad(d.getFullYear() % 1e4, p, 4);
            },
            Z: d3_time_zone,
            "%": function() {
                return "%";
            }
        };
        var d3_time_parsers = {
            a: d3_time_parseWeekdayAbbrev,
            A: d3_time_parseWeekday,
            b: d3_time_parseMonthAbbrev,
            B: d3_time_parseMonth,
            c: d3_time_parseLocaleFull,
            d: d3_time_parseDay,
            e: d3_time_parseDay,
            H: d3_time_parseHour24,
            I: d3_time_parseHour24,
            j: d3_time_parseDayOfYear,
            L: d3_time_parseMilliseconds,
            m: d3_time_parseMonthNumber,
            M: d3_time_parseMinutes,
            p: d3_time_parseAmPm,
            S: d3_time_parseSeconds,
            U: d3_time_parseWeekNumberSunday,
            w: d3_time_parseWeekdayNumber,
            W: d3_time_parseWeekNumberMonday,
            x: d3_time_parseLocaleDate,
            X: d3_time_parseLocaleTime,
            y: d3_time_parseYear,
            Y: d3_time_parseFullYear,
            Z: d3_time_parseZone,
            "%": d3_time_parseLiteralPercent
        };
        function d3_time_parseWeekdayAbbrev(date, string, i) {
            d3_time_dayAbbrevRe.lastIndex = 0;
            var n = d3_time_dayAbbrevRe.exec(string.slice(i));
            return n ? (date.w = d3_time_dayAbbrevLookup.get(n[0].toLowerCase()), i + n[0].length) : -1;
        }
        function d3_time_parseWeekday(date, string, i) {
            d3_time_dayRe.lastIndex = 0;
            var n = d3_time_dayRe.exec(string.slice(i));
            return n ? (date.w = d3_time_dayLookup.get(n[0].toLowerCase()), i + n[0].length) : -1;
        }
        function d3_time_parseMonthAbbrev(date, string, i) {
            d3_time_monthAbbrevRe.lastIndex = 0;
            var n = d3_time_monthAbbrevRe.exec(string.slice(i));
            return n ? (date.m = d3_time_monthAbbrevLookup.get(n[0].toLowerCase()), i + n[0].length) : -1;
        }
        function d3_time_parseMonth(date, string, i) {
            d3_time_monthRe.lastIndex = 0;
            var n = d3_time_monthRe.exec(string.slice(i));
            return n ? (date.m = d3_time_monthLookup.get(n[0].toLowerCase()), i + n[0].length) : -1;
        }
        function d3_time_parseLocaleFull(date, string, i) {
            return d3_time_parse(date, d3_time_formats.c.toString(), string, i);
        }
        function d3_time_parseLocaleDate(date, string, i) {
            return d3_time_parse(date, d3_time_formats.x.toString(), string, i);
        }
        function d3_time_parseLocaleTime(date, string, i) {
            return d3_time_parse(date, d3_time_formats.X.toString(), string, i);
        }
        function d3_time_parseAmPm(date, string, i) {
            var n = d3_time_periodLookup.get(string.slice(i, i += 2).toLowerCase());
            return n == null ? -1 : (date.p = n, i);
        }
        return d3_time_format;
    }
    var d3_time_formatPads = {
        "-": "",
        _: " ",
        "0": "0"
    }, d3_time_numberRe = /^\s*\d+/, d3_time_percentRe = /^%/;
    function d3_time_formatPad(value, fill, width) {
        var sign = value < 0 ? "-" : "", string = (sign ? -value : value) + "", length = string.length;
        return sign + (length < width ? new Array(width - length + 1).join(fill) + string : string);
    }
    function d3_time_formatRe(names) {
        return new RegExp("^(?:" + names.map(d3.requote).join("|") + ")", "i");
    }
    function d3_time_formatLookup(names) {
        var map = new d3_Map(), i = -1, n = names.length;
        while (++i < n) map.set(names[i].toLowerCase(), i);
        return map;
    }
    function d3_time_parseWeekdayNumber(date, string, i) {
        d3_time_numberRe.lastIndex = 0;
        var n = d3_time_numberRe.exec(string.slice(i, i + 1));
        return n ? (date.w = +n[0], i + n[0].length) : -1;
    }
    function d3_time_parseWeekNumberSunday(date, string, i) {
        d3_time_numberRe.lastIndex = 0;
        var n = d3_time_numberRe.exec(string.slice(i));
        return n ? (date.U = +n[0], i + n[0].length) : -1;
    }
    function d3_time_parseWeekNumberMonday(date, string, i) {
        d3_time_numberRe.lastIndex = 0;
        var n = d3_time_numberRe.exec(string.slice(i));
        return n ? (date.W = +n[0], i + n[0].length) : -1;
    }
    function d3_time_parseFullYear(date, string, i) {
        d3_time_numberRe.lastIndex = 0;
        var n = d3_time_numberRe.exec(string.slice(i, i + 4));
        return n ? (date.y = +n[0], i + n[0].length) : -1;
    }
    function d3_time_parseYear(date, string, i) {
        d3_time_numberRe.lastIndex = 0;
        var n = d3_time_numberRe.exec(string.slice(i, i + 2));
        return n ? (date.y = d3_time_expandYear(+n[0]), i + n[0].length) : -1;
    }
    function d3_time_parseZone(date, string, i) {
        return /^[+-]\d{4}$/.test(string = string.slice(i, i + 5)) ? (date.Z = -string,
        i + 5) : -1;
    }
    function d3_time_expandYear(d) {
        return d + (d > 68 ? 1900 : 2e3);
    }
    function d3_time_parseMonthNumber(date, string, i) {
        d3_time_numberRe.lastIndex = 0;
        var n = d3_time_numberRe.exec(string.slice(i, i + 2));
        return n ? (date.m = n[0] - 1, i + n[0].length) : -1;
    }
    function d3_time_parseDay(date, string, i) {
        d3_time_numberRe.lastIndex = 0;
        var n = d3_time_numberRe.exec(string.slice(i, i + 2));
        return n ? (date.d = +n[0], i + n[0].length) : -1;
    }
    function d3_time_parseDayOfYear(date, string, i) {
        d3_time_numberRe.lastIndex = 0;
        var n = d3_time_numberRe.exec(string.slice(i, i + 3));
        return n ? (date.j = +n[0], i + n[0].length) : -1;
    }
    function d3_time_parseHour24(date, string, i) {
        d3_time_numberRe.lastIndex = 0;
        var n = d3_time_numberRe.exec(string.slice(i, i + 2));
        return n ? (date.H = +n[0], i + n[0].length) : -1;
    }
    function d3_time_parseMinutes(date, string, i) {
        d3_time_numberRe.lastIndex = 0;
        var n = d3_time_numberRe.exec(string.slice(i, i + 2));
        return n ? (date.M = +n[0], i + n[0].length) : -1;
    }
    function d3_time_parseSeconds(date, string, i) {
        d3_time_numberRe.lastIndex = 0;
        var n = d3_time_numberRe.exec(string.slice(i, i + 2));
        return n ? (date.S = +n[0], i + n[0].length) : -1;
    }
    function d3_time_parseMilliseconds(date, string, i) {
        d3_time_numberRe.lastIndex = 0;
        var n = d3_time_numberRe.exec(string.slice(i, i + 3));
        return n ? (date.L = +n[0], i + n[0].length) : -1;
    }
    function d3_time_zone(d) {
        var z = d.getTimezoneOffset(), zs = z > 0 ? "-" : "+", zh = abs(z) / 60 | 0, zm = abs(z) % 60;
        return zs + d3_time_formatPad(zh, "0", 2) + d3_time_formatPad(zm, "0", 2);
    }
    function d3_time_parseLiteralPercent(date, string, i) {
        d3_time_percentRe.lastIndex = 0;
        var n = d3_time_percentRe.exec(string.slice(i, i + 1));
        return n ? i + n[0].length : -1;
    }
    function d3_time_formatMulti(formats) {
        var n = formats.length, i = -1;
        while (++i < n) formats[i][0] = this(formats[i][0]);
        return function(date) {
            var i = 0, f = formats[i];
            while (!f[1](date)) f = formats[++i];
            return f[0](date);
        };
    }
    d3.locale = function(locale) {
        return {
            numberFormat: d3_locale_numberFormat(locale),
            timeFormat: d3_locale_timeFormat(locale)
        };
    };
    var d3_locale_enUS = d3.locale({
        decimal: ".",
        thousands: ",",
        grouping: [ 3 ],
        currency: [ "$", "" ],
        dateTime: "%a %b %e %X %Y",
        date: "%m/%d/%Y",
        time: "%H:%M:%S",
        periods: [ "AM", "PM" ],
        days: [ "Sunday", "Monday", "Tuesday", "Wednesday", "Thursday", "Friday", "Saturday" ],
        shortDays: [ "Sun", "Mon", "Tue", "Wed", "Thu", "Fri", "Sat" ],
        months: [ "January", "February", "March", "April", "May", "June", "July", "August", "September", "October", "November", "December" ],
        shortMonths: [ "Jan", "Feb", "Mar", "Apr", "May", "Jun", "Jul", "Aug", "Sep", "Oct", "Nov", "Dec" ]
    });
    d3.format = d3_locale_enUS.numberFormat;
    d3.geo = {};
    function d3_adder() {}
    d3_adder.prototype = {
        s: 0,
        t: 0,
        add: function(y) {
            d3_adderSum(y, this.t, d3_adderTemp);
            d3_adderSum(d3_adderTemp.s, this.s, this);
            if (this.s) this.t += d3_adderTemp.t; else this.s = d3_adderTemp.t;
        },
        reset: function() {
            this.s = this.t = 0;
        },
        valueOf: function() {
            return this.s;
        }
    };
    var d3_adderTemp = new d3_adder();
    function d3_adderSum(a, b, o) {
        var x = o.s = a + b, bv = x - a, av = x - bv;
        o.t = a - av + (b - bv);
    }
    d3.geo.stream = function(object, listener) {
        if (object && d3_geo_streamObjectType.hasOwnProperty(object.type)) {
            d3_geo_streamObjectType[object.type](object, listener);
        } else {
            d3_geo_streamGeometry(object, listener);
        }
    };
    function d3_geo_streamGeometry(geometry, listener) {
        if (geometry && d3_geo_streamGeometryType.hasOwnProperty(geometry.type)) {
            d3_geo_streamGeometryType[geometry.type](geometry, listener);
        }
    }
    var d3_geo_streamObjectType = {
        Feature: function(feature, listener) {
            d3_geo_streamGeometry(feature.geometry, listener);
        },
        FeatureCollection: function(object, listener) {
            var features = object.features, i = -1, n = features.length;
            while (++i < n) d3_geo_streamGeometry(features[i].geometry, listener);
        }
    };
    var d3_geo_streamGeometryType = {
        Sphere: function(object, listener) {
            listener.sphere();
        },
        Point: function(object, listener) {
            object = object.coordinates;
            listener.point(object[0], object[1], object[2]);
        },
        MultiPoint: function(object, listener) {
            var coordinates = object.coordinates, i = -1, n = coordinates.length;
            while (++i < n) object = coordinates[i], listener.point(object[0], object[1], object[2]);
        },
        LineString: function(object, listener) {
            d3_geo_streamLine(object.coordinates, listener, 0);
        },
        MultiLineString: function(object, listener) {
            var coordinates = object.coordinates, i = -1, n = coordinates.length;
            while (++i < n) d3_geo_streamLine(coordinates[i], listener, 0);
        },
        Polygon: function(object, listener) {
            d3_geo_streamPolygon(object.coordinates, listener);
        },
        MultiPolygon: function(object, listener) {
            var coordinates = object.coordinates, i = -1, n = coordinates.length;
            while (++i < n) d3_geo_streamPolygon(coordinates[i], listener);
        },
        GeometryCollection: function(object, listener) {
            var geometries = object.geometries, i = -1, n = geometries.length;
            while (++i < n) d3_geo_streamGeometry(geometries[i], listener);
        }
    };
    function d3_geo_streamLine(coordinates, listener, closed) {
        var i = -1, n = coordinates.length - closed, coordinate;
        listener.lineStart();
        while (++i < n) coordinate = coordinates[i], listener.point(coordinate[0], coordinate[1], coordinate[2]);
        listener.lineEnd();
    }
    function d3_geo_streamPolygon(coordinates, listener) {
        var i = -1, n = coordinates.length;
        listener.polygonStart();
        while (++i < n) d3_geo_streamLine(coordinates[i], listener, 1);
        listener.polygonEnd();
    }
    d3.geo.area = function(object) {
        d3_geo_areaSum = 0;
        d3.geo.stream(object, d3_geo_area);
        return d3_geo_areaSum;
    };
    var d3_geo_areaSum, d3_geo_areaRingSum = new d3_adder();
    var d3_geo_area = {
        sphere: function() {
            d3_geo_areaSum += 4 * π;
        },
        point: d3_noop,
        lineStart: d3_noop,
        lineEnd: d3_noop,
        polygonStart: function() {
            d3_geo_areaRingSum.reset();
            d3_geo_area.lineStart = d3_geo_areaRingStart;
        },
        polygonEnd: function() {
            var area = 2 * d3_geo_areaRingSum;
            d3_geo_areaSum += area < 0 ? 4 * π + area : area;
            d3_geo_area.lineStart = d3_geo_area.lineEnd = d3_geo_area.point = d3_noop;
        }
    };
    function d3_geo_areaRingStart() {
        var λ00, φ00, λ0, cosφ0, sinφ0;
        d3_geo_area.point = function(λ, φ) {
            d3_geo_area.point = nextPoint;
            λ0 = (λ00 = λ) * d3_radians, cosφ0 = Math.cos(φ = (φ00 = φ) * d3_radians / 2 + π / 4),
                sinφ0 = Math.sin(φ);
        };
        function nextPoint(λ, φ) {
            λ *= d3_radians;
            φ = φ * d3_radians / 2 + π / 4;
            var dλ = λ - λ0, sdλ = dλ >= 0 ? 1 : -1, adλ = sdλ * dλ, cosφ = Math.cos(φ), sinφ = Math.sin(φ), k = sinφ0 * sinφ, u = cosφ0 * cosφ + k * Math.cos(adλ), v = k * sdλ * Math.sin(adλ);
            d3_geo_areaRingSum.add(Math.atan2(v, u));
            λ0 = λ, cosφ0 = cosφ, sinφ0 = sinφ;
        }
        d3_geo_area.lineEnd = function() {
            nextPoint(λ00, φ00);
        };
    }
    function d3_geo_cartesian(spherical) {
        var λ = spherical[0], φ = spherical[1], cosφ = Math.cos(φ);
        return [ cosφ * Math.cos(λ), cosφ * Math.sin(λ), Math.sin(φ) ];
    }
    function d3_geo_cartesianDot(a, b) {
        return a[0] * b[0] + a[1] * b[1] + a[2] * b[2];
    }
    function d3_geo_cartesianCross(a, b) {
        return [ a[1] * b[2] - a[2] * b[1], a[2] * b[0] - a[0] * b[2], a[0] * b[1] - a[1] * b[0] ];
    }
    function d3_geo_cartesianAdd(a, b) {
        a[0] += b[0];
        a[1] += b[1];
        a[2] += b[2];
    }
    function d3_geo_cartesianScale(vector, k) {
        return [ vector[0] * k, vector[1] * k, vector[2] * k ];
    }
    function d3_geo_cartesianNormalize(d) {
        var l = Math.sqrt(d[0] * d[0] + d[1] * d[1] + d[2] * d[2]);
        d[0] /= l;
        d[1] /= l;
        d[2] /= l;
    }
    function d3_geo_spherical(cartesian) {
        return [ Math.atan2(cartesian[1], cartesian[0]), d3_asin(cartesian[2]) ];
    }
    function d3_geo_sphericalEqual(a, b) {
        return abs(a[0] - b[0]) < ε && abs(a[1] - b[1]) < ε;
    }
    d3.geo.bounds = function() {
        var λ0, φ0, λ1, φ1, λ_, λ__, φ__, p0, dλSum, ranges, range;
        var bound = {
            point: point,
            lineStart: lineStart,
            lineEnd: lineEnd,
            polygonStart: function() {
                bound.point = ringPoint;
                bound.lineStart = ringStart;
                bound.lineEnd = ringEnd;
                dλSum = 0;
                d3_geo_area.polygonStart();
            },
            polygonEnd: function() {
                d3_geo_area.polygonEnd();
                bound.point = point;
                bound.lineStart = lineStart;
                bound.lineEnd = lineEnd;
                if (d3_geo_areaRingSum < 0) λ0 = -(λ1 = 180), φ0 = -(φ1 = 90); else if (dλSum > ε) φ1 = 90; else if (dλSum < -ε) φ0 = -90;
                range[0] = λ0, range[1] = λ1;
            }
        };
        function point(λ, φ) {
            ranges.push(range = [ λ0 = λ, λ1 = λ ]);
            if (φ < φ0) φ0 = φ;
            if (φ > φ1) φ1 = φ;
        }
        function linePoint(λ, φ) {
            var p = d3_geo_cartesian([ λ * d3_radians, φ * d3_radians ]);
            if (p0) {
                var normal = d3_geo_cartesianCross(p0, p), equatorial = [ normal[1], -normal[0], 0 ], inflection = d3_geo_cartesianCross(equatorial, normal);
                d3_geo_cartesianNormalize(inflection);
                inflection = d3_geo_spherical(inflection);
                var dλ = λ - λ_, s = dλ > 0 ? 1 : -1, λi = inflection[0] * d3_degrees * s, antimeridian = abs(dλ) > 180;
                if (antimeridian ^ (s * λ_ < λi && λi < s * λ)) {
                    var φi = inflection[1] * d3_degrees;
                    if (φi > φ1) φ1 = φi;
                } else if (λi = (λi + 360) % 360 - 180, antimeridian ^ (s * λ_ < λi && λi < s * λ)) {
                    var φi = -inflection[1] * d3_degrees;
                    if (φi < φ0) φ0 = φi;
                } else {
                    if (φ < φ0) φ0 = φ;
                    if (φ > φ1) φ1 = φ;
                }
                if (antimeridian) {
                    if (λ < λ_) {
                        if (angle(λ0, λ) > angle(λ0, λ1)) λ1 = λ;
                    } else {
                        if (angle(λ, λ1) > angle(λ0, λ1)) λ0 = λ;
                    }
                } else {
                    if (λ1 >= λ0) {
                        if (λ < λ0) λ0 = λ;
                        if (λ > λ1) λ1 = λ;
                    } else {
                        if (λ > λ_) {
                            if (angle(λ0, λ) > angle(λ0, λ1)) λ1 = λ;
                        } else {
                            if (angle(λ, λ1) > angle(λ0, λ1)) λ0 = λ;
                        }
                    }
                }
            } else {
                point(λ, φ);
            }
            p0 = p, λ_ = λ;
        }
        function lineStart() {
            bound.point = linePoint;
        }
        function lineEnd() {
            range[0] = λ0, range[1] = λ1;
            bound.point = point;
            p0 = null;
        }
        function ringPoint(λ, φ) {
            if (p0) {
                var dλ = λ - λ_;
                dλSum += abs(dλ) > 180 ? dλ + (dλ > 0 ? 360 : -360) : dλ;
            } else λ__ = λ, φ__ = φ;
            d3_geo_area.point(λ, φ);
            linePoint(λ, φ);
        }
        function ringStart() {
            d3_geo_area.lineStart();
        }
        function ringEnd() {
            ringPoint(λ__, φ__);
            d3_geo_area.lineEnd();
            if (abs(dλSum) > ε) λ0 = -(λ1 = 180);
            range[0] = λ0, range[1] = λ1;
            p0 = null;
        }
        function angle(λ0, λ1) {
            return (λ1 -= λ0) < 0 ? λ1 + 360 : λ1;
        }
        function compareRanges(a, b) {
            return a[0] - b[0];
        }
        function withinRange(x, range) {
            return range[0] <= range[1] ? range[0] <= x && x <= range[1] : x < range[0] || range[1] < x;
        }
        return function(feature) {
            φ1 = λ1 = -(λ0 = φ0 = Infinity);
            ranges = [];
            d3.geo.stream(feature, bound);
            var n = ranges.length;
            if (n) {
                ranges.sort(compareRanges);
                for (var i = 1, a = ranges[0], b, merged = [ a ]; i < n; ++i) {
                    b = ranges[i];
                    if (withinRange(b[0], a) || withinRange(b[1], a)) {
                        if (angle(a[0], b[1]) > angle(a[0], a[1])) a[1] = b[1];
                        if (angle(b[0], a[1]) > angle(a[0], a[1])) a[0] = b[0];
                    } else {
                        merged.push(a = b);
                    }
                }
                var best = -Infinity, dλ;
                for (var n = merged.length - 1, i = 0, a = merged[n], b; i <= n; a = b, ++i) {
                    b = merged[i];
                    if ((dλ = angle(a[1], b[0])) > best) best = dλ, λ0 = b[0], λ1 = a[1];
                }
            }
            ranges = range = null;
            return λ0 === Infinity || φ0 === Infinity ? [ [ NaN, NaN ], [ NaN, NaN ] ] : [ [ λ0, φ0 ], [ λ1, φ1 ] ];
        };
    }();
    d3.geo.centroid = function(object) {
        d3_geo_centroidW0 = d3_geo_centroidW1 = d3_geo_centroidX0 = d3_geo_centroidY0 = d3_geo_centroidZ0 = d3_geo_centroidX1 = d3_geo_centroidY1 = d3_geo_centroidZ1 = d3_geo_centroidX2 = d3_geo_centroidY2 = d3_geo_centroidZ2 = 0;
        d3.geo.stream(object, d3_geo_centroid);
        var x = d3_geo_centroidX2, y = d3_geo_centroidY2, z = d3_geo_centroidZ2, m = x * x + y * y + z * z;
        if (m < ε2) {
            x = d3_geo_centroidX1, y = d3_geo_centroidY1, z = d3_geo_centroidZ1;
            if (d3_geo_centroidW1 < ε) x = d3_geo_centroidX0, y = d3_geo_centroidY0, z = d3_geo_centroidZ0;
            m = x * x + y * y + z * z;
            if (m < ε2) return [ NaN, NaN ];
        }
        return [ Math.atan2(y, x) * d3_degrees, d3_asin(z / Math.sqrt(m)) * d3_degrees ];
    };
    var d3_geo_centroidW0, d3_geo_centroidW1, d3_geo_centroidX0, d3_geo_centroidY0, d3_geo_centroidZ0, d3_geo_centroidX1, d3_geo_centroidY1, d3_geo_centroidZ1, d3_geo_centroidX2, d3_geo_centroidY2, d3_geo_centroidZ2;
    var d3_geo_centroid = {
        sphere: d3_noop,
        point: d3_geo_centroidPoint,
        lineStart: d3_geo_centroidLineStart,
        lineEnd: d3_geo_centroidLineEnd,
        polygonStart: function() {
            d3_geo_centroid.lineStart = d3_geo_centroidRingStart;
        },
        polygonEnd: function() {
            d3_geo_centroid.lineStart = d3_geo_centroidLineStart;
        }
    };
    function d3_geo_centroidPoint(λ, φ) {
        λ *= d3_radians;
        var cosφ = Math.cos(φ *= d3_radians);
        d3_geo_centroidPointXYZ(cosφ * Math.cos(λ), cosφ * Math.sin(λ), Math.sin(φ));
    }
    function d3_geo_centroidPointXYZ(x, y, z) {
        ++d3_geo_centroidW0;
        d3_geo_centroidX0 += (x - d3_geo_centroidX0) / d3_geo_centroidW0;
        d3_geo_centroidY0 += (y - d3_geo_centroidY0) / d3_geo_centroidW0;
        d3_geo_centroidZ0 += (z - d3_geo_centroidZ0) / d3_geo_centroidW0;
    }
    function d3_geo_centroidLineStart() {
        var x0, y0, z0;
        d3_geo_centroid.point = function(λ, φ) {
            λ *= d3_radians;
            var cosφ = Math.cos(φ *= d3_radians);
            x0 = cosφ * Math.cos(λ);
            y0 = cosφ * Math.sin(λ);
            z0 = Math.sin(φ);
            d3_geo_centroid.point = nextPoint;
            d3_geo_centroidPointXYZ(x0, y0, z0);
        };
        function nextPoint(λ, φ) {
            λ *= d3_radians;
            var cosφ = Math.cos(φ *= d3_radians), x = cosφ * Math.cos(λ), y = cosφ * Math.sin(λ), z = Math.sin(φ), w = Math.atan2(Math.sqrt((w = y0 * z - z0 * y) * w + (w = z0 * x - x0 * z) * w + (w = x0 * y - y0 * x) * w), x0 * x + y0 * y + z0 * z);
            d3_geo_centroidW1 += w;
            d3_geo_centroidX1 += w * (x0 + (x0 = x));
            d3_geo_centroidY1 += w * (y0 + (y0 = y));
            d3_geo_centroidZ1 += w * (z0 + (z0 = z));
            d3_geo_centroidPointXYZ(x0, y0, z0);
        }
    }
    function d3_geo_centroidLineEnd() {
        d3_geo_centroid.point = d3_geo_centroidPoint;
    }
    function d3_geo_centroidRingStart() {
        var λ00, φ00, x0, y0, z0;
        d3_geo_centroid.point = function(λ, φ) {
            λ00 = λ, φ00 = φ;
            d3_geo_centroid.point = nextPoint;
            λ *= d3_radians;
            var cosφ = Math.cos(φ *= d3_radians);
            x0 = cosφ * Math.cos(λ);
            y0 = cosφ * Math.sin(λ);
            z0 = Math.sin(φ);
            d3_geo_centroidPointXYZ(x0, y0, z0);
        };
        d3_geo_centroid.lineEnd = function() {
            nextPoint(λ00, φ00);
            d3_geo_centroid.lineEnd = d3_geo_centroidLineEnd;
            d3_geo_centroid.point = d3_geo_centroidPoint;
        };
        function nextPoint(λ, φ) {
            λ *= d3_radians;
            var cosφ = Math.cos(φ *= d3_radians), x = cosφ * Math.cos(λ), y = cosφ * Math.sin(λ), z = Math.sin(φ), cx = y0 * z - z0 * y, cy = z0 * x - x0 * z, cz = x0 * y - y0 * x, m = Math.sqrt(cx * cx + cy * cy + cz * cz), u = x0 * x + y0 * y + z0 * z, v = m && -d3_acos(u) / m, w = Math.atan2(m, u);
            d3_geo_centroidX2 += v * cx;
            d3_geo_centroidY2 += v * cy;
            d3_geo_centroidZ2 += v * cz;
            d3_geo_centroidW1 += w;
            d3_geo_centroidX1 += w * (x0 + (x0 = x));
            d3_geo_centroidY1 += w * (y0 + (y0 = y));
            d3_geo_centroidZ1 += w * (z0 + (z0 = z));
            d3_geo_centroidPointXYZ(x0, y0, z0);
        }
    }
    function d3_geo_compose(a, b) {
        function compose(x, y) {
            return x = a(x, y), b(x[0], x[1]);
        }
        if (a.invert && b.invert) compose.invert = function(x, y) {
            return x = b.invert(x, y), x && a.invert(x[0], x[1]);
        };
        return compose;
    }
    function d3_true() {
        return true;
    }
    function d3_geo_clipPolygon(segments, compare, clipStartInside, interpolate, listener) {
        var subject = [], clip = [];
        segments.forEach(function(segment) {
            if ((n = segment.length - 1) <= 0) return;
            var n, p0 = segment[0], p1 = segment[n];
            if (d3_geo_sphericalEqual(p0, p1)) {
                listener.lineStart();
                for (var i = 0; i < n; ++i) listener.point((p0 = segment[i])[0], p0[1]);
                listener.lineEnd();
                return;
            }
            var a = new d3_geo_clipPolygonIntersection(p0, segment, null, true), b = new d3_geo_clipPolygonIntersection(p0, null, a, false);
            a.o = b;
            subject.push(a);
            clip.push(b);
            a = new d3_geo_clipPolygonIntersection(p1, segment, null, false);
            b = new d3_geo_clipPolygonIntersection(p1, null, a, true);
            a.o = b;
            subject.push(a);
            clip.push(b);
        });
        clip.sort(compare);
        d3_geo_clipPolygonLinkCircular(subject);
        d3_geo_clipPolygonLinkCircular(clip);
        if (!subject.length) return;
        for (var i = 0, entry = clipStartInside, n = clip.length; i < n; ++i) {
            clip[i].e = entry = !entry;
        }
        var start = subject[0], points, point;
        while (1) {
            var current = start, isSubject = true;
            while (current.v) if ((current = current.n) === start) return;
            points = current.z;
            listener.lineStart();
            do {
                current.v = current.o.v = true;
                if (current.e) {
                    if (isSubject) {
                        for (var i = 0, n = points.length; i < n; ++i) listener.point((point = points[i])[0], point[1]);
                    } else {
                        interpolate(current.x, current.n.x, 1, listener);
                    }
                    current = current.n;
                } else {
                    if (isSubject) {
                        points = current.p.z;
                        for (var i = points.length - 1; i >= 0; --i) listener.point((point = points[i])[0], point[1]);
                    } else {
                        interpolate(current.x, current.p.x, -1, listener);
                    }
                    current = current.p;
                }
                current = current.o;
                points = current.z;
                isSubject = !isSubject;
            } while (!current.v);
            listener.lineEnd();
        }
    }
    function d3_geo_clipPolygonLinkCircular(array) {
        if (!(n = array.length)) return;
        var n, i = 0, a = array[0], b;
        while (++i < n) {
            a.n = b = array[i];
            b.p = a;
            a = b;
        }
        a.n = b = array[0];
        b.p = a;
    }
    function d3_geo_clipPolygonIntersection(point, points, other, entry) {
        this.x = point;
        this.z = points;
        this.o = other;
        this.e = entry;
        this.v = false;
        this.n = this.p = null;
    }
    function d3_geo_clip(pointVisible, clipLine, interpolate, clipStart) {
        return function(rotate, listener) {
            var line = clipLine(listener), rotatedClipStart = rotate.invert(clipStart[0], clipStart[1]);
            var clip = {
                point: point,
                lineStart: lineStart,
                lineEnd: lineEnd,
                polygonStart: function() {
                    clip.point = pointRing;
                    clip.lineStart = ringStart;
                    clip.lineEnd = ringEnd;
                    segments = [];
                    polygon = [];
                },
                polygonEnd: function() {
                    clip.point = point;
                    clip.lineStart = lineStart;
                    clip.lineEnd = lineEnd;
                    segments = d3.merge(segments);
                    var clipStartInside = d3_geo_pointInPolygon(rotatedClipStart, polygon);
                    if (segments.length) {
                        if (!polygonStarted) listener.polygonStart(), polygonStarted = true;
                        d3_geo_clipPolygon(segments, d3_geo_clipSort, clipStartInside, interpolate, listener);
                    } else if (clipStartInside) {
                        if (!polygonStarted) listener.polygonStart(), polygonStarted = true;
                        listener.lineStart();
                        interpolate(null, null, 1, listener);
                        listener.lineEnd();
                    }
                    if (polygonStarted) listener.polygonEnd(), polygonStarted = false;
                    segments = polygon = null;
                },
                sphere: function() {
                    listener.polygonStart();
                    listener.lineStart();
                    interpolate(null, null, 1, listener);
                    listener.lineEnd();
                    listener.polygonEnd();
                }
            };
            function point(λ, φ) {
                var point = rotate(λ, φ);
                if (pointVisible(λ = point[0], φ = point[1])) listener.point(λ, φ);
            }
            function pointLine(λ, φ) {
                var point = rotate(λ, φ);
                line.point(point[0], point[1]);
            }
            function lineStart() {
                clip.point = pointLine;
                line.lineStart();
            }
            function lineEnd() {
                clip.point = point;
                line.lineEnd();
            }
            var segments;
            var buffer = d3_geo_clipBufferListener(), ringListener = clipLine(buffer), polygonStarted = false, polygon, ring;
            function pointRing(λ, φ) {
                ring.push([ λ, φ ]);
                var point = rotate(λ, φ);
                ringListener.point(point[0], point[1]);
            }
            function ringStart() {
                ringListener.lineStart();
                ring = [];
            }
            function ringEnd() {
                pointRing(ring[0][0], ring[0][1]);
                ringListener.lineEnd();
                var clean = ringListener.clean(), ringSegments = buffer.buffer(), segment, n = ringSegments.length;
                ring.pop();
                polygon.push(ring);
                ring = null;
                if (!n) return;
                if (clean & 1) {
                    segment = ringSegments[0];
                    var n = segment.length - 1, i = -1, point;
                    if (n > 0) {
                        if (!polygonStarted) listener.polygonStart(), polygonStarted = true;
                        listener.lineStart();
                        while (++i < n) listener.point((point = segment[i])[0], point[1]);
                        listener.lineEnd();
                    }
                    return;
                }
                if (n > 1 && clean & 2) ringSegments.push(ringSegments.pop().concat(ringSegments.shift()));
                segments.push(ringSegments.filter(d3_geo_clipSegmentLength1));
            }
            return clip;
        };
    }
    function d3_geo_clipSegmentLength1(segment) {
        return segment.length > 1;
    }
    function d3_geo_clipBufferListener() {
        var lines = [], line;
        return {
            lineStart: function() {
                lines.push(line = []);
            },
            point: function(λ, φ) {
                line.push([ λ, φ ]);
            },
            lineEnd: d3_noop,
            buffer: function() {
                var buffer = lines;
                lines = [];
                line = null;
                return buffer;
            },
            rejoin: function() {
                if (lines.length > 1) lines.push(lines.pop().concat(lines.shift()));
            }
        };
    }
    function d3_geo_clipSort(a, b) {
        return ((a = a.x)[0] < 0 ? a[1] - halfπ - ε : halfπ - a[1]) - ((b = b.x)[0] < 0 ? b[1] - halfπ - ε : halfπ - b[1]);
    }
    var d3_geo_clipAntimeridian = d3_geo_clip(d3_true, d3_geo_clipAntimeridianLine, d3_geo_clipAntimeridianInterpolate, [ -π, -π / 2 ]);
    function d3_geo_clipAntimeridianLine(listener) {
        var λ0 = NaN, φ0 = NaN, sλ0 = NaN, clean;
        return {
            lineStart: function() {
                listener.lineStart();
                clean = 1;
            },
            point: function(λ1, φ1) {
                var sλ1 = λ1 > 0 ? π : -π, dλ = abs(λ1 - λ0);
                if (abs(dλ - π) < ε) {
                    listener.point(λ0, φ0 = (φ0 + φ1) / 2 > 0 ? halfπ : -halfπ);
                    listener.point(sλ0, φ0);
                    listener.lineEnd();
                    listener.lineStart();
                    listener.point(sλ1, φ0);
                    listener.point(λ1, φ0);
                    clean = 0;
                } else if (sλ0 !== sλ1 && dλ >= π) {
                    if (abs(λ0 - sλ0) < ε) λ0 -= sλ0 * ε;
                    if (abs(λ1 - sλ1) < ε) λ1 -= sλ1 * ε;
                    φ0 = d3_geo_clipAntimeridianIntersect(λ0, φ0, λ1, φ1);
                    listener.point(sλ0, φ0);
                    listener.lineEnd();
                    listener.lineStart();
                    listener.point(sλ1, φ0);
                    clean = 0;
                }
                listener.point(λ0 = λ1, φ0 = φ1);
                sλ0 = sλ1;
            },
            lineEnd: function() {
                listener.lineEnd();
                λ0 = φ0 = NaN;
            },
            clean: function() {
                return 2 - clean;
            }
        };
    }
    function d3_geo_clipAntimeridianIntersect(λ0, φ0, λ1, φ1) {
        var cosφ0, cosφ1, sinλ0_λ1 = Math.sin(λ0 - λ1);
        return abs(sinλ0_λ1) > ε ? Math.atan((Math.sin(φ0) * (cosφ1 = Math.cos(φ1)) * Math.sin(λ1) - Math.sin(φ1) * (cosφ0 = Math.cos(φ0)) * Math.sin(λ0)) / (cosφ0 * cosφ1 * sinλ0_λ1)) : (φ0 + φ1) / 2;
    }
    function d3_geo_clipAntimeridianInterpolate(from, to, direction, listener) {
        var φ;
        if (from == null) {
            φ = direction * halfπ;
            listener.point(-π, φ);
            listener.point(0, φ);
            listener.point(π, φ);
            listener.point(π, 0);
            listener.point(π, -φ);
            listener.point(0, -φ);
            listener.point(-π, -φ);
            listener.point(-π, 0);
            listener.point(-π, φ);
        } else if (abs(from[0] - to[0]) > ε) {
            var s = from[0] < to[0] ? π : -π;
            φ = direction * s / 2;
            listener.point(-s, φ);
            listener.point(0, φ);
            listener.point(s, φ);
        } else {
            listener.point(to[0], to[1]);
        }
    }
    function d3_geo_pointInPolygon(point, polygon) {
        var meridian = point[0], parallel = point[1], meridianNormal = [ Math.sin(meridian), -Math.cos(meridian), 0 ], polarAngle = 0, winding = 0;
        d3_geo_areaRingSum.reset();
        for (var i = 0, n = polygon.length; i < n; ++i) {
            var ring = polygon[i], m = ring.length;
            if (!m) continue;
            var point0 = ring[0], λ0 = point0[0], φ0 = point0[1] / 2 + π / 4, sinφ0 = Math.sin(φ0), cosφ0 = Math.cos(φ0), j = 1;
            while (true) {
                if (j === m) j = 0;
                point = ring[j];
                var λ = point[0], φ = point[1] / 2 + π / 4, sinφ = Math.sin(φ), cosφ = Math.cos(φ), dλ = λ - λ0, sdλ = dλ >= 0 ? 1 : -1, adλ = sdλ * dλ, antimeridian = adλ > π, k = sinφ0 * sinφ;
                d3_geo_areaRingSum.add(Math.atan2(k * sdλ * Math.sin(adλ), cosφ0 * cosφ + k * Math.cos(adλ)));
                polarAngle += antimeridian ? dλ + sdλ * τ : dλ;
                if (antimeridian ^ λ0 >= meridian ^ λ >= meridian) {
                    var arc = d3_geo_cartesianCross(d3_geo_cartesian(point0), d3_geo_cartesian(point));
                    d3_geo_cartesianNormalize(arc);
                    var intersection = d3_geo_cartesianCross(meridianNormal, arc);
                    d3_geo_cartesianNormalize(intersection);
                    var φarc = (antimeridian ^ dλ >= 0 ? -1 : 1) * d3_asin(intersection[2]);
                    if (parallel > φarc || parallel === φarc && (arc[0] || arc[1])) {
                        winding += antimeridian ^ dλ >= 0 ? 1 : -1;
                    }
                }
                if (!j++) break;
                λ0 = λ, sinφ0 = sinφ, cosφ0 = cosφ, point0 = point;
            }
        }
        return (polarAngle < -ε || polarAngle < ε && d3_geo_areaRingSum < 0) ^ winding & 1;
    }
    function d3_geo_clipCircle(radius) {
        var cr = Math.cos(radius), smallRadius = cr > 0, notHemisphere = abs(cr) > ε, interpolate = d3_geo_circleInterpolate(radius, 6 * d3_radians);
        return d3_geo_clip(visible, clipLine, interpolate, smallRadius ? [ 0, -radius ] : [ -π, radius - π ]);
        function visible(λ, φ) {
            return Math.cos(λ) * Math.cos(φ) > cr;
        }
        function clipLine(listener) {
            var point0, c0, v0, v00, clean;
            return {
                lineStart: function() {
                    v00 = v0 = false;
                    clean = 1;
                },
                point: function(λ, φ) {
                    var point1 = [ λ, φ ], point2, v = visible(λ, φ), c = smallRadius ? v ? 0 : code(λ, φ) : v ? code(λ + (λ < 0 ? π : -π), φ) : 0;
                    if (!point0 && (v00 = v0 = v)) listener.lineStart();
                    if (v !== v0) {
                        point2 = intersect(point0, point1);
                        if (d3_geo_sphericalEqual(point0, point2) || d3_geo_sphericalEqual(point1, point2)) {
                            point1[0] += ε;
                            point1[1] += ε;
                            v = visible(point1[0], point1[1]);
                        }
                    }
                    if (v !== v0) {
                        clean = 0;
                        if (v) {
                            listener.lineStart();
                            point2 = intersect(point1, point0);
                            listener.point(point2[0], point2[1]);
                        } else {
                            point2 = intersect(point0, point1);
                            listener.point(point2[0], point2[1]);
                            listener.lineEnd();
                        }
                        point0 = point2;
                    } else if (notHemisphere && point0 && smallRadius ^ v) {
                        var t;
                        if (!(c & c0) && (t = intersect(point1, point0, true))) {
                            clean = 0;
                            if (smallRadius) {
                                listener.lineStart();
                                listener.point(t[0][0], t[0][1]);
                                listener.point(t[1][0], t[1][1]);
                                listener.lineEnd();
                            } else {
                                listener.point(t[1][0], t[1][1]);
                                listener.lineEnd();
                                listener.lineStart();
                                listener.point(t[0][0], t[0][1]);
                            }
                        }
                    }
                    if (v && (!point0 || !d3_geo_sphericalEqual(point0, point1))) {
                        listener.point(point1[0], point1[1]);
                    }
                    point0 = point1, v0 = v, c0 = c;
                },
                lineEnd: function() {
                    if (v0) listener.lineEnd();
                    point0 = null;
                },
                clean: function() {
                    return clean | (v00 && v0) << 1;
                }
            };
        }
        function intersect(a, b, two) {
            var pa = d3_geo_cartesian(a), pb = d3_geo_cartesian(b);
            var n1 = [ 1, 0, 0 ], n2 = d3_geo_cartesianCross(pa, pb), n2n2 = d3_geo_cartesianDot(n2, n2), n1n2 = n2[0], determinant = n2n2 - n1n2 * n1n2;
            if (!determinant) return !two && a;
            var c1 = cr * n2n2 / determinant, c2 = -cr * n1n2 / determinant, n1xn2 = d3_geo_cartesianCross(n1, n2), A = d3_geo_cartesianScale(n1, c1), B = d3_geo_cartesianScale(n2, c2);
            d3_geo_cartesianAdd(A, B);
            var u = n1xn2, w = d3_geo_cartesianDot(A, u), uu = d3_geo_cartesianDot(u, u), t2 = w * w - uu * (d3_geo_cartesianDot(A, A) - 1);
            if (t2 < 0) return;
            var t = Math.sqrt(t2), q = d3_geo_cartesianScale(u, (-w - t) / uu);
            d3_geo_cartesianAdd(q, A);
            q = d3_geo_spherical(q);
            if (!two) return q;
            var λ0 = a[0], λ1 = b[0], φ0 = a[1], φ1 = b[1], z;
            if (λ1 < λ0) z = λ0, λ0 = λ1, λ1 = z;
            var δλ = λ1 - λ0, polar = abs(δλ - π) < ε, meridian = polar || δλ < ε;
            if (!polar && φ1 < φ0) z = φ0, φ0 = φ1, φ1 = z;
            if (meridian ? polar ? φ0 + φ1 > 0 ^ q[1] < (abs(q[0] - λ0) < ε ? φ0 : φ1) : φ0 <= q[1] && q[1] <= φ1 : δλ > π ^ (λ0 <= q[0] && q[0] <= λ1)) {
                var q1 = d3_geo_cartesianScale(u, (-w + t) / uu);
                d3_geo_cartesianAdd(q1, A);
                return [ q, d3_geo_spherical(q1) ];
            }
        }
        function code(λ, φ) {
            var r = smallRadius ? radius : π - radius, code = 0;
            if (λ < -r) code |= 1; else if (λ > r) code |= 2;
            if (φ < -r) code |= 4; else if (φ > r) code |= 8;
            return code;
        }
    }
    function d3_geom_clipLine(x0, y0, x1, y1) {
        return function(line) {
            var a = line.a, b = line.b, ax = a.x, ay = a.y, bx = b.x, by = b.y, t0 = 0, t1 = 1, dx = bx - ax, dy = by - ay, r;
            r = x0 - ax;
            if (!dx && r > 0) return;
            r /= dx;
            if (dx < 0) {
                if (r < t0) return;
                if (r < t1) t1 = r;
            } else if (dx > 0) {
                if (r > t1) return;
                if (r > t0) t0 = r;
            }
            r = x1 - ax;
            if (!dx && r < 0) return;
            r /= dx;
            if (dx < 0) {
                if (r > t1) return;
                if (r > t0) t0 = r;
            } else if (dx > 0) {
                if (r < t0) return;
                if (r < t1) t1 = r;
            }
            r = y0 - ay;
            if (!dy && r > 0) return;
            r /= dy;
            if (dy < 0) {
                if (r < t0) return;
                if (r < t1) t1 = r;
            } else if (dy > 0) {
                if (r > t1) return;
                if (r > t0) t0 = r;
            }
            r = y1 - ay;
            if (!dy && r < 0) return;
            r /= dy;
            if (dy < 0) {
                if (r > t1) return;
                if (r > t0) t0 = r;
            } else if (dy > 0) {
                if (r < t0) return;
                if (r < t1) t1 = r;
            }
            if (t0 > 0) line.a = {
                x: ax + t0 * dx,
                y: ay + t0 * dy
            };
            if (t1 < 1) line.b = {
                x: ax + t1 * dx,
                y: ay + t1 * dy
            };
            return line;
        };
    }
    var d3_geo_clipExtentMAX = 1e9;
    d3.geo.clipExtent = function() {
        var x0, y0, x1, y1, stream, clip, clipExtent = {
            stream: function(output) {
                if (stream) stream.valid = false;
                stream = clip(output);
                stream.valid = true;
                return stream;
            },
            extent: function(_) {
                if (!arguments.length) return [ [ x0, y0 ], [ x1, y1 ] ];
                clip = d3_geo_clipExtent(x0 = +_[0][0], y0 = +_[0][1], x1 = +_[1][0], y1 = +_[1][1]);
                if (stream) stream.valid = false, stream = null;
                return clipExtent;
            }
        };
        return clipExtent.extent([ [ 0, 0 ], [ 960, 500 ] ]);
    };
    function d3_geo_clipExtent(x0, y0, x1, y1) {
        return function(listener) {
            var listener_ = listener, bufferListener = d3_geo_clipBufferListener(), clipLine = d3_geom_clipLine(x0, y0, x1, y1), segments, polygon, ring;
            var clip = {
                point: point,
                lineStart: lineStart,
                lineEnd: lineEnd,
                polygonStart: function() {
                    listener = bufferListener;
                    segments = [];
                    polygon = [];
                    clean = true;
                },
                polygonEnd: function() {
                    listener = listener_;
                    segments = d3.merge(segments);
                    var clipStartInside = insidePolygon([ x0, y1 ]), inside = clean && clipStartInside, visible = segments.length;
                    if (inside || visible) {
                        listener.polygonStart();
                        if (inside) {
                            listener.lineStart();
                            interpolate(null, null, 1, listener);
                            listener.lineEnd();
                        }
                        if (visible) {
                            d3_geo_clipPolygon(segments, compare, clipStartInside, interpolate, listener);
                        }
                        listener.polygonEnd();
                    }
                    segments = polygon = ring = null;
                }
            };
            function insidePolygon(p) {
                var wn = 0, n = polygon.length, y = p[1];
                for (var i = 0; i < n; ++i) {
                    for (var j = 1, v = polygon[i], m = v.length, a = v[0], b; j < m; ++j) {
                        b = v[j];
                        if (a[1] <= y) {
                            if (b[1] > y && d3_cross2d(a, b, p) > 0) ++wn;
                        } else {
                            if (b[1] <= y && d3_cross2d(a, b, p) < 0) --wn;
                        }
                        a = b;
                    }
                }
                return wn !== 0;
            }
            function interpolate(from, to, direction, listener) {
                var a = 0, a1 = 0;
                if (from == null || (a = corner(from, direction)) !== (a1 = corner(to, direction)) || comparePoints(from, to) < 0 ^ direction > 0) {
                    do {
                        listener.point(a === 0 || a === 3 ? x0 : x1, a > 1 ? y1 : y0);
                    } while ((a = (a + direction + 4) % 4) !== a1);
                } else {
                    listener.point(to[0], to[1]);
                }
            }
            function pointVisible(x, y) {
                return x0 <= x && x <= x1 && y0 <= y && y <= y1;
            }
            function point(x, y) {
                if (pointVisible(x, y)) listener.point(x, y);
            }
            var x__, y__, v__, x_, y_, v_, first, clean;
            function lineStart() {
                clip.point = linePoint;
                if (polygon) polygon.push(ring = []);
                first = true;
                v_ = false;
                x_ = y_ = NaN;
            }
            function lineEnd() {
                if (segments) {
                    linePoint(x__, y__);
                    if (v__ && v_) bufferListener.rejoin();
                    segments.push(bufferListener.buffer());
                }
                clip.point = point;
                if (v_) listener.lineEnd();
            }
            function linePoint(x, y) {
                x = Math.max(-d3_geo_clipExtentMAX, Math.min(d3_geo_clipExtentMAX, x));
                y = Math.max(-d3_geo_clipExtentMAX, Math.min(d3_geo_clipExtentMAX, y));
                var v = pointVisible(x, y);
                if (polygon) ring.push([ x, y ]);
                if (first) {
                    x__ = x, y__ = y, v__ = v;
                    first = false;
                    if (v) {
                        listener.lineStart();
                        listener.point(x, y);
                    }
                } else {
                    if (v && v_) listener.point(x, y); else {
                        var l = {
                            a: {
                                x: x_,
                                y: y_
                            },
                            b: {
                                x: x,
                                y: y
                            }
                        };
                        if (clipLine(l)) {
                            if (!v_) {
                                listener.lineStart();
                                listener.point(l.a.x, l.a.y);
                            }
                            listener.point(l.b.x, l.b.y);
                            if (!v) listener.lineEnd();
                            clean = false;
                        } else if (v) {
                            listener.lineStart();
                            listener.point(x, y);
                            clean = false;
                        }
                    }
                }
                x_ = x, y_ = y, v_ = v;
            }
            return clip;
        };
        function corner(p, direction) {
            return abs(p[0] - x0) < ε ? direction > 0 ? 0 : 3 : abs(p[0] - x1) < ε ? direction > 0 ? 2 : 1 : abs(p[1] - y0) < ε ? direction > 0 ? 1 : 0 : direction > 0 ? 3 : 2;
        }
        function compare(a, b) {
            return comparePoints(a.x, b.x);
        }
        function comparePoints(a, b) {
            var ca = corner(a, 1), cb = corner(b, 1);
            return ca !== cb ? ca - cb : ca === 0 ? b[1] - a[1] : ca === 1 ? a[0] - b[0] : ca === 2 ? a[1] - b[1] : b[0] - a[0];
        }
    }
    function d3_geo_conic(projectAt) {
        var φ0 = 0, φ1 = π / 3, m = d3_geo_projectionMutator(projectAt), p = m(φ0, φ1);
        p.parallels = function(_) {
            if (!arguments.length) return [ φ0 / π * 180, φ1 / π * 180 ];
            return m(φ0 = _[0] * π / 180, φ1 = _[1] * π / 180);
        };
        return p;
    }
    function d3_geo_conicEqualArea(φ0, φ1) {
        var sinφ0 = Math.sin(φ0), n = (sinφ0 + Math.sin(φ1)) / 2, C = 1 + sinφ0 * (2 * n - sinφ0), ρ0 = Math.sqrt(C) / n;
        function forward(λ, φ) {
            var ρ = Math.sqrt(C - 2 * n * Math.sin(φ)) / n;
            return [ ρ * Math.sin(λ *= n), ρ0 - ρ * Math.cos(λ) ];
        }
        forward.invert = function(x, y) {
            var ρ0_y = ρ0 - y;
            return [ Math.atan2(x, ρ0_y) / n, d3_asin((C - (x * x + ρ0_y * ρ0_y) * n * n) / (2 * n)) ];
        };
        return forward;
    }
    (d3.geo.conicEqualArea = function() {
        return d3_geo_conic(d3_geo_conicEqualArea);
    }).raw = d3_geo_conicEqualArea;
    d3.geo.albers = function() {
        return d3.geo.conicEqualArea().rotate([ 96, 0 ]).center([ -.6, 38.7 ]).parallels([ 29.5, 45.5 ]).scale(1070);
    };
    d3.geo.albersUsa = function() {
        var lower48 = d3.geo.albers();
        var alaska = d3.geo.conicEqualArea().rotate([ 154, 0 ]).center([ -2, 58.5 ]).parallels([ 55, 65 ]);
        var hawaii = d3.geo.conicEqualArea().rotate([ 157, 0 ]).center([ -3, 19.9 ]).parallels([ 8, 18 ]);
        var point, pointStream = {
            point: function(x, y) {
                point = [ x, y ];
            }
        }, lower48Point, alaskaPoint, hawaiiPoint;
        function albersUsa(coordinates) {
            var x = coordinates[0], y = coordinates[1];
            point = null;
            (lower48Point(x, y), point) || (alaskaPoint(x, y), point) || hawaiiPoint(x, y);
            return point;
        }
        albersUsa.invert = function(coordinates) {
            var k = lower48.scale(), t = lower48.translate(), x = (coordinates[0] - t[0]) / k, y = (coordinates[1] - t[1]) / k;
            return (y >= .12 && y < .234 && x >= -.425 && x < -.214 ? alaska : y >= .166 && y < .234 && x >= -.214 && x < -.115 ? hawaii : lower48).invert(coordinates);
        };
        albersUsa.stream = function(stream) {
            var lower48Stream = lower48.stream(stream), alaskaStream = alaska.stream(stream), hawaiiStream = hawaii.stream(stream);
            return {
                point: function(x, y) {
                    lower48Stream.point(x, y);
                    alaskaStream.point(x, y);
                    hawaiiStream.point(x, y);
                },
                sphere: function() {
                    lower48Stream.sphere();
                    alaskaStream.sphere();
                    hawaiiStream.sphere();
                },
                lineStart: function() {
                    lower48Stream.lineStart();
                    alaskaStream.lineStart();
                    hawaiiStream.lineStart();
                },
                lineEnd: function() {
                    lower48Stream.lineEnd();
                    alaskaStream.lineEnd();
                    hawaiiStream.lineEnd();
                },
                polygonStart: function() {
                    lower48Stream.polygonStart();
                    alaskaStream.polygonStart();
                    hawaiiStream.polygonStart();
                },
                polygonEnd: function() {
                    lower48Stream.polygonEnd();
                    alaskaStream.polygonEnd();
                    hawaiiStream.polygonEnd();
                }
            };
        };
        albersUsa.precision = function(_) {
            if (!arguments.length) return lower48.precision();
            lower48.precision(_);
            alaska.precision(_);
            hawaii.precision(_);
            return albersUsa;
        };
        albersUsa.scale = function(_) {
            if (!arguments.length) return lower48.scale();
            lower48.scale(_);
            alaska.scale(_ * .35);
            hawaii.scale(_);
            return albersUsa.translate(lower48.translate());
        };
        albersUsa.translate = function(_) {
            if (!arguments.length) return lower48.translate();
            var k = lower48.scale(), x = +_[0], y = +_[1];
            lower48Point = lower48.translate(_).clipExtent([ [ x - .455 * k, y - .238 * k ], [ x + .455 * k, y + .238 * k ] ]).stream(pointStream).point;
            alaskaPoint = alaska.translate([ x - .307 * k, y + .201 * k ]).clipExtent([ [ x - .425 * k + ε, y + .12 * k + ε ], [ x - .214 * k - ε, y + .234 * k - ε ] ]).stream(pointStream).point;
            hawaiiPoint = hawaii.translate([ x - .205 * k, y + .212 * k ]).clipExtent([ [ x - .214 * k + ε, y + .166 * k + ε ], [ x - .115 * k - ε, y + .234 * k - ε ] ]).stream(pointStream).point;
            return albersUsa;
        };
        return albersUsa.scale(1070);
    };
    var d3_geo_pathAreaSum, d3_geo_pathAreaPolygon, d3_geo_pathArea = {
        point: d3_noop,
        lineStart: d3_noop,
        lineEnd: d3_noop,
        polygonStart: function() {
            d3_geo_pathAreaPolygon = 0;
            d3_geo_pathArea.lineStart = d3_geo_pathAreaRingStart;
        },
        polygonEnd: function() {
            d3_geo_pathArea.lineStart = d3_geo_pathArea.lineEnd = d3_geo_pathArea.point = d3_noop;
            d3_geo_pathAreaSum += abs(d3_geo_pathAreaPolygon / 2);
        }
    };
    function d3_geo_pathAreaRingStart() {
        var x00, y00, x0, y0;
        d3_geo_pathArea.point = function(x, y) {
            d3_geo_pathArea.point = nextPoint;
            x00 = x0 = x, y00 = y0 = y;
        };
        function nextPoint(x, y) {
            d3_geo_pathAreaPolygon += y0 * x - x0 * y;
            x0 = x, y0 = y;
        }
        d3_geo_pathArea.lineEnd = function() {
            nextPoint(x00, y00);
        };
    }
    var d3_geo_pathBoundsX0, d3_geo_pathBoundsY0, d3_geo_pathBoundsX1, d3_geo_pathBoundsY1;
    var d3_geo_pathBounds = {
        point: d3_geo_pathBoundsPoint,
        lineStart: d3_noop,
        lineEnd: d3_noop,
        polygonStart: d3_noop,
        polygonEnd: d3_noop
    };
    function d3_geo_pathBoundsPoint(x, y) {
        if (x < d3_geo_pathBoundsX0) d3_geo_pathBoundsX0 = x;
        if (x > d3_geo_pathBoundsX1) d3_geo_pathBoundsX1 = x;
        if (y < d3_geo_pathBoundsY0) d3_geo_pathBoundsY0 = y;
        if (y > d3_geo_pathBoundsY1) d3_geo_pathBoundsY1 = y;
    }
    function d3_geo_pathBuffer() {
        var pointCircle = d3_geo_pathBufferCircle(4.5), buffer = [];
        var stream = {
            point: point,
            lineStart: function() {
                stream.point = pointLineStart;
            },
            lineEnd: lineEnd,
            polygonStart: function() {
                stream.lineEnd = lineEndPolygon;
            },
            polygonEnd: function() {
                stream.lineEnd = lineEnd;
                stream.point = point;
            },
            pointRadius: function(_) {
                pointCircle = d3_geo_pathBufferCircle(_);
                return stream;
            },
            result: function() {
                if (buffer.length) {
                    var result = buffer.join("");
                    buffer = [];
                    return result;
                }
            }
        };
        function point(x, y) {
            buffer.push("M", x, ",", y, pointCircle);
        }
        function pointLineStart(x, y) {
            buffer.push("M", x, ",", y);
            stream.point = pointLine;
        }
        function pointLine(x, y) {
            buffer.push("L", x, ",", y);
        }
        function lineEnd() {
            stream.point = point;
        }
        function lineEndPolygon() {
            buffer.push("Z");
        }
        return stream;
    }
    function d3_geo_pathBufferCircle(radius) {
        return "m0," + radius + "a" + radius + "," + radius + " 0 1,1 0," + -2 * radius + "a" + radius + "," + radius + " 0 1,1 0," + 2 * radius + "z";
    }
    var d3_geo_pathCentroid = {
        point: d3_geo_pathCentroidPoint,
        lineStart: d3_geo_pathCentroidLineStart,
        lineEnd: d3_geo_pathCentroidLineEnd,
        polygonStart: function() {
            d3_geo_pathCentroid.lineStart = d3_geo_pathCentroidRingStart;
        },
        polygonEnd: function() {
            d3_geo_pathCentroid.point = d3_geo_pathCentroidPoint;
            d3_geo_pathCentroid.lineStart = d3_geo_pathCentroidLineStart;
            d3_geo_pathCentroid.lineEnd = d3_geo_pathCentroidLineEnd;
        }
    };
    function d3_geo_pathCentroidPoint(x, y) {
        d3_geo_centroidX0 += x;
        d3_geo_centroidY0 += y;
        ++d3_geo_centroidZ0;
    }
    function d3_geo_pathCentroidLineStart() {
        var x0, y0;
        d3_geo_pathCentroid.point = function(x, y) {
            d3_geo_pathCentroid.point = nextPoint;
            d3_geo_pathCentroidPoint(x0 = x, y0 = y);
        };
        function nextPoint(x, y) {
            var dx = x - x0, dy = y - y0, z = Math.sqrt(dx * dx + dy * dy);
            d3_geo_centroidX1 += z * (x0 + x) / 2;
            d3_geo_centroidY1 += z * (y0 + y) / 2;
            d3_geo_centroidZ1 += z;
            d3_geo_pathCentroidPoint(x0 = x, y0 = y);
        }
    }
    function d3_geo_pathCentroidLineEnd() {
        d3_geo_pathCentroid.point = d3_geo_pathCentroidPoint;
    }
    function d3_geo_pathCentroidRingStart() {
        var x00, y00, x0, y0;
        d3_geo_pathCentroid.point = function(x, y) {
            d3_geo_pathCentroid.point = nextPoint;
            d3_geo_pathCentroidPoint(x00 = x0 = x, y00 = y0 = y);
        };
        function nextPoint(x, y) {
            var dx = x - x0, dy = y - y0, z = Math.sqrt(dx * dx + dy * dy);
            d3_geo_centroidX1 += z * (x0 + x) / 2;
            d3_geo_centroidY1 += z * (y0 + y) / 2;
            d3_geo_centroidZ1 += z;
            z = y0 * x - x0 * y;
            d3_geo_centroidX2 += z * (x0 + x);
            d3_geo_centroidY2 += z * (y0 + y);
            d3_geo_centroidZ2 += z * 3;
            d3_geo_pathCentroidPoint(x0 = x, y0 = y);
        }
        d3_geo_pathCentroid.lineEnd = function() {
            nextPoint(x00, y00);
        };
    }
    function d3_geo_pathContext(context) {
        var pointRadius = 4.5;
        var stream = {
            point: point,
            lineStart: function() {
                stream.point = pointLineStart;
            },
            lineEnd: lineEnd,
            polygonStart: function() {
                stream.lineEnd = lineEndPolygon;
            },
            polygonEnd: function() {
                stream.lineEnd = lineEnd;
                stream.point = point;
            },
            pointRadius: function(_) {
                pointRadius = _;
                return stream;
            },
            result: d3_noop
        };
        function point(x, y) {
            context.moveTo(x + pointRadius, y);
            context.arc(x, y, pointRadius, 0, τ);
        }
        function pointLineStart(x, y) {
            context.moveTo(x, y);
            stream.point = pointLine;
        }
        function pointLine(x, y) {
            context.lineTo(x, y);
        }
        function lineEnd() {
            stream.point = point;
        }
        function lineEndPolygon() {
            context.closePath();
        }
        return stream;
    }
    function d3_geo_resample(project) {
        var δ2 = .5, cosMinDistance = Math.cos(30 * d3_radians), maxDepth = 16;
        function resample(stream) {
            return (maxDepth ? resampleRecursive : resampleNone)(stream);
        }
        function resampleNone(stream) {
            return d3_geo_transformPoint(stream, function(x, y) {
                x = project(x, y);
                stream.point(x[0], x[1]);
            });
        }
        function resampleRecursive(stream) {
            var λ00, φ00, x00, y00, a00, b00, c00, λ0, x0, y0, a0, b0, c0;
            var resample = {
                point: point,
                lineStart: lineStart,
                lineEnd: lineEnd,
                polygonStart: function() {
                    stream.polygonStart();
                    resample.lineStart = ringStart;
                },
                polygonEnd: function() {
                    stream.polygonEnd();
                    resample.lineStart = lineStart;
                }
            };
            function point(x, y) {
                x = project(x, y);
                stream.point(x[0], x[1]);
            }
            function lineStart() {
                x0 = NaN;
                resample.point = linePoint;
                stream.lineStart();
            }
            function linePoint(λ, φ) {
                var c = d3_geo_cartesian([ λ, φ ]), p = project(λ, φ);
                resampleLineTo(x0, y0, λ0, a0, b0, c0, x0 = p[0], y0 = p[1], λ0 = λ, a0 = c[0], b0 = c[1], c0 = c[2], maxDepth, stream);
                stream.point(x0, y0);
            }
            function lineEnd() {
                resample.point = point;
                stream.lineEnd();
            }
            function ringStart() {
                lineStart();
                resample.point = ringPoint;
                resample.lineEnd = ringEnd;
            }
            function ringPoint(λ, φ) {
                linePoint(λ00 = λ, φ00 = φ), x00 = x0, y00 = y0, a00 = a0, b00 = b0, c00 = c0;
                resample.point = linePoint;
            }
            function ringEnd() {
                resampleLineTo(x0, y0, λ0, a0, b0, c0, x00, y00, λ00, a00, b00, c00, maxDepth, stream);
                resample.lineEnd = lineEnd;
                lineEnd();
            }
            return resample;
        }
        function resampleLineTo(x0, y0, λ0, a0, b0, c0, x1, y1, λ1, a1, b1, c1, depth, stream) {
            var dx = x1 - x0, dy = y1 - y0, d2 = dx * dx + dy * dy;
            if (d2 > 4 * δ2 && depth--) {
                var a = a0 + a1, b = b0 + b1, c = c0 + c1, m = Math.sqrt(a * a + b * b + c * c), φ2 = Math.asin(c /= m), λ2 = abs(abs(c) - 1) < ε || abs(λ0 - λ1) < ε ? (λ0 + λ1) / 2 : Math.atan2(b, a), p = project(λ2, φ2), x2 = p[0], y2 = p[1], dx2 = x2 - x0, dy2 = y2 - y0, dz = dy * dx2 - dx * dy2;
                if (dz * dz / d2 > δ2 || abs((dx * dx2 + dy * dy2) / d2 - .5) > .3 || a0 * a1 + b0 * b1 + c0 * c1 < cosMinDistance) {
                    resampleLineTo(x0, y0, λ0, a0, b0, c0, x2, y2, λ2, a /= m, b /= m, c, depth, stream);
                    stream.point(x2, y2);
                    resampleLineTo(x2, y2, λ2, a, b, c, x1, y1, λ1, a1, b1, c1, depth, stream);
                }
            }
        }
        resample.precision = function(_) {
            if (!arguments.length) return Math.sqrt(δ2);
            maxDepth = (δ2 = _ * _) > 0 && 16;
            return resample;
        };
        return resample;
    }
    d3.geo.path = function() {
        var pointRadius = 4.5, projection, context, projectStream, contextStream, cacheStream;
        function path(object) {
            if (object) {
                if (typeof pointRadius === "function") contextStream.pointRadius(+pointRadius.apply(this, arguments));
                if (!cacheStream || !cacheStream.valid) cacheStream = projectStream(contextStream);
                d3.geo.stream(object, cacheStream);
            }
            return contextStream.result();
        }
        path.area = function(object) {
            d3_geo_pathAreaSum = 0;
            d3.geo.stream(object, projectStream(d3_geo_pathArea));
            return d3_geo_pathAreaSum;
        };
        path.centroid = function(object) {
            d3_geo_centroidX0 = d3_geo_centroidY0 = d3_geo_centroidZ0 = d3_geo_centroidX1 = d3_geo_centroidY1 = d3_geo_centroidZ1 = d3_geo_centroidX2 = d3_geo_centroidY2 = d3_geo_centroidZ2 = 0;
            d3.geo.stream(object, projectStream(d3_geo_pathCentroid));
            return d3_geo_centroidZ2 ? [ d3_geo_centroidX2 / d3_geo_centroidZ2, d3_geo_centroidY2 / d3_geo_centroidZ2 ] : d3_geo_centroidZ1 ? [ d3_geo_centroidX1 / d3_geo_centroidZ1, d3_geo_centroidY1 / d3_geo_centroidZ1 ] : d3_geo_centroidZ0 ? [ d3_geo_centroidX0 / d3_geo_centroidZ0, d3_geo_centroidY0 / d3_geo_centroidZ0 ] : [ NaN, NaN ];
        };
        path.bounds = function(object) {
            d3_geo_pathBoundsX1 = d3_geo_pathBoundsY1 = -(d3_geo_pathBoundsX0 = d3_geo_pathBoundsY0 = Infinity);
            d3.geo.stream(object, projectStream(d3_geo_pathBounds));
            return [ [ d3_geo_pathBoundsX0, d3_geo_pathBoundsY0 ], [ d3_geo_pathBoundsX1, d3_geo_pathBoundsY1 ] ];
        };
        path.projection = function(_) {
            if (!arguments.length) return projection;
            projectStream = (projection = _) ? _.stream || d3_geo_pathProjectStream(_) : d3_identity;
            return reset();
        };
        path.context = function(_) {
            if (!arguments.length) return context;
            contextStream = (context = _) == null ? new d3_geo_pathBuffer() : new d3_geo_pathContext(_);
            if (typeof pointRadius !== "function") contextStream.pointRadius(pointRadius);
            return reset();
        };
        path.pointRadius = function(_) {
            if (!arguments.length) return pointRadius;
            pointRadius = typeof _ === "function" ? _ : (contextStream.pointRadius(+_), +_);
            return path;
        };
        function reset() {
            cacheStream = null;
            return path;
        }
        return path.projection(d3.geo.albersUsa()).context(null);
    };
    function d3_geo_pathProjectStream(project) {
        var resample = d3_geo_resample(function(x, y) {
            return project([ x * d3_degrees, y * d3_degrees ]);
        });
        return function(stream) {
            return d3_geo_projectionRadians(resample(stream));
        };
    }
    d3.geo.transform = function(methods) {
        return {
            stream: function(stream) {
                var transform = new d3_geo_transform(stream);
                for (var k in methods) transform[k] = methods[k];
                return transform;
            }
        };
    };
    function d3_geo_transform(stream) {
        this.stream = stream;
    }
    d3_geo_transform.prototype = {
        point: function(x, y) {
            this.stream.point(x, y);
        },
        sphere: function() {
            this.stream.sphere();
        },
        lineStart: function() {
            this.stream.lineStart();
        },
        lineEnd: function() {
            this.stream.lineEnd();
        },
        polygonStart: function() {
            this.stream.polygonStart();
        },
        polygonEnd: function() {
            this.stream.polygonEnd();
        }
    };
    function d3_geo_transformPoint(stream, point) {
        return {
            point: point,
            sphere: function() {
                stream.sphere();
            },
            lineStart: function() {
                stream.lineStart();
            },
            lineEnd: function() {
                stream.lineEnd();
            },
            polygonStart: function() {
                stream.polygonStart();
            },
            polygonEnd: function() {
                stream.polygonEnd();
            }
        };
    }
    d3.geo.projection = d3_geo_projection;
    d3.geo.projectionMutator = d3_geo_projectionMutator;
    function d3_geo_projection(project) {
        return d3_geo_projectionMutator(function() {
            return project;
        })();
    }
    function d3_geo_projectionMutator(projectAt) {
        var project, rotate, projectRotate, projectResample = d3_geo_resample(function(x, y) {
            x = project(x, y);
            return [ x[0] * k + δx, δy - x[1] * k ];
        }), k = 150, x = 480, y = 250, λ = 0, φ = 0, δλ = 0, δφ = 0, δγ = 0, δx, δy, preclip = d3_geo_clipAntimeridian, postclip = d3_identity, clipAngle = null, clipExtent = null, stream;
        function projection(point) {
            point = projectRotate(point[0] * d3_radians, point[1] * d3_radians);
            return [ point[0] * k + δx, δy - point[1] * k ];
        }
        function invert(point) {
            point = projectRotate.invert((point[0] - δx) / k, (δy - point[1]) / k);
            return point && [ point[0] * d3_degrees, point[1] * d3_degrees ];
        }
        projection.stream = function(output) {
            if (stream) stream.valid = false;
            stream = d3_geo_projectionRadians(preclip(rotate, projectResample(postclip(output))));
            stream.valid = true;
            return stream;
        };
        projection.clipAngle = function(_) {
            if (!arguments.length) return clipAngle;
            preclip = _ == null ? (clipAngle = _, d3_geo_clipAntimeridian) : d3_geo_clipCircle((clipAngle = +_) * d3_radians);
            return invalidate();
        };
        projection.clipExtent = function(_) {
            if (!arguments.length) return clipExtent;
            clipExtent = _;
            postclip = _ ? d3_geo_clipExtent(_[0][0], _[0][1], _[1][0], _[1][1]) : d3_identity;
            return invalidate();
        };
        projection.scale = function(_) {
            if (!arguments.length) return k;
            k = +_;
            return reset();
        };
        projection.translate = function(_) {
            if (!arguments.length) return [ x, y ];
            x = +_[0];
            y = +_[1];
            return reset();
        };
        projection.center = function(_) {
            if (!arguments.length) return [ λ * d3_degrees, φ * d3_degrees ];
            λ = _[0] % 360 * d3_radians;
            φ = _[1] % 360 * d3_radians;
            return reset();
        };
        projection.rotate = function(_) {
            if (!arguments.length) return [ δλ * d3_degrees, δφ * d3_degrees, δγ * d3_degrees ];
            δλ = _[0] % 360 * d3_radians;
            δφ = _[1] % 360 * d3_radians;
            δγ = _.length > 2 ? _[2] % 360 * d3_radians : 0;
            return reset();
        };
        d3.rebind(projection, projectResample, "precision");
        function reset() {
            projectRotate = d3_geo_compose(rotate = d3_geo_rotation(δλ, δφ, δγ), project);
            var center = project(λ, φ);
            δx = x - center[0] * k;
            δy = y + center[1] * k;
            return invalidate();
        }
        function invalidate() {
            if (stream) stream.valid = false, stream = null;
            return projection;
        }
        return function() {
            project = projectAt.apply(this, arguments);
            projection.invert = project.invert && invert;
            return reset();
        };
    }
    function d3_geo_projectionRadians(stream) {
        return d3_geo_transformPoint(stream, function(x, y) {
            stream.point(x * d3_radians, y * d3_radians);
        });
    }
    function d3_geo_equirectangular(λ, φ) {
        return [ λ, φ ];
    }
    (d3.geo.equirectangular = function() {
        return d3_geo_projection(d3_geo_equirectangular);
    }).raw = d3_geo_equirectangular.invert = d3_geo_equirectangular;
    d3.geo.rotation = function(rotate) {
        rotate = d3_geo_rotation(rotate[0] % 360 * d3_radians, rotate[1] * d3_radians, rotate.length > 2 ? rotate[2] * d3_radians : 0);
        function forward(coordinates) {
            coordinates = rotate(coordinates[0] * d3_radians, coordinates[1] * d3_radians);
            return coordinates[0] *= d3_degrees, coordinates[1] *= d3_degrees, coordinates;
        }
        forward.invert = function(coordinates) {
            coordinates = rotate.invert(coordinates[0] * d3_radians, coordinates[1] * d3_radians);
            return coordinates[0] *= d3_degrees, coordinates[1] *= d3_degrees, coordinates;
        };
        return forward;
    };
    function d3_geo_identityRotation(λ, φ) {
        return [ λ > π ? λ - τ : λ < -π ? λ + τ : λ, φ ];
    }
    d3_geo_identityRotation.invert = d3_geo_equirectangular;
    function d3_geo_rotation(δλ, δφ, δγ) {
        return δλ ? δφ || δγ ? d3_geo_compose(d3_geo_rotationλ(δλ), d3_geo_rotationφγ(δφ, δγ)) : d3_geo_rotationλ(δλ) : δφ || δγ ? d3_geo_rotationφγ(δφ, δγ) : d3_geo_identityRotation;
    }
    function d3_geo_forwardRotationλ(δλ) {
        return function(λ, φ) {
            return λ += δλ, [ λ > π ? λ - τ : λ < -π ? λ + τ : λ, φ ];
        };
    }
    function d3_geo_rotationλ(δλ) {
        var rotation = d3_geo_forwardRotationλ(δλ);
        rotation.invert = d3_geo_forwardRotationλ(-δλ);
        return rotation;
    }
    function d3_geo_rotationφγ(δφ, δγ) {
        var cosδφ = Math.cos(δφ), sinδφ = Math.sin(δφ), cosδγ = Math.cos(δγ), sinδγ = Math.sin(δγ);
        function rotation(λ, φ) {
            var cosφ = Math.cos(φ), x = Math.cos(λ) * cosφ, y = Math.sin(λ) * cosφ, z = Math.sin(φ), k = z * cosδφ + x * sinδφ;
            return [ Math.atan2(y * cosδγ - k * sinδγ, x * cosδφ - z * sinδφ), d3_asin(k * cosδγ + y * sinδγ) ];
        }
        rotation.invert = function(λ, φ) {
            var cosφ = Math.cos(φ), x = Math.cos(λ) * cosφ, y = Math.sin(λ) * cosφ, z = Math.sin(φ), k = z * cosδγ - y * sinδγ;
            return [ Math.atan2(y * cosδγ + z * sinδγ, x * cosδφ + k * sinδφ), d3_asin(k * cosδφ - x * sinδφ) ];
        };
        return rotation;
    }
    d3.geo.circle = function() {
        var origin = [ 0, 0 ], angle, precision = 6, interpolate;
        function circle() {
            var center = typeof origin === "function" ? origin.apply(this, arguments) : origin, rotate = d3_geo_rotation(-center[0] * d3_radians, -center[1] * d3_radians, 0).invert, ring = [];
            interpolate(null, null, 1, {
                point: function(x, y) {
                    ring.push(x = rotate(x, y));
                    x[0] *= d3_degrees, x[1] *= d3_degrees;
                }
            });
            return {
                type: "Polygon",
                coordinates: [ ring ]
            };
        }
        circle.origin = function(x) {
            if (!arguments.length) return origin;
            origin = x;
            return circle;
        };
        circle.angle = function(x) {
            if (!arguments.length) return angle;
            interpolate = d3_geo_circleInterpolate((angle = +x) * d3_radians, precision * d3_radians);
            return circle;
        };
        circle.precision = function(_) {
            if (!arguments.length) return precision;
            interpolate = d3_geo_circleInterpolate(angle * d3_radians, (precision = +_) * d3_radians);
            return circle;
        };
        return circle.angle(90);
    };
    function d3_geo_circleInterpolate(radius, precision) {
        var cr = Math.cos(radius), sr = Math.sin(radius);
        return function(from, to, direction, listener) {
            var step = direction * precision;
            if (from != null) {
                from = d3_geo_circleAngle(cr, from);
                to = d3_geo_circleAngle(cr, to);
                if (direction > 0 ? from < to : from > to) from += direction * τ;
            } else {
                from = radius + direction * τ;
                to = radius - .5 * step;
            }
            for (var point, t = from; direction > 0 ? t > to : t < to; t -= step) {
                listener.point((point = d3_geo_spherical([ cr, -sr * Math.cos(t), -sr * Math.sin(t) ]))[0], point[1]);
            }
        };
    }
    function d3_geo_circleAngle(cr, point) {
        var a = d3_geo_cartesian(point);
        a[0] -= cr;
        d3_geo_cartesianNormalize(a);
        var angle = d3_acos(-a[1]);
        return ((-a[2] < 0 ? -angle : angle) + 2 * Math.PI - ε) % (2 * Math.PI);
    }
    d3.geo.distance = function(a, b) {
        var Δλ = (b[0] - a[0]) * d3_radians, φ0 = a[1] * d3_radians, φ1 = b[1] * d3_radians, sinΔλ = Math.sin(Δλ), cosΔλ = Math.cos(Δλ), sinφ0 = Math.sin(φ0), cosφ0 = Math.cos(φ0), sinφ1 = Math.sin(φ1), cosφ1 = Math.cos(φ1), t;
        return Math.atan2(Math.sqrt((t = cosφ1 * sinΔλ) * t + (t = cosφ0 * sinφ1 - sinφ0 * cosφ1 * cosΔλ) * t), sinφ0 * sinφ1 + cosφ0 * cosφ1 * cosΔλ);
    };
    d3.geo.graticule = function() {
        var x1, x0, X1, X0, y1, y0, Y1, Y0, dx = 10, dy = dx, DX = 90, DY = 360, x, y, X, Y, precision = 2.5;
        function graticule() {
            return {
                type: "MultiLineString",
                coordinates: lines()
            };
        }
        function lines() {
            return d3.range(Math.ceil(X0 / DX) * DX, X1, DX).map(X).concat(d3.range(Math.ceil(Y0 / DY) * DY, Y1, DY).map(Y)).concat(d3.range(Math.ceil(x0 / dx) * dx, x1, dx).filter(function(x) {
                return abs(x % DX) > ε;
            }).map(x)).concat(d3.range(Math.ceil(y0 / dy) * dy, y1, dy).filter(function(y) {
                return abs(y % DY) > ε;
            }).map(y));
        }
        graticule.lines = function() {
            return lines().map(function(coordinates) {
                return {
                    type: "LineString",
                    coordinates: coordinates
                };
            });
        };
        graticule.outline = function() {
            return {
                type: "Polygon",
                coordinates: [ X(X0).concat(Y(Y1).slice(1), X(X1).reverse().slice(1), Y(Y0).reverse().slice(1)) ]
            };
        };
        graticule.extent = function(_) {
            if (!arguments.length) return graticule.minorExtent();
            return graticule.majorExtent(_).minorExtent(_);
        };
        graticule.majorExtent = function(_) {
            if (!arguments.length) return [ [ X0, Y0 ], [ X1, Y1 ] ];
            X0 = +_[0][0], X1 = +_[1][0];
            Y0 = +_[0][1], Y1 = +_[1][1];
            if (X0 > X1) _ = X0, X0 = X1, X1 = _;
            if (Y0 > Y1) _ = Y0, Y0 = Y1, Y1 = _;
            return graticule.precision(precision);
        };
        graticule.minorExtent = function(_) {
            if (!arguments.length) return [ [ x0, y0 ], [ x1, y1 ] ];
            x0 = +_[0][0], x1 = +_[1][0];
            y0 = +_[0][1], y1 = +_[1][1];
            if (x0 > x1) _ = x0, x0 = x1, x1 = _;
            if (y0 > y1) _ = y0, y0 = y1, y1 = _;
            return graticule.precision(precision);
        };
        graticule.step = function(_) {
            if (!arguments.length) return graticule.minorStep();
            return graticule.majorStep(_).minorStep(_);
        };
        graticule.majorStep = function(_) {
            if (!arguments.length) return [ DX, DY ];
            DX = +_[0], DY = +_[1];
            return graticule;
        };
        graticule.minorStep = function(_) {
            if (!arguments.length) return [ dx, dy ];
            dx = +_[0], dy = +_[1];
            return graticule;
        };
        graticule.precision = function(_) {
            if (!arguments.length) return precision;
            precision = +_;
            x = d3_geo_graticuleX(y0, y1, 90);
            y = d3_geo_graticuleY(x0, x1, precision);
            X = d3_geo_graticuleX(Y0, Y1, 90);
            Y = d3_geo_graticuleY(X0, X1, precision);
            return graticule;
        };
        return graticule.majorExtent([ [ -180, -90 + ε ], [ 180, 90 - ε ] ]).minorExtent([ [ -180, -80 - ε ], [ 180, 80 + ε ] ]);
    };
    function d3_geo_graticuleX(y0, y1, dy) {
        var y = d3.range(y0, y1 - ε, dy).concat(y1);
        return function(x) {
            return y.map(function(y) {
                return [ x, y ];
            });
        };
    }
    function d3_geo_graticuleY(x0, x1, dx) {
        var x = d3.range(x0, x1 - ε, dx).concat(x1);
        return function(y) {
            return x.map(function(x) {
                return [ x, y ];
            });
        };
    }
    function d3_source(d) {
        return d.source;
    }
    function d3_target(d) {
        return d.target;
    }
    d3.geo.greatArc = function() {
        var source = d3_source, source_, target = d3_target, target_;
        function greatArc() {
            return {
                type: "LineString",
                coordinates: [ source_ || source.apply(this, arguments), target_ || target.apply(this, arguments) ]
            };
        }
        greatArc.distance = function() {
            return d3.geo.distance(source_ || source.apply(this, arguments), target_ || target.apply(this, arguments));
        };
        greatArc.source = function(_) {
            if (!arguments.length) return source;
            source = _, source_ = typeof _ === "function" ? null : _;
            return greatArc;
        };
        greatArc.target = function(_) {
            if (!arguments.length) return target;
            target = _, target_ = typeof _ === "function" ? null : _;
            return greatArc;
        };
        greatArc.precision = function() {
            return arguments.length ? greatArc : 0;
        };
        return greatArc;
    };
    d3.geo.interpolate = function(source, target) {
        return d3_geo_interpolate(source[0] * d3_radians, source[1] * d3_radians, target[0] * d3_radians, target[1] * d3_radians);
    };
    function d3_geo_interpolate(x0, y0, x1, y1) {
        var cy0 = Math.cos(y0), sy0 = Math.sin(y0), cy1 = Math.cos(y1), sy1 = Math.sin(y1), kx0 = cy0 * Math.cos(x0), ky0 = cy0 * Math.sin(x0), kx1 = cy1 * Math.cos(x1), ky1 = cy1 * Math.sin(x1), d = 2 * Math.asin(Math.sqrt(d3_haversin(y1 - y0) + cy0 * cy1 * d3_haversin(x1 - x0))), k = 1 / Math.sin(d);
        var interpolate = d ? function(t) {
            var B = Math.sin(t *= d) * k, A = Math.sin(d - t) * k, x = A * kx0 + B * kx1, y = A * ky0 + B * ky1, z = A * sy0 + B * sy1;
            return [ Math.atan2(y, x) * d3_degrees, Math.atan2(z, Math.sqrt(x * x + y * y)) * d3_degrees ];
        } : function() {
            return [ x0 * d3_degrees, y0 * d3_degrees ];
        };
        interpolate.distance = d;
        return interpolate;
    }
    d3.geo.length = function(object) {
        d3_geo_lengthSum = 0;
        d3.geo.stream(object, d3_geo_length);
        return d3_geo_lengthSum;
    };
    var d3_geo_lengthSum;
    var d3_geo_length = {
        sphere: d3_noop,
        point: d3_noop,
        lineStart: d3_geo_lengthLineStart,
        lineEnd: d3_noop,
        polygonStart: d3_noop,
        polygonEnd: d3_noop
    };
    function d3_geo_lengthLineStart() {
        var λ0, sinφ0, cosφ0;
        d3_geo_length.point = function(λ, φ) {
            λ0 = λ * d3_radians, sinφ0 = Math.sin(φ *= d3_radians), cosφ0 = Math.cos(φ);
            d3_geo_length.point = nextPoint;
        };
        d3_geo_length.lineEnd = function() {
            d3_geo_length.point = d3_geo_length.lineEnd = d3_noop;
        };
        function nextPoint(λ, φ) {
            var sinφ = Math.sin(φ *= d3_radians), cosφ = Math.cos(φ), t = abs((λ *= d3_radians) - λ0), cosΔλ = Math.cos(t);
            d3_geo_lengthSum += Math.atan2(Math.sqrt((t = cosφ * Math.sin(t)) * t + (t = cosφ0 * sinφ - sinφ0 * cosφ * cosΔλ) * t), sinφ0 * sinφ + cosφ0 * cosφ * cosΔλ);
            λ0 = λ, sinφ0 = sinφ, cosφ0 = cosφ;
        }
    }
    function d3_geo_azimuthal(scale, angle) {
        function azimuthal(λ, φ) {
            var cosλ = Math.cos(λ), cosφ = Math.cos(φ), k = scale(cosλ * cosφ);
            return [ k * cosφ * Math.sin(λ), k * Math.sin(φ) ];
        }
        azimuthal.invert = function(x, y) {
            var ρ = Math.sqrt(x * x + y * y), c = angle(ρ), sinc = Math.sin(c), cosc = Math.cos(c);
            return [ Math.atan2(x * sinc, ρ * cosc), Math.asin(ρ && y * sinc / ρ) ];
        };
        return azimuthal;
    }
    var d3_geo_azimuthalEqualArea = d3_geo_azimuthal(function(cosλcosφ) {
        return Math.sqrt(2 / (1 + cosλcosφ));
    }, function(ρ) {
        return 2 * Math.asin(ρ / 2);
    });
    (d3.geo.azimuthalEqualArea = function() {
        return d3_geo_projection(d3_geo_azimuthalEqualArea);
    }).raw = d3_geo_azimuthalEqualArea;
    var d3_geo_azimuthalEquidistant = d3_geo_azimuthal(function(cosλcosφ) {
        var c = Math.acos(cosλcosφ);
        return c && c / Math.sin(c);
    }, d3_identity);
    (d3.geo.azimuthalEquidistant = function() {
        return d3_geo_projection(d3_geo_azimuthalEquidistant);
    }).raw = d3_geo_azimuthalEquidistant;
    function d3_geo_conicConformal(φ0, φ1) {
        var cosφ0 = Math.cos(φ0), t = function(φ) {
            return Math.tan(π / 4 + φ / 2);
        }, n = φ0 === φ1 ? Math.sin(φ0) : Math.log(cosφ0 / Math.cos(φ1)) / Math.log(t(φ1) / t(φ0)), F = cosφ0 * Math.pow(t(φ0), n) / n;
        if (!n) return d3_geo_mercator;
        function forward(λ, φ) {
            if (F > 0) {
                if (φ < -halfπ + ε) φ = -halfπ + ε;
            } else {
                if (φ > halfπ - ε) φ = halfπ - ε;
            }
            var ρ = F / Math.pow(t(φ), n);
            return [ ρ * Math.sin(n * λ), F - ρ * Math.cos(n * λ) ];
        }
        forward.invert = function(x, y) {
            var ρ0_y = F - y, ρ = d3_sgn(n) * Math.sqrt(x * x + ρ0_y * ρ0_y);
            return [ Math.atan2(x, ρ0_y) / n, 2 * Math.atan(Math.pow(F / ρ, 1 / n)) - halfπ ];
        };
        return forward;
    }
    (d3.geo.conicConformal = function() {
        return d3_geo_conic(d3_geo_conicConformal);
    }).raw = d3_geo_conicConformal;
    function d3_geo_conicEquidistant(φ0, φ1) {
        var cosφ0 = Math.cos(φ0), n = φ0 === φ1 ? Math.sin(φ0) : (cosφ0 - Math.cos(φ1)) / (φ1 - φ0), G = cosφ0 / n + φ0;
        if (abs(n) < ε) return d3_geo_equirectangular;
        function forward(λ, φ) {
            var ρ = G - φ;
            return [ ρ * Math.sin(n * λ), G - ρ * Math.cos(n * λ) ];
        }
        forward.invert = function(x, y) {
            var ρ0_y = G - y;
            return [ Math.atan2(x, ρ0_y) / n, G - d3_sgn(n) * Math.sqrt(x * x + ρ0_y * ρ0_y) ];
        };
        return forward;
    }
    (d3.geo.conicEquidistant = function() {
        return d3_geo_conic(d3_geo_conicEquidistant);
    }).raw = d3_geo_conicEquidistant;
    var d3_geo_gnomonic = d3_geo_azimuthal(function(cosλcosφ) {
        return 1 / cosλcosφ;
    }, Math.atan);
    (d3.geo.gnomonic = function() {
        return d3_geo_projection(d3_geo_gnomonic);
    }).raw = d3_geo_gnomonic;
    function d3_geo_mercator(λ, φ) {
        return [ λ, Math.log(Math.tan(π / 4 + φ / 2)) ];
    }
    d3_geo_mercator.invert = function(x, y) {
        return [ x, 2 * Math.atan(Math.exp(y)) - halfπ ];
    };
    function d3_geo_mercatorProjection(project) {
        var m = d3_geo_projection(project), scale = m.scale, translate = m.translate, clipExtent = m.clipExtent, clipAuto;
        m.scale = function() {
            var v = scale.apply(m, arguments);
            return v === m ? clipAuto ? m.clipExtent(null) : m : v;
        };
        m.translate = function() {
            var v = translate.apply(m, arguments);
            return v === m ? clipAuto ? m.clipExtent(null) : m : v;
        };
        m.clipExtent = function(_) {
            var v = clipExtent.apply(m, arguments);
            if (v === m) {
                if (clipAuto = _ == null) {
                    var k = π * scale(), t = translate();
                    clipExtent([ [ t[0] - k, t[1] - k ], [ t[0] + k, t[1] + k ] ]);
                }
            } else if (clipAuto) {
                v = null;
            }
            return v;
        };
        return m.clipExtent(null);
    }
    (d3.geo.mercator = function() {
        return d3_geo_mercatorProjection(d3_geo_mercator);
    }).raw = d3_geo_mercator;
    var d3_geo_orthographic = d3_geo_azimuthal(function() {
        return 1;
    }, Math.asin);
    (d3.geo.orthographic = function() {
        return d3_geo_projection(d3_geo_orthographic);
    }).raw = d3_geo_orthographic;
    var d3_geo_stereographic = d3_geo_azimuthal(function(cosλcosφ) {
        return 1 / (1 + cosλcosφ);
    }, function(ρ) {
        return 2 * Math.atan(ρ);
    });
    (d3.geo.stereographic = function() {
        return d3_geo_projection(d3_geo_stereographic);
    }).raw = d3_geo_stereographic;
    function d3_geo_transverseMercator(λ, φ) {
        return [ Math.log(Math.tan(π / 4 + φ / 2)), -λ ];
    }
    d3_geo_transverseMercator.invert = function(x, y) {
        return [ -y, 2 * Math.atan(Math.exp(x)) - halfπ ];
    };
    (d3.geo.transverseMercator = function() {
        var projection = d3_geo_mercatorProjection(d3_geo_transverseMercator), center = projection.center, rotate = projection.rotate;
        projection.center = function(_) {
            return _ ? center([ -_[1], _[0] ]) : (_ = center(), [ _[1], -_[0] ]);
        };
        projection.rotate = function(_) {
            return _ ? rotate([ _[0], _[1], _.length > 2 ? _[2] + 90 : 90 ]) : (_ = rotate(),
                [ _[0], _[1], _[2] - 90 ]);
        };
        return rotate([ 0, 0, 90 ]);
    }).raw = d3_geo_transverseMercator;
    d3.geom = {};
    function d3_geom_pointX(d) {
        return d[0];
    }
    function d3_geom_pointY(d) {
        return d[1];
    }
    d3.geom.hull = function(vertices) {
        var x = d3_geom_pointX, y = d3_geom_pointY;
        if (arguments.length) return hull(vertices);
        function hull(data) {
            if (data.length < 3) return [];
            var fx = d3_functor(x), fy = d3_functor(y), i, n = data.length, points = [], flippedPoints = [];
            for (i = 0; i < n; i++) {
                points.push([ +fx.call(this, data[i], i), +fy.call(this, data[i], i), i ]);
            }
            points.sort(d3_geom_hullOrder);
            for (i = 0; i < n; i++) flippedPoints.push([ points[i][0], -points[i][1] ]);
            var upper = d3_geom_hullUpper(points), lower = d3_geom_hullUpper(flippedPoints);
            var skipLeft = lower[0] === upper[0], skipRight = lower[lower.length - 1] === upper[upper.length - 1], polygon = [];
            for (i = upper.length - 1; i >= 0; --i) polygon.push(data[points[upper[i]][2]]);
            for (i = +skipLeft; i < lower.length - skipRight; ++i) polygon.push(data[points[lower[i]][2]]);
            return polygon;
        }
        hull.x = function(_) {
            return arguments.length ? (x = _, hull) : x;
        };
        hull.y = function(_) {
            return arguments.length ? (y = _, hull) : y;
        };
        return hull;
    };
    function d3_geom_hullUpper(points) {
        var n = points.length, hull = [ 0, 1 ], hs = 2;
        for (var i = 2; i < n; i++) {
            while (hs > 1 && d3_cross2d(points[hull[hs - 2]], points[hull[hs - 1]], points[i]) <= 0) --hs;
            hull[hs++] = i;
        }
        return hull.slice(0, hs);
    }
    function d3_geom_hullOrder(a, b) {
        return a[0] - b[0] || a[1] - b[1];
    }
    d3.geom.polygon = function(coordinates) {
        d3_subclass(coordinates, d3_geom_polygonPrototype);
        return coordinates;
    };
    var d3_geom_polygonPrototype = d3.geom.polygon.prototype = [];
    d3_geom_polygonPrototype.area = function() {
        var i = -1, n = this.length, a, b = this[n - 1], area = 0;
        while (++i < n) {
            a = b;
            b = this[i];
            area += a[1] * b[0] - a[0] * b[1];
        }
        return area * .5;
    };
    d3_geom_polygonPrototype.centroid = function(k) {
        var i = -1, n = this.length, x = 0, y = 0, a, b = this[n - 1], c;
        if (!arguments.length) k = -1 / (6 * this.area());
        while (++i < n) {
            a = b;
            b = this[i];
            c = a[0] * b[1] - b[0] * a[1];
            x += (a[0] + b[0]) * c;
            y += (a[1] + b[1]) * c;
        }
        return [ x * k, y * k ];
    };
    d3_geom_polygonPrototype.clip = function(subject) {
        var input, closed = d3_geom_polygonClosed(subject), i = -1, n = this.length - d3_geom_polygonClosed(this), j, m, a = this[n - 1], b, c, d;
        while (++i < n) {
            input = subject.slice();
            subject.length = 0;
            b = this[i];
            c = input[(m = input.length - closed) - 1];
            j = -1;
            while (++j < m) {
                d = input[j];
                if (d3_geom_polygonInside(d, a, b)) {
                    if (!d3_geom_polygonInside(c, a, b)) {
                        subject.push(d3_geom_polygonIntersect(c, d, a, b));
                    }
                    subject.push(d);
                } else if (d3_geom_polygonInside(c, a, b)) {
                    subject.push(d3_geom_polygonIntersect(c, d, a, b));
                }
                c = d;
            }
            if (closed) subject.push(subject[0]);
            a = b;
        }
        return subject;
    };
    function d3_geom_polygonInside(p, a, b) {
        return (b[0] - a[0]) * (p[1] - a[1]) < (b[1] - a[1]) * (p[0] - a[0]);
    }
    function d3_geom_polygonIntersect(c, d, a, b) {
        var x1 = c[0], x3 = a[0], x21 = d[0] - x1, x43 = b[0] - x3, y1 = c[1], y3 = a[1], y21 = d[1] - y1, y43 = b[1] - y3, ua = (x43 * (y1 - y3) - y43 * (x1 - x3)) / (y43 * x21 - x43 * y21);
        return [ x1 + ua * x21, y1 + ua * y21 ];
    }
    function d3_geom_polygonClosed(coordinates) {
        var a = coordinates[0], b = coordinates[coordinates.length - 1];
        return !(a[0] - b[0] || a[1] - b[1]);
    }
    var d3_geom_voronoiEdges, d3_geom_voronoiCells, d3_geom_voronoiBeaches, d3_geom_voronoiBeachPool = [], d3_geom_voronoiFirstCircle, d3_geom_voronoiCircles, d3_geom_voronoiCirclePool = [];
    function d3_geom_voronoiBeach() {
        d3_geom_voronoiRedBlackNode(this);
        this.edge = this.site = this.circle = null;
    }
    function d3_geom_voronoiCreateBeach(site) {
        var beach = d3_geom_voronoiBeachPool.pop() || new d3_geom_voronoiBeach();
        beach.site = site;
        return beach;
    }
    function d3_geom_voronoiDetachBeach(beach) {
        d3_geom_voronoiDetachCircle(beach);
        d3_geom_voronoiBeaches.remove(beach);
        d3_geom_voronoiBeachPool.push(beach);
        d3_geom_voronoiRedBlackNode(beach);
    }
    function d3_geom_voronoiRemoveBeach(beach) {
        var circle = beach.circle, x = circle.x, y = circle.cy, vertex = {
            x: x,
            y: y
        }, previous = beach.P, next = beach.N, disappearing = [ beach ];
        d3_geom_voronoiDetachBeach(beach);
        var lArc = previous;
        while (lArc.circle && abs(x - lArc.circle.x) < ε && abs(y - lArc.circle.cy) < ε) {
            previous = lArc.P;
            disappearing.unshift(lArc);
            d3_geom_voronoiDetachBeach(lArc);
            lArc = previous;
        }
        disappearing.unshift(lArc);
        d3_geom_voronoiDetachCircle(lArc);
        var rArc = next;
        while (rArc.circle && abs(x - rArc.circle.x) < ε && abs(y - rArc.circle.cy) < ε) {
            next = rArc.N;
            disappearing.push(rArc);
            d3_geom_voronoiDetachBeach(rArc);
            rArc = next;
        }
        disappearing.push(rArc);
        d3_geom_voronoiDetachCircle(rArc);
        var nArcs = disappearing.length, iArc;
        for (iArc = 1; iArc < nArcs; ++iArc) {
            rArc = disappearing[iArc];
            lArc = disappearing[iArc - 1];
            d3_geom_voronoiSetEdgeEnd(rArc.edge, lArc.site, rArc.site, vertex);
        }
        lArc = disappearing[0];
        rArc = disappearing[nArcs - 1];
        rArc.edge = d3_geom_voronoiCreateEdge(lArc.site, rArc.site, null, vertex);
        d3_geom_voronoiAttachCircle(lArc);
        d3_geom_voronoiAttachCircle(rArc);
    }
    function d3_geom_voronoiAddBeach(site) {
        var x = site.x, directrix = site.y, lArc, rArc, dxl, dxr, node = d3_geom_voronoiBeaches._;
        while (node) {
            dxl = d3_geom_voronoiLeftBreakPoint(node, directrix) - x;
            if (dxl > ε) node = node.L; else {
                dxr = x - d3_geom_voronoiRightBreakPoint(node, directrix);
                if (dxr > ε) {
                    if (!node.R) {
                        lArc = node;
                        break;
                    }
                    node = node.R;
                } else {
                    if (dxl > -ε) {
                        lArc = node.P;
                        rArc = node;
                    } else if (dxr > -ε) {
                        lArc = node;
                        rArc = node.N;
                    } else {
                        lArc = rArc = node;
                    }
                    break;
                }
            }
        }
        var newArc = d3_geom_voronoiCreateBeach(site);
        d3_geom_voronoiBeaches.insert(lArc, newArc);
        if (!lArc && !rArc) return;
        if (lArc === rArc) {
            d3_geom_voronoiDetachCircle(lArc);
            rArc = d3_geom_voronoiCreateBeach(lArc.site);
            d3_geom_voronoiBeaches.insert(newArc, rArc);
            newArc.edge = rArc.edge = d3_geom_voronoiCreateEdge(lArc.site, newArc.site);
            d3_geom_voronoiAttachCircle(lArc);
            d3_geom_voronoiAttachCircle(rArc);
            return;
        }
        if (!rArc) {
            newArc.edge = d3_geom_voronoiCreateEdge(lArc.site, newArc.site);
            return;
        }
        d3_geom_voronoiDetachCircle(lArc);
        d3_geom_voronoiDetachCircle(rArc);
        var lSite = lArc.site, ax = lSite.x, ay = lSite.y, bx = site.x - ax, by = site.y - ay, rSite = rArc.site, cx = rSite.x - ax, cy = rSite.y - ay, d = 2 * (bx * cy - by * cx), hb = bx * bx + by * by, hc = cx * cx + cy * cy, vertex = {
            x: (cy * hb - by * hc) / d + ax,
            y: (bx * hc - cx * hb) / d + ay
        };
        d3_geom_voronoiSetEdgeEnd(rArc.edge, lSite, rSite, vertex);
        newArc.edge = d3_geom_voronoiCreateEdge(lSite, site, null, vertex);
        rArc.edge = d3_geom_voronoiCreateEdge(site, rSite, null, vertex);
        d3_geom_voronoiAttachCircle(lArc);
        d3_geom_voronoiAttachCircle(rArc);
    }
    function d3_geom_voronoiLeftBreakPoint(arc, directrix) {
        var site = arc.site, rfocx = site.x, rfocy = site.y, pby2 = rfocy - directrix;
        if (!pby2) return rfocx;
        var lArc = arc.P;
        if (!lArc) return -Infinity;
        site = lArc.site;
        var lfocx = site.x, lfocy = site.y, plby2 = lfocy - directrix;
        if (!plby2) return lfocx;
        var hl = lfocx - rfocx, aby2 = 1 / pby2 - 1 / plby2, b = hl / plby2;
        if (aby2) return (-b + Math.sqrt(b * b - 2 * aby2 * (hl * hl / (-2 * plby2) - lfocy + plby2 / 2 + rfocy - pby2 / 2))) / aby2 + rfocx;
        return (rfocx + lfocx) / 2;
    }
    function d3_geom_voronoiRightBreakPoint(arc, directrix) {
        var rArc = arc.N;
        if (rArc) return d3_geom_voronoiLeftBreakPoint(rArc, directrix);
        var site = arc.site;
        return site.y === directrix ? site.x : Infinity;
    }
    function d3_geom_voronoiCell(site) {
        this.site = site;
        this.edges = [];
    }
    d3_geom_voronoiCell.prototype.prepare = function() {
        var halfEdges = this.edges, iHalfEdge = halfEdges.length, edge;
        while (iHalfEdge--) {
            edge = halfEdges[iHalfEdge].edge;
            if (!edge.b || !edge.a) halfEdges.splice(iHalfEdge, 1);
        }
        halfEdges.sort(d3_geom_voronoiHalfEdgeOrder);
        return halfEdges.length;
    };
    function d3_geom_voronoiCloseCells(extent) {
        var x0 = extent[0][0], x1 = extent[1][0], y0 = extent[0][1], y1 = extent[1][1], x2, y2, x3, y3, cells = d3_geom_voronoiCells, iCell = cells.length, cell, iHalfEdge, halfEdges, nHalfEdges, start, end;
        while (iCell--) {
            cell = cells[iCell];
            if (!cell || !cell.prepare()) continue;
            halfEdges = cell.edges;
            nHalfEdges = halfEdges.length;
            iHalfEdge = 0;
            while (iHalfEdge < nHalfEdges) {
                end = halfEdges[iHalfEdge].end(), x3 = end.x, y3 = end.y;
                start = halfEdges[++iHalfEdge % nHalfEdges].start(), x2 = start.x, y2 = start.y;
                if (abs(x3 - x2) > ε || abs(y3 - y2) > ε) {
                    halfEdges.splice(iHalfEdge, 0, new d3_geom_voronoiHalfEdge(d3_geom_voronoiCreateBorderEdge(cell.site, end, abs(x3 - x0) < ε && y1 - y3 > ε ? {
                        x: x0,
                        y: abs(x2 - x0) < ε ? y2 : y1
                    } : abs(y3 - y1) < ε && x1 - x3 > ε ? {
                        x: abs(y2 - y1) < ε ? x2 : x1,
                        y: y1
                    } : abs(x3 - x1) < ε && y3 - y0 > ε ? {
                        x: x1,
                        y: abs(x2 - x1) < ε ? y2 : y0
                    } : abs(y3 - y0) < ε && x3 - x0 > ε ? {
                        x: abs(y2 - y0) < ε ? x2 : x0,
                        y: y0
                    } : null), cell.site, null));
                    ++nHalfEdges;
                }
            }
        }
    }
    function d3_geom_voronoiHalfEdgeOrder(a, b) {
        return b.angle - a.angle;
    }
    function d3_geom_voronoiCircle() {
        d3_geom_voronoiRedBlackNode(this);
        this.x = this.y = this.arc = this.site = this.cy = null;
    }
    function d3_geom_voronoiAttachCircle(arc) {
        var lArc = arc.P, rArc = arc.N;
        if (!lArc || !rArc) return;
        var lSite = lArc.site, cSite = arc.site, rSite = rArc.site;
        if (lSite === rSite) return;
        var bx = cSite.x, by = cSite.y, ax = lSite.x - bx, ay = lSite.y - by, cx = rSite.x - bx, cy = rSite.y - by;
        var d = 2 * (ax * cy - ay * cx);
        if (d >= -ε2) return;
        var ha = ax * ax + ay * ay, hc = cx * cx + cy * cy, x = (cy * ha - ay * hc) / d, y = (ax * hc - cx * ha) / d, cy = y + by;
        var circle = d3_geom_voronoiCirclePool.pop() || new d3_geom_voronoiCircle();
        circle.arc = arc;
        circle.site = cSite;
        circle.x = x + bx;
        circle.y = cy + Math.sqrt(x * x + y * y);
        circle.cy = cy;
        arc.circle = circle;
        var before = null, node = d3_geom_voronoiCircles._;
        while (node) {
            if (circle.y < node.y || circle.y === node.y && circle.x <= node.x) {
                if (node.L) node = node.L; else {
                    before = node.P;
                    break;
                }
            } else {
                if (node.R) node = node.R; else {
                    before = node;
                    break;
                }
            }
        }
        d3_geom_voronoiCircles.insert(before, circle);
        if (!before) d3_geom_voronoiFirstCircle = circle;
    }
    function d3_geom_voronoiDetachCircle(arc) {
        var circle = arc.circle;
        if (circle) {
            if (!circle.P) d3_geom_voronoiFirstCircle = circle.N;
            d3_geom_voronoiCircles.remove(circle);
            d3_geom_voronoiCirclePool.push(circle);
            d3_geom_voronoiRedBlackNode(circle);
            arc.circle = null;
        }
    }
    function d3_geom_voronoiClipEdges(extent) {
        var edges = d3_geom_voronoiEdges, clip = d3_geom_clipLine(extent[0][0], extent[0][1], extent[1][0], extent[1][1]), i = edges.length, e;
        while (i--) {
            e = edges[i];
            if (!d3_geom_voronoiConnectEdge(e, extent) || !clip(e) || abs(e.a.x - e.b.x) < ε && abs(e.a.y - e.b.y) < ε) {
                e.a = e.b = null;
                edges.splice(i, 1);
            }
        }
    }
    function d3_geom_voronoiConnectEdge(edge, extent) {
        var vb = edge.b;
        if (vb) return true;
        var va = edge.a, x0 = extent[0][0], x1 = extent[1][0], y0 = extent[0][1], y1 = extent[1][1], lSite = edge.l, rSite = edge.r, lx = lSite.x, ly = lSite.y, rx = rSite.x, ry = rSite.y, fx = (lx + rx) / 2, fy = (ly + ry) / 2, fm, fb;
        if (ry === ly) {
            if (fx < x0 || fx >= x1) return;
            if (lx > rx) {
                if (!va) va = {
                    x: fx,
                    y: y0
                }; else if (va.y >= y1) return;
                vb = {
                    x: fx,
                    y: y1
                };
            } else {
                if (!va) va = {
                    x: fx,
                    y: y1
                }; else if (va.y < y0) return;
                vb = {
                    x: fx,
                    y: y0
                };
            }
        } else {
            fm = (lx - rx) / (ry - ly);
            fb = fy - fm * fx;
            if (fm < -1 || fm > 1) {
                if (lx > rx) {
                    if (!va) va = {
                        x: (y0 - fb) / fm,
                        y: y0
                    }; else if (va.y >= y1) return;
                    vb = {
                        x: (y1 - fb) / fm,
                        y: y1
                    };
                } else {
                    if (!va) va = {
                        x: (y1 - fb) / fm,
                        y: y1
                    }; else if (va.y < y0) return;
                    vb = {
                        x: (y0 - fb) / fm,
                        y: y0
                    };
                }
            } else {
                if (ly < ry) {
                    if (!va) va = {
                        x: x0,
                        y: fm * x0 + fb
                    }; else if (va.x >= x1) return;
                    vb = {
                        x: x1,
                        y: fm * x1 + fb
                    };
                } else {
                    if (!va) va = {
                        x: x1,
                        y: fm * x1 + fb
                    }; else if (va.x < x0) return;
                    vb = {
                        x: x0,
                        y: fm * x0 + fb
                    };
                }
            }
        }
        edge.a = va;
        edge.b = vb;
        return true;
    }
    function d3_geom_voronoiEdge(lSite, rSite) {
        this.l = lSite;
        this.r = rSite;
        this.a = this.b = null;
    }
    function d3_geom_voronoiCreateEdge(lSite, rSite, va, vb) {
        var edge = new d3_geom_voronoiEdge(lSite, rSite);
        d3_geom_voronoiEdges.push(edge);
        if (va) d3_geom_voronoiSetEdgeEnd(edge, lSite, rSite, va);
        if (vb) d3_geom_voronoiSetEdgeEnd(edge, rSite, lSite, vb);
        d3_geom_voronoiCells[lSite.i].edges.push(new d3_geom_voronoiHalfEdge(edge, lSite, rSite));
        d3_geom_voronoiCells[rSite.i].edges.push(new d3_geom_voronoiHalfEdge(edge, rSite, lSite));
        return edge;
    }
    function d3_geom_voronoiCreateBorderEdge(lSite, va, vb) {
        var edge = new d3_geom_voronoiEdge(lSite, null);
        edge.a = va;
        edge.b = vb;
        d3_geom_voronoiEdges.push(edge);
        return edge;
    }
    function d3_geom_voronoiSetEdgeEnd(edge, lSite, rSite, vertex) {
        if (!edge.a && !edge.b) {
            edge.a = vertex;
            edge.l = lSite;
            edge.r = rSite;
        } else if (edge.l === rSite) {
            edge.b = vertex;
        } else {
            edge.a = vertex;
        }
    }
    function d3_geom_voronoiHalfEdge(edge, lSite, rSite) {
        var va = edge.a, vb = edge.b;
        this.edge = edge;
        this.site = lSite;
        this.angle = rSite ? Math.atan2(rSite.y - lSite.y, rSite.x - lSite.x) : edge.l === lSite ? Math.atan2(vb.x - va.x, va.y - vb.y) : Math.atan2(va.x - vb.x, vb.y - va.y);
    }
    d3_geom_voronoiHalfEdge.prototype = {
        start: function() {
            return this.edge.l === this.site ? this.edge.a : this.edge.b;
        },
        end: function() {
            return this.edge.l === this.site ? this.edge.b : this.edge.a;
        }
    };
    function d3_geom_voronoiRedBlackTree() {
        this._ = null;
    }
    function d3_geom_voronoiRedBlackNode(node) {
        node.U = node.C = node.L = node.R = node.P = node.N = null;
    }
    d3_geom_voronoiRedBlackTree.prototype = {
        insert: function(after, node) {
            var parent, grandpa, uncle;
            if (after) {
                node.P = after;
                node.N = after.N;
                if (after.N) after.N.P = node;
                after.N = node;
                if (after.R) {
                    after = after.R;
                    while (after.L) after = after.L;
                    after.L = node;
                } else {
                    after.R = node;
                }
                parent = after;
            } else if (this._) {
                after = d3_geom_voronoiRedBlackFirst(this._);
                node.P = null;
                node.N = after;
                after.P = after.L = node;
                parent = after;
            } else {
                node.P = node.N = null;
                this._ = node;
                parent = null;
            }
            node.L = node.R = null;
            node.U = parent;
            node.C = true;
            after = node;
            while (parent && parent.C) {
                grandpa = parent.U;
                if (parent === grandpa.L) {
                    uncle = grandpa.R;
                    if (uncle && uncle.C) {
                        parent.C = uncle.C = false;
                        grandpa.C = true;
                        after = grandpa;
                    } else {
                        if (after === parent.R) {
                            d3_geom_voronoiRedBlackRotateLeft(this, parent);
                            after = parent;
                            parent = after.U;
                        }
                        parent.C = false;
                        grandpa.C = true;
                        d3_geom_voronoiRedBlackRotateRight(this, grandpa);
                    }
                } else {
                    uncle = grandpa.L;
                    if (uncle && uncle.C) {
                        parent.C = uncle.C = false;
                        grandpa.C = true;
                        after = grandpa;
                    } else {
                        if (after === parent.L) {
                            d3_geom_voronoiRedBlackRotateRight(this, parent);
                            after = parent;
                            parent = after.U;
                        }
                        parent.C = false;
                        grandpa.C = true;
                        d3_geom_voronoiRedBlackRotateLeft(this, grandpa);
                    }
                }
                parent = after.U;
            }
            this._.C = false;
        },
        remove: function(node) {
            if (node.N) node.N.P = node.P;
            if (node.P) node.P.N = node.N;
            node.N = node.P = null;
            var parent = node.U, sibling, left = node.L, right = node.R, next, red;
            if (!left) next = right; else if (!right) next = left; else next = d3_geom_voronoiRedBlackFirst(right);
            if (parent) {
                if (parent.L === node) parent.L = next; else parent.R = next;
            } else {
                this._ = next;
            }
            if (left && right) {
                red = next.C;
                next.C = node.C;
                next.L = left;
                left.U = next;
                if (next !== right) {
                    parent = next.U;
                    next.U = node.U;
                    node = next.R;
                    parent.L = node;
                    next.R = right;
                    right.U = next;
                } else {
                    next.U = parent;
                    parent = next;
                    node = next.R;
                }
            } else {
                red = node.C;
                node = next;
            }
            if (node) node.U = parent;
            if (red) return;
            if (node && node.C) {
                node.C = false;
                return;
            }
            do {
                if (node === this._) break;
                if (node === parent.L) {
                    sibling = parent.R;
                    if (sibling.C) {
                        sibling.C = false;
                        parent.C = true;
                        d3_geom_voronoiRedBlackRotateLeft(this, parent);
                        sibling = parent.R;
                    }
                    if (sibling.L && sibling.L.C || sibling.R && sibling.R.C) {
                        if (!sibling.R || !sibling.R.C) {
                            sibling.L.C = false;
                            sibling.C = true;
                            d3_geom_voronoiRedBlackRotateRight(this, sibling);
                            sibling = parent.R;
                        }
                        sibling.C = parent.C;
                        parent.C = sibling.R.C = false;
                        d3_geom_voronoiRedBlackRotateLeft(this, parent);
                        node = this._;
                        break;
                    }
                } else {
                    sibling = parent.L;
                    if (sibling.C) {
                        sibling.C = false;
                        parent.C = true;
                        d3_geom_voronoiRedBlackRotateRight(this, parent);
                        sibling = parent.L;
                    }
                    if (sibling.L && sibling.L.C || sibling.R && sibling.R.C) {
                        if (!sibling.L || !sibling.L.C) {
                            sibling.R.C = false;
                            sibling.C = true;
                            d3_geom_voronoiRedBlackRotateLeft(this, sibling);
                            sibling = parent.L;
                        }
                        sibling.C = parent.C;
                        parent.C = sibling.L.C = false;
                        d3_geom_voronoiRedBlackRotateRight(this, parent);
                        node = this._;
                        break;
                    }
                }
                sibling.C = true;
                node = parent;
                parent = parent.U;
            } while (!node.C);
            if (node) node.C = false;
        }
    };
    function d3_geom_voronoiRedBlackRotateLeft(tree, node) {
        var p = node, q = node.R, parent = p.U;
        if (parent) {
            if (parent.L === p) parent.L = q; else parent.R = q;
        } else {
            tree._ = q;
        }
        q.U = parent;
        p.U = q;
        p.R = q.L;
        if (p.R) p.R.U = p;
        q.L = p;
    }
    function d3_geom_voronoiRedBlackRotateRight(tree, node) {
        var p = node, q = node.L, parent = p.U;
        if (parent) {
            if (parent.L === p) parent.L = q; else parent.R = q;
        } else {
            tree._ = q;
        }
        q.U = parent;
        p.U = q;
        p.L = q.R;
        if (p.L) p.L.U = p;
        q.R = p;
    }
    function d3_geom_voronoiRedBlackFirst(node) {
        while (node.L) node = node.L;
        return node;
    }
    function d3_geom_voronoi(sites, bbox) {
        var site = sites.sort(d3_geom_voronoiVertexOrder).pop(), x0, y0, circle;
        d3_geom_voronoiEdges = [];
        d3_geom_voronoiCells = new Array(sites.length);
        d3_geom_voronoiBeaches = new d3_geom_voronoiRedBlackTree();
        d3_geom_voronoiCircles = new d3_geom_voronoiRedBlackTree();
        while (true) {
            circle = d3_geom_voronoiFirstCircle;
            if (site && (!circle || site.y < circle.y || site.y === circle.y && site.x < circle.x)) {
                if (site.x !== x0 || site.y !== y0) {
                    d3_geom_voronoiCells[site.i] = new d3_geom_voronoiCell(site);
                    d3_geom_voronoiAddBeach(site);
                    x0 = site.x, y0 = site.y;
                }
                site = sites.pop();
            } else if (circle) {
                d3_geom_voronoiRemoveBeach(circle.arc);
            } else {
                break;
            }
        }
        if (bbox) d3_geom_voronoiClipEdges(bbox), d3_geom_voronoiCloseCells(bbox);
        var diagram = {
            cells: d3_geom_voronoiCells,
            edges: d3_geom_voronoiEdges
        };
        d3_geom_voronoiBeaches = d3_geom_voronoiCircles = d3_geom_voronoiEdges = d3_geom_voronoiCells = null;
        return diagram;
    }
    function d3_geom_voronoiVertexOrder(a, b) {
        return b.y - a.y || b.x - a.x;
    }
    d3.geom.voronoi = function(points) {
        var x = d3_geom_pointX, y = d3_geom_pointY, fx = x, fy = y, clipExtent = d3_geom_voronoiClipExtent;
        if (points) return voronoi(points);
        function voronoi(data) {
            var polygons = new Array(data.length), x0 = clipExtent[0][0], y0 = clipExtent[0][1], x1 = clipExtent[1][0], y1 = clipExtent[1][1];
            d3_geom_voronoi(sites(data), clipExtent).cells.forEach(function(cell, i) {
                var edges = cell.edges, site = cell.site, polygon = polygons[i] = edges.length ? edges.map(function(e) {
                    var s = e.start();
                    return [ s.x, s.y ];
                }) : site.x >= x0 && site.x <= x1 && site.y >= y0 && site.y <= y1 ? [ [ x0, y1 ], [ x1, y1 ], [ x1, y0 ], [ x0, y0 ] ] : [];
                polygon.point = data[i];
            });
            return polygons;
        }
        function sites(data) {
            return data.map(function(d, i) {
                return {
                    x: Math.round(fx(d, i) / ε) * ε,
                    y: Math.round(fy(d, i) / ε) * ε,
                    i: i
                };
            });
        }
        voronoi.links = function(data) {
            return d3_geom_voronoi(sites(data)).edges.filter(function(edge) {
                return edge.l && edge.r;
            }).map(function(edge) {
                return {
                    source: data[edge.l.i],
                    target: data[edge.r.i]
                };
            });
        };
        voronoi.triangles = function(data) {
            var triangles = [];
            d3_geom_voronoi(sites(data)).cells.forEach(function(cell, i) {
                var site = cell.site, edges = cell.edges.sort(d3_geom_voronoiHalfEdgeOrder), j = -1, m = edges.length, e0, s0, e1 = edges[m - 1].edge, s1 = e1.l === site ? e1.r : e1.l;
                while (++j < m) {
                    e0 = e1;
                    s0 = s1;
                    e1 = edges[j].edge;
                    s1 = e1.l === site ? e1.r : e1.l;
                    if (i < s0.i && i < s1.i && d3_geom_voronoiTriangleArea(site, s0, s1) < 0) {
                        triangles.push([ data[i], data[s0.i], data[s1.i] ]);
                    }
                }
            });
            return triangles;
        };
        voronoi.x = function(_) {
            return arguments.length ? (fx = d3_functor(x = _), voronoi) : x;
        };
        voronoi.y = function(_) {
            return arguments.length ? (fy = d3_functor(y = _), voronoi) : y;
        };
        voronoi.clipExtent = function(_) {
            if (!arguments.length) return clipExtent === d3_geom_voronoiClipExtent ? null : clipExtent;
            clipExtent = _ == null ? d3_geom_voronoiClipExtent : _;
            return voronoi;
        };
        voronoi.size = function(_) {
            if (!arguments.length) return clipExtent === d3_geom_voronoiClipExtent ? null : clipExtent && clipExtent[1];
            return voronoi.clipExtent(_ && [ [ 0, 0 ], _ ]);
        };
        return voronoi;
    };
    var d3_geom_voronoiClipExtent = [ [ -1e6, -1e6 ], [ 1e6, 1e6 ] ];
    function d3_geom_voronoiTriangleArea(a, b, c) {
        return (a.x - c.x) * (b.y - a.y) - (a.x - b.x) * (c.y - a.y);
    }
    d3.geom.delaunay = function(vertices) {
        return d3.geom.voronoi().triangles(vertices);
    };
    d3.geom.quadtree = function(points, x1, y1, x2, y2) {
        var x = d3_geom_pointX, y = d3_geom_pointY, compat;
        if (compat = arguments.length) {
            x = d3_geom_quadtreeCompatX;
            y = d3_geom_quadtreeCompatY;
            if (compat === 3) {
                y2 = y1;
                x2 = x1;
                y1 = x1 = 0;
            }
            return quadtree(points);
        }
        function quadtree(data) {
            var d, fx = d3_functor(x), fy = d3_functor(y), xs, ys, i, n, x1_, y1_, x2_, y2_;
            if (x1 != null) {
                x1_ = x1, y1_ = y1, x2_ = x2, y2_ = y2;
            } else {
                x2_ = y2_ = -(x1_ = y1_ = Infinity);
                xs = [], ys = [];
                n = data.length;
                if (compat) for (i = 0; i < n; ++i) {
                    d = data[i];
                    if (d.x < x1_) x1_ = d.x;
                    if (d.y < y1_) y1_ = d.y;
                    if (d.x > x2_) x2_ = d.x;
                    if (d.y > y2_) y2_ = d.y;
                    xs.push(d.x);
                    ys.push(d.y);
                } else for (i = 0; i < n; ++i) {
                    var x_ = +fx(d = data[i], i), y_ = +fy(d, i);
                    if (x_ < x1_) x1_ = x_;
                    if (y_ < y1_) y1_ = y_;
                    if (x_ > x2_) x2_ = x_;
                    if (y_ > y2_) y2_ = y_;
                    xs.push(x_);
                    ys.push(y_);
                }
            }
            var dx = x2_ - x1_, dy = y2_ - y1_;
            if (dx > dy) y2_ = y1_ + dx; else x2_ = x1_ + dy;
            function insert(n, d, x, y, x1, y1, x2, y2) {
                if (isNaN(x) || isNaN(y)) return;
                if (n.leaf) {
                    var nx = n.x, ny = n.y;
                    if (nx != null) {
                        if (abs(nx - x) + abs(ny - y) < .01) {
                            insertChild(n, d, x, y, x1, y1, x2, y2);
                        } else {
                            var nPoint = n.point;
                            n.x = n.y = n.point = null;
                            insertChild(n, nPoint, nx, ny, x1, y1, x2, y2);
                            insertChild(n, d, x, y, x1, y1, x2, y2);
                        }
                    } else {
                        n.x = x, n.y = y, n.point = d;
                    }
                } else {
                    insertChild(n, d, x, y, x1, y1, x2, y2);
                }
            }
            function insertChild(n, d, x, y, x1, y1, x2, y2) {
                var xm = (x1 + x2) * .5, ym = (y1 + y2) * .5, right = x >= xm, below = y >= ym, i = below << 1 | right;
                n.leaf = false;
                n = n.nodes[i] || (n.nodes[i] = d3_geom_quadtreeNode());
                if (right) x1 = xm; else x2 = xm;
                if (below) y1 = ym; else y2 = ym;
                insert(n, d, x, y, x1, y1, x2, y2);
            }
            var root = d3_geom_quadtreeNode();
            root.add = function(d) {
                insert(root, d, +fx(d, ++i), +fy(d, i), x1_, y1_, x2_, y2_);
            };
            root.visit = function(f) {
                d3_geom_quadtreeVisit(f, root, x1_, y1_, x2_, y2_);
            };
            root.find = function(point) {
                return d3_geom_quadtreeFind(root, point[0], point[1], x1_, y1_, x2_, y2_);
            };
            i = -1;
            if (x1 == null) {
                while (++i < n) {
                    insert(root, data[i], xs[i], ys[i], x1_, y1_, x2_, y2_);
                }
                --i;
            } else data.forEach(root.add);
            xs = ys = data = d = null;
            return root;
        }
        quadtree.x = function(_) {
            return arguments.length ? (x = _, quadtree) : x;
        };
        quadtree.y = function(_) {
            return arguments.length ? (y = _, quadtree) : y;
        };
        quadtree.extent = function(_) {
            if (!arguments.length) return x1 == null ? null : [ [ x1, y1 ], [ x2, y2 ] ];
            if (_ == null) x1 = y1 = x2 = y2 = null; else x1 = +_[0][0], y1 = +_[0][1], x2 = +_[1][0],
                y2 = +_[1][1];
            return quadtree;
        };
        quadtree.size = function(_) {
            if (!arguments.length) return x1 == null ? null : [ x2 - x1, y2 - y1 ];
            if (_ == null) x1 = y1 = x2 = y2 = null; else x1 = y1 = 0, x2 = +_[0], y2 = +_[1];
            return quadtree;
        };
        return quadtree;
    };
    function d3_geom_quadtreeCompatX(d) {
        return d.x;
    }
    function d3_geom_quadtreeCompatY(d) {
        return d.y;
    }
    function d3_geom_quadtreeNode() {
        return {
            leaf: true,
            nodes: [],
            point: null,
            x: null,
            y: null
        };
    }
    function d3_geom_quadtreeVisit(f, node, x1, y1, x2, y2) {
        if (!f(node, x1, y1, x2, y2)) {
            var sx = (x1 + x2) * .5, sy = (y1 + y2) * .5, children = node.nodes;
            if (children[0]) d3_geom_quadtreeVisit(f, children[0], x1, y1, sx, sy);
            if (children[1]) d3_geom_quadtreeVisit(f, children[1], sx, y1, x2, sy);
            if (children[2]) d3_geom_quadtreeVisit(f, children[2], x1, sy, sx, y2);
            if (children[3]) d3_geom_quadtreeVisit(f, children[3], sx, sy, x2, y2);
        }
    }
    function d3_geom_quadtreeFind(root, x, y, x0, y0, x3, y3) {
        var minDistance2 = Infinity, closestPoint;
        (function find(node, x1, y1, x2, y2) {
            if (x1 > x3 || y1 > y3 || x2 < x0 || y2 < y0) return;
            if (point = node.point) {
                var point, dx = x - node.x, dy = y - node.y, distance2 = dx * dx + dy * dy;
                if (distance2 < minDistance2) {
                    var distance = Math.sqrt(minDistance2 = distance2);
                    x0 = x - distance, y0 = y - distance;
                    x3 = x + distance, y3 = y + distance;
                    closestPoint = point;
                }
            }
            var children = node.nodes, xm = (x1 + x2) * .5, ym = (y1 + y2) * .5, right = x >= xm, below = y >= ym;
            for (var i = below << 1 | right, j = i + 4; i < j; ++i) {
                if (node = children[i & 3]) switch (i & 3) {
                    case 0:
                        find(node, x1, y1, xm, ym);
                        break;

                    case 1:
                        find(node, xm, y1, x2, ym);
                        break;

                    case 2:
                        find(node, x1, ym, xm, y2);
                        break;

                    case 3:
                        find(node, xm, ym, x2, y2);
                        break;
                }
            }
        })(root, x0, y0, x3, y3);
        return closestPoint;
    }
    d3.interpolateRgb = d3_interpolateRgb;
    function d3_interpolateRgb(a, b) {
        a = d3.rgb(a);
        b = d3.rgb(b);
        var ar = a.r, ag = a.g, ab = a.b, br = b.r - ar, bg = b.g - ag, bb = b.b - ab;
        return function(t) {
            return "#" + d3_rgb_hex(Math.round(ar + br * t)) + d3_rgb_hex(Math.round(ag + bg * t)) + d3_rgb_hex(Math.round(ab + bb * t));
        };
    }
    d3.interpolateObject = d3_interpolateObject;
    function d3_interpolateObject(a, b) {
        var i = {}, c = {}, k;
        for (k in a) {
            if (k in b) {
                i[k] = d3_interpolate(a[k], b[k]);
            } else {
                c[k] = a[k];
            }
        }
        for (k in b) {
            if (!(k in a)) {
                c[k] = b[k];
            }
        }
        return function(t) {
            for (k in i) c[k] = i[k](t);
            return c;
        };
    }
    d3.interpolateNumber = d3_interpolateNumber;
    function d3_interpolateNumber(a, b) {
        a = +a, b = +b;
        return function(t) {
            return a * (1 - t) + b * t;
        };
    }
    d3.interpolateString = d3_interpolateString;
    function d3_interpolateString(a, b) {
        var bi = d3_interpolate_numberA.lastIndex = d3_interpolate_numberB.lastIndex = 0, am, bm, bs, i = -1, s = [], q = [];
        a = a + "", b = b + "";
        while ((am = d3_interpolate_numberA.exec(a)) && (bm = d3_interpolate_numberB.exec(b))) {
            if ((bs = bm.index) > bi) {
                bs = b.slice(bi, bs);
                if (s[i]) s[i] += bs; else s[++i] = bs;
            }
            if ((am = am[0]) === (bm = bm[0])) {
                if (s[i]) s[i] += bm; else s[++i] = bm;
            } else {
                s[++i] = null;
                q.push({
                    i: i,
                    x: d3_interpolateNumber(am, bm)
                });
            }
            bi = d3_interpolate_numberB.lastIndex;
        }
        if (bi < b.length) {
            bs = b.slice(bi);
            if (s[i]) s[i] += bs; else s[++i] = bs;
        }
        return s.length < 2 ? q[0] ? (b = q[0].x, function(t) {
            return b(t) + "";
        }) : function() {
            return b;
        } : (b = q.length, function(t) {
            for (var i = 0, o; i < b; ++i) s[(o = q[i]).i] = o.x(t);
            return s.join("");
        });
    }
    var d3_interpolate_numberA = /[-+]?(?:\d+\.?\d*|\.?\d+)(?:[eE][-+]?\d+)?/g, d3_interpolate_numberB = new RegExp(d3_interpolate_numberA.source, "g");
    d3.interpolate = d3_interpolate;
    function d3_interpolate(a, b) {
        var i = d3.interpolators.length, f;
        while (--i >= 0 && !(f = d3.interpolators[i](a, b))) ;
        return f;
    }
    d3.interpolators = [ function(a, b) {
        var t = typeof b;
        return (t === "string" ? d3_rgb_names.has(b) || /^(#|rgb\(|hsl\()/.test(b) ? d3_interpolateRgb : d3_interpolateString : b instanceof d3_color ? d3_interpolateRgb : Array.isArray(b) ? d3_interpolateArray : t === "object" && isNaN(b) ? d3_interpolateObject : d3_interpolateNumber)(a, b);
    } ];
    d3.interpolateArray = d3_interpolateArray;
    function d3_interpolateArray(a, b) {
        var x = [], c = [], na = a.length, nb = b.length, n0 = Math.min(a.length, b.length), i;
        for (i = 0; i < n0; ++i) x.push(d3_interpolate(a[i], b[i]));
        for (;i < na; ++i) c[i] = a[i];
        for (;i < nb; ++i) c[i] = b[i];
        return function(t) {
            for (i = 0; i < n0; ++i) c[i] = x[i](t);
            return c;
        };
    }
    var d3_ease_default = function() {
        return d3_identity;
    };
    var d3_ease = d3.map({
        linear: d3_ease_default,
        poly: d3_ease_poly,
        quad: function() {
            return d3_ease_quad;
        },
        cubic: function() {
            return d3_ease_cubic;
        },
        sin: function() {
            return d3_ease_sin;
        },
        exp: function() {
            return d3_ease_exp;
        },
        circle: function() {
            return d3_ease_circle;
        },
        elastic: d3_ease_elastic,
        back: d3_ease_back,
        bounce: function() {
            return d3_ease_bounce;
        }
    });
    var d3_ease_mode = d3.map({
        "in": d3_identity,
        out: d3_ease_reverse,
        "in-out": d3_ease_reflect,
        "out-in": function(f) {
            return d3_ease_reflect(d3_ease_reverse(f));
        }
    });
    d3.ease = function(name) {
        var i = name.indexOf("-"), t = i >= 0 ? name.slice(0, i) : name, m = i >= 0 ? name.slice(i + 1) : "in";
        t = d3_ease.get(t) || d3_ease_default;
        m = d3_ease_mode.get(m) || d3_identity;
        return d3_ease_clamp(m(t.apply(null, d3_arraySlice.call(arguments, 1))));
    };
    function d3_ease_clamp(f) {
        return function(t) {
            return t <= 0 ? 0 : t >= 1 ? 1 : f(t);
        };
    }
    function d3_ease_reverse(f) {
        return function(t) {
            return 1 - f(1 - t);
        };
    }
    function d3_ease_reflect(f) {
        return function(t) {
            return .5 * (t < .5 ? f(2 * t) : 2 - f(2 - 2 * t));
        };
    }
    function d3_ease_quad(t) {
        return t * t;
    }
    function d3_ease_cubic(t) {
        return t * t * t;
    }
    function d3_ease_cubicInOut(t) {
        if (t <= 0) return 0;
        if (t >= 1) return 1;
        var t2 = t * t, t3 = t2 * t;
        return 4 * (t < .5 ? t3 : 3 * (t - t2) + t3 - .75);
    }
    function d3_ease_poly(e) {
        return function(t) {
            return Math.pow(t, e);
        };
    }
    function d3_ease_sin(t) {
        return 1 - Math.cos(t * halfπ);
    }
    function d3_ease_exp(t) {
        return Math.pow(2, 10 * (t - 1));
    }
    function d3_ease_circle(t) {
        return 1 - Math.sqrt(1 - t * t);
    }
    function d3_ease_elastic(a, p) {
        var s;
        if (arguments.length < 2) p = .45;
        if (arguments.length) s = p / τ * Math.asin(1 / a); else a = 1, s = p / 4;
        return function(t) {
            return 1 + a * Math.pow(2, -10 * t) * Math.sin((t - s) * τ / p);
        };
    }
    function d3_ease_back(s) {
        if (!s) s = 1.70158;
        return function(t) {
            return t * t * ((s + 1) * t - s);
        };
    }
    function d3_ease_bounce(t) {
        return t < 1 / 2.75 ? 7.5625 * t * t : t < 2 / 2.75 ? 7.5625 * (t -= 1.5 / 2.75) * t + .75 : t < 2.5 / 2.75 ? 7.5625 * (t -= 2.25 / 2.75) * t + .9375 : 7.5625 * (t -= 2.625 / 2.75) * t + .984375;
    }
    d3.interpolateHcl = d3_interpolateHcl;
    function d3_interpolateHcl(a, b) {
        a = d3.hcl(a);
        b = d3.hcl(b);
        var ah = a.h, ac = a.c, al = a.l, bh = b.h - ah, bc = b.c - ac, bl = b.l - al;
        if (isNaN(bc)) bc = 0, ac = isNaN(ac) ? b.c : ac;
        if (isNaN(bh)) bh = 0, ah = isNaN(ah) ? b.h : ah; else if (bh > 180) bh -= 360; else if (bh < -180) bh += 360;
        return function(t) {
            return d3_hcl_lab(ah + bh * t, ac + bc * t, al + bl * t) + "";
        };
    }
    d3.interpolateHsl = d3_interpolateHsl;
    function d3_interpolateHsl(a, b) {
        a = d3.hsl(a);
        b = d3.hsl(b);
        var ah = a.h, as = a.s, al = a.l, bh = b.h - ah, bs = b.s - as, bl = b.l - al;
        if (isNaN(bs)) bs = 0, as = isNaN(as) ? b.s : as;
        if (isNaN(bh)) bh = 0, ah = isNaN(ah) ? b.h : ah; else if (bh > 180) bh -= 360; else if (bh < -180) bh += 360;
        return function(t) {
            return d3_hsl_rgb(ah + bh * t, as + bs * t, al + bl * t) + "";
        };
    }
    d3.interpolateLab = d3_interpolateLab;
    function d3_interpolateLab(a, b) {
        a = d3.lab(a);
        b = d3.lab(b);
        var al = a.l, aa = a.a, ab = a.b, bl = b.l - al, ba = b.a - aa, bb = b.b - ab;
        return function(t) {
            return d3_lab_rgb(al + bl * t, aa + ba * t, ab + bb * t) + "";
        };
    }
    d3.interpolateRound = d3_interpolateRound;
    function d3_interpolateRound(a, b) {
        b -= a;
        return function(t) {
            return Math.round(a + b * t);
        };
    }
    d3.transform = function(string) {
        var g = d3_document.createElementNS(d3.ns.prefix.svg, "g");
        return (d3.transform = function(string) {
            if (string != null) {
                g.setAttribute("transform", string);
                var t = g.transform.baseVal.consolidate();
            }
            return new d3_transform(t ? t.matrix : d3_transformIdentity);
        })(string);
    };
    function d3_transform(m) {
        var r0 = [ m.a, m.b ], r1 = [ m.c, m.d ], kx = d3_transformNormalize(r0), kz = d3_transformDot(r0, r1), ky = d3_transformNormalize(d3_transformCombine(r1, r0, -kz)) || 0;
        if (r0[0] * r1[1] < r1[0] * r0[1]) {
            r0[0] *= -1;
            r0[1] *= -1;
            kx *= -1;
            kz *= -1;
        }
        this.rotate = (kx ? Math.atan2(r0[1], r0[0]) : Math.atan2(-r1[0], r1[1])) * d3_degrees;
        this.translate = [ m.e, m.f ];
        this.scale = [ kx, ky ];
        this.skew = ky ? Math.atan2(kz, ky) * d3_degrees : 0;
    }
    d3_transform.prototype.toString = function() {
        return "translate(" + this.translate + ")rotate(" + this.rotate + ")skewX(" + this.skew + ")scale(" + this.scale + ")";
    };
    function d3_transformDot(a, b) {
        return a[0] * b[0] + a[1] * b[1];
    }
    function d3_transformNormalize(a) {
        var k = Math.sqrt(d3_transformDot(a, a));
        if (k) {
            a[0] /= k;
            a[1] /= k;
        }
        return k;
    }
    function d3_transformCombine(a, b, k) {
        a[0] += k * b[0];
        a[1] += k * b[1];
        return a;
    }
    var d3_transformIdentity = {
        a: 1,
        b: 0,
        c: 0,
        d: 1,
        e: 0,
        f: 0
    };
    d3.interpolateTransform = d3_interpolateTransform;
    function d3_interpolateTransform(a, b) {
        var s = [], q = [], n, A = d3.transform(a), B = d3.transform(b), ta = A.translate, tb = B.translate, ra = A.rotate, rb = B.rotate, wa = A.skew, wb = B.skew, ka = A.scale, kb = B.scale;
        if (ta[0] != tb[0] || ta[1] != tb[1]) {
            s.push("translate(", null, ",", null, ")");
            q.push({
                i: 1,
                x: d3_interpolateNumber(ta[0], tb[0])
            }, {
                i: 3,
                x: d3_interpolateNumber(ta[1], tb[1])
            });
        } else if (tb[0] || tb[1]) {
            s.push("translate(" + tb + ")");
        } else {
            s.push("");
        }
        if (ra != rb) {
            if (ra - rb > 180) rb += 360; else if (rb - ra > 180) ra += 360;
            q.push({
                i: s.push(s.pop() + "rotate(", null, ")") - 2,
                x: d3_interpolateNumber(ra, rb)
            });
        } else if (rb) {
            s.push(s.pop() + "rotate(" + rb + ")");
        }
        if (wa != wb) {
            q.push({
                i: s.push(s.pop() + "skewX(", null, ")") - 2,
                x: d3_interpolateNumber(wa, wb)
            });
        } else if (wb) {
            s.push(s.pop() + "skewX(" + wb + ")");
        }
        if (ka[0] != kb[0] || ka[1] != kb[1]) {
            n = s.push(s.pop() + "scale(", null, ",", null, ")");
            q.push({
                i: n - 4,
                x: d3_interpolateNumber(ka[0], kb[0])
            }, {
                i: n - 2,
                x: d3_interpolateNumber(ka[1], kb[1])
            });
        } else if (kb[0] != 1 || kb[1] != 1) {
            s.push(s.pop() + "scale(" + kb + ")");
        }
        n = q.length;
        return function(t) {
            var i = -1, o;
            while (++i < n) s[(o = q[i]).i] = o.x(t);
            return s.join("");
        };
    }
    function d3_uninterpolateNumber(a, b) {
        b = (b -= a = +a) || 1 / b;
        return function(x) {
            return (x - a) / b;
        };
    }
    function d3_uninterpolateClamp(a, b) {
        b = (b -= a = +a) || 1 / b;
        return function(x) {
            return Math.max(0, Math.min(1, (x - a) / b));
        };
    }
    d3.layout = {};
    d3.layout.bundle = function() {
        return function(links) {
            var paths = [], i = -1, n = links.length;
            while (++i < n) paths.push(d3_layout_bundlePath(links[i]));
            return paths;
        };
    };
    function d3_layout_bundlePath(link) {
        var start = link.source, end = link.target, lca = d3_layout_bundleLeastCommonAncestor(start, end), points = [ start ];
        while (start !== lca) {
            start = start.parent;
            points.push(start);
        }
        var k = points.length;
        while (end !== lca) {
            points.splice(k, 0, end);
            end = end.parent;
        }
        return points;
    }
    function d3_layout_bundleAncestors(node) {
        var ancestors = [], parent = node.parent;
        while (parent != null) {
            ancestors.push(node);
            node = parent;
            parent = parent.parent;
        }
        ancestors.push(node);
        return ancestors;
    }
    function d3_layout_bundleLeastCommonAncestor(a, b) {
        if (a === b) return a;
        var aNodes = d3_layout_bundleAncestors(a), bNodes = d3_layout_bundleAncestors(b), aNode = aNodes.pop(), bNode = bNodes.pop(), sharedNode = null;
        while (aNode === bNode) {
            sharedNode = aNode;
            aNode = aNodes.pop();
            bNode = bNodes.pop();
        }
        return sharedNode;
    }
    d3.layout.chord = function() {
        var chord = {}, chords, groups, matrix, n, padding = 0, sortGroups, sortSubgroups, sortChords;
        function relayout() {
            var subgroups = {}, groupSums = [], groupIndex = d3.range(n), subgroupIndex = [], k, x, x0, i, j;
            chords = [];
            groups = [];
            k = 0, i = -1;
            while (++i < n) {
                x = 0, j = -1;
                while (++j < n) {
                    x += matrix[i][j];
                }
                groupSums.push(x);
                subgroupIndex.push(d3.range(n));
                k += x;
            }
            if (sortGroups) {
                groupIndex.sort(function(a, b) {
                    return sortGroups(groupSums[a], groupSums[b]);
                });
            }
            if (sortSubgroups) {
                subgroupIndex.forEach(function(d, i) {
                    d.sort(function(a, b) {
                        return sortSubgroups(matrix[i][a], matrix[i][b]);
                    });
                });
            }
            k = (τ - padding * n) / k;
            x = 0, i = -1;
            while (++i < n) {
                x0 = x, j = -1;
                while (++j < n) {
                    var di = groupIndex[i], dj = subgroupIndex[di][j], v = matrix[di][dj], a0 = x, a1 = x += v * k;
                    subgroups[di + "-" + dj] = {
                        index: di,
                        subindex: dj,
                        startAngle: a0,
                        endAngle: a1,
                        value: v
                    };
                }
                groups[di] = {
                    index: di,
                    startAngle: x0,
                    endAngle: x,
                    value: (x - x0) / k
                };
                x += padding;
            }
            i = -1;
            while (++i < n) {
                j = i - 1;
                while (++j < n) {
                    var source = subgroups[i + "-" + j], target = subgroups[j + "-" + i];
                    if (source.value || target.value) {
                        chords.push(source.value < target.value ? {
                            source: target,
                            target: source
                        } : {
                            source: source,
                            target: target
                        });
                    }
                }
            }
            if (sortChords) resort();
        }
        function resort() {
            chords.sort(function(a, b) {
                return sortChords((a.source.value + a.target.value) / 2, (b.source.value + b.target.value) / 2);
            });
        }
        chord.matrix = function(x) {
            if (!arguments.length) return matrix;
            n = (matrix = x) && matrix.length;
            chords = groups = null;
            return chord;
        };
        chord.padding = function(x) {
            if (!arguments.length) return padding;
            padding = x;
            chords = groups = null;
            return chord;
        };
        chord.sortGroups = function(x) {
            if (!arguments.length) return sortGroups;
            sortGroups = x;
            chords = groups = null;
            return chord;
        };
        chord.sortSubgroups = function(x) {
            if (!arguments.length) return sortSubgroups;
            sortSubgroups = x;
            chords = null;
            return chord;
        };
        chord.sortChords = function(x) {
            if (!arguments.length) return sortChords;
            sortChords = x;
            if (chords) resort();
            return chord;
        };
        chord.chords = function() {
            if (!chords) relayout();
            return chords;
        };
        chord.groups = function() {
            if (!groups) relayout();
            return groups;
        };
        return chord;
    };
    d3.layout.force = function() {
        var force = {}, event = d3.dispatch("start", "tick", "end"), size = [ 1, 1 ], drag, alpha, friction = .9, linkDistance = d3_layout_forceLinkDistance, linkStrength = d3_layout_forceLinkStrength, charge = -30, chargeDistance2 = d3_layout_forceChargeDistance2, gravity = .1, theta2 = .64, nodes = [], links = [], distances, strengths, charges;
        function repulse(node) {
            return function(quad, x1, _, x2) {
                if (quad.point !== node) {
                    var dx = quad.cx - node.x, dy = quad.cy - node.y, dw = x2 - x1, dn = dx * dx + dy * dy;
                    if (dw * dw / theta2 < dn) {
                        if (dn < chargeDistance2) {
                            var k = quad.charge / dn;
                            node.px -= dx * k;
                            node.py -= dy * k;
                        }
                        return true;
                    }
                    if (quad.point && dn && dn < chargeDistance2) {
                        var k = quad.pointCharge / dn;
                        node.px -= dx * k;
                        node.py -= dy * k;
                    }
                }
                return !quad.charge;
            };
        }
        force.tick = function() {
            if ((alpha *= .99) < .005) {
                event.end({
                    type: "end",
                    alpha: alpha = 0
                });
                return true;
            }
            var n = nodes.length, m = links.length, q, i, o, s, t, l, k, x, y;
            for (i = 0; i < m; ++i) {
                o = links[i];
                s = o.source;
                t = o.target;
                x = t.x - s.x;
                y = t.y - s.y;
                if (l = x * x + y * y) {
                    l = alpha * strengths[i] * ((l = Math.sqrt(l)) - distances[i]) / l;
                    x *= l;
                    y *= l;
                    t.x -= x * (k = s.weight / (t.weight + s.weight));
                    t.y -= y * k;
                    s.x += x * (k = 1 - k);
                    s.y += y * k;
                }
            }
            if (k = alpha * gravity) {
                x = size[0] / 2;
                y = size[1] / 2;
                i = -1;
                if (k) while (++i < n) {
                    o = nodes[i];
                    o.x += (x - o.x) * k;
                    o.y += (y - o.y) * k;
                }
            }
            if (charge) {
                d3_layout_forceAccumulate(q = d3.geom.quadtree(nodes), alpha, charges);
                i = -1;
                while (++i < n) {
                    if (!(o = nodes[i]).fixed) {
                        q.visit(repulse(o));
                    }
                }
            }
            i = -1;
            while (++i < n) {
                o = nodes[i];
                if (o.fixed) {
                    o.x = o.px;
                    o.y = o.py;
                } else {
                    o.x -= (o.px - (o.px = o.x)) * friction;
                    o.y -= (o.py - (o.py = o.y)) * friction;
                }
            }
            event.tick({
                type: "tick",
                alpha: alpha
            });
        };
        force.nodes = function(x) {
            if (!arguments.length) return nodes;
            nodes = x;
            return force;
        };
        force.links = function(x) {
            if (!arguments.length) return links;
            links = x;
            return force;
        };
        force.size = function(x) {
            if (!arguments.length) return size;
            size = x;
            return force;
        };
        force.linkDistance = function(x) {
            if (!arguments.length) return linkDistance;
            linkDistance = typeof x === "function" ? x : +x;
            return force;
        };
        force.distance = force.linkDistance;
        force.linkStrength = function(x) {
            if (!arguments.length) return linkStrength;
            linkStrength = typeof x === "function" ? x : +x;
            return force;
        };
        force.friction = function(x) {
            if (!arguments.length) return friction;
            friction = +x;
            return force;
        };
        force.charge = function(x) {
            if (!arguments.length) return charge;
            charge = typeof x === "function" ? x : +x;
            return force;
        };
        force.chargeDistance = function(x) {
            if (!arguments.length) return Math.sqrt(chargeDistance2);
            chargeDistance2 = x * x;
            return force;
        };
        force.gravity = function(x) {
            if (!arguments.length) return gravity;
            gravity = +x;
            return force;
        };
        force.theta = function(x) {
            if (!arguments.length) return Math.sqrt(theta2);
            theta2 = x * x;
            return force;
        };
        force.alpha = function(x) {
            if (!arguments.length) return alpha;
            x = +x;
            if (alpha) {
                if (x > 0) alpha = x; else alpha = 0;
            } else if (x > 0) {
                event.start({
                    type: "start",
                    alpha: alpha = x
                });
                d3.timer(force.tick);
            }
            return force;
        };
        force.start = function() {
            var i, n = nodes.length, m = links.length, w = size[0], h = size[1], neighbors, o;
            for (i = 0; i < n; ++i) {
                (o = nodes[i]).index = i;
                o.weight = 0;
            }
            for (i = 0; i < m; ++i) {
                o = links[i];
                if (typeof o.source == "number") o.source = nodes[o.source];
                if (typeof o.target == "number") o.target = nodes[o.target];
                ++o.source.weight;
                ++o.target.weight;
            }
            for (i = 0; i < n; ++i) {
                o = nodes[i];
                if (isNaN(o.x)) o.x = position("x", w);
                if (isNaN(o.y)) o.y = position("y", h);
                if (isNaN(o.px)) o.px = o.x;
                if (isNaN(o.py)) o.py = o.y;
            }
            distances = [];
            if (typeof linkDistance === "function") for (i = 0; i < m; ++i) distances[i] = +linkDistance.call(this, links[i], i); else for (i = 0; i < m; ++i) distances[i] = linkDistance;
            strengths = [];
            if (typeof linkStrength === "function") for (i = 0; i < m; ++i) strengths[i] = +linkStrength.call(this, links[i], i); else for (i = 0; i < m; ++i) strengths[i] = linkStrength;
            charges = [];
            if (typeof charge === "function") for (i = 0; i < n; ++i) charges[i] = +charge.call(this, nodes[i], i); else for (i = 0; i < n; ++i) charges[i] = charge;
            function position(dimension, size) {
                if (!neighbors) {
                    neighbors = new Array(n);
                    for (j = 0; j < n; ++j) {
                        neighbors[j] = [];
                    }
                    for (j = 0; j < m; ++j) {
                        var o = links[j];
                        neighbors[o.source.index].push(o.target);
                        neighbors[o.target.index].push(o.source);
                    }
                }
                var candidates = neighbors[i], j = -1, l = candidates.length, x;
                while (++j < l) if (!isNaN(x = candidates[j][dimension])) return x;
                return Math.random() * size;
            }
            return force.resume();
        };
        force.resume = function() {
            return force.alpha(.1);
        };
        force.stop = function() {
            return force.alpha(0);
        };
        force.drag = function() {
            if (!drag) drag = d3.behavior.drag().origin(d3_identity).on("dragstart.force", d3_layout_forceDragstart).on("drag.force", dragmove).on("dragend.force", d3_layout_forceDragend);
            if (!arguments.length) return drag;
            this.on("mouseover.force", d3_layout_forceMouseover).on("mouseout.force", d3_layout_forceMouseout).call(drag);
        };
        function dragmove(d) {
            d.px = d3.event.x, d.py = d3.event.y;
            force.resume();
        }
        return d3.rebind(force, event, "on");
    };
    function d3_layout_forceDragstart(d) {
        d.fixed |= 2;
    }
    function d3_layout_forceDragend(d) {
        d.fixed &= ~6;
    }
    function d3_layout_forceMouseover(d) {
        d.fixed |= 4;
        d.px = d.x, d.py = d.y;
    }
    function d3_layout_forceMouseout(d) {
        d.fixed &= ~4;
    }
    function d3_layout_forceAccumulate(quad, alpha, charges) {
        var cx = 0, cy = 0;
        quad.charge = 0;
        if (!quad.leaf) {
            var nodes = quad.nodes, n = nodes.length, i = -1, c;
            while (++i < n) {
                c = nodes[i];
                if (c == null) continue;
                d3_layout_forceAccumulate(c, alpha, charges);
                quad.charge += c.charge;
                cx += c.charge * c.cx;
                cy += c.charge * c.cy;
            }
        }
        if (quad.point) {
            if (!quad.leaf) {
                quad.point.x += Math.random() - .5;
                quad.point.y += Math.random() - .5;
            }
            var k = alpha * charges[quad.point.index];
            quad.charge += quad.pointCharge = k;
            cx += k * quad.point.x;
            cy += k * quad.point.y;
        }
        quad.cx = cx / quad.charge;
        quad.cy = cy / quad.charge;
    }
    var d3_layout_forceLinkDistance = 20, d3_layout_forceLinkStrength = 1, d3_layout_forceChargeDistance2 = Infinity;
    d3.layout.hierarchy = function() {
        var sort = d3_layout_hierarchySort, children = d3_layout_hierarchyChildren, value = d3_layout_hierarchyValue;
        function hierarchy(root) {
            var stack = [ root ], nodes = [], node;
            root.depth = 0;
            while ((node = stack.pop()) != null) {
                nodes.push(node);
                if ((childs = children.call(hierarchy, node, node.depth)) && (n = childs.length)) {
                    var n, childs, child;
                    while (--n >= 0) {
                        stack.push(child = childs[n]);
                        child.parent = node;
                        child.depth = node.depth + 1;
                    }
                    if (value) node.value = 0;
                    node.children = childs;
                } else {
                    if (value) node.value = +value.call(hierarchy, node, node.depth) || 0;
                    delete node.children;
                }
            }
            d3_layout_hierarchyVisitAfter(root, function(node) {
                var childs, parent;
                if (sort && (childs = node.children)) childs.sort(sort);
                if (value && (parent = node.parent)) parent.value += node.value;
            });
            return nodes;
        }
        hierarchy.sort = function(x) {
            if (!arguments.length) return sort;
            sort = x;
            return hierarchy;
        };
        hierarchy.children = function(x) {
            if (!arguments.length) return children;
            children = x;
            return hierarchy;
        };
        hierarchy.value = function(x) {
            if (!arguments.length) return value;
            value = x;
            return hierarchy;
        };
        hierarchy.revalue = function(root) {
            if (value) {
                d3_layout_hierarchyVisitBefore(root, function(node) {
                    if (node.children) node.value = 0;
                });
                d3_layout_hierarchyVisitAfter(root, function(node) {
                    var parent;
                    if (!node.children) node.value = +value.call(hierarchy, node, node.depth) || 0;
                    if (parent = node.parent) parent.value += node.value;
                });
            }
            return root;
        };
        return hierarchy;
    };
    function d3_layout_hierarchyRebind(object, hierarchy) {
        d3.rebind(object, hierarchy, "sort", "children", "value");
        object.nodes = object;
        object.links = d3_layout_hierarchyLinks;
        return object;
    }
    function d3_layout_hierarchyVisitBefore(node, callback) {
        var nodes = [ node ];
        while ((node = nodes.pop()) != null) {
            callback(node);
            if ((children = node.children) && (n = children.length)) {
                var n, children;
                while (--n >= 0) nodes.push(children[n]);
            }
        }
    }
    function d3_layout_hierarchyVisitAfter(node, callback) {
        var nodes = [ node ], nodes2 = [];
        while ((node = nodes.pop()) != null) {
            nodes2.push(node);
            if ((children = node.children) && (n = children.length)) {
                var i = -1, n, children;
                while (++i < n) nodes.push(children[i]);
            }
        }
        while ((node = nodes2.pop()) != null) {
            callback(node);
        }
    }
    function d3_layout_hierarchyChildren(d) {
        return d.children;
    }
    function d3_layout_hierarchyValue(d) {
        return d.value;
    }
    function d3_layout_hierarchySort(a, b) {
        return b.value - a.value;
    }
    function d3_layout_hierarchyLinks(nodes) {
        return d3.merge(nodes.map(function(parent) {
            return (parent.children || []).map(function(child) {
                return {
                    source: parent,
                    target: child
                };
            });
        }));
    }
    d3.layout.partition = function() {
        var hierarchy = d3.layout.hierarchy(), size = [ 1, 1 ];
        function position(node, x, dx, dy) {
            var children = node.children;
            node.x = x;
            node.y = node.depth * dy;
            node.dx = dx;
            node.dy = dy;
            if (children && (n = children.length)) {
                var i = -1, n, c, d;
                dx = node.value ? dx / node.value : 0;
                while (++i < n) {
                    position(c = children[i], x, d = c.value * dx, dy);
                    x += d;
                }
            }
        }
        function depth(node) {
            var children = node.children, d = 0;
            if (children && (n = children.length)) {
                var i = -1, n;
                while (++i < n) d = Math.max(d, depth(children[i]));
            }
            return 1 + d;
        }
        function partition(d, i) {
            var nodes = hierarchy.call(this, d, i);
            position(nodes[0], 0, size[0], size[1] / depth(nodes[0]));
            return nodes;
        }
        partition.size = function(x) {
            if (!arguments.length) return size;
            size = x;
            return partition;
        };
        return d3_layout_hierarchyRebind(partition, hierarchy);
    };
    d3.layout.pie = function() {
        var value = Number, sort = d3_layout_pieSortByValue, startAngle = 0, endAngle = τ, padAngle = 0;
        function pie(data) {
            var n = data.length, values = data.map(function(d, i) {
                return +value.call(pie, d, i);
            }), a = +(typeof startAngle === "function" ? startAngle.apply(this, arguments) : startAngle), da = (typeof endAngle === "function" ? endAngle.apply(this, arguments) : endAngle) - a, p = Math.min(Math.abs(da) / n, +(typeof padAngle === "function" ? padAngle.apply(this, arguments) : padAngle)), pa = p * (da < 0 ? -1 : 1), k = (da - n * pa) / d3.sum(values), index = d3.range(n), arcs = [], v;
            if (sort != null) index.sort(sort === d3_layout_pieSortByValue ? function(i, j) {
                return values[j] - values[i];
            } : function(i, j) {
                return sort(data[i], data[j]);
            });
            index.forEach(function(i) {
                arcs[i] = {
                    data: data[i],
                    value: v = values[i],
                    startAngle: a,
                    endAngle: a += v * k + pa,
                    padAngle: p
                };
            });
            return arcs;
        }
        pie.value = function(_) {
            if (!arguments.length) return value;
            value = _;
            return pie;
        };
        pie.sort = function(_) {
            if (!arguments.length) return sort;
            sort = _;
            return pie;
        };
        pie.startAngle = function(_) {
            if (!arguments.length) return startAngle;
            startAngle = _;
            return pie;
        };
        pie.endAngle = function(_) {
            if (!arguments.length) return endAngle;
            endAngle = _;
            return pie;
        };
        pie.padAngle = function(_) {
            if (!arguments.length) return padAngle;
            padAngle = _;
            return pie;
        };
        return pie;
    };
    var d3_layout_pieSortByValue = {};
    d3.layout.stack = function() {
        var values = d3_identity, order = d3_layout_stackOrderDefault, offset = d3_layout_stackOffsetZero, out = d3_layout_stackOut, x = d3_layout_stackX, y = d3_layout_stackY;
        function stack(data, index) {
            if (!(n = data.length)) return data;
            var series = data.map(function(d, i) {
                return values.call(stack, d, i);
            });
            var points = series.map(function(d) {
                return d.map(function(v, i) {
                    return [ x.call(stack, v, i), y.call(stack, v, i) ];
                });
            });
            var orders = order.call(stack, points, index);
            series = d3.permute(series, orders);
            points = d3.permute(points, orders);
            var offsets = offset.call(stack, points, index);
            var m = series[0].length, n, i, j, o;
            for (j = 0; j < m; ++j) {
                out.call(stack, series[0][j], o = offsets[j], points[0][j][1]);
                for (i = 1; i < n; ++i) {
                    out.call(stack, series[i][j], o += points[i - 1][j][1], points[i][j][1]);
                }
            }
            return data;
        }
        stack.values = function(x) {
            if (!arguments.length) return values;
            values = x;
            return stack;
        };
        stack.order = function(x) {
            if (!arguments.length) return order;
            order = typeof x === "function" ? x : d3_layout_stackOrders.get(x) || d3_layout_stackOrderDefault;
            return stack;
        };
        stack.offset = function(x) {
            if (!arguments.length) return offset;
            offset = typeof x === "function" ? x : d3_layout_stackOffsets.get(x) || d3_layout_stackOffsetZero;
            return stack;
        };
        stack.x = function(z) {
            if (!arguments.length) return x;
            x = z;
            return stack;
        };
        stack.y = function(z) {
            if (!arguments.length) return y;
            y = z;
            return stack;
        };
        stack.out = function(z) {
            if (!arguments.length) return out;
            out = z;
            return stack;
        };
        return stack;
    };
    function d3_layout_stackX(d) {
        return d.x;
    }
    function d3_layout_stackY(d) {
        return d.y;
    }
    function d3_layout_stackOut(d, y0, y) {
        d.y0 = y0;
        d.y = y;
    }
    var d3_layout_stackOrders = d3.map({
        "inside-out": function(data) {
            var n = data.length, i, j, max = data.map(d3_layout_stackMaxIndex), sums = data.map(d3_layout_stackReduceSum), index = d3.range(n).sort(function(a, b) {
                return max[a] - max[b];
            }), top = 0, bottom = 0, tops = [], bottoms = [];
            for (i = 0; i < n; ++i) {
                j = index[i];
                if (top < bottom) {
                    top += sums[j];
                    tops.push(j);
                } else {
                    bottom += sums[j];
                    bottoms.push(j);
                }
            }
            return bottoms.reverse().concat(tops);
        },
        reverse: function(data) {
            return d3.range(data.length).reverse();
        },
        "default": d3_layout_stackOrderDefault
    });
    var d3_layout_stackOffsets = d3.map({
        silhouette: function(data) {
            var n = data.length, m = data[0].length, sums = [], max = 0, i, j, o, y0 = [];
            for (j = 0; j < m; ++j) {
                for (i = 0, o = 0; i < n; i++) o += data[i][j][1];
                if (o > max) max = o;
                sums.push(o);
            }
            for (j = 0; j < m; ++j) {
                y0[j] = (max - sums[j]) / 2;
            }
            return y0;
        },
        wiggle: function(data) {
            var n = data.length, x = data[0], m = x.length, i, j, k, s1, s2, s3, dx, o, o0, y0 = [];
            y0[0] = o = o0 = 0;
            for (j = 1; j < m; ++j) {
                for (i = 0, s1 = 0; i < n; ++i) s1 += data[i][j][1];
                for (i = 0, s2 = 0, dx = x[j][0] - x[j - 1][0]; i < n; ++i) {
                    for (k = 0, s3 = (data[i][j][1] - data[i][j - 1][1]) / (2 * dx); k < i; ++k) {
                        s3 += (data[k][j][1] - data[k][j - 1][1]) / dx;
                    }
                    s2 += s3 * data[i][j][1];
                }
                y0[j] = o -= s1 ? s2 / s1 * dx : 0;
                if (o < o0) o0 = o;
            }
            for (j = 0; j < m; ++j) y0[j] -= o0;
            return y0;
        },
        expand: function(data) {
            var n = data.length, m = data[0].length, k = 1 / n, i, j, o, y0 = [];
            for (j = 0; j < m; ++j) {
                for (i = 0, o = 0; i < n; i++) o += data[i][j][1];
                if (o) for (i = 0; i < n; i++) data[i][j][1] /= o; else for (i = 0; i < n; i++) data[i][j][1] = k;
            }
            for (j = 0; j < m; ++j) y0[j] = 0;
            return y0;
        },
        zero: d3_layout_stackOffsetZero
    });
    function d3_layout_stackOrderDefault(data) {
        return d3.range(data.length);
    }
    function d3_layout_stackOffsetZero(data) {
        var j = -1, m = data[0].length, y0 = [];
        while (++j < m) y0[j] = 0;
        return y0;
    }
    function d3_layout_stackMaxIndex(array) {
        var i = 1, j = 0, v = array[0][1], k, n = array.length;
        for (;i < n; ++i) {
            if ((k = array[i][1]) > v) {
                j = i;
                v = k;
            }
        }
        return j;
    }
    function d3_layout_stackReduceSum(d) {
        return d.reduce(d3_layout_stackSum, 0);
    }
    function d3_layout_stackSum(p, d) {
        return p + d[1];
    }
    d3.layout.histogram = function() {
        var frequency = true, valuer = Number, ranger = d3_layout_histogramRange, binner = d3_layout_histogramBinSturges;
        function histogram(data, i) {
            var bins = [], values = data.map(valuer, this), range = ranger.call(this, values, i), thresholds = binner.call(this, range, values, i), bin, i = -1, n = values.length, m = thresholds.length - 1, k = frequency ? 1 : 1 / n, x;
            while (++i < m) {
                bin = bins[i] = [];
                bin.dx = thresholds[i + 1] - (bin.x = thresholds[i]);
                bin.y = 0;
            }
            if (m > 0) {
                i = -1;
                while (++i < n) {
                    x = values[i];
                    if (x >= range[0] && x <= range[1]) {
                        bin = bins[d3.bisect(thresholds, x, 1, m) - 1];
                        bin.y += k;
                        bin.push(data[i]);
                    }
                }
            }
            return bins;
        }
        histogram.value = function(x) {
            if (!arguments.length) return valuer;
            valuer = x;
            return histogram;
        };
        histogram.range = function(x) {
            if (!arguments.length) return ranger;
            ranger = d3_functor(x);
            return histogram;
        };
        histogram.bins = function(x) {
            if (!arguments.length) return binner;
            binner = typeof x === "number" ? function(range) {
                return d3_layout_histogramBinFixed(range, x);
            } : d3_functor(x);
            return histogram;
        };
        histogram.frequency = function(x) {
            if (!arguments.length) return frequency;
            frequency = !!x;
            return histogram;
        };
        return histogram;
    };
    function d3_layout_histogramBinSturges(range, values) {
        return d3_layout_histogramBinFixed(range, Math.ceil(Math.log(values.length) / Math.LN2 + 1));
    }
    function d3_layout_histogramBinFixed(range, n) {
        var x = -1, b = +range[0], m = (range[1] - b) / n, f = [];
        while (++x <= n) f[x] = m * x + b;
        return f;
    }
    function d3_layout_histogramRange(values) {
        return [ d3.min(values), d3.max(values) ];
    }
    d3.layout.pack = function() {
        var hierarchy = d3.layout.hierarchy().sort(d3_layout_packSort), padding = 0, size = [ 1, 1 ], radius;
        function pack(d, i) {
            var nodes = hierarchy.call(this, d, i), root = nodes[0], w = size[0], h = size[1], r = radius == null ? Math.sqrt : typeof radius === "function" ? radius : function() {
                return radius;
            };
            root.x = root.y = 0;
            d3_layout_hierarchyVisitAfter(root, function(d) {
                d.r = +r(d.value);
            });
            d3_layout_hierarchyVisitAfter(root, d3_layout_packSiblings);
            if (padding) {
                var dr = padding * (radius ? 1 : Math.max(2 * root.r / w, 2 * root.r / h)) / 2;
                d3_layout_hierarchyVisitAfter(root, function(d) {
                    d.r += dr;
                });
                d3_layout_hierarchyVisitAfter(root, d3_layout_packSiblings);
                d3_layout_hierarchyVisitAfter(root, function(d) {
                    d.r -= dr;
                });
            }
            d3_layout_packTransform(root, w / 2, h / 2, radius ? 1 : 1 / Math.max(2 * root.r / w, 2 * root.r / h));
            return nodes;
        }
        pack.size = function(_) {
            if (!arguments.length) return size;
            size = _;
            return pack;
        };
        pack.radius = function(_) {
            if (!arguments.length) return radius;
            radius = _ == null || typeof _ === "function" ? _ : +_;
            return pack;
        };
        pack.padding = function(_) {
            if (!arguments.length) return padding;
            padding = +_;
            return pack;
        };
        return d3_layout_hierarchyRebind(pack, hierarchy);
    };
    function d3_layout_packSort(a, b) {
        return a.value - b.value;
    }
    function d3_layout_packInsert(a, b) {
        var c = a._pack_next;
        a._pack_next = b;
        b._pack_prev = a;
        b._pack_next = c;
        c._pack_prev = b;
    }
    function d3_layout_packSplice(a, b) {
        a._pack_next = b;
        b._pack_prev = a;
    }
    function d3_layout_packIntersects(a, b) {
        var dx = b.x - a.x, dy = b.y - a.y, dr = a.r + b.r;
        return .999 * dr * dr > dx * dx + dy * dy;
    }
    function d3_layout_packSiblings(node) {
        if (!(nodes = node.children) || !(n = nodes.length)) return;
        var nodes, xMin = Infinity, xMax = -Infinity, yMin = Infinity, yMax = -Infinity, a, b, c, i, j, k, n;
        function bound(node) {
            xMin = Math.min(node.x - node.r, xMin);
            xMax = Math.max(node.x + node.r, xMax);
            yMin = Math.min(node.y - node.r, yMin);
            yMax = Math.max(node.y + node.r, yMax);
        }
        nodes.forEach(d3_layout_packLink);
        a = nodes[0];
        a.x = -a.r;
        a.y = 0;
        bound(a);
        if (n > 1) {
            b = nodes[1];
            b.x = b.r;
            b.y = 0;
            bound(b);
            if (n > 2) {
                c = nodes[2];
                d3_layout_packPlace(a, b, c);
                bound(c);
                d3_layout_packInsert(a, c);
                a._pack_prev = c;
                d3_layout_packInsert(c, b);
                b = a._pack_next;
                for (i = 3; i < n; i++) {
                    d3_layout_packPlace(a, b, c = nodes[i]);
                    var isect = 0, s1 = 1, s2 = 1;
                    for (j = b._pack_next; j !== b; j = j._pack_next, s1++) {
                        if (d3_layout_packIntersects(j, c)) {
                            isect = 1;
                            break;
                        }
                    }
                    if (isect == 1) {
                        for (k = a._pack_prev; k !== j._pack_prev; k = k._pack_prev, s2++) {
                            if (d3_layout_packIntersects(k, c)) {
                                break;
                            }
                        }
                    }
                    if (isect) {
                        if (s1 < s2 || s1 == s2 && b.r < a.r) d3_layout_packSplice(a, b = j); else d3_layout_packSplice(a = k, b);
                        i--;
                    } else {
                        d3_layout_packInsert(a, c);
                        b = c;
                        bound(c);
                    }
                }
            }
        }
        var cx = (xMin + xMax) / 2, cy = (yMin + yMax) / 2, cr = 0;
        for (i = 0; i < n; i++) {
            c = nodes[i];
            c.x -= cx;
            c.y -= cy;
            cr = Math.max(cr, c.r + Math.sqrt(c.x * c.x + c.y * c.y));
        }
        node.r = cr;
        nodes.forEach(d3_layout_packUnlink);
    }
    function d3_layout_packLink(node) {
        node._pack_next = node._pack_prev = node;
    }
    function d3_layout_packUnlink(node) {
        delete node._pack_next;
        delete node._pack_prev;
    }
    function d3_layout_packTransform(node, x, y, k) {
        var children = node.children;
        node.x = x += k * node.x;
        node.y = y += k * node.y;
        node.r *= k;
        if (children) {
            var i = -1, n = children.length;
            while (++i < n) d3_layout_packTransform(children[i], x, y, k);
        }
    }
    function d3_layout_packPlace(a, b, c) {
        var db = a.r + c.r, dx = b.x - a.x, dy = b.y - a.y;
        if (db && (dx || dy)) {
            var da = b.r + c.r, dc = dx * dx + dy * dy;
            da *= da;
            db *= db;
            var x = .5 + (db - da) / (2 * dc), y = Math.sqrt(Math.max(0, 2 * da * (db + dc) - (db -= dc) * db - da * da)) / (2 * dc);
            c.x = a.x + x * dx + y * dy;
            c.y = a.y + x * dy - y * dx;
        } else {
            c.x = a.x + db;
            c.y = a.y;
        }
    }
    d3.layout.tree = function() {
        var hierarchy = d3.layout.hierarchy().sort(null).value(null), separation = d3_layout_treeSeparation, size = [ 1, 1 ], nodeSize = null;
        function tree(d, i) {
            var nodes = hierarchy.call(this, d, i), root0 = nodes[0], root1 = wrapTree(root0);
            d3_layout_hierarchyVisitAfter(root1, firstWalk), root1.parent.m = -root1.z;
            d3_layout_hierarchyVisitBefore(root1, secondWalk);
            if (nodeSize) d3_layout_hierarchyVisitBefore(root0, sizeNode); else {
                var left = root0, right = root0, bottom = root0;
                d3_layout_hierarchyVisitBefore(root0, function(node) {
                    if (node.x < left.x) left = node;
                    if (node.x > right.x) right = node;
                    if (node.depth > bottom.depth) bottom = node;
                });
                var tx = separation(left, right) / 2 - left.x, kx = size[0] / (right.x + separation(right, left) / 2 + tx), ky = size[1] / (bottom.depth || 1);
                d3_layout_hierarchyVisitBefore(root0, function(node) {
                    node.x = (node.x + tx) * kx;
                    node.y = node.depth * ky;
                });
            }
            return nodes;
        }
        function wrapTree(root0) {
            var root1 = {
                A: null,
                children: [ root0 ]
            }, queue = [ root1 ], node1;
            while ((node1 = queue.pop()) != null) {
                for (var children = node1.children, child, i = 0, n = children.length; i < n; ++i) {
                    queue.push((children[i] = child = {
                        _: children[i],
                        parent: node1,
                        children: (child = children[i].children) && child.slice() || [],
                        A: null,
                        a: null,
                        z: 0,
                        m: 0,
                        c: 0,
                        s: 0,
                        t: null,
                        i: i
                    }).a = child);
                }
            }
            return root1.children[0];
        }
        function firstWalk(v) {
            var children = v.children, siblings = v.parent.children, w = v.i ? siblings[v.i - 1] : null;
            if (children.length) {
                d3_layout_treeShift(v);
                var midpoint = (children[0].z + children[children.length - 1].z) / 2;
                if (w) {
                    v.z = w.z + separation(v._, w._);
                    v.m = v.z - midpoint;
                } else {
                    v.z = midpoint;
                }
            } else if (w) {
                v.z = w.z + separation(v._, w._);
            }
            v.parent.A = apportion(v, w, v.parent.A || siblings[0]);
        }
        function secondWalk(v) {
            v._.x = v.z + v.parent.m;
            v.m += v.parent.m;
        }
        function apportion(v, w, ancestor) {
            if (w) {
                var vip = v, vop = v, vim = w, vom = vip.parent.children[0], sip = vip.m, sop = vop.m, sim = vim.m, som = vom.m, shift;
                while (vim = d3_layout_treeRight(vim), vip = d3_layout_treeLeft(vip), vim && vip) {
                    vom = d3_layout_treeLeft(vom);
                    vop = d3_layout_treeRight(vop);
                    vop.a = v;
                    shift = vim.z + sim - vip.z - sip + separation(vim._, vip._);
                    if (shift > 0) {
                        d3_layout_treeMove(d3_layout_treeAncestor(vim, v, ancestor), v, shift);
                        sip += shift;
                        sop += shift;
                    }
                    sim += vim.m;
                    sip += vip.m;
                    som += vom.m;
                    sop += vop.m;
                }
                if (vim && !d3_layout_treeRight(vop)) {
                    vop.t = vim;
                    vop.m += sim - sop;
                }
                if (vip && !d3_layout_treeLeft(vom)) {
                    vom.t = vip;
                    vom.m += sip - som;
                    ancestor = v;
                }
            }
            return ancestor;
        }
        function sizeNode(node) {
            node.x *= size[0];
            node.y = node.depth * size[1];
        }
        tree.separation = function(x) {
            if (!arguments.length) return separation;
            separation = x;
            return tree;
        };
        tree.size = function(x) {
            if (!arguments.length) return nodeSize ? null : size;
            nodeSize = (size = x) == null ? sizeNode : null;
            return tree;
        };
        tree.nodeSize = function(x) {
            if (!arguments.length) return nodeSize ? size : null;
            nodeSize = (size = x) == null ? null : sizeNode;
            return tree;
        };
        return d3_layout_hierarchyRebind(tree, hierarchy);
    };
    function d3_layout_treeSeparation(a, b) {
        return a.parent == b.parent ? 1 : 2;
    }
    function d3_layout_treeLeft(v) {
        var children = v.children;
        return children.length ? children[0] : v.t;
    }
    function d3_layout_treeRight(v) {
        var children = v.children, n;
        return (n = children.length) ? children[n - 1] : v.t;
    }
    function d3_layout_treeMove(wm, wp, shift) {
        var change = shift / (wp.i - wm.i);
        wp.c -= change;
        wp.s += shift;
        wm.c += change;
        wp.z += shift;
        wp.m += shift;
    }
    function d3_layout_treeShift(v) {
        var shift = 0, change = 0, children = v.children, i = children.length, w;
        while (--i >= 0) {
            w = children[i];
            w.z += shift;
            w.m += shift;
            shift += w.s + (change += w.c);
        }
    }
    function d3_layout_treeAncestor(vim, v, ancestor) {
        return vim.a.parent === v.parent ? vim.a : ancestor;
    }
    d3.layout.cluster = function() {
        var hierarchy = d3.layout.hierarchy().sort(null).value(null), separation = d3_layout_treeSeparation, size = [ 1, 1 ], nodeSize = false;
        function cluster(d, i) {
            var nodes = hierarchy.call(this, d, i), root = nodes[0], previousNode, x = 0;
            d3_layout_hierarchyVisitAfter(root, function(node) {
                var children = node.children;
                if (children && children.length) {
                    node.x = d3_layout_clusterX(children);
                    node.y = d3_layout_clusterY(children);
                } else {
                    node.x = previousNode ? x += separation(node, previousNode) : 0;
                    node.y = 0;
                    previousNode = node;
                }
            });
            var left = d3_layout_clusterLeft(root), right = d3_layout_clusterRight(root), x0 = left.x - separation(left, right) / 2, x1 = right.x + separation(right, left) / 2;
            d3_layout_hierarchyVisitAfter(root, nodeSize ? function(node) {
                node.x = (node.x - root.x) * size[0];
                node.y = (root.y - node.y) * size[1];
            } : function(node) {
                node.x = (node.x - x0) / (x1 - x0) * size[0];
                node.y = (1 - (root.y ? node.y / root.y : 1)) * size[1];
            });
            return nodes;
        }
        cluster.separation = function(x) {
            if (!arguments.length) return separation;
            separation = x;
            return cluster;
        };
        cluster.size = function(x) {
            if (!arguments.length) return nodeSize ? null : size;
            nodeSize = (size = x) == null;
            return cluster;
        };
        cluster.nodeSize = function(x) {
            if (!arguments.length) return nodeSize ? size : null;
            nodeSize = (size = x) != null;
            return cluster;
        };
        return d3_layout_hierarchyRebind(cluster, hierarchy);
    };
    function d3_layout_clusterY(children) {
        return 1 + d3.max(children, function(child) {
                return child.y;
            });
    }
    function d3_layout_clusterX(children) {
        return children.reduce(function(x, child) {
                return x + child.x;
            }, 0) / children.length;
    }
    function d3_layout_clusterLeft(node) {
        var children = node.children;
        return children && children.length ? d3_layout_clusterLeft(children[0]) : node;
    }
    function d3_layout_clusterRight(node) {
        var children = node.children, n;
        return children && (n = children.length) ? d3_layout_clusterRight(children[n - 1]) : node;
    }
    d3.layout.treemap = function() {
        var hierarchy = d3.layout.hierarchy(), round = Math.round, size = [ 1, 1 ], padding = null, pad = d3_layout_treemapPadNull, sticky = false, stickies, mode = "squarify", ratio = .5 * (1 + Math.sqrt(5));
        function scale(children, k) {
            var i = -1, n = children.length, child, area;
            while (++i < n) {
                area = (child = children[i]).value * (k < 0 ? 0 : k);
                child.area = isNaN(area) || area <= 0 ? 0 : area;
            }
        }
        function squarify(node) {
            var children = node.children;
            if (children && children.length) {
                var rect = pad(node), row = [], remaining = children.slice(), child, best = Infinity, score, u = mode === "slice" ? rect.dx : mode === "dice" ? rect.dy : mode === "slice-dice" ? node.depth & 1 ? rect.dy : rect.dx : Math.min(rect.dx, rect.dy), n;
                scale(remaining, rect.dx * rect.dy / node.value);
                row.area = 0;
                while ((n = remaining.length) > 0) {
                    row.push(child = remaining[n - 1]);
                    row.area += child.area;
                    if (mode !== "squarify" || (score = worst(row, u)) <= best) {
                        remaining.pop();
                        best = score;
                    } else {
                        row.area -= row.pop().area;
                        position(row, u, rect, false);
                        u = Math.min(rect.dx, rect.dy);
                        row.length = row.area = 0;
                        best = Infinity;
                    }
                }
                if (row.length) {
                    position(row, u, rect, true);
                    row.length = row.area = 0;
                }
                children.forEach(squarify);
            }
        }
        function stickify(node) {
            var children = node.children;
            if (children && children.length) {
                var rect = pad(node), remaining = children.slice(), child, row = [];
                scale(remaining, rect.dx * rect.dy / node.value);
                row.area = 0;
                while (child = remaining.pop()) {
                    row.push(child);
                    row.area += child.area;
                    if (child.z != null) {
                        position(row, child.z ? rect.dx : rect.dy, rect, !remaining.length);
                        row.length = row.area = 0;
                    }
                }
                children.forEach(stickify);
            }
        }
        function worst(row, u) {
            var s = row.area, r, rmax = 0, rmin = Infinity, i = -1, n = row.length;
            while (++i < n) {
                if (!(r = row[i].area)) continue;
                if (r < rmin) rmin = r;
                if (r > rmax) rmax = r;
            }
            s *= s;
            u *= u;
            return s ? Math.max(u * rmax * ratio / s, s / (u * rmin * ratio)) : Infinity;
        }
        function position(row, u, rect, flush) {
            var i = -1, n = row.length, x = rect.x, y = rect.y, v = u ? round(row.area / u) : 0, o;
            if (u == rect.dx) {
                if (flush || v > rect.dy) v = rect.dy;
                while (++i < n) {
                    o = row[i];
                    o.x = x;
                    o.y = y;
                    o.dy = v;
                    x += o.dx = Math.min(rect.x + rect.dx - x, v ? round(o.area / v) : 0);
                }
                o.z = true;
                o.dx += rect.x + rect.dx - x;
                rect.y += v;
                rect.dy -= v;
            } else {
                if (flush || v > rect.dx) v = rect.dx;
                while (++i < n) {
                    o = row[i];
                    o.x = x;
                    o.y = y;
                    o.dx = v;
                    y += o.dy = Math.min(rect.y + rect.dy - y, v ? round(o.area / v) : 0);
                }
                o.z = false;
                o.dy += rect.y + rect.dy - y;
                rect.x += v;
                rect.dx -= v;
            }
        }
        function treemap(d) {
            var nodes = stickies || hierarchy(d), root = nodes[0];
            root.x = 0;
            root.y = 0;
            root.dx = size[0];
            root.dy = size[1];
            if (stickies) hierarchy.revalue(root);
            scale([ root ], root.dx * root.dy / root.value);
            (stickies ? stickify : squarify)(root);
            if (sticky) stickies = nodes;
            return nodes;
        }
        treemap.size = function(x) {
            if (!arguments.length) return size;
            size = x;
            return treemap;
        };
        treemap.padding = function(x) {
            if (!arguments.length) return padding;
            function padFunction(node) {
                var p = x.call(treemap, node, node.depth);
                return p == null ? d3_layout_treemapPadNull(node) : d3_layout_treemapPad(node, typeof p === "number" ? [ p, p, p, p ] : p);
            }
            function padConstant(node) {
                return d3_layout_treemapPad(node, x);
            }
            var type;
            pad = (padding = x) == null ? d3_layout_treemapPadNull : (type = typeof x) === "function" ? padFunction : type === "number" ? (x = [ x, x, x, x ],
                padConstant) : padConstant;
            return treemap;
        };
        treemap.round = function(x) {
            if (!arguments.length) return round != Number;
            round = x ? Math.round : Number;
            return treemap;
        };
        treemap.sticky = function(x) {
            if (!arguments.length) return sticky;
            sticky = x;
            stickies = null;
            return treemap;
        };
        treemap.ratio = function(x) {
            if (!arguments.length) return ratio;
            ratio = x;
            return treemap;
        };
        treemap.mode = function(x) {
            if (!arguments.length) return mode;
            mode = x + "";
            return treemap;
        };
        return d3_layout_hierarchyRebind(treemap, hierarchy);
    };
    function d3_layout_treemapPadNull(node) {
        return {
            x: node.x,
            y: node.y,
            dx: node.dx,
            dy: node.dy
        };
    }
    function d3_layout_treemapPad(node, padding) {
        var x = node.x + padding[3], y = node.y + padding[0], dx = node.dx - padding[1] - padding[3], dy = node.dy - padding[0] - padding[2];
        if (dx < 0) {
            x += dx / 2;
            dx = 0;
        }
        if (dy < 0) {
            y += dy / 2;
            dy = 0;
        }
        return {
            x: x,
            y: y,
            dx: dx,
            dy: dy
        };
    }
    d3.random = {
        normal: function(base, sigma) {
            var n = arguments.length;
            if (n < 2) sigma = 1;
            if (n < 1) base = 0;
            return function() {
                var x, y, r;
                do {
                    x = Math.random() * 2 - 1;
                    y = Math.random() * 2 - 1;
                    r = x * x + y * y;
                } while (!r || r > 1);
                return base + sigma * x * Math.sqrt(-2 * Math.log(r) / r);
            };
        },
        logNormal: function() {
            var random = d3.random.normal.apply(d3, arguments);
            return function() {
                return Math.exp(random());
            };
        },
        bates: function(m) {
            var random = d3.random.irwinHall(m);
            return function() {
                return random() / m;
            };
        },
        irwinHall: function(m) {
            return function() {
                for (var s = 0, j = 0; j < m; j++) s += Math.random();
                return s;
            };
        }
    };
    d3.scale = {};
    function d3_scaleExtent(domain) {
        var start = domain[0], stop = domain[domain.length - 1];
        return start < stop ? [ start, stop ] : [ stop, start ];
    }
    function d3_scaleRange(scale) {
        return scale.rangeExtent ? scale.rangeExtent() : d3_scaleExtent(scale.range());
    }
    function d3_scale_bilinear(domain, range, uninterpolate, interpolate) {
        var u = uninterpolate(domain[0], domain[1]), i = interpolate(range[0], range[1]);
        return function(x) {
            return i(u(x));
        };
    }
    function d3_scale_nice(domain, nice) {
        var i0 = 0, i1 = domain.length - 1, x0 = domain[i0], x1 = domain[i1], dx;
        if (x1 < x0) {
            dx = i0, i0 = i1, i1 = dx;
            dx = x0, x0 = x1, x1 = dx;
        }
        domain[i0] = nice.floor(x0);
        domain[i1] = nice.ceil(x1);
        return domain;
    }
    function d3_scale_niceStep(step) {
        return step ? {
            floor: function(x) {
                return Math.floor(x / step) * step;
            },
            ceil: function(x) {
                return Math.ceil(x / step) * step;
            }
        } : d3_scale_niceIdentity;
    }
    var d3_scale_niceIdentity = {
        floor: d3_identity,
        ceil: d3_identity
    };
    function d3_scale_polylinear(domain, range, uninterpolate, interpolate) {
        var u = [], i = [], j = 0, k = Math.min(domain.length, range.length) - 1;
        if (domain[k] < domain[0]) {
            domain = domain.slice().reverse();
            range = range.slice().reverse();
        }
        while (++j <= k) {
            u.push(uninterpolate(domain[j - 1], domain[j]));
            i.push(interpolate(range[j - 1], range[j]));
        }
        return function(x) {
            var j = d3.bisect(domain, x, 1, k) - 1;
            return i[j](u[j](x));
        };
    }
    d3.scale.linear = function() {
        return d3_scale_linear([ 0, 1 ], [ 0, 1 ], d3_interpolate, false);
    };
    function d3_scale_linear(domain, range, interpolate, clamp) {
        var output, input;
        function rescale() {
            var linear = Math.min(domain.length, range.length) > 2 ? d3_scale_polylinear : d3_scale_bilinear, uninterpolate = clamp ? d3_uninterpolateClamp : d3_uninterpolateNumber;
            output = linear(domain, range, uninterpolate, interpolate);
            input = linear(range, domain, uninterpolate, d3_interpolate);
            return scale;
        }
        function scale(x) {
            return output(x);
        }
        scale.invert = function(y) {
            return input(y);
        };
        scale.domain = function(x) {
            if (!arguments.length) return domain;
            domain = x.map(Number);
            return rescale();
        };
        scale.range = function(x) {
            if (!arguments.length) return range;
            range = x;
            return rescale();
        };
        scale.rangeRound = function(x) {
            return scale.range(x).interpolate(d3_interpolateRound);
        };
        scale.clamp = function(x) {
            if (!arguments.length) return clamp;
            clamp = x;
            return rescale();
        };
        scale.interpolate = function(x) {
            if (!arguments.length) return interpolate;
            interpolate = x;
            return rescale();
        };
        scale.ticks = function(m) {
            return d3_scale_linearTicks(domain, m);
        };
        scale.tickFormat = function(m, format) {
            return d3_scale_linearTickFormat(domain, m, format);
        };
        scale.nice = function(m) {
            d3_scale_linearNice(domain, m);
            return rescale();
        };
        scale.copy = function() {
            return d3_scale_linear(domain, range, interpolate, clamp);
        };
        return rescale();
    }
    function d3_scale_linearRebind(scale, linear) {
        return d3.rebind(scale, linear, "range", "rangeRound", "interpolate", "clamp");
    }
    function d3_scale_linearNice(domain, m) {
        return d3_scale_nice(domain, d3_scale_niceStep(d3_scale_linearTickRange(domain, m)[2]));
    }
    function d3_scale_linearTickRange(domain, m) {
        if (m == null) m = 10;
        var extent = d3_scaleExtent(domain), span = extent[1] - extent[0], step = Math.pow(10, Math.floor(Math.log(span / m) / Math.LN10)), err = m / span * step;
        if (err <= .15) step *= 10; else if (err <= .35) step *= 5; else if (err <= .75) step *= 2;
        extent[0] = Math.ceil(extent[0] / step) * step;
        extent[1] = Math.floor(extent[1] / step) * step + step * .5;
        extent[2] = step;
        return extent;
    }
    function d3_scale_linearTicks(domain, m) {
        return d3.range.apply(d3, d3_scale_linearTickRange(domain, m));
    }
    function d3_scale_linearTickFormat(domain, m, format) {
        var range = d3_scale_linearTickRange(domain, m);
        if (format) {
            var match = d3_format_re.exec(format);
            match.shift();
            if (match[8] === "s") {
                var prefix = d3.formatPrefix(Math.max(abs(range[0]), abs(range[1])));
                if (!match[7]) match[7] = "." + d3_scale_linearPrecision(prefix.scale(range[2]));
                match[8] = "f";
                format = d3.format(match.join(""));
                return function(d) {
                    return format(prefix.scale(d)) + prefix.symbol;
                };
            }
            if (!match[7]) match[7] = "." + d3_scale_linearFormatPrecision(match[8], range);
            format = match.join("");
        } else {
            format = ",." + d3_scale_linearPrecision(range[2]) + "f";
        }
        return d3.format(format);
    }
    var d3_scale_linearFormatSignificant = {
        s: 1,
        g: 1,
        p: 1,
        r: 1,
        e: 1
    };
    function d3_scale_linearPrecision(value) {
        return -Math.floor(Math.log(value) / Math.LN10 + .01);
    }
    function d3_scale_linearFormatPrecision(type, range) {
        var p = d3_scale_linearPrecision(range[2]);
        return type in d3_scale_linearFormatSignificant ? Math.abs(p - d3_scale_linearPrecision(Math.max(abs(range[0]), abs(range[1])))) + +(type !== "e") : p - (type === "%") * 2;
    }
    d3.scale.log = function() {
        return d3_scale_log(d3.scale.linear().domain([ 0, 1 ]), 10, true, [ 1, 10 ]);
    };
    function d3_scale_log(linear, base, positive, domain) {
        function log(x) {
            return (positive ? Math.log(x < 0 ? 0 : x) : -Math.log(x > 0 ? 0 : -x)) / Math.log(base);
        }
        function pow(x) {
            return positive ? Math.pow(base, x) : -Math.pow(base, -x);
        }
        function scale(x) {
            return linear(log(x));
        }
        scale.invert = function(x) {
            return pow(linear.invert(x));
        };
        scale.domain = function(x) {
            if (!arguments.length) return domain;
            positive = x[0] >= 0;
            linear.domain((domain = x.map(Number)).map(log));
            return scale;
        };
        scale.base = function(_) {
            if (!arguments.length) return base;
            base = +_;
            linear.domain(domain.map(log));
            return scale;
        };
        scale.nice = function() {
            var niced = d3_scale_nice(domain.map(log), positive ? Math : d3_scale_logNiceNegative);
            linear.domain(niced);
            domain = niced.map(pow);
            return scale;
        };
        scale.ticks = function() {
            var extent = d3_scaleExtent(domain), ticks = [], u = extent[0], v = extent[1], i = Math.floor(log(u)), j = Math.ceil(log(v)), n = base % 1 ? 2 : base;
            if (isFinite(j - i)) {
                if (positive) {
                    for (;i < j; i++) for (var k = 1; k < n; k++) ticks.push(pow(i) * k);
                    ticks.push(pow(i));
                } else {
                    ticks.push(pow(i));
                    for (;i++ < j; ) for (var k = n - 1; k > 0; k--) ticks.push(pow(i) * k);
                }
                for (i = 0; ticks[i] < u; i++) {}
                for (j = ticks.length; ticks[j - 1] > v; j--) {}
                ticks = ticks.slice(i, j);
            }
            return ticks;
        };
        scale.tickFormat = function(n, format) {
            if (!arguments.length) return d3_scale_logFormat;
            if (arguments.length < 2) format = d3_scale_logFormat; else if (typeof format !== "function") format = d3.format(format);
            var k = Math.max(.1, n / scale.ticks().length), f = positive ? (e = 1e-12, Math.ceil) : (e = -1e-12,
                Math.floor), e;
            return function(d) {
                return d / pow(f(log(d) + e)) <= k ? format(d) : "";
            };
        };
        scale.copy = function() {
            return d3_scale_log(linear.copy(), base, positive, domain);
        };
        return d3_scale_linearRebind(scale, linear);
    }
    var d3_scale_logFormat = d3.format(".0e"), d3_scale_logNiceNegative = {
        floor: function(x) {
            return -Math.ceil(-x);
        },
        ceil: function(x) {
            return -Math.floor(-x);
        }
    };
    d3.scale.pow = function() {
        return d3_scale_pow(d3.scale.linear(), 1, [ 0, 1 ]);
    };
    function d3_scale_pow(linear, exponent, domain) {
        var powp = d3_scale_powPow(exponent), powb = d3_scale_powPow(1 / exponent);
        function scale(x) {
            return linear(powp(x));
        }
        scale.invert = function(x) {
            return powb(linear.invert(x));
        };
        scale.domain = function(x) {
            if (!arguments.length) return domain;
            linear.domain((domain = x.map(Number)).map(powp));
            return scale;
        };
        scale.ticks = function(m) {
            return d3_scale_linearTicks(domain, m);
        };
        scale.tickFormat = function(m, format) {
            return d3_scale_linearTickFormat(domain, m, format);
        };
        scale.nice = function(m) {
            return scale.domain(d3_scale_linearNice(domain, m));
        };
        scale.exponent = function(x) {
            if (!arguments.length) return exponent;
            powp = d3_scale_powPow(exponent = x);
            powb = d3_scale_powPow(1 / exponent);
            linear.domain(domain.map(powp));
            return scale;
        };
        scale.copy = function() {
            return d3_scale_pow(linear.copy(), exponent, domain);
        };
        return d3_scale_linearRebind(scale, linear);
    }
    function d3_scale_powPow(e) {
        return function(x) {
            return x < 0 ? -Math.pow(-x, e) : Math.pow(x, e);
        };
    }
    d3.scale.sqrt = function() {
        return d3.scale.pow().exponent(.5);
    };
    d3.scale.ordinal = function() {
        return d3_scale_ordinal([], {
            t: "range",
            a: [ [] ]
        });
    };
    function d3_scale_ordinal(domain, ranger) {
        var index, range, rangeBand;
        function scale(x) {
            return range[((index.get(x) || (ranger.t === "range" ? index.set(x, domain.push(x)) : NaN)) - 1) % range.length];
        }
        function steps(start, step) {
            return d3.range(domain.length).map(function(i) {
                return start + step * i;
            });
        }
        scale.domain = function(x) {
            if (!arguments.length) return domain;
            domain = [];
            index = new d3_Map();
            var i = -1, n = x.length, xi;
            while (++i < n) if (!index.has(xi = x[i])) index.set(xi, domain.push(xi));
            return scale[ranger.t].apply(scale, ranger.a);
        };
        scale.range = function(x) {
            if (!arguments.length) return range;
            range = x;
            rangeBand = 0;
            ranger = {
                t: "range",
                a: arguments
            };
            return scale;
        };
        scale.rangePoints = function(x, padding) {
            if (arguments.length < 2) padding = 0;
            var start = x[0], stop = x[1], step = domain.length < 2 ? (start = (start + stop) / 2,
                0) : (stop - start) / (domain.length - 1 + padding);
            range = steps(start + step * padding / 2, step);
            rangeBand = 0;
            ranger = {
                t: "rangePoints",
                a: arguments
            };
            return scale;
        };
        scale.rangeRoundPoints = function(x, padding) {
            if (arguments.length < 2) padding = 0;
            var start = x[0], stop = x[1], step = domain.length < 2 ? (start = stop = Math.round((start + stop) / 2),
                0) : (stop - start) / (domain.length - 1 + padding) | 0;
            range = steps(start + Math.round(step * padding / 2 + (stop - start - (domain.length - 1 + padding) * step) / 2), step);
            rangeBand = 0;
            ranger = {
                t: "rangeRoundPoints",
                a: arguments
            };
            return scale;
        };
        scale.rangeBands = function(x, padding, outerPadding) {
            if (arguments.length < 2) padding = 0;
            if (arguments.length < 3) outerPadding = padding;
            var reverse = x[1] < x[0], start = x[reverse - 0], stop = x[1 - reverse], step = (stop - start) / (domain.length - padding + 2 * outerPadding);
            range = steps(start + step * outerPadding, step);
            if (reverse) range.reverse();
            rangeBand = step * (1 - padding);
            ranger = {
                t: "rangeBands",
                a: arguments
            };
            return scale;
        };
        scale.rangeRoundBands = function(x, padding, outerPadding) {
            if (arguments.length < 2) padding = 0;
            if (arguments.length < 3) outerPadding = padding;
            var reverse = x[1] < x[0], start = x[reverse - 0], stop = x[1 - reverse], step = Math.floor((stop - start) / (domain.length - padding + 2 * outerPadding));
            range = steps(start + Math.round((stop - start - (domain.length - padding) * step) / 2), step);
            if (reverse) range.reverse();
            rangeBand = Math.round(step * (1 - padding));
            ranger = {
                t: "rangeRoundBands",
                a: arguments
            };
            return scale;
        };
        scale.rangeBand = function() {
            return rangeBand;
        };
        scale.rangeExtent = function() {
            return d3_scaleExtent(ranger.a[0]);
        };
        scale.copy = function() {
            return d3_scale_ordinal(domain, ranger);
        };
        return scale.domain(domain);
    }
    d3.scale.category10 = function() {
        return d3.scale.ordinal().range(d3_category10);
    };
    d3.scale.category20 = function() {
        return d3.scale.ordinal().range(d3_category20);
    };
    d3.scale.category20b = function() {
        return d3.scale.ordinal().range(d3_category20b);
    };
    d3.scale.category20c = function() {
        return d3.scale.ordinal().range(d3_category20c);
    };
    var d3_category10 = [ 2062260, 16744206, 2924588, 14034728, 9725885, 9197131, 14907330, 8355711, 12369186, 1556175 ].map(d3_rgbString);
    var d3_category20 = [ 2062260, 11454440, 16744206, 16759672, 2924588, 10018698, 14034728, 16750742, 9725885, 12955861, 9197131, 12885140, 14907330, 16234194, 8355711, 13092807, 12369186, 14408589, 1556175, 10410725 ].map(d3_rgbString);
    var d3_category20b = [ 3750777, 5395619, 7040719, 10264286, 6519097, 9216594, 11915115, 13556636, 9202993, 12426809, 15186514, 15190932, 8666169, 11356490, 14049643, 15177372, 8077683, 10834324, 13528509, 14589654 ].map(d3_rgbString);
    var d3_category20c = [ 3244733, 7057110, 10406625, 13032431, 15095053, 16616764, 16625259, 16634018, 3253076, 7652470, 10607003, 13101504, 7695281, 10394312, 12369372, 14342891, 6513507, 9868950, 12434877, 14277081 ].map(d3_rgbString);
    d3.scale.quantile = function() {
        return d3_scale_quantile([], []);
    };
    function d3_scale_quantile(domain, range) {
        var thresholds;
        function rescale() {
            var k = 0, q = range.length;
            thresholds = [];
            while (++k < q) thresholds[k - 1] = d3.quantile(domain, k / q);
            return scale;
        }
        function scale(x) {
            if (!isNaN(x = +x)) return range[d3.bisect(thresholds, x)];
        }
        scale.domain = function(x) {
            if (!arguments.length) return domain;
            domain = x.map(d3_number).filter(d3_numeric).sort(d3_ascending);
            return rescale();
        };
        scale.range = function(x) {
            if (!arguments.length) return range;
            range = x;
            return rescale();
        };
        scale.quantiles = function() {
            return thresholds;
        };
        scale.invertExtent = function(y) {
            y = range.indexOf(y);
            return y < 0 ? [ NaN, NaN ] : [ y > 0 ? thresholds[y - 1] : domain[0], y < thresholds.length ? thresholds[y] : domain[domain.length - 1] ];
        };
        scale.copy = function() {
            return d3_scale_quantile(domain, range);
        };
        return rescale();
    }
    d3.scale.quantize = function() {
        return d3_scale_quantize(0, 1, [ 0, 1 ]);
    };
    function d3_scale_quantize(x0, x1, range) {
        var kx, i;
        function scale(x) {
            return range[Math.max(0, Math.min(i, Math.floor(kx * (x - x0))))];
        }
        function rescale() {
            kx = range.length / (x1 - x0);
            i = range.length - 1;
            return scale;
        }
        scale.domain = function(x) {
            if (!arguments.length) return [ x0, x1 ];
            x0 = +x[0];
            x1 = +x[x.length - 1];
            return rescale();
        };
        scale.range = function(x) {
            if (!arguments.length) return range;
            range = x;
            return rescale();
        };
        scale.invertExtent = function(y) {
            y = range.indexOf(y);
            y = y < 0 ? NaN : y / kx + x0;
            return [ y, y + 1 / kx ];
        };
        scale.copy = function() {
            return d3_scale_quantize(x0, x1, range);
        };
        return rescale();
    }
    d3.scale.threshold = function() {
        return d3_scale_threshold([ .5 ], [ 0, 1 ]);
    };
    function d3_scale_threshold(domain, range) {
        function scale(x) {
            if (x <= x) return range[d3.bisect(domain, x)];
        }
        scale.domain = function(_) {
            if (!arguments.length) return domain;
            domain = _;
            return scale;
        };
        scale.range = function(_) {
            if (!arguments.length) return range;
            range = _;
            return scale;
        };
        scale.invertExtent = function(y) {
            y = range.indexOf(y);
            return [ domain[y - 1], domain[y] ];
        };
        scale.copy = function() {
            return d3_scale_threshold(domain, range);
        };
        return scale;
    }
    d3.scale.identity = function() {
        return d3_scale_identity([ 0, 1 ]);
    };
    function d3_scale_identity(domain) {
        function identity(x) {
            return +x;
        }
        identity.invert = identity;
        identity.domain = identity.range = function(x) {
            if (!arguments.length) return domain;
            domain = x.map(identity);
            return identity;
        };
        identity.ticks = function(m) {
            return d3_scale_linearTicks(domain, m);
        };
        identity.tickFormat = function(m, format) {
            return d3_scale_linearTickFormat(domain, m, format);
        };
        identity.copy = function() {
            return d3_scale_identity(domain);
        };
        return identity;
    }
    d3.svg = {};
    function d3_zero() {
        return 0;
    }
    d3.svg.arc = function() {
        var toCenter = true;
        var closePath = true;
        var innerRadius = d3_svg_arcInnerRadius, outerRadius = d3_svg_arcOuterRadius, cornerRadius = d3_zero, padRadius = d3_svg_arcAuto, startAngle = d3_svg_arcStartAngle, endAngle = d3_svg_arcEndAngle, padAngle = d3_svg_arcPadAngle;
        function arc() {
            var r0 = Math.max(0, +innerRadius.apply(this, arguments)), r1 = Math.max(0, +outerRadius.apply(this, arguments)), a0 = startAngle.apply(this, arguments) - halfπ, a1 = endAngle.apply(this, arguments) - halfπ, da = Math.abs(a1 - a0), cw = a0 > a1 ? 0 : 1;
            if (r1 < r0) rc = r1, r1 = r0, r0 = rc;
            if (da >= τε) return circleSegment(r1, cw) + (r0 ? circleSegment(r0, 1 - cw) : "") + "Z";
            var rc, cr, rp, ap, p0 = 0, p1 = 0, x0, y0, x1, y1, x2, y2, x3, y3, path = [];
            if (ap = (+padAngle.apply(this, arguments) || 0) / 2) {
                rp = padRadius === d3_svg_arcAuto ? Math.sqrt(r0 * r0 + r1 * r1) : +padRadius.apply(this, arguments);
                if (!cw) p1 *= -1;
                if (r1) p1 = d3_asin(rp / r1 * Math.sin(ap));
                if (r0) p0 = d3_asin(rp / r0 * Math.sin(ap));
            }
            if (r1) {
                x0 = r1 * Math.cos(a0 + p1);
                y0 = r1 * Math.sin(a0 + p1);
                x1 = r1 * Math.cos(a1 - p1);
                y1 = r1 * Math.sin(a1 - p1);
                var l1 = Math.abs(a1 - a0 - 2 * p1) <= π ? 0 : 1;
                if (p1 && d3_svg_arcSweep(x0, y0, x1, y1) === cw ^ l1) {
                    var h1 = (a0 + a1) / 2;
                    x0 = r1 * Math.cos(h1);
                    y0 = r1 * Math.sin(h1);
                    x1 = y1 = null;
                }
            } else {
                x0 = y0 = 0;
            }
            if (r0) {
                x2 = r0 * Math.cos(a1 - p0);
                y2 = r0 * Math.sin(a1 - p0);
                x3 = r0 * Math.cos(a0 + p0);
                y3 = r0 * Math.sin(a0 + p0);
                var l0 = Math.abs(a0 - a1 + 2 * p0) <= π ? 0 : 1;
                if (p0 && d3_svg_arcSweep(x2, y2, x3, y3) === 1 - cw ^ l0) {
                    var h0 = (a0 + a1) / 2;
                    x2 = r0 * Math.cos(h0);
                    y2 = r0 * Math.sin(h0);
                    x3 = y3 = null;
                }
            } else {
                x2 = y2 = 0;
            }
            if ((rc = Math.min(Math.abs(r1 - r0) / 2, +cornerRadius.apply(this, arguments))) > .001) {
                cr = r0 < r1 ^ cw ? 0 : 1;
                var oc = x3 == null ? [ x2, y2 ] : x1 == null ? [ x0, y0 ] : d3_geom_polygonIntersect([ x0, y0 ], [ x3, y3 ], [ x1, y1 ], [ x2, y2 ]), ax = x0 - oc[0], ay = y0 - oc[1], bx = x1 - oc[0], by = y1 - oc[1], kc = 1 / Math.sin(Math.acos((ax * bx + ay * by) / (Math.sqrt(ax * ax + ay * ay) * Math.sqrt(bx * bx + by * by))) / 2), lc = Math.sqrt(oc[0] * oc[0] + oc[1] * oc[1]);
                if (x1 != null) {
                    var rc1 = Math.min(rc, (r1 - lc) / (kc + 1)), t30 = d3_svg_arcCornerTangents(x3 == null ? [ x2, y2 ] : [ x3, y3 ], [ x0, y0 ], r1, rc1, cw), t12 = d3_svg_arcCornerTangents([ x1, y1 ], [ x2, y2 ], r1, rc1, cw);
                    if (rc === rc1) {
                        path.push("M", t30[0], "A", rc1, ",", rc1, " 0 0,", cr, " ", t30[1], "A", r1, ",", r1, " 0 ", 1 - cw ^ d3_svg_arcSweep(t30[1][0], t30[1][1], t12[1][0], t12[1][1]), ",", cw, " ", t12[1], "A", rc1, ",", rc1, " 0 0,", cr, " ", t12[0]);
                    } else {
                        path.push("M", t30[0], "A", rc1, ",", rc1, " 0 1,", cr, " ", t12[0]);
                    }
                } else {
                    path.push("M", x0, ",", y0);
                }
                if (x3 != null) {
                    var rc0 = Math.min(rc, (r0 - lc) / (kc - 1)), t03 = d3_svg_arcCornerTangents([ x0, y0 ], [ x3, y3 ], r0, -rc0, cw), t21 = d3_svg_arcCornerTangents([ x2, y2 ], x1 == null ? [ x0, y0 ] : [ x1, y1 ], r0, -rc0, cw);
                    if (rc === rc0) {
                        path.push("L", t21[0], "A", rc0, ",", rc0, " 0 0,", cr, " ", t21[1], "A", r0, ",", r0, " 0 ", cw ^ d3_svg_arcSweep(t21[1][0], t21[1][1], t03[1][0], t03[1][1]), ",", 1 - cw, " ", t03[1], "A", rc0, ",", rc0, " 0 0,", cr, " ", t03[0]);
                    } else {
                        path.push("L", t21[0], "A", rc0, ",", rc0, " 0 0,", cr, " ", t03[0]);
                    }
                } else if(toCenter){
                    path.push("L", x2, ",", y2);
                }
            } else {
                path.push("M", x0, ",", y0);
                if (x1 != null) path.push("A", r1, ",", r1, " 0 ", l1, ",", cw, " ", x1, ",", y1);
                if (toCenter) path.push("L", x2, ",", y2);
                if (x3 != null) path.push("A", r0, ",", r0, " 0 ", l0, ",", 1 - cw, " ", x3, ",", y3);
            }
            if(closePath) path.push("Z");
            return path.join("");
        }
        function circleSegment(r1, cw) {
            return "M0," + r1 + "A" + r1 + "," + r1 + " 0 1," + cw + " 0," + -r1 + "A" + r1 + "," + r1 + " 0 1," + cw + " 0," + r1;
        }

        arc.toCenter = function(v){
            if (!arguments.length) return toCenter;
            toCenter = !!v;
            return arc;
        };

        arc.closePath = function(v){
            if (!arguments.length) return closePath;
            closePath = !!v;
            return arc;
        },

            arc.innerRadius = function(v) {
                if (!arguments.length) return innerRadius;
                innerRadius = d3_functor(v);
                return arc;
            };
        arc.outerRadius = function(v) {
            if (!arguments.length) return outerRadius;
            outerRadius = d3_functor(v);
            return arc;
        };
        arc.cornerRadius = function(v) {
            if (!arguments.length) return cornerRadius;
            cornerRadius = d3_functor(v);
            return arc;
        };
        arc.padRadius = function(v) {
            if (!arguments.length) return padRadius;
            padRadius = v == d3_svg_arcAuto ? d3_svg_arcAuto : d3_functor(v);
            return arc;
        };
        arc.startAngle = function(v) {
            if (!arguments.length) return startAngle;
            startAngle = d3_functor(v);
            return arc;
        };
        arc.endAngle = function(v) {
            if (!arguments.length) return endAngle;
            endAngle = d3_functor(v);
            return arc;
        };
        arc.padAngle = function(v) {
            if (!arguments.length) return padAngle;
            padAngle = d3_functor(v);
            return arc;
        };
        arc.centroid = function() {
            var r = (+innerRadius.apply(this, arguments) + +outerRadius.apply(this, arguments)) / 2, a = (+startAngle.apply(this, arguments) + +endAngle.apply(this, arguments)) / 2 - halfπ;
            return [ Math.cos(a) * r, Math.sin(a) * r ];
        };
        return arc;
    };
    var d3_svg_arcAuto = "auto";
    function d3_svg_arcInnerRadius(d) {
        return d.innerRadius;
    }
    function d3_svg_arcOuterRadius(d) {
        return d.outerRadius;
    }
    function d3_svg_arcStartAngle(d) {
        return d.startAngle;
    }
    function d3_svg_arcEndAngle(d) {
        return d.endAngle;
    }
    function d3_svg_arcPadAngle(d) {
        return d && d.padAngle;
    }
    function d3_svg_arcSweep(x0, y0, x1, y1) {
        return (x0 - x1) * y0 - (y0 - y1) * x0 > 0 ? 0 : 1;
    }
    function d3_svg_arcCornerTangents(p0, p1, r1, rc, cw) {
        var x01 = p0[0] - p1[0], y01 = p0[1] - p1[1], lo = (cw ? rc : -rc) / Math.sqrt(x01 * x01 + y01 * y01), ox = lo * y01, oy = -lo * x01, x1 = p0[0] + ox, y1 = p0[1] + oy, x2 = p1[0] + ox, y2 = p1[1] + oy, x3 = (x1 + x2) / 2, y3 = (y1 + y2) / 2, dx = x2 - x1, dy = y2 - y1, d2 = dx * dx + dy * dy, r = r1 - rc, D = x1 * y2 - x2 * y1, d = (dy < 0 ? -1 : 1) * Math.sqrt(r * r * d2 - D * D), cx0 = (D * dy - dx * d) / d2, cy0 = (-D * dx - dy * d) / d2, cx1 = (D * dy + dx * d) / d2, cy1 = (-D * dx + dy * d) / d2, dx0 = cx0 - x3, dy0 = cy0 - y3, dx1 = cx1 - x3, dy1 = cy1 - y3;
        if (dx0 * dx0 + dy0 * dy0 > dx1 * dx1 + dy1 * dy1) cx0 = cx1, cy0 = cy1;
        return [ [ cx0 - ox, cy0 - oy ], [ cx0 * r1 / r, cy0 * r1 / r ] ];
    }
    function d3_svg_line(projection) {
        var x = d3_geom_pointX, y = d3_geom_pointY, defined = d3_true, interpolate = d3_svg_lineLinear, interpolateKey = interpolate.key, tension = .7;
        function line(data) {
            var segments = [], points = [], i = -1, n = data.length, d, fx = d3_functor(x), fy = d3_functor(y);
            function segment() {
                segments.push("M", interpolate(projection(points), tension));
            }
            while (++i < n) {
                if (defined.call(this, d = data[i], i)) {
                    points.push([ +fx.call(this, d, i), +fy.call(this, d, i) ]);
                } else if (points.length) {
                    segment();
                    points = [];
                }
            }
            if (points.length) segment();
            return segments.length ? segments.join("") : null;
        }
        line.x = function(_) {
            if (!arguments.length) return x;
            x = _;
            return line;
        };
        line.y = function(_) {
            if (!arguments.length) return y;
            y = _;
            return line;
        };
        line.defined = function(_) {
            if (!arguments.length) return defined;
            defined = _;
            return line;
        };
        line.interpolate = function(_) {
            if (!arguments.length) return interpolateKey;
            if (typeof _ === "function") interpolateKey = interpolate = _; else interpolateKey = (interpolate = d3_svg_lineInterpolators.get(_) || d3_svg_lineLinear).key;
            return line;
        };
        line.tension = function(_) {
            if (!arguments.length) return tension;
            tension = _;
            return line;
        };
        return line;
    }
    d3.svg.line = function() {
        return d3_svg_line(d3_identity);
    };
    var d3_svg_lineInterpolators = d3.map({
        linear: d3_svg_lineLinear,
        "linear-closed": d3_svg_lineLinearClosed,
        step: d3_svg_lineStep,
        "step-before": d3_svg_lineStepBefore,
        "step-after": d3_svg_lineStepAfter,
        basis: d3_svg_lineBasis,
        "basis-open": d3_svg_lineBasisOpen,
        "basis-closed": d3_svg_lineBasisClosed,
        bundle: d3_svg_lineBundle,
        cardinal: d3_svg_lineCardinal,
        "cardinal-open": d3_svg_lineCardinalOpen,
        "cardinal-closed": d3_svg_lineCardinalClosed,
        monotone: d3_svg_lineMonotone
    });
    d3_svg_lineInterpolators.forEach(function(key, value) {
        value.key = key;
        value.closed = /-closed$/.test(key);
    });
    function d3_svg_lineLinear(points) {
        return points.join("L");
    }
    function d3_svg_lineLinearClosed(points) {
        return d3_svg_lineLinear(points) + "Z";
    }
    function d3_svg_lineStep(points) {
        var i = 0, n = points.length, p = points[0], path = [ p[0], ",", p[1] ];
        while (++i < n) path.push("H", (p[0] + (p = points[i])[0]) / 2, "V", p[1]);
        if (n > 1) path.push("H", p[0]);
        return path.join("");
    }
    function d3_svg_lineStepBefore(points) {
        var i = 0, n = points.length, p = points[0], path = [ p[0], ",", p[1] ];
        while (++i < n) path.push("V", (p = points[i])[1], "H", p[0]);
        return path.join("");
    }
    function d3_svg_lineStepAfter(points) {
        var i = 0, n = points.length, p = points[0], path = [ p[0], ",", p[1] ];
        while (++i < n) path.push("H", (p = points[i])[0], "V", p[1]);
        return path.join("");
    }
    function d3_svg_lineCardinalOpen(points, tension) {
        return points.length < 4 ? d3_svg_lineLinear(points) : points[1] + d3_svg_lineHermite(points.slice(1, -1), d3_svg_lineCardinalTangents(points, tension));
    }
    function d3_svg_lineCardinalClosed(points, tension) {
        return points.length < 3 ? d3_svg_lineLinear(points) : points[0] + d3_svg_lineHermite((points.push(points[0]),
            points), d3_svg_lineCardinalTangents([ points[points.length - 2] ].concat(points, [ points[1] ]), tension));
    }
    function d3_svg_lineCardinal(points, tension) {
        return points.length < 3 ? d3_svg_lineLinear(points) : points[0] + d3_svg_lineHermite(points, d3_svg_lineCardinalTangents(points, tension));
    }
    function d3_svg_lineHermite(points, tangents) {
        if (tangents.length < 1 || points.length != tangents.length && points.length != tangents.length + 2) {
            return d3_svg_lineLinear(points);
        }
        var quad = points.length != tangents.length, path = "", p0 = points[0], p = points[1], t0 = tangents[0], t = t0, pi = 1;
        if (quad) {
            path += "Q" + (p[0] - t0[0] * 2 / 3) + "," + (p[1] - t0[1] * 2 / 3) + "," + p[0] + "," + p[1];
            p0 = points[1];
            pi = 2;
        }
        if (tangents.length > 1) {
            t = tangents[1];
            p = points[pi];
            pi++;
            path += "C" + (p0[0] + t0[0]) + "," + (p0[1] + t0[1]) + "," + (p[0] - t[0]) + "," + (p[1] - t[1]) + "," + p[0] + "," + p[1];
            for (var i = 2; i < tangents.length; i++, pi++) {
                p = points[pi];
                t = tangents[i];
                path += "S" + (p[0] - t[0]) + "," + (p[1] - t[1]) + "," + p[0] + "," + p[1];
            }
        }
        if (quad) {
            var lp = points[pi];
            path += "Q" + (p[0] + t[0] * 2 / 3) + "," + (p[1] + t[1] * 2 / 3) + "," + lp[0] + "," + lp[1];
        }
        return path;
    }
    function d3_svg_lineCardinalTangents(points, tension) {
        var tangents = [], a = (1 - tension) / 2, p0, p1 = points[0], p2 = points[1], i = 1, n = points.length;
        while (++i < n) {
            p0 = p1;
            p1 = p2;
            p2 = points[i];
            tangents.push([ a * (p2[0] - p0[0]), a * (p2[1] - p0[1]) ]);
        }
        return tangents;
    }
    function d3_svg_lineBasis(points) {
        if (points.length < 3) return d3_svg_lineLinear(points);
        var i = 1, n = points.length, pi = points[0], x0 = pi[0], y0 = pi[1], px = [ x0, x0, x0, (pi = points[1])[0] ], py = [ y0, y0, y0, pi[1] ], path = [ x0, ",", y0, "L", d3_svg_lineDot4(d3_svg_lineBasisBezier3, px), ",", d3_svg_lineDot4(d3_svg_lineBasisBezier3, py) ];
        points.push(points[n - 1]);
        while (++i <= n) {
            pi = points[i];
            px.shift();
            px.push(pi[0]);
            py.shift();
            py.push(pi[1]);
            d3_svg_lineBasisBezier(path, px, py);
        }
        points.pop();
        path.push("L", pi);
        return path.join("");
    }
    function d3_svg_lineBasisOpen(points) {
        if (points.length < 4) return d3_svg_lineLinear(points);
        var path = [], i = -1, n = points.length, pi, px = [ 0 ], py = [ 0 ];
        while (++i < 3) {
            pi = points[i];
            px.push(pi[0]);
            py.push(pi[1]);
        }
        path.push(d3_svg_lineDot4(d3_svg_lineBasisBezier3, px) + "," + d3_svg_lineDot4(d3_svg_lineBasisBezier3, py));
        --i;
        while (++i < n) {
            pi = points[i];
            px.shift();
            px.push(pi[0]);
            py.shift();
            py.push(pi[1]);
            d3_svg_lineBasisBezier(path, px, py);
        }
        return path.join("");
    }
    function d3_svg_lineBasisClosed(points) {
        var path, i = -1, n = points.length, m = n + 4, pi, px = [], py = [];
        while (++i < 4) {
            pi = points[i % n];
            px.push(pi[0]);
            py.push(pi[1]);
        }
        path = [ d3_svg_lineDot4(d3_svg_lineBasisBezier3, px), ",", d3_svg_lineDot4(d3_svg_lineBasisBezier3, py) ];
        --i;
        while (++i < m) {
            pi = points[i % n];
            px.shift();
            px.push(pi[0]);
            py.shift();
            py.push(pi[1]);
            d3_svg_lineBasisBezier(path, px, py);
        }
        return path.join("");
    }
    function d3_svg_lineBundle(points, tension) {
        var n = points.length - 1;
        if (n) {
            var x0 = points[0][0], y0 = points[0][1], dx = points[n][0] - x0, dy = points[n][1] - y0, i = -1, p, t;
            while (++i <= n) {
                p = points[i];
                t = i / n;
                p[0] = tension * p[0] + (1 - tension) * (x0 + t * dx);
                p[1] = tension * p[1] + (1 - tension) * (y0 + t * dy);
            }
        }
        return d3_svg_lineBasis(points);
    }
    function d3_svg_lineDot4(a, b) {
        return a[0] * b[0] + a[1] * b[1] + a[2] * b[2] + a[3] * b[3];
    }
    var d3_svg_lineBasisBezier1 = [ 0, 2 / 3, 1 / 3, 0 ], d3_svg_lineBasisBezier2 = [ 0, 1 / 3, 2 / 3, 0 ], d3_svg_lineBasisBezier3 = [ 0, 1 / 6, 2 / 3, 1 / 6 ];
    function d3_svg_lineBasisBezier(path, x, y) {
        path.push("C", d3_svg_lineDot4(d3_svg_lineBasisBezier1, x), ",", d3_svg_lineDot4(d3_svg_lineBasisBezier1, y), ",", d3_svg_lineDot4(d3_svg_lineBasisBezier2, x), ",", d3_svg_lineDot4(d3_svg_lineBasisBezier2, y), ",", d3_svg_lineDot4(d3_svg_lineBasisBezier3, x), ",", d3_svg_lineDot4(d3_svg_lineBasisBezier3, y));
    }
    function d3_svg_lineSlope(p0, p1) {
        return (p1[1] - p0[1]) / (p1[0] - p0[0]);
    }
    function d3_svg_lineFiniteDifferences(points) {
        var i = 0, j = points.length - 1, m = [], p0 = points[0], p1 = points[1], d = m[0] = d3_svg_lineSlope(p0, p1);
        while (++i < j) {
            m[i] = (d + (d = d3_svg_lineSlope(p0 = p1, p1 = points[i + 1]))) / 2;
        }
        m[i] = d;
        return m;
    }
    function d3_svg_lineMonotoneTangents(points) {
        var tangents = [], d, a, b, s, m = d3_svg_lineFiniteDifferences(points), i = -1, j = points.length - 1;
        while (++i < j) {
            d = d3_svg_lineSlope(points[i], points[i + 1]);
            if (abs(d) < ε) {
                m[i] = m[i + 1] = 0;
            } else {
                a = m[i] / d;
                b = m[i + 1] / d;
                s = a * a + b * b;
                if (s > 9) {
                    s = d * 3 / Math.sqrt(s);
                    m[i] = s * a;
                    m[i + 1] = s * b;
                }
            }
        }
        i = -1;
        while (++i <= j) {
            s = (points[Math.min(j, i + 1)][0] - points[Math.max(0, i - 1)][0]) / (6 * (1 + m[i] * m[i]));
            tangents.push([ s || 0, m[i] * s || 0 ]);
        }
        return tangents;
    }
    function d3_svg_lineMonotone(points) {
        return points.length < 3 ? d3_svg_lineLinear(points) : points[0] + d3_svg_lineHermite(points, d3_svg_lineMonotoneTangents(points));
    }
    d3.svg.line.radial = function() {
        var line = d3_svg_line(d3_svg_lineRadial);
        line.radius = line.x, delete line.x;
        line.angle = line.y, delete line.y;
        return line;
    };
    function d3_svg_lineRadial(points) {
        var point, i = -1, n = points.length, r, a;
        while (++i < n) {
            point = points[i];
            r = point[0];
            a = point[1] - halfπ;
            point[0] = r * Math.cos(a);
            point[1] = r * Math.sin(a);
        }
        return points;
    }
    function d3_svg_area(projection) {
        var x0 = d3_geom_pointX, x1 = d3_geom_pointX, y0 = 0, y1 = d3_geom_pointY, defined = d3_true, interpolate = d3_svg_lineLinear, interpolateKey = interpolate.key, interpolateReverse = interpolate, L = "L", tension = .7;
        function area(data) {
            var segments = [], points0 = [], points1 = [], i = -1, n = data.length, d, fx0 = d3_functor(x0), fy0 = d3_functor(y0), fx1 = x0 === x1 ? function() {
                return x;
            } : d3_functor(x1), fy1 = y0 === y1 ? function() {
                return y;
            } : d3_functor(y1), x, y;
            function segment() {
                segments.push("M", interpolate(projection(points1), tension), L, interpolateReverse(projection(points0.reverse()), tension), "Z");
            }
            while (++i < n) {
                if (defined.call(this, d = data[i], i)) {
                    points0.push([ x = +fx0.call(this, d, i), y = +fy0.call(this, d, i) ]);
                    points1.push([ +fx1.call(this, d, i), +fy1.call(this, d, i) ]);
                } else if (points0.length) {
                    segment();
                    points0 = [];
                    points1 = [];
                }
            }
            if (points0.length) segment();
            return segments.length ? segments.join("") : null;
        }
        area.x = function(_) {
            if (!arguments.length) return x1;
            x0 = x1 = _;
            return area;
        };
        area.x0 = function(_) {
            if (!arguments.length) return x0;
            x0 = _;
            return area;
        };
        area.x1 = function(_) {
            if (!arguments.length) return x1;
            x1 = _;
            return area;
        };
        area.y = function(_) {
            if (!arguments.length) return y1;
            y0 = y1 = _;
            return area;
        };
        area.y0 = function(_) {
            if (!arguments.length) return y0;
            y0 = _;
            return area;
        };
        area.y1 = function(_) {
            if (!arguments.length) return y1;
            y1 = _;
            return area;
        };
        area.defined = function(_) {
            if (!arguments.length) return defined;
            defined = _;
            return area;
        };
        area.interpolate = function(_) {
            if (!arguments.length) return interpolateKey;
            if (typeof _ === "function") interpolateKey = interpolate = _; else interpolateKey = (interpolate = d3_svg_lineInterpolators.get(_) || d3_svg_lineLinear).key;
            interpolateReverse = interpolate.reverse || interpolate;
            L = interpolate.closed ? "M" : "L";
            return area;
        };
        area.tension = function(_) {
            if (!arguments.length) return tension;
            tension = _;
            return area;
        };
        return area;
    }
    d3_svg_lineStepBefore.reverse = d3_svg_lineStepAfter;
    d3_svg_lineStepAfter.reverse = d3_svg_lineStepBefore;
    d3.svg.area = function() {
        return d3_svg_area(d3_identity);
    };
    d3.svg.area.radial = function() {
        var area = d3_svg_area(d3_svg_lineRadial);
        area.radius = area.x, delete area.x;
        area.innerRadius = area.x0, delete area.x0;
        area.outerRadius = area.x1, delete area.x1;
        area.angle = area.y, delete area.y;
        area.startAngle = area.y0, delete area.y0;
        area.endAngle = area.y1, delete area.y1;
        return area;
    };
    d3.svg.chord = function() {
        var source = d3_source, target = d3_target, radius = d3_svg_chordRadius, startAngle = d3_svg_arcStartAngle, endAngle = d3_svg_arcEndAngle;
        function chord(d, i) {
            var s = subgroup(this, source, d, i), t = subgroup(this, target, d, i);
            return "M" + s.p0 + arc(s.r, s.p1, s.a1 - s.a0) + (equals(s, t) ? curve(s.r, s.p1, s.r, s.p0) : curve(s.r, s.p1, t.r, t.p0) + arc(t.r, t.p1, t.a1 - t.a0) + curve(t.r, t.p1, s.r, s.p0)) + "Z";
        }
        function subgroup(self, f, d, i) {
            var subgroup = f.call(self, d, i), r = radius.call(self, subgroup, i), a0 = startAngle.call(self, subgroup, i) - halfπ, a1 = endAngle.call(self, subgroup, i) - halfπ;
            return {
                r: r,
                a0: a0,
                a1: a1,
                p0: [ r * Math.cos(a0), r * Math.sin(a0) ],
                p1: [ r * Math.cos(a1), r * Math.sin(a1) ]
            };
        }
        function equals(a, b) {
            return a.a0 == b.a0 && a.a1 == b.a1;
        }
        function arc(r, p, a) {
            return "A" + r + "," + r + " 0 " + +(a > π) + ",1 " + p;
        }
        function curve(r0, p0, r1, p1) {
            return "Q 0,0 " + p1;
        }
        chord.radius = function(v) {
            if (!arguments.length) return radius;
            radius = d3_functor(v);
            return chord;
        };
        chord.source = function(v) {
            if (!arguments.length) return source;
            source = d3_functor(v);
            return chord;
        };
        chord.target = function(v) {
            if (!arguments.length) return target;
            target = d3_functor(v);
            return chord;
        };
        chord.startAngle = function(v) {
            if (!arguments.length) return startAngle;
            startAngle = d3_functor(v);
            return chord;
        };
        chord.endAngle = function(v) {
            if (!arguments.length) return endAngle;
            endAngle = d3_functor(v);
            return chord;
        };
        return chord;
    };
    function d3_svg_chordRadius(d) {
        return d.radius;
    }
    d3.svg.diagonal = function() {
        var source = d3_source, target = d3_target, projection = d3_svg_diagonalProjection;
        function diagonal(d, i) {
            var p0 = source.call(this, d, i), p3 = target.call(this, d, i), m = (p0.y + p3.y) / 2, p = [ p0, {
                x: p0.x,
                y: m
            }, {
                x: p3.x,
                y: m
            }, p3 ];
            p = p.map(projection);
            return "M" + p[0] + "C" + p[1] + " " + p[2] + " " + p[3];
        }
        diagonal.source = function(x) {
            if (!arguments.length) return source;
            source = d3_functor(x);
            return diagonal;
        };
        diagonal.target = function(x) {
            if (!arguments.length) return target;
            target = d3_functor(x);
            return diagonal;
        };
        diagonal.projection = function(x) {
            if (!arguments.length) return projection;
            projection = x;
            return diagonal;
        };
        return diagonal;
    };
    function d3_svg_diagonalProjection(d) {
        return [ d.x, d.y ];
    }
    d3.svg.diagonal.radial = function() {
        var diagonal = d3.svg.diagonal(), projection = d3_svg_diagonalProjection, projection_ = diagonal.projection;
        diagonal.projection = function(x) {
            return arguments.length ? projection_(d3_svg_diagonalRadialProjection(projection = x)) : projection;
        };
        return diagonal;
    };
    function d3_svg_diagonalRadialProjection(projection) {
        return function() {
            var d = projection.apply(this, arguments), r = d[0], a = d[1] - halfπ;
            return [ r * Math.cos(a), r * Math.sin(a) ];
        };
    }
    d3.svg.symbol = function() {
        var type = d3_svg_symbolType, size = d3_svg_symbolSize;
        function symbol(d, i) {
            return (d3_svg_symbols.get(type.call(this, d, i)) || d3_svg_symbolCircle)(size.call(this, d, i));
        }
        symbol.type = function(x) {
            if (!arguments.length) return type;
            type = d3_functor(x);
            return symbol;
        };
        symbol.size = function(x) {
            if (!arguments.length) return size;
            size = d3_functor(x);
            return symbol;
        };
        return symbol;
    };
    function d3_svg_symbolSize() {
        return 64;
    }
    function d3_svg_symbolType() {
        return "circle";
    }
    function d3_svg_symbolCircle(size) {
        var r = Math.sqrt(size / π);
        return "M0," + r + "A" + r + "," + r + " 0 1,1 0," + -r + "A" + r + "," + r + " 0 1,1 0," + r + "Z";
    }
    var d3_svg_symbols = d3.map({
        circle: d3_svg_symbolCircle,
        cross: function(size) {
            var r = Math.sqrt(size / 5) / 2;
            return "M" + -3 * r + "," + -r + "H" + -r + "V" + -3 * r + "H" + r + "V" + -r + "H" + 3 * r + "V" + r + "H" + r + "V" + 3 * r + "H" + -r + "V" + r + "H" + -3 * r + "Z";
        },
        diamond: function(size) {
            var ry = Math.sqrt(size / (2 * d3_svg_symbolTan30)), rx = ry * d3_svg_symbolTan30;
            return "M0," + -ry + "L" + rx + ",0" + " 0," + ry + " " + -rx + ",0" + "Z";
        },
        square: function(size) {
            var r = Math.sqrt(size) / 2;
            return "M" + -r + "," + -r + "L" + r + "," + -r + " " + r + "," + r + " " + -r + "," + r + "Z";
        },
        "triangle-down": function(size) {
            var rx = Math.sqrt(size / d3_svg_symbolSqrt3), ry = rx * d3_svg_symbolSqrt3 / 2;
            return "M0," + ry + "L" + rx + "," + -ry + " " + -rx + "," + -ry + "Z";
        },
        "triangle-up": function(size) {
            var rx = Math.sqrt(size / d3_svg_symbolSqrt3), ry = rx * d3_svg_symbolSqrt3 / 2;
            return "M0," + -ry + "L" + rx + "," + ry + " " + -rx + "," + ry + "Z";
        }
    });
    d3.svg.symbolTypes = d3_svg_symbols.keys();
    var d3_svg_symbolSqrt3 = Math.sqrt(3), d3_svg_symbolTan30 = Math.tan(30 * d3_radians);
    d3_selectionPrototype.transition = function(name) {
        var id = d3_transitionInheritId || ++d3_transitionId, ns = d3_transitionNamespace(name), subgroups = [], subgroup, node, transition = d3_transitionInherit || {
                time: Date.now(),
                ease: d3_ease_cubicInOut,
                delay: 0,
                duration: 250
            };
        for (var j = -1, m = this.length; ++j < m; ) {
            subgroups.push(subgroup = []);
            for (var group = this[j], i = -1, n = group.length; ++i < n; ) {
                if (node = group[i]) d3_transitionNode(node, i, ns, id, transition);
                subgroup.push(node);
            }
        }
        return d3_transition(subgroups, ns, id);
    };
    d3_selectionPrototype.interrupt = function(name) {
        return this.each(name == null ? d3_selection_interrupt : d3_selection_interruptNS(d3_transitionNamespace(name)));
    };
    var d3_selection_interrupt = d3_selection_interruptNS(d3_transitionNamespace());
    function d3_selection_interruptNS(ns) {
        return function() {
            var lock, active;
            if ((lock = this[ns]) && (active = lock[lock.active])) {
                if (--lock.count) delete lock[lock.active]; else delete this[ns];
                lock.active += .5;
                active.event && active.event.interrupt.call(this, this.__data__, active.index);
            }
        };
    }
    function d3_transition(groups, ns, id) {
        d3_subclass(groups, d3_transitionPrototype);
        groups.namespace = ns;
        groups.id = id;
        return groups;
    }
    var d3_transitionPrototype = [], d3_transitionId = 0, d3_transitionInheritId, d3_transitionInherit;
    d3_transitionPrototype.call = d3_selectionPrototype.call;
    d3_transitionPrototype.empty = d3_selectionPrototype.empty;
    d3_transitionPrototype.node = d3_selectionPrototype.node;
    d3_transitionPrototype.size = d3_selectionPrototype.size;
    d3.transition = function(selection, name) {
        return selection && selection.transition ? d3_transitionInheritId ? selection.transition(name) : selection : d3.selection().transition(selection);
    };
    d3.transition.prototype = d3_transitionPrototype;
    d3_transitionPrototype.select = function(selector) {
        var id = this.id, ns = this.namespace, subgroups = [], subgroup, subnode, node;
        selector = d3_selection_selector(selector);
        for (var j = -1, m = this.length; ++j < m; ) {
            subgroups.push(subgroup = []);
            for (var group = this[j], i = -1, n = group.length; ++i < n; ) {
                if ((node = group[i]) && (subnode = selector.call(node, node.__data__, i, j))) {
                    if ("__data__" in node) subnode.__data__ = node.__data__;
                    d3_transitionNode(subnode, i, ns, id, node[ns][id]);
                    subgroup.push(subnode);
                } else {
                    subgroup.push(null);
                }
            }
        }
        return d3_transition(subgroups, ns, id);
    };
    d3_transitionPrototype.selectAll = function(selector) {
        var id = this.id, ns = this.namespace, subgroups = [], subgroup, subnodes, node, subnode, transition;
        selector = d3_selection_selectorAll(selector);
        for (var j = -1, m = this.length; ++j < m; ) {
            for (var group = this[j], i = -1, n = group.length; ++i < n; ) {
                if (node = group[i]) {
                    transition = node[ns][id];
                    subnodes = selector.call(node, node.__data__, i, j);
                    subgroups.push(subgroup = []);
                    for (var k = -1, o = subnodes.length; ++k < o; ) {
                        if (subnode = subnodes[k]) d3_transitionNode(subnode, k, ns, id, transition);
                        subgroup.push(subnode);
                    }
                }
            }
        }
        return d3_transition(subgroups, ns, id);
    };
    d3_transitionPrototype.filter = function(filter) {
        var subgroups = [], subgroup, group, node;
        if (typeof filter !== "function") filter = d3_selection_filter(filter);
        for (var j = 0, m = this.length; j < m; j++) {
            subgroups.push(subgroup = []);
            for (var group = this[j], i = 0, n = group.length; i < n; i++) {
                if ((node = group[i]) && filter.call(node, node.__data__, i, j)) {
                    subgroup.push(node);
                }
            }
        }
        return d3_transition(subgroups, this.namespace, this.id);
    };
    d3_transitionPrototype.tween = function(name, tween) {
        var id = this.id, ns = this.namespace;
        if (arguments.length < 2) return this.node()[ns][id].tween.get(name);
        return d3_selection_each(this, tween == null ? function(node) {
            node[ns][id].tween.remove(name);
        } : function(node) {
            node[ns][id].tween.set(name, tween);
        });
    };
    function d3_transition_tween(groups, name, value, tween) {
        var id = groups.id, ns = groups.namespace;
        return d3_selection_each(groups, typeof value === "function" ? function(node, i, j) {
            node[ns][id].tween.set(name, tween(value.call(node, node.__data__, i, j)));
        } : (value = tween(value), function(node) {
            node[ns][id].tween.set(name, value);
        }));
    }
    d3_transitionPrototype.attr = function(nameNS, value) {
        if (arguments.length < 2) {
            for (value in nameNS) this.attr(value, nameNS[value]);
            return this;
        }
        var interpolate = nameNS == "transform" ? d3_interpolateTransform : d3_interpolate, name = d3.ns.qualify(nameNS);
        function attrNull() {
            this.removeAttribute(name);
        }
        function attrNullNS() {
            this.removeAttributeNS(name.space, name.local);
        }
        function attrTween(b) {
            return b == null ? attrNull : (b += "", function() {
                var a = this.getAttribute(name), i;
                return a !== b && (i = interpolate(a, b), function(t) {
                        this.setAttribute(name, i(t));
                    });
            });
        }
        function attrTweenNS(b) {
            return b == null ? attrNullNS : (b += "", function() {
                var a = this.getAttributeNS(name.space, name.local), i;
                return a !== b && (i = interpolate(a, b), function(t) {
                        this.setAttributeNS(name.space, name.local, i(t));
                    });
            });
        }
        return d3_transition_tween(this, "attr." + nameNS, value, name.local ? attrTweenNS : attrTween);
    };
    d3_transitionPrototype.attrTween = function(nameNS, tween) {
        var name = d3.ns.qualify(nameNS);
        function attrTween(d, i) {
            var f = tween.call(this, d, i, this.getAttribute(name));
            return f && function(t) {
                    this.setAttribute(name, f(t));
                };
        }
        function attrTweenNS(d, i) {
            var f = tween.call(this, d, i, this.getAttributeNS(name.space, name.local));
            return f && function(t) {
                    this.setAttributeNS(name.space, name.local, f(t));
                };
        }
        return this.tween("attr." + nameNS, name.local ? attrTweenNS : attrTween);
    };
    d3_transitionPrototype.style = function(name, value, priority) {
        var n = arguments.length;
        if (n < 3) {
            if (typeof name !== "string") {
                if (n < 2) value = "";
                for (priority in name) this.style(priority, name[priority], value);
                return this;
            }
            priority = "";
        }
        function styleNull() {
            this.style.removeProperty(name);
        }
        function styleString(b) {
            return b == null ? styleNull : (b += "", function() {
                var a = d3_window(this).getComputedStyle(this, null).getPropertyValue(name), i;
                return a !== b && (i = d3_interpolate(a, b), function(t) {
                        this.style.setProperty(name, i(t), priority);
                    });
            });
        }
        return d3_transition_tween(this, "style." + name, value, styleString);
    };
    d3_transitionPrototype.styleTween = function(name, tween, priority) {
        if (arguments.length < 3) priority = "";
        function styleTween(d, i) {
            var f = tween.call(this, d, i, d3_window(this).getComputedStyle(this, null).getPropertyValue(name));
            return f && function(t) {
                    this.style.setProperty(name, f(t), priority);
                };
        }
        return this.tween("style." + name, styleTween);
    };
    d3_transitionPrototype.text = function(value) {
        return d3_transition_tween(this, "text", value, d3_transition_text);
    };
    function d3_transition_text(b) {
        if (b == null) b = "";
        return function() {
            this.textContent = b;
        };
    }
    d3_transitionPrototype.remove = function() {
        var ns = this.namespace;
        return this.each("end.transition", function() {
            var p;
            if (this[ns].count < 2 && (p = this.parentNode)) p.removeChild(this);
        });
    };
    d3_transitionPrototype.ease = function(value) {
        var id = this.id, ns = this.namespace;
        if (arguments.length < 1) return this.node()[ns][id].ease;
        if (typeof value !== "function") value = d3.ease.apply(d3, arguments);
        return d3_selection_each(this, function(node) {
            node[ns][id].ease = value;
        });
    };
    d3_transitionPrototype.delay = function(value) {
        var id = this.id, ns = this.namespace;
        if (arguments.length < 1) return this.node()[ns][id].delay;
        return d3_selection_each(this, typeof value === "function" ? function(node, i, j) {
            node[ns][id].delay = +value.call(node, node.__data__, i, j);
        } : (value = +value, function(node) {
            node[ns][id].delay = value;
        }));
    };
    d3_transitionPrototype.duration = function(value) {
        var id = this.id, ns = this.namespace;
        if (arguments.length < 1) return this.node()[ns][id].duration;
        return d3_selection_each(this, typeof value === "function" ? function(node, i, j) {
            node[ns][id].duration = Math.max(1, value.call(node, node.__data__, i, j));
        } : (value = Math.max(1, value), function(node) {
            node[ns][id].duration = value;
        }));
    };
    d3_transitionPrototype.each = function(type, listener) {
        var id = this.id, ns = this.namespace;
        if (arguments.length < 2) {
            var inherit = d3_transitionInherit, inheritId = d3_transitionInheritId;
            try {
                d3_transitionInheritId = id;
                d3_selection_each(this, function(node, i, j) {
                    d3_transitionInherit = node[ns][id];
                    type.call(node, node.__data__, i, j);
                });
            } finally {
                d3_transitionInherit = inherit;
                d3_transitionInheritId = inheritId;
            }
        } else {
            d3_selection_each(this, function(node) {
                var transition = node[ns][id];
                (transition.event || (transition.event = d3.dispatch("start", "end", "interrupt"))).on(type, listener);
            });
        }
        return this;
    };
    d3_transitionPrototype.transition = function() {
        var id0 = this.id, id1 = ++d3_transitionId, ns = this.namespace, subgroups = [], subgroup, group, node, transition;
        for (var j = 0, m = this.length; j < m; j++) {
            subgroups.push(subgroup = []);
            for (var group = this[j], i = 0, n = group.length; i < n; i++) {
                if (node = group[i]) {
                    transition = node[ns][id0];
                    d3_transitionNode(node, i, ns, id1, {
                        time: transition.time,
                        ease: transition.ease,
                        delay: transition.delay + transition.duration,
                        duration: transition.duration
                    });
                }
                subgroup.push(node);
            }
        }
        return d3_transition(subgroups, ns, id1);
    };
    function d3_transitionNamespace(name) {
        return name == null ? "__transition__" : "__transition_" + name + "__";
    }
    function d3_transitionNode(node, i, ns, id, inherit) {
        var lock = node[ns] || (node[ns] = {
                active: 0,
                count: 0
            }), transition = lock[id];
        if (!transition) {
            var time = inherit.time;
            transition = lock[id] = {
                tween: new d3_Map(),
                time: time,
                delay: inherit.delay,
                duration: inherit.duration,
                ease: inherit.ease,
                index: i
            };
            inherit = null;
            ++lock.count;
            d3.timer(function(elapsed) {
                var delay = transition.delay, duration, ease, timer = d3_timer_active, tweened = [];
                timer.t = delay + time;
                if (delay <= elapsed) return start(elapsed - delay);
                timer.c = start;
                function start(elapsed) {
                    if (lock.active > id) return stop();
                    var active = lock[lock.active];
                    if (active) {
                        --lock.count;
                        delete lock[lock.active];
                        active.event && active.event.interrupt.call(node, node.__data__, active.index);
                    }
                    lock.active = id;
                    transition.event && transition.event.start.call(node, node.__data__, i);
                    transition.tween.forEach(function(key, value) {
                        if (value = value.call(node, node.__data__, i)) {
                            tweened.push(value);
                        }
                    });
                    ease = transition.ease;
                    duration = transition.duration;
                    d3.timer(function() {
                        timer.c = tick(elapsed || 1) ? d3_true : tick;
                        return 1;
                    }, 0, time);
                }
                function tick(elapsed) {
                    if (lock.active !== id) return 1;
                    var t = elapsed / duration, e = ease(t), n = tweened.length;
                    while (n > 0) {
                        tweened[--n].call(node, e);
                    }
                    if (t >= 1) {
                        transition.event && transition.event.end.call(node, node.__data__, i);
                        return stop();
                    }
                }
                function stop() {
                    if (--lock.count) delete lock[id]; else delete node[ns];
                    return 1;
                }
            }, 0, time);
        }
    }
    d3.svg.axis = function() {
        var scale = d3.scale.linear(), orient = d3_svg_axisDefaultOrient, innerTickSize = 6, outerTickSize = 6, tickPadding = 3, tickArguments_ = [ 10 ], tickValues = null, tickFormat_;
        function axis(g) {
            g.each(function() {
                var g = d3.select(this);
                var scale0 = this.__chart__ || scale, scale1 = this.__chart__ = scale.copy();
                var ticks = tickValues == null ? scale1.ticks ? scale1.ticks.apply(scale1, tickArguments_) : scale1.domain() : tickValues, tickFormat = tickFormat_ == null ? scale1.tickFormat ? scale1.tickFormat.apply(scale1, tickArguments_) : d3_identity : tickFormat_, tick = g.selectAll(".tick").data(ticks, scale1), tickEnter = tick.enter().insert("g", ".domain").attr("class", "tick").style("opacity", ε), tickExit = d3.transition(tick.exit()).style("opacity", ε).remove(), tickUpdate = d3.transition(tick.order()).style("opacity", 1), tickSpacing = Math.max(innerTickSize, 0) + tickPadding, tickTransform;
                var range = d3_scaleRange(scale1), path = g.selectAll(".domain").data([ 0 ]), pathUpdate = (path.enter().append("path").attr("class", "domain"),
                    d3.transition(path));
                tickEnter.append("line");
                tickEnter.append("text");
                var lineEnter = tickEnter.select("line"), lineUpdate = tickUpdate.select("line"), text = tick.select("text").text(tickFormat), textEnter = tickEnter.select("text"), textUpdate = tickUpdate.select("text"), sign = orient === "top" || orient === "left" ? -1 : 1, x1, x2, y1, y2;
                if (orient === "bottom" || orient === "top") {
                    tickTransform = d3_svg_axisX, x1 = "x", y1 = "y", x2 = "x2", y2 = "y2";
                    text.attr("dy", sign < 0 ? "0em" : ".71em").style("text-anchor", "middle");
                    pathUpdate.attr("d", "M" + range[0] + "," + sign * outerTickSize + "V0H" + range[1] + "V" + sign * outerTickSize);
                } else {
                    tickTransform = d3_svg_axisY, x1 = "y", y1 = "x", x2 = "y2", y2 = "x2";
                    text.attr("dy", ".32em").style("text-anchor", sign < 0 ? "end" : "start");
                    pathUpdate.attr("d", "M" + sign * outerTickSize + "," + range[0] + "H0V" + range[1] + "H" + sign * outerTickSize);
                }
                lineEnter.attr(y2, sign * innerTickSize);
                textEnter.attr(y1, sign * tickSpacing);
                lineUpdate.attr(x2, 0).attr(y2, sign * innerTickSize);
                textUpdate.attr(x1, 0).attr(y1, sign * tickSpacing);
                if (scale1.rangeBand) {
                    var x = scale1, dx = x.rangeBand() / 2;
                    scale0 = scale1 = function(d) {
                        return x(d) + dx;
                    };
                } else if (scale0.rangeBand) {
                    scale0 = scale1;
                } else {
                    tickExit.call(tickTransform, scale1, scale0);
                }
                tickEnter.call(tickTransform, scale0, scale1);
                tickUpdate.call(tickTransform, scale1, scale1);
            });
        }
        axis.scale = function(x) {
            if (!arguments.length) return scale;
            scale = x;
            return axis;
        };
        axis.orient = function(x) {
            if (!arguments.length) return orient;
            orient = x in d3_svg_axisOrients ? x + "" : d3_svg_axisDefaultOrient;
            return axis;
        };
        axis.ticks = function() {
            if (!arguments.length) return tickArguments_;
            tickArguments_ = arguments;
            return axis;
        };
        axis.tickValues = function(x) {
            if (!arguments.length) return tickValues;
            tickValues = x;
            return axis;
        };
        axis.tickFormat = function(x) {
            if (!arguments.length) return tickFormat_;
            tickFormat_ = x;
            return axis;
        };
        axis.tickSize = function(x) {
            var n = arguments.length;
            if (!n) return innerTickSize;
            innerTickSize = +x;
            outerTickSize = +arguments[n - 1];
            return axis;
        };
        axis.innerTickSize = function(x) {
            if (!arguments.length) return innerTickSize;
            innerTickSize = +x;
            return axis;
        };
        axis.outerTickSize = function(x) {
            if (!arguments.length) return outerTickSize;
            outerTickSize = +x;
            return axis;
        };
        axis.tickPadding = function(x) {
            if (!arguments.length) return tickPadding;
            tickPadding = +x;
            return axis;
        };
        axis.tickSubdivide = function() {
            return arguments.length && axis;
        };
        return axis;
    };
    var d3_svg_axisDefaultOrient = "bottom", d3_svg_axisOrients = {
        top: 1,
        right: 1,
        bottom: 1,
        left: 1
    };
    function d3_svg_axisX(selection, x0, x1) {
        selection.attr("transform", function(d) {
            var v0 = x0(d);
            return "translate(" + (isFinite(v0) ? v0 : x1(d)) + ",0)";
        });
    }
    function d3_svg_axisY(selection, y0, y1) {
        selection.attr("transform", function(d) {
            var v0 = y0(d);
            return "translate(0," + (isFinite(v0) ? v0 : y1(d)) + ")";
        });
    }
    d3.svg.brush = function() {
        var event = d3_eventDispatch(brush, "brushstart", "brush", "brushend"), x = null, y = null, xExtent = [ 0, 0 ], yExtent = [ 0, 0 ], xExtentDomain, yExtentDomain, xClamp = true, yClamp = true, resizes = d3_svg_brushResizes[0];
        function brush(g) {
            g.each(function() {
                var g = d3.select(this).style("pointer-events", "all").style("-webkit-tap-highlight-color", "rgba(0,0,0,0)").on("mousedown.brush", brushstart).on("touchstart.brush", brushstart);
                var background = g.selectAll(".background").data([ 0 ]);
                background.enter().append("rect").attr("class", "background").style("visibility", "hidden").style("cursor", "crosshair");
                g.selectAll(".extent").data([ 0 ]).enter().append("rect").attr("class", "extent").style("cursor", "move");
                var resize = g.selectAll(".resize").data(resizes, d3_identity);
                resize.exit().remove();
                resize.enter().append("g").attr("class", function(d) {
                    return "resize " + d;
                }).style("cursor", function(d) {
                    return d3_svg_brushCursor[d];
                }).append("rect").attr("x", function(d) {
                    return /[ew]$/.test(d) ? -3 : null;
                }).attr("y", function(d) {
                    return /^[ns]/.test(d) ? -3 : null;
                }).attr("width", 6).attr("height", 6).style("visibility", "hidden");
                resize.style("display", brush.empty() ? "none" : null);
                var gUpdate = d3.transition(g), backgroundUpdate = d3.transition(background), range;
                if (x) {
                    range = d3_scaleRange(x);
                    backgroundUpdate.attr("x", range[0]).attr("width", range[1] - range[0]);
                    redrawX(gUpdate);
                }
                if (y) {
                    range = d3_scaleRange(y);
                    backgroundUpdate.attr("y", range[0]).attr("height", range[1] - range[0]);
                    redrawY(gUpdate);
                }
                redraw(gUpdate);
            });
        }
        brush.event = function(g) {
            g.each(function() {
                var event_ = event.of(this, arguments), extent1 = {
                    x: xExtent,
                    y: yExtent,
                    i: xExtentDomain,
                    j: yExtentDomain
                }, extent0 = this.__chart__ || extent1;
                this.__chart__ = extent1;
                if (d3_transitionInheritId) {
                    d3.select(this).transition().each("start.brush", function() {
                        xExtentDomain = extent0.i;
                        yExtentDomain = extent0.j;
                        xExtent = extent0.x;
                        yExtent = extent0.y;
                        event_({
                            type: "brushstart"
                        });
                    }).tween("brush:brush", function() {
                        var xi = d3_interpolateArray(xExtent, extent1.x), yi = d3_interpolateArray(yExtent, extent1.y);
                        xExtentDomain = yExtentDomain = null;
                        return function(t) {
                            xExtent = extent1.x = xi(t);
                            yExtent = extent1.y = yi(t);
                            event_({
                                type: "brush",
                                mode: "resize"
                            });
                        };
                    }).each("end.brush", function() {
                        xExtentDomain = extent1.i;
                        yExtentDomain = extent1.j;
                        event_({
                            type: "brush",
                            mode: "resize"
                        });
                        event_({
                            type: "brushend"
                        });
                    });
                } else {
                    event_({
                        type: "brushstart"
                    });
                    event_({
                        type: "brush",
                        mode: "resize"
                    });
                    event_({
                        type: "brushend"
                    });
                }
            });
        };
        function redraw(g) {
            g.selectAll(".resize").attr("transform", function(d) {
                return "translate(" + xExtent[+/e$/.test(d)] + "," + yExtent[+/^s/.test(d)] + ")";
            });
        }
        function redrawX(g) {
            g.select(".extent").attr("x", xExtent[0]);
            g.selectAll(".extent,.n>rect,.s>rect").attr("width", xExtent[1] - xExtent[0]);
        }
        function redrawY(g) {
            g.select(".extent").attr("y", yExtent[0]);
            g.selectAll(".extent,.e>rect,.w>rect").attr("height", yExtent[1] - yExtent[0]);
        }
        function brushstart() {
            var target = this, eventTarget = d3.select(d3.event.target), event_ = event.of(target, arguments), g = d3.select(target), resizing = eventTarget.datum(), resizingX = !/^(n|s)$/.test(resizing) && x, resizingY = !/^(e|w)$/.test(resizing) && y, dragging = eventTarget.classed("extent"), dragRestore = d3_event_dragSuppress(target), center, origin = d3.mouse(target), offset;
            var w = d3.select(d3_window(target)).on("keydown.brush", keydown).on("keyup.brush", keyup);
            if (d3.event.changedTouches) {
                w.on("touchmove.brush", brushmove).on("touchend.brush", brushend);
            } else {
                w.on("mousemove.brush", brushmove).on("mouseup.brush", brushend);
            }
            g.interrupt().selectAll("*").interrupt();
            if (dragging) {
                origin[0] = xExtent[0] - origin[0];
                origin[1] = yExtent[0] - origin[1];
            } else if (resizing) {
                var ex = +/w$/.test(resizing), ey = +/^n/.test(resizing);
                offset = [ xExtent[1 - ex] - origin[0], yExtent[1 - ey] - origin[1] ];
                origin[0] = xExtent[ex];
                origin[1] = yExtent[ey];
            } else if (d3.event.altKey) center = origin.slice();
            g.style("pointer-events", "none").selectAll(".resize").style("display", null);
            d3.select("body").style("cursor", eventTarget.style("cursor"));
            event_({
                type: "brushstart"
            });
            brushmove();
            function keydown() {
                if (d3.event.keyCode == 32) {
                    if (!dragging) {
                        center = null;
                        origin[0] -= xExtent[1];
                        origin[1] -= yExtent[1];
                        dragging = 2;
                    }
                    d3_eventPreventDefault();
                }
            }
            function keyup() {
                if (d3.event.keyCode == 32 && dragging == 2) {
                    origin[0] += xExtent[1];
                    origin[1] += yExtent[1];
                    dragging = 0;
                    d3_eventPreventDefault();
                }
            }
            function brushmove() {
                var point = d3.mouse(target), moved = false;
                if (offset) {
                    point[0] += offset[0];
                    point[1] += offset[1];
                }
                if (!dragging) {
                    if (d3.event.altKey) {
                        if (!center) center = [ (xExtent[0] + xExtent[1]) / 2, (yExtent[0] + yExtent[1]) / 2 ];
                        origin[0] = xExtent[+(point[0] < center[0])];
                        origin[1] = yExtent[+(point[1] < center[1])];
                    } else center = null;
                }
                if (resizingX && move1(point, x, 0)) {
                    redrawX(g);
                    moved = true;
                }
                if (resizingY && move1(point, y, 1)) {
                    redrawY(g);
                    moved = true;
                }
                if (moved) {
                    redraw(g);
                    event_({
                        type: "brush",
                        mode: dragging ? "move" : "resize"
                    });
                }
            }
            function move1(point, scale, i) {
                var range = d3_scaleRange(scale), r0 = range[0], r1 = range[1], position = origin[i], extent = i ? yExtent : xExtent, size = extent[1] - extent[0], min, max;
                if (dragging) {
                    r0 -= position;
                    r1 -= size + position;
                }
                min = (i ? yClamp : xClamp) ? Math.max(r0, Math.min(r1, point[i])) : point[i];
                if (dragging) {
                    max = (min += position) + size;
                } else {
                    if (center) position = Math.max(r0, Math.min(r1, 2 * center[i] - min));
                    if (position < min) {
                        max = min;
                        min = position;
                    } else {
                        max = position;
                    }
                }
                if (extent[0] != min || extent[1] != max) {
                    if (i) yExtentDomain = null; else xExtentDomain = null;
                    extent[0] = min;
                    extent[1] = max;
                    return true;
                }
            }
            function brushend() {
                brushmove();
                g.style("pointer-events", "all").selectAll(".resize").style("display", brush.empty() ? "none" : null);
                d3.select("body").style("cursor", null);
                w.on("mousemove.brush", null).on("mouseup.brush", null).on("touchmove.brush", null).on("touchend.brush", null).on("keydown.brush", null).on("keyup.brush", null);
                dragRestore();
                event_({
                    type: "brushend"
                });
            }
        }
        brush.x = function(z) {
            if (!arguments.length) return x;
            x = z;
            resizes = d3_svg_brushResizes[!x << 1 | !y];
            return brush;
        };
        brush.y = function(z) {
            if (!arguments.length) return y;
            y = z;
            resizes = d3_svg_brushResizes[!x << 1 | !y];
            return brush;
        };
        brush.clamp = function(z) {
            if (!arguments.length) return x && y ? [ xClamp, yClamp ] : x ? xClamp : y ? yClamp : null;
            if (x && y) xClamp = !!z[0], yClamp = !!z[1]; else if (x) xClamp = !!z; else if (y) yClamp = !!z;
            return brush;
        };
        brush.extent = function(z) {
            var x0, x1, y0, y1, t;
            if (!arguments.length) {
                if (x) {
                    if (xExtentDomain) {
                        x0 = xExtentDomain[0], x1 = xExtentDomain[1];
                    } else {
                        x0 = xExtent[0], x1 = xExtent[1];
                        if (x.invert) x0 = x.invert(x0), x1 = x.invert(x1);
                        if (x1 < x0) t = x0, x0 = x1, x1 = t;
                    }
                }
                if (y) {
                    if (yExtentDomain) {
                        y0 = yExtentDomain[0], y1 = yExtentDomain[1];
                    } else {
                        y0 = yExtent[0], y1 = yExtent[1];
                        if (y.invert) y0 = y.invert(y0), y1 = y.invert(y1);
                        if (y1 < y0) t = y0, y0 = y1, y1 = t;
                    }
                }
                return x && y ? [ [ x0, y0 ], [ x1, y1 ] ] : x ? [ x0, x1 ] : y && [ y0, y1 ];
            }
            if (x) {
                x0 = z[0], x1 = z[1];
                if (y) x0 = x0[0], x1 = x1[0];
                xExtentDomain = [ x0, x1 ];
                if (x.invert) x0 = x(x0), x1 = x(x1);
                if (x1 < x0) t = x0, x0 = x1, x1 = t;
                if (x0 != xExtent[0] || x1 != xExtent[1]) xExtent = [ x0, x1 ];
            }
            if (y) {
                y0 = z[0], y1 = z[1];
                if (x) y0 = y0[1], y1 = y1[1];
                yExtentDomain = [ y0, y1 ];
                if (y.invert) y0 = y(y0), y1 = y(y1);
                if (y1 < y0) t = y0, y0 = y1, y1 = t;
                if (y0 != yExtent[0] || y1 != yExtent[1]) yExtent = [ y0, y1 ];
            }
            return brush;
        };
        brush.clear = function() {
            if (!brush.empty()) {
                xExtent = [ 0, 0 ], yExtent = [ 0, 0 ];
                xExtentDomain = yExtentDomain = null;
            }
            return brush;
        };
        brush.empty = function() {
            return !!x && xExtent[0] == xExtent[1] || !!y && yExtent[0] == yExtent[1];
        };
        return d3.rebind(brush, event, "on");
    };
    var d3_svg_brushCursor = {
        n: "ns-resize",
        e: "ew-resize",
        s: "ns-resize",
        w: "ew-resize",
        nw: "nwse-resize",
        ne: "nesw-resize",
        se: "nwse-resize",
        sw: "nesw-resize"
    };
    var d3_svg_brushResizes = [ [ "n", "e", "s", "w", "nw", "ne", "se", "sw" ], [ "e", "w" ], [ "n", "s" ], [] ];
    var d3_time_format = d3_time.format = d3_locale_enUS.timeFormat;
    var d3_time_formatUtc = d3_time_format.utc;
    var d3_time_formatIso = d3_time_formatUtc("%Y-%m-%dT%H:%M:%S.%LZ");
    d3_time_format.iso = Date.prototype.toISOString && +new Date("2000-01-01T00:00:00.000Z") ? d3_time_formatIsoNative : d3_time_formatIso;
    function d3_time_formatIsoNative(date) {
        return date.toISOString();
    }
    d3_time_formatIsoNative.parse = function(string) {
        var date = new Date(string);
        return isNaN(date) ? null : date;
    };
    d3_time_formatIsoNative.toString = d3_time_formatIso.toString;
    d3_time.second = d3_time_interval(function(date) {
        return new d3_date(Math.floor(date / 1e3) * 1e3);
    }, function(date, offset) {
        date.setTime(date.getTime() + Math.floor(offset) * 1e3);
    }, function(date) {
        return date.getSeconds();
    });
    d3_time.seconds = d3_time.second.range;
    d3_time.seconds.utc = d3_time.second.utc.range;
    d3_time.minute = d3_time_interval(function(date) {
        return new d3_date(Math.floor(date / 6e4) * 6e4);
    }, function(date, offset) {
        date.setTime(date.getTime() + Math.floor(offset) * 6e4);
    }, function(date) {
        return date.getMinutes();
    });
    d3_time.minutes = d3_time.minute.range;
    d3_time.minutes.utc = d3_time.minute.utc.range;
    d3_time.hour = d3_time_interval(function(date) {
        var timezone = date.getTimezoneOffset() / 60;
        return new d3_date((Math.floor(date / 36e5 - timezone) + timezone) * 36e5);
    }, function(date, offset) {
        date.setTime(date.getTime() + Math.floor(offset) * 36e5);
    }, function(date) {
        return date.getHours();
    });
    d3_time.hours = d3_time.hour.range;
    d3_time.hours.utc = d3_time.hour.utc.range;
    d3_time.month = d3_time_interval(function(date) {
        date = d3_time.day(date);
        date.setDate(1);
        return date;
    }, function(date, offset) {
        date.setMonth(date.getMonth() + offset);
    }, function(date) {
        return date.getMonth();
    });
    d3_time.months = d3_time.month.range;
    d3_time.months.utc = d3_time.month.utc.range;
    function d3_time_scale(linear, methods, format) {
        function scale(x) {
            return linear(x);
        }
        scale.invert = function(x) {
            return d3_time_scaleDate(linear.invert(x));
        };
        scale.domain = function(x) {
            if (!arguments.length) return linear.domain().map(d3_time_scaleDate);
            linear.domain(x);
            return scale;
        };
        function tickMethod(extent, count) {
            var span = extent[1] - extent[0], target = span / count, i = d3.bisect(d3_time_scaleSteps, target);
            return i == d3_time_scaleSteps.length ? [ methods.year, d3_scale_linearTickRange(extent.map(function(d) {
                return d / 31536e6;
            }), count)[2] ] : !i ? [ d3_time_scaleMilliseconds, d3_scale_linearTickRange(extent, count)[2] ] : methods[target / d3_time_scaleSteps[i - 1] < d3_time_scaleSteps[i] / target ? i - 1 : i];
        }
        scale.nice = function(interval, skip) {
            var domain = scale.domain(), extent = d3_scaleExtent(domain), method = interval == null ? tickMethod(extent, 10) : typeof interval === "number" && tickMethod(extent, interval);
            if (method) interval = method[0], skip = method[1];
            function skipped(date) {
                return !isNaN(date) && !interval.range(date, d3_time_scaleDate(+date + 1), skip).length;
            }
            return scale.domain(d3_scale_nice(domain, skip > 1 ? {
                floor: function(date) {
                    while (skipped(date = interval.floor(date))) date = d3_time_scaleDate(date - 1);
                    return date;
                },
                ceil: function(date) {
                    while (skipped(date = interval.ceil(date))) date = d3_time_scaleDate(+date + 1);
                    return date;
                }
            } : interval));
        };
        scale.ticks = function(interval, skip) {
            var extent = d3_scaleExtent(scale.domain()), method = interval == null ? tickMethod(extent, 10) : typeof interval === "number" ? tickMethod(extent, interval) : !interval.range && [ {
                range: interval
            }, skip ];
            if (method) interval = method[0], skip = method[1];
            return interval.range(extent[0], d3_time_scaleDate(+extent[1] + 1), skip < 1 ? 1 : skip);
        };
        scale.tickFormat = function() {
            return format;
        };
        scale.copy = function() {
            return d3_time_scale(linear.copy(), methods, format);
        };
        return d3_scale_linearRebind(scale, linear);
    }
    function d3_time_scaleDate(t) {
        return new Date(t);
    }
    var d3_time_scaleSteps = [ 1e3, 5e3, 15e3, 3e4, 6e4, 3e5, 9e5, 18e5, 36e5, 108e5, 216e5, 432e5, 864e5, 1728e5, 6048e5, 2592e6, 7776e6, 31536e6 ];
    var d3_time_scaleLocalMethods = [ [ d3_time.second, 1 ], [ d3_time.second, 5 ], [ d3_time.second, 15 ], [ d3_time.second, 30 ], [ d3_time.minute, 1 ], [ d3_time.minute, 5 ], [ d3_time.minute, 15 ], [ d3_time.minute, 30 ], [ d3_time.hour, 1 ], [ d3_time.hour, 3 ], [ d3_time.hour, 6 ], [ d3_time.hour, 12 ], [ d3_time.day, 1 ], [ d3_time.day, 2 ], [ d3_time.week, 1 ], [ d3_time.month, 1 ], [ d3_time.month, 3 ], [ d3_time.year, 1 ] ];
    var d3_time_scaleLocalFormat = d3_time_format.multi([ [ ".%L", function(d) {
        return d.getMilliseconds();
    } ], [ ":%S", function(d) {
        return d.getSeconds();
    } ], [ "%I:%M", function(d) {
        return d.getMinutes();
    } ], [ "%I %p", function(d) {
        return d.getHours();
    } ], [ "%a %d", function(d) {
        return d.getDay() && d.getDate() != 1;
    } ], [ "%b %d", function(d) {
        return d.getDate() != 1;
    } ], [ "%B", function(d) {
        return d.getMonth();
    } ], [ "%Y", d3_true ] ]);
    var d3_time_scaleMilliseconds = {
        range: function(start, stop, step) {
            return d3.range(Math.ceil(start / step) * step, +stop, step).map(d3_time_scaleDate);
        },
        floor: d3_identity,
        ceil: d3_identity
    };
    d3_time_scaleLocalMethods.year = d3_time.year;
    d3_time.scale = function() {
        return d3_time_scale(d3.scale.linear(), d3_time_scaleLocalMethods, d3_time_scaleLocalFormat);
    };
    var d3_time_scaleUtcMethods = d3_time_scaleLocalMethods.map(function(m) {
        return [ m[0].utc, m[1] ];
    });
    var d3_time_scaleUtcFormat = d3_time_formatUtc.multi([ [ ".%L", function(d) {
        return d.getUTCMilliseconds();
    } ], [ ":%S", function(d) {
        return d.getUTCSeconds();
    } ], [ "%I:%M", function(d) {
        return d.getUTCMinutes();
    } ], [ "%I %p", function(d) {
        return d.getUTCHours();
    } ], [ "%a %d", function(d) {
        return d.getUTCDay() && d.getUTCDate() != 1;
    } ], [ "%b %d", function(d) {
        return d.getUTCDate() != 1;
    } ], [ "%B", function(d) {
        return d.getUTCMonth();
    } ], [ "%Y", d3_true ] ]);
    d3_time_scaleUtcMethods.year = d3_time.year.utc;
    d3_time.scale.utc = function() {
        return d3_time_scale(d3.scale.linear(), d3_time_scaleUtcMethods, d3_time_scaleUtcFormat);
    };
    d3.text = d3_xhrType(function(request) {
        return request.responseText;
    });
    d3.json = function(url, callback) {
        return d3_xhr(url, "application/json", d3_json, callback);
    };
    function d3_json(request) {
        return JSON.parse(request.responseText);
    }
    d3.html = function(url, callback) {
        return d3_xhr(url, "text/html", d3_html, callback);
    };
    function d3_html(request) {
        var range = d3_document.createRange();
        range.selectNode(d3_document.body);
        return range.createContextualFragment(request.responseText);
    }
    d3.xml = d3_xhrType(function(request) {
        return request.responseXML;
    });
    if (typeof define === "function" && define.amd) define(d3); else if (typeof module === "object" && module.exports) module.exports = d3;
    this.d3 = d3;
}();

(function (root, factory) {
    if (typeof define === 'function' && define.amd) {
        //Allow using this built library as an AMD module
        //in another project. That other project will only
        //see this AMD call, not the internal modules in
        //the closure below.
        define([], factory);
    } else {
        //Browser globals case. Just assign the
        //result to a property on the global.
        root.VanCharts = factory();
    }
}(this, function () {
/**
 * @license almond 0.3.1 Copyright (c) 2011-2014, The Dojo Foundation All Rights Reserved.
 * Available via the MIT or new BSD license.
 * see: http://github.com/jrburke/almond for details
 */
//Going sloppy to avoid 'use strict' string cost, but strict practices should
//be followed.
/*jslint sloppy: true */
/*global setTimeout: false */

var requirejs, require, define;
(function (undef) {
    var main, req, makeMap, handlers,
        defined = {},
        waiting = {},
        config = {},
        defining = {},
        hasOwn = Object.prototype.hasOwnProperty,
        aps = [].slice,
        jsSuffixRegExp = /\.js$/;

    function hasProp(obj, prop) {
        return hasOwn.call(obj, prop);
    }

    /**
     * Given a relative module name, like ./something, normalize it to
     * a real name that can be mapped to a path.
     * @param {String} name the relative name
     * @param {String} baseName a real name that the name arg is relative
     * to.
     * @returns {String} normalized name
     */
    function normalize(name, baseName) {
        var nameParts, nameSegment, mapValue, foundMap, lastIndex,
            foundI, foundStarMap, starI, i, j, part,
            baseParts = baseName && baseName.split("/"),
            map = config.map,
            starMap = (map && map['*']) || {};

        //Adjust any relative paths.
        if (name && name.charAt(0) === ".") {
            //If have a base name, try to normalize against it,
            //otherwise, assume it is a top-level require that will
            //be relative to baseUrl in the end.
            if (baseName) {
                name = name.split('/');
                lastIndex = name.length - 1;

                // Node .js allowance:
                if (config.nodeIdCompat && jsSuffixRegExp.test(name[lastIndex])) {
                    name[lastIndex] = name[lastIndex].replace(jsSuffixRegExp, '');
                }

                //Lop off the last part of baseParts, so that . matches the
                //"directory" and not name of the baseName's module. For instance,
                //baseName of "one/two/three", maps to "one/two/three.js", but we
                //want the directory, "one/two" for this normalization.
                name = baseParts.slice(0, baseParts.length - 1).concat(name);

                //start trimDots
                for (i = 0; i < name.length; i += 1) {
                    part = name[i];
                    if (part === ".") {
                        name.splice(i, 1);
                        i -= 1;
                    } else if (part === "..") {
                        if (i === 1 && (name[2] === '..' || name[0] === '..')) {
                            //End of the line. Keep at least one non-dot
                            //path segment at the front so it can be mapped
                            //correctly to disk. Otherwise, there is likely
                            //no path mapping for a path starting with '..'.
                            //This can still fail, but catches the most reasonable
                            //uses of ..
                            break;
                        } else if (i > 0) {
                            name.splice(i - 1, 2);
                            i -= 2;
                        }
                    }
                }
                //end trimDots

                name = name.join("/");
            } else if (name.indexOf('./') === 0) {
                // No baseName, so this is ID is resolved relative
                // to baseUrl, pull off the leading dot.
                name = name.substring(2);
            }
        }

        //Apply map config if available.
        if ((baseParts || starMap) && map) {
            nameParts = name.split('/');

            for (i = nameParts.length; i > 0; i -= 1) {
                nameSegment = nameParts.slice(0, i).join("/");

                if (baseParts) {
                    //Find the longest baseName segment match in the config.
                    //So, do joins on the biggest to smallest lengths of baseParts.
                    for (j = baseParts.length; j > 0; j -= 1) {
                        mapValue = map[baseParts.slice(0, j).join('/')];

                        //baseName segment has  config, find if it has one for
                        //this name.
                        if (mapValue) {
                            mapValue = mapValue[nameSegment];
                            if (mapValue) {
                                //Match, update name to the new value.
                                foundMap = mapValue;
                                foundI = i;
                                break;
                            }
                        }
                    }
                }

                if (foundMap) {
                    break;
                }

                //Check for a star map match, but just hold on to it,
                //if there is a shorter segment match later in a matching
                //config, then favor over this star map.
                if (!foundStarMap && starMap && starMap[nameSegment]) {
                    foundStarMap = starMap[nameSegment];
                    starI = i;
                }
            }

            if (!foundMap && foundStarMap) {
                foundMap = foundStarMap;
                foundI = starI;
            }

            if (foundMap) {
                nameParts.splice(0, foundI, foundMap);
                name = nameParts.join('/');
            }
        }

        return name;
    }

    function makeRequire(relName, forceSync) {
        return function () {
            //A version of a require function that passes a moduleName
            //value for items that may need to
            //look up paths relative to the moduleName
            var args = aps.call(arguments, 0);

            //If first arg is not require('string'), and there is only
            //one arg, it is the array form without a callback. Insert
            //a null so that the following concat is correct.
            if (typeof args[0] !== 'string' && args.length === 1) {
                args.push(null);
            }
            return req.apply(undef, args.concat([relName, forceSync]));
        };
    }

    function makeNormalize(relName) {
        return function (name) {
            return normalize(name, relName);
        };
    }

    function makeLoad(depName) {
        return function (value) {
            defined[depName] = value;
        };
    }

    function callDep(name) {
        if (hasProp(waiting, name)) {
            var args = waiting[name];
            delete waiting[name];
            defining[name] = true;
            main.apply(undef, args);
        }

        if (!hasProp(defined, name) && !hasProp(defining, name)) {
            throw new Error('No ' + name);
        }
        return defined[name];
    }

    //Turns a plugin!resource to [plugin, resource]
    //with the plugin being undefined if the name
    //did not have a plugin prefix.
    function splitPrefix(name) {
        var prefix,
            index = name ? name.indexOf('!') : -1;
        if (index > -1) {
            prefix = name.substring(0, index);
            name = name.substring(index + 1, name.length);
        }
        return [prefix, name];
    }

    /**
     * Makes a name map, normalizing the name, and using a plugin
     * for normalization if necessary. Grabs a ref to plugin
     * too, as an optimization.
     */
    makeMap = function (name, relName) {
        var plugin,
            parts = splitPrefix(name),
            prefix = parts[0];

        name = parts[1];

        if (prefix) {
            prefix = normalize(prefix, relName);
            plugin = callDep(prefix);
        }

        //Normalize according
        if (prefix) {
            if (plugin && plugin.normalize) {
                name = plugin.normalize(name, makeNormalize(relName));
            } else {
                name = normalize(name, relName);
            }
        } else {
            name = normalize(name, relName);
            parts = splitPrefix(name);
            prefix = parts[0];
            name = parts[1];
            if (prefix) {
                plugin = callDep(prefix);
            }
        }

        //Using ridiculous property names for space reasons
        return {
            f: prefix ? prefix + '!' + name : name, //fullName
            n: name,
            pr: prefix,
            p: plugin
        };
    };

    function makeConfig(name) {
        return function () {
            return (config && config.config && config.config[name]) || {};
        };
    }

    handlers = {
        require: function (name) {
            return makeRequire(name);
        },
        exports: function (name) {
            var e = defined[name];
            if (typeof e !== 'undefined') {
                return e;
            } else {
                return (defined[name] = {});
            }
        },
        module: function (name) {
            return {
                id: name,
                uri: '',
                exports: defined[name],
                config: makeConfig(name)
            };
        }
    };

    main = function (name, deps, callback, relName) {
        var cjsModule, depName, ret, map, i,
            args = [],
            callbackType = typeof callback,
            usingExports;

        //Use name if no relName
        relName = relName || name;

        //Call the callback to define the module, if necessary.
        if (callbackType === 'undefined' || callbackType === 'function') {
            //Pull out the defined dependencies and pass the ordered
            //values to the callback.
            //Default to [require, exports, module] if no deps
            deps = !deps.length && callback.length ? ['require', 'exports', 'module'] : deps;
            for (i = 0; i < deps.length; i += 1) {
                map = makeMap(deps[i], relName);
                depName = map.f;

                //Fast path CommonJS standard dependencies.
                if (depName === "require") {
                    args[i] = handlers.require(name);
                } else if (depName === "exports") {
                    //CommonJS module spec 1.1
                    args[i] = handlers.exports(name);
                    usingExports = true;
                } else if (depName === "module") {
                    //CommonJS module spec 1.1
                    cjsModule = args[i] = handlers.module(name);
                } else if (hasProp(defined, depName) ||
                    hasProp(waiting, depName) ||
                    hasProp(defining, depName)) {
                    args[i] = callDep(depName);
                } else if (map.p) {
                    map.p.load(map.n, makeRequire(relName, true), makeLoad(depName), {});
                    args[i] = defined[depName];
                } else {
                    throw new Error(name + ' missing ' + depName);
                }
            }

            ret = callback ? callback.apply(defined[name], args) : undefined;

            if (name) {
                //If setting exports via "module" is in play,
                //favor that over return value and exports. After that,
                //favor a non-undefined return value over exports use.
                if (cjsModule && cjsModule.exports !== undef &&
                    cjsModule.exports !== defined[name]) {
                    defined[name] = cjsModule.exports;
                } else if (ret !== undef || !usingExports) {
                    //Use the return value from the function.
                    defined[name] = ret;
                }
            }
        } else if (name) {
            //May just be an object definition for the module. Only
            //worry about defining if have a module name.
            defined[name] = callback;
        }
    };

    requirejs = require = req = function (deps, callback, relName, forceSync, alt) {
        if (typeof deps === "string") {
            if (handlers[deps]) {
                //callback in this case is really relName
                return handlers[deps](callback);
            }
            //Just return the module wanted. In this scenario, the
            //deps arg is the module name, and second arg (if passed)
            //is just the relName.
            //Normalize module name, if it contains . or ..
            return callDep(makeMap(deps, callback).f);
        } else if (!deps.splice) {
            //deps is a config object, not an array.
            config = deps;
            if (config.deps) {
                req(config.deps, config.callback);
            }
            if (!callback) {
                return;
            }

            if (callback.splice) {
                //callback is an array, which means it is a dependency list.
                //Adjust args if there are dependencies
                deps = callback;
                callback = relName;
                relName = null;
            } else {
                deps = undef;
            }
        }

        //Support require(['a'])
        callback = callback || function () {};

        //If relName is a function, it is an errback handler,
        //so remove it.
        if (typeof relName === 'function') {
            relName = forceSync;
            forceSync = alt;
        }

        //Simulate async callback;
        if (forceSync) {
            main(undef, deps, callback, relName);
        } else {
            //Using a non-zero value because of concern for what old browsers
            //do, and latest browsers "upgrade" to 4 if lower value is used:
            //http://www.whatwg.org/specs/web-apps/current-work/multipage/timers.html#dom-windowtimers-settimeout:
            //If want a value immediately, use require('id') instead -- something
            //that works in almond on the global level, but not guaranteed and
            //unlikely to work in other AMD implementations.
            setTimeout(function () {
                main(undef, deps, callback, relName);
            }, 4);
        }

        return req;
    };

    /**
     * Just drops the config on the floor, but returns req in case
     * the config return value is used.
     */
    req.config = function (cfg) {
        return req(cfg);
    };

    /**
     * Expose module registry for debugging and tooling
     */
    requirejs._defined = defined;

    define = function (name, deps, callback) {
        if (typeof name !== 'string') {
            throw new Error('See almond README: incorrect module build, no module name');
        }

        //This module may not have dependencies
        if (!deps.splice) {
            //deps is not an array, so probably means
            //an object literal or factory function for
            //the value. Adjust args.
            callback = deps;
            deps = [];
        }

        if (!hasProp(defined, name) && !hasProp(waiting, name)) {
            waiting[name] = [name, deps, callback];
        }
    };

    define.amd = {
        jQuery: true
    };
}());
define("almond", function(){});

/**
 * Created by eason on 15/5/4.
 */
define('Constants',[],function(){
    return {

        INSTANCES_KEY:'vancharts_index_',

        SELECT_ANIMATION:'select',

        //图表类型
        BAR_CHART:'bar',//条形图
        COLUMN_CHART:'column',//柱形图
        LINE_CHART:'line',//折线图
        AREA_CHART:'area',//面积图
        PIE_CHART:'pie',//饼图
        SCATTER_CHART:'scatter',//散点图
        BUBBLE_CHART:'bubble',//气泡图
        GAUGE_CHART:'gauge',//仪表盘
        RADAR_CHART:'radar',//雷达图
        MAP_CHART:'map',//地图
        POINT_MAP:'pointMap',

        //组件类型
        GEO_COMPONENT:'geo',
        X_AXIS_COMPONENT:'xAxis',
        Y_AXIS_COMPONENT:'yAxis',
        POLAR_COMPONENT:'polar',
        RADIUS_AXIS_COMPONENT:'radiusAxis',
        ANGLE_AXIS_COMPONENT:'angleAxis',
        GAUGE_AXIS_COMPONENT:'gaugeAxis',
        VALUE_AXIS_COMPONENT:'value',
        CATEGORY_AXIS_COMPONENT:'category',
        DATE_AXIS_COMPONENT:'datetime',
        DATA_SHEET_COMPONENT:'dataSheet',
        LEGEND_COMPONENT:'legend',
        TITLE_COMPONENT:'title',
        AXIS_COMPONENT:'axis',
        TOOLTIP_COMPONENT:'tooltip',
        TOOLBAR_COMPONENT:'tools',
        ZOOM_COMPONENT:'zoom',
        RANGE_LEGEND_COMPONENT:'rangeLegend',
        DRILL_TOOLS:'dTools',

        VANCHART:'vanchart',

        //工具栏的icon类型
        MAX_ICON : 'vancharts-icon-max',
        MIN_ICON:'vancharts-icon-min',
        MENU_ICON : 'vancharts-icon-menu',
        REFRESH_ICON : 'vancharts-icon-refresh',
        DECREASE_ICON : 'vancharts-icon-decrease',
        INCREASE_ICON : 'vancharts-icon-increase',
        EXPORT_ICON : 'vancharts-icon-export',

        AXIS_GROUP:'vanchart-axis-group',

        //位置相关的常量
        BOTTOM:'bottom',
        TOP:'top',
        LEFT:'left',
        RIGHT:'right',
        RIGHT_TOP:'right-top',

        //动画的方向
        LEFT_TO_RIGHT:'left-to-right',
        RIGHT_TO_LEFT:'right-to-right',
        BOTTOM_TO_TOP:'bottom-to-top',
        TOP_TO_BOTTOM:'top-to-botttom',

        //标记点类型
        NULL_MARKER:'null_marker',
        CIRCLE:'circle',
        SQUARE:'square',
        DIAMOND:'diamond',
        TRIANGLE:'triangle',

        CIRCLE_HOLLOW:'circle_hollow',
        SQUARE_HOLLOW:'square_hollow',
        DIAMOND_HOLLOW:'diamond_hollow',
        TRIANGLE_HOLLOW:'triangle_hollow',

        //图例的另外三种类型
        NORMAL_ICON:'normal-legend-icon',//一般的图例
        PIE_ICON:'pie-legend-icon',
        DONUT_ICON:'donut-legend-icon',
        BUBBLE_ICON:'bubble-legend-icon',
        SCATTER_ICON:'scatter-legend-icon',

        //虚线的类型
        DASH_TYPE:{
            Solid:'0,0',
            Dash:'8,6'
        },

        //玫瑰图的不同形状
        SAME_ARC : 'sameArc',//所有扇形弧长相同
        DIFFERENT_ARC : 'differentArc',//所有扇形弧长不相等

        //图的排序的状态
        DISORDER:'disorder',
        DESCENDING:'descending',
        ASCENDING:'ascending',

        //图的状态
        STATE_INIT:'init-state',//初始状态
        STATE_RESTORE_REFRESH:'restore-refresh-state',//缩放后的刷新状态
        STATE_CHANGE_DATA_REFRESH:'change-data-refresh-state',//自动刷新（数据变换）状态
        STATE_ZOOM_REFRESH:'zoom-refresh-state',//缩放状态

        //标签的位置
        OUTSIDE : 'outside',
        INSIDE : 'inside',
        CENTER:'center',

        //各种渲染器的名字
        VANCHART_SVG:'vanchart-svg-render',
        VANCHART_VML:'vanchart-vml-render',

        PIE_SVG:'pie-svg-render',
        PIE_VML:'pie-vml-render',

        BAR_SVG:'bar-svg-render',
        BAR_VML:'bar-vml-render',

        LINE_SVG:'line-svg-render',
        LINE_VML:'line-vml-render',

        AREA_SVG:'area-svg-render',
        AREA_VML:'area-vml-render',

        GAUGE_SVG:'gauge-svg-render',
        GAUGE_VML:'gauge-vml-render',

        RADAR_SVG:'radar-svg-render',
        RADAR_VML:'radar-vml-render',

        BUBBLE_SVG:'bubble-svg-render',
        BUBBLE_VML:'bubble-vml-render',

        SCATTER_SVG:'scatter-svg-render',
        SCATTER_VML:'scatter-vml-render',

        MAP_SVG:'map-svg-render',
        MAP_VML:'map-vml-render',

        TITLE_SVG:'title-svg-render',
        TITLE_VML:'title-vml-render',
        LEGEND_SVG:'legend-svg-render',
        LEGEND_VML:'legend-vml-render',
        RANGE_LEGEND_SVG:'range-legend-svg-render',
        RANGE_LEGEND_VML:'range-legend-vml-render',
        TOOLBAR_SVG:'toolbar-svg-render',
        TOOLBAR_VML:'toolbar-vml-render',
        DRILL_TOOLS_SVG:'dTools-svg-render',
        DRILL_TOOLS_VML:'dTools-vml-render',

        ZOOM_SVG:'zoom-svg-render',

        DATA_SHEET_SVG:'data-sheet-svg-render',
        DATA_SHEET_VML:'data-sheet-vml-render',

        AXIS_RENDER:'axis-render',
        RADIUS_AXIS_RENDER:'radius-axis-render',
        ANGLE_AXIS_RENDER:'angle-axis-render',
        CATEGORY_AXIS_SVG:'category-axis-svg-render',
        CATEGORY_AXIS_VML:'category-axis-vml-render',
        VALUE_AXIS_SVG:'value-axis-svg-render',
        VALUE_AXIS_VML:'value-axis-vml-render',
        DATE_AXIS_SVG:'date-axis-svg-render',
        DATE_AXIS_VML:'date-axis-vml-render',
        RADIUS_AXIS_SVG:'radius-axis-svg-render',
        RADIUS_AXIS_VML:'radius-axis-vml-render',
        ANGLE_AXIS_SVG:'angle-axis-svg-render',
        ANGLE_AXIS_VML:'angle-axis-vml-render',

        //样式的名字
        STYLE_GRADUAL:'gradual', //渐变

        //四种仪表盘的样式
        GAUGE_POINTER:'pointer',
        GAUGE_POINTER_SEMI:'pointer_semi',
        GAUGE_SLOT:'slot',
        GAUGE_THERMOMETER:'thermometer',
        GAUGE_RING:'ring',

        //仪表盘布局
        HORIZONTAL_LAYOUT:'horizontal',
        VERTICAL_LAYOUT:'vertical',

        //雷达图底边
        POLYGON_RADAR:'polygon',
        CIRCLE_RADAR:'circle',

        //size是通过气泡的半径还是面积表现出来
        SIZE_BY_AREA:'area',
        SIZE_BY_WIDTH:'width',

        TOOLTIP_CATEGORY_STYLE: '<span style="font-size:16px;font-family:Verdana;color:white;">',
        TOOLTIP_SERIES_STYLE: '<span style="font-size:14px;font-family:Verdana;color:white">',
        TOOLTIP_VALUE_STYLE: '<span style="font-size:14px;font-family:Verdana;font-weight:bold;color:white">'
    }

});
/**
 * Created by eason on 15/6/30.
 * some of the following methods are borrowed from zrender
 */

//Copyright (c) 2013, Baidu Inc.
//    All rights reserved.
//
//    Redistribution and use of this software in source and binary forms, with or
//    without modification, are permitted provided that the following conditions
//are met:
//
//    Redistributions of source code must retain the above copyright notice, this
//list of conditions and the following disclaimer.
//
//    Redistributions in binary form must reproduce the above copyright notice,
//    this list of conditions and the following disclaimer in the documentation
//and/or other materials provided with the distribution.
//
//    Neither the name of Baidu Inc. nor the names of its contributors may be used
//to endorse or promote products derived from this software without specific
//prior written permission of Baidu Inc.
//
//    THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
//AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
//IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
//DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR
//ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
//(INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
//LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON
//ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
//(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
//SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.

define('utils/ColorUtils',[],function(){
    var _nameColors = {
        aliceblue : '#f0f8ff',
        antiquewhite : '#faebd7',
        aqua : '#0ff',
        aquamarine : '#7fffd4',
        azure : '#f0ffff',
        beige : '#f5f5dc',
        bisque : '#ffe4c4',
        black : '#000',
        blanchedalmond : '#ffebcd',
        blue : '#00f',
        blueviolet : '#8a2be2',
        brown : '#a52a2a',
        burlywood : '#deb887',
        cadetblue : '#5f9ea0',
        chartreuse : '#7fff00',
        chocolate : '#d2691e',
        coral : '#ff7f50',
        cornflowerblue : '#6495ed',
        cornsilk : '#fff8dc',
        crimson : '#dc143c',
        cyan : '#0ff',
        darkblue : '#00008b',
        darkcyan : '#008b8b',
        darkgoldenrod : '#b8860b',
        darkgray : '#a9a9a9',
        darkgrey : '#a9a9a9',
        darkgreen : '#006400',
        darkkhaki : '#bdb76b',
        darkmagenta : '#8b008b',
        darkolivegreen : '#556b2f',
        darkorange : '#ff8c00',
        darkorchid : '#9932cc',
        darkred : '#8b0000',
        darksalmon : '#e9967a',
        darkseagreen : '#8fbc8f',
        darkslateblue : '#483d8b',
        darkslategray : '#2f4f4f',
        darkslategrey : '#2f4f4f',
        darkturquoise : '#00ced1',
        darkviolet : '#9400d3',
        deeppink : '#ff1493',
        deepskyblue : '#00bfff',
        dimgray : '#696969',
        dimgrey : '#696969',
        dodgerblue : '#1e90ff',
        firebrick : '#b22222',
        floralwhite : '#fffaf0',
        forestgreen : '#228b22',
        fuchsia : '#f0f',
        gainsboro : '#dcdcdc',
        ghostwhite : '#f8f8ff',
        gold : '#ffd700',
        goldenrod : '#daa520',
        gray : '#808080',
        grey : '#808080',
        green : '#008000',
        greenyellow : '#adff2f',
        honeydew : '#f0fff0',
        hotpink : '#ff69b4',
        indianred : '#cd5c5c',
        indigo : '#4b0082',
        ivory : '#fffff0',
        khaki : '#f0e68c',
        lavender : '#e6e6fa',
        lavenderblush : '#fff0f5',
        lawngreen : '#7cfc00',
        lemonchiffon : '#fffacd',
        lightblue : '#add8e6',
        lightcoral : '#f08080',
        lightcyan : '#e0ffff',
        lightgoldenrodyellow : '#fafad2',
        lightgray : '#d3d3d3',
        lightgrey : '#d3d3d3',
        lightgreen : '#90ee90',
        lightpink : '#ffb6c1',
        lightsalmon : '#ffa07a',
        lightseagreen : '#20b2aa',
        lightskyblue : '#87cefa',
        lightslategray : '#789',
        lightslategrey : '#789',
        lightsteelblue : '#b0c4de',
        lightyellow : '#ffffe0',
        lime : '#0f0',
        limegreen : '#32cd32',
        linen : '#faf0e6',
        magenta : '#f0f',
        maroon : '#800000',
        mediumaquamarine : '#66cdaa',
        mediumblue : '#0000cd',
        mediumorchid : '#ba55d3',
        mediumpurple : '#9370d8',
        mediumseagreen : '#3cb371',
        mediumslateblue : '#7b68ee',
        mediumspringgreen : '#00fa9a',
        mediumturquoise : '#48d1cc',
        mediumvioletred : '#c71585',
        midnightblue : '#191970',
        mintcream : '#f5fffa',
        mistyrose : '#ffe4e1',
        moccasin : '#ffe4b5',
        navajowhite : '#ffdead',
        navy : '#000080',
        oldlace : '#fdf5e6',
        olive : '#808000',
        olivedrab : '#6b8e23',
        orange : '#ffa500',
        orangered : '#ff4500',
        orchid : '#da70d6',
        palegoldenrod : '#eee8aa',
        palegreen : '#98fb98',
        paleturquoise : '#afeeee',
        palevioletred : '#d87093',
        papayawhip : '#ffefd5',
        peachpuff : '#ffdab9',
        peru : '#cd853f',
        pink : '#ffc0cb',
        plum : '#dda0dd',
        powderblue : '#b0e0e6',
        purple : '#800080',
        red : '#f00',
        rosybrown : '#bc8f8f',
        royalblue : '#4169e1',
        saddlebrown : '#8b4513',
        salmon : '#fa8072',
        sandybrown : '#f4a460',
        seagreen : '#2e8b57',
        seashell : '#fff5ee',
        sienna : '#a0522d',
        silver : '#c0c0c0',
        skyblue : '#87ceeb',
        slateblue : '#6a5acd',
        slategray : '#708090',
        slategrey : '#708090',
        snow : '#fffafa',
        springgreen : '#00ff7f',
        steelblue : '#4682b4',
        tan : '#d2b48c',
        teal : '#008080',
        thistle : '#d8bfd8',
        tomato : '#ff6347',
        turquoise : '#40e0d0',
        violet : '#ee82ee',
        wheat : '#f5deb3',
        white : '#fff',
        whitesmoke : '#f5f5f5',
        yellow : '#ff0',
        yellowgreen : '#9acd32'
    };

    var colorRegExp = /^\s*((#[a-f\d]{6})|(#[a-f\d]{3})|rgba?\(\s*([\d\.]+%?\s*,\s*[\d\.]+%?\s*,\s*[\d\.]+%?(?:\s*,\s*[\d\.]+%?)?)\s*\)|hsba?\(\s*([\d\.]+(?:deg|\xb0|%)?\s*,\s*[\d\.]+%?\s*,\s*[\d\.]+%?(?:\s*,\s*[\d\.]+)?)%?\s*\)|hsla?\(\s*([\d\.]+(?:deg|\xb0|%)?\s*,\s*[\d\.]+%?\s*,\s*[\d\.]+%?(?:\s*,\s*[\d\.]+)?)%?\s*\))\s*$/i;

    function trim(color) {
        return String(color).replace(/\s+/g, '');
    }

    // 调整值区间
    function adjust(value, region) {
        if (value <= region[0]) {
            value = region[0];
        }
        else if (value >= region[1]) {
            value = region[1];
        }
        return value;
    }

    // 数组映射
    function map(array, fun) {
        if (typeof fun !== 'function') {
            throw new TypeError();
        }
        var len = array ? array.length : 0;
        for (var i = 0; i < len; i++) {
            array[i] = fun(array[i]);
        }
        return array;
    }

    /**
     * 把颜色转化成数组数据，用于计算
     * @param color 颜色
     */
    function getRGBAColorArray(color){
        if (_nameColors[color]) {
            color = _nameColors[color];
        }

        color = trim(color);

        if (/^#[\da-f]{3}$/i.test(color)) {
            color = parseInt(color.slice(1), 16);
            var r = (color & 0xf00) << 8;
            var g = (color & 0xf0) << 4;
            var b = color & 0xf;

            color = '#' + ((1 << 24) + (r << 4) + r + (g << 4) + g + (b << 4) + b).toString(16).slice(1);
        }

        var r = color.match(colorRegExp);

        var d;
        var a;
        var data = [];
        var rgb;

        if (r[2]) {
            // #rrggbb
            d = r[2].replace('#', '').split('');
            rgb = [ d[0] + d[1], d[2] + d[3], d[4] + d[5] ];
            data = map(rgb,
                function(c) {
                    return adjust(parseInt(c, 16), [ 0, 255 ]);
                }
            );
        } else if (r[4]) {
            // rgb rgba
            var rgba = (r[4]).split(',');
            a = rgba[3];
            rgb = rgba.slice(0, 3);
            data = map(
                rgb,
                function(c) {
                    c = Math.floor(
                        c.indexOf('%') > 0 ? parseInt(c, 0) * 2.55 : c
                    );
                    return adjust(c, [ 0, 255 ]);
                }
            );

            if (typeof a !== 'undefined') {
                data.push(adjust(parseFloat(a), [ 0, 1 ]));
            }
        }


        //统一rgba的格式
        if(data.length == 3){
            data.push(1);
        }

        return data;
    }

    function toColor(data, format){
        format = format || 'rgb';
        if (data && (data.length === 3 || data.length === 4)) {
            data = map(data,
                function(c) {
                    return c > 1 ? Math.ceil(c) : c;
                }
            );

            if (format.indexOf('hex') > -1) {
                return '#' + ((1 << 24) + (data[0] << 16) + (data[1] << 8) + (+data[2])).toString(16).slice(1);
            }
            else if (format.indexOf('hs') > -1) {
                var sx = map(data.slice(1, 3),
                    function(c) {
                        return c + '%';
                    }
                );
                data[1] = sx[0];
                data[2] = sx[1];
            }

            if (format.indexOf('a') > -1) {
                if (data.length === 3) {
                    data.push(1);
                }
                data[3] = adjust(data[3], [ 0, 1 ]);
                return format + '(' + data.slice(0, 4).join(',') + ')';
            }

            return format + '(' + data.slice(0, 3).join(',') + ')';
        }
    }

    function getHighLightColor(color){
        var rgba = getRGBAColorArray(color);
        var tmp = [];
        for(var i = 0; i < 3; i++){
            var x = rgba[i];
            if(x <= 128){
                tmp.push(adjust(x-(255-x)*(255-2*x)/(2*x), [0,255]));
            }else{
                tmp.push(adjust(x+x*(2*x-255)/(2*(255-x)), [0,255]));
            }
        }

        var result = [];
        for(i = 0; i < 3; i++){
            result.push(Math.round(0.65 * rgba[i] + 0.35 * tmp[i]));
        }

        return toColor(result);
    }

    function getColorWithDivider(color, divider){
        var rgba = getRGBAColorArray(color);

        for(var i = 0; i < 3; i++){
            rgba[i] /= divider;
        }

        return toColor(rgba, 'rgba');
    }

    function getClickColor(color){

        var rgba = getRGBAColorArray(color);

        for(var i = 0; i < 3; i++){
            rgba[i] *= 0.95;
        }

        return toColor(rgba, 'rgba');
    }

    function mixColorWithAlpha(color, alpha){
        var rgba = getRGBAColorArray(color);
        rgba[3] = alpha;
        return toColor(rgba, 'rgba');
    }

    function mixColorWithHSB(color, detH, detS, detB){
        var rgba = getRGBAColorArray(color);

        var hsb = rgb2hsb(rgba[0], rgba[1], rgba[2]);

        hsb[0] += detH;
        hsb[1] += detS;
        hsb[2] += detB;

        var rgb = hsb2rgb(hsb[0], hsb[1], hsb[2]);

        return toColor(rgb, 'rgb');
    }

    function hsb2rgb(hue, saturation, brightness){

        saturation = Math.min(1, Math.max(0, saturation));

        brightness = Math.min(1, Math.max(0, brightness));

        var r = 0, g = 0, b = 0;
        if (saturation === 0) {
            r = g = b = brightness * 255.0 + 0.5;
        } else {
            var h = (hue - Math.floor(hue)) * 6.0;
            var f = h - Math.floor(h);
            var p = brightness * (1.0 - saturation);
            var q = brightness * (1.0 - saturation * f);
            var t = brightness * (1.0 - (saturation * (1.0 - f)));
            switch (Math.floor(h)) {
                case 0:
                    r = brightness * 255.0 + 0.5;
                    g = t * 255.0 + 0.5;
                    b = p * 255.0 + 0.5;
                    break;
                case 1:
                    r = q * 255.0 + 0.5;
                    g = brightness * 255.0 + 0.5;
                    b = p * 255.0 + 0.5;
                    break;
                case 2:
                    r = p * 255.0 + 0.5;
                    g = brightness * 255.0 + 0.5;
                    b = t * 255.0 + 0.5;
                    break;
                case 3:
                    r = p * 255.0 + 0.5;
                    g = q * 255.0 + 0.5;
                    b = brightness * 255.0 + 0.5;
                    break;
                case 4:
                    r = t * 255.0 + 0.5;
                    g = p * 255.0 + 0.5;
                    b = brightness * 255.0 + 0.5;
                    break;
                case 5:
                    r = brightness * 255.0 + 0.5;
                    g = p * 255.0 + 0.5;
                    b = q * 255.0 + 0.5;
                    break;
            }
        }
        var rgb = [];
        rgb.push(Math.floor(r));
        rgb.push(Math.floor(g));
        rgb.push(Math.floor(b));
        return rgb;
    }

    function rgb2hsb(r, g, b){

        var hue, saturation, brightness;

        var hsbvals = [3];
        var cmax = (r > g) ? r : g;
        if (b > cmax) {
            cmax = b;
        }
        var cmin = (r < g) ? r : g;
        if (b < cmin) {
            cmin = b;
        }

        brightness = cmax / 255.0;
        if (cmax !== 0) {
            saturation = (cmax - cmin) / cmax;
        }else{
            saturation = 0;
        }


        if (saturation === 0) {
            hue = 0;
        }else{
            var redc = (cmax - r) / (cmax - cmin);
            var greenc = (cmax - g) / (cmax - cmin);
            var bluec = (cmax - b) / (cmax - cmin);
            if (r == cmax) {
                hue = bluec - greenc;
            }
            else if (g == cmax) {
                hue = 2.0 + redc - bluec;
            }
            else {
                hue = 4.0 + greenc - redc;
            }
            hue = hue / 6.0;
            if (hue < 0) {
                hue = hue + 1.0;
            }
        }

        hsbvals[0] = hue;
        hsbvals[1] = saturation;
        hsbvals[2] = brightness;
        return hsbvals;
    }

    function getColorOpacity(color){
        var rgba = getRGBAColorArray(color);

        //透明度
        return rgba[3];
    }

    //没有a定义的话返回空
    function getColorOpacityWithoutDefault(color){

        return (color && typeof color == 'string' && (color.indexOf('rgba') != -1))
                                                    ? getColorOpacity(color) : undefined;

    }

    function colorToHex(color){
        return colorToHexAlpha(color).hex;
    }

    function colorToHexAlpha(color){
        var rgb = toColor(getRGBAColorArray(color), 'rgba');

        var rRgba = /rgba?\((\d{1,3}),(\d{1,3}),(\d{1,3})(,([.\d]+))?\)/,
            r, g, b, a,
            rsa = rgb.replace(/\s+/g, "").match(rRgba);

        r = (+rsa[1]).toString(16);
        r = r.length === 1 ? "0" + r : r;
        g = (+rsa[2]).toString(16);
        g = g.length === 1 ? "0" + g : g;
        b = (+rsa[3]).toString(16);
        b = b.length === 1 ? "0" + b : b;
        a = (+(rsa[5] ? rsa[5] : 1)) * 100;

        return {hex: "#" + r + g + b, alpha: Math.ceil(a)};
    }

    return {
        toColor:toColor,
        hsb2rgb:hsb2rgb,
        rgb2hsb:rgb2hsb,
        getRGBAColorArray:getRGBAColorArray,
        mixColorWithHSB:mixColorWithHSB,
        getHighLightColor:getHighLightColor,
        getColorWithDivider:getColorWithDivider,
        mixColorWithAlpha:mixColorWithAlpha,
        getColorOpacity:getColorOpacity,
        getColorOpacityWithoutDefault:getColorOpacityWithoutDefault,
        colorToHex:colorToHex,
        colorToHexAlpha:colorToHexAlpha,
        getClickColor:getClickColor
    }

});
/**
 * Created by eason on 15/6/16.
 */

define('utils/QueryUtils',['require','./BaseUtils'],function(require){
    var BaseUtils = require('./BaseUtils');

    //从选项中读出指定属性
    function query(opt, optLocation){
        if(!opt || !optLocation){
            return;
        }

        optLocation = optLocation.split('.');
        for(var index = 0, length = optLocation.length; index < length; index++){
            opt = opt[optLocation[index]];

            //这里的opt可能为0,false等
            if(opt == undefined){
                return;
            }
        }

        return opt;
    }


    //从可能的属性列表里读optLocation的属性，前面的优先级高
    function queryList(optList, optLocation){
        if(!optList || !optList.length || !optLocation){
            return undefined;
        }

        for(var i = 0; i < optList.length; i++){
            var result = query(optList[i], optLocation);
            if(result != undefined){
                return result;
            }
        }
    }

    function merge(target, source, overwrite){
        for (var key in source) {
            if (source.hasOwnProperty(key)) {
                var targetProp = target[key];
                if (typeof targetProp == 'object') {

                    //target[key]不为对象时？
                    merge(target[key], source[key], overwrite);
                }else if(overwrite || !(key in target)){
                    target[key] = source[key];
                }
            }
        }
        return target;
    }


    //从list里合并需要的选项
    function mergeList(optList, optLocation){
        if(!optList || !optList.length || !optLocation){
            return undefined;
        }

        var result;
        for(var i = 0, length = optList.length; i < length; i++){
            var tmpOption = query(optList[i], optLocation);

            if(result == undefined){
                result = BaseUtils.clone(tmpOption);
            }else{
                merge(result, tmpOption);
            }
        }

        return result;
    }

    return {
        mergeList:mergeList,
        queryList:queryList,
        query:query,
        merge:merge
    };
});
/**
 * Created by eason on 15/5/18.
 * 各种注册了的组件
 */
define('ComponentLibrary',[],function(){
    var _registeredComponents = Object.create(null);

    /**
     * 根据名字获得组件的function
     * @param name 组件的名字
     */
    function get(name){
        return _registeredComponents[name];
    }

    /**
     * 注册某种组件类型
     * @param name 组件的名字
     * @param chart 组件的实现
     */
    function register(name, compnent){
        _registeredComponents[name] = compnent;
    }

    return {
        get:get,
        register:register
    }

});
/**
 * Created by eason on 15/5/4.
 * 注册了的图表的工厂,所有加载的图表模块都在这里注册
 */
define('ChartLibrary',[],function(){
    var _registeredCharts = {};

    /**
     * 根据名字获得某种图表类型的function
     * @param name 图表名字
     */
    function get(name){
        return _registeredCharts[name];
    }

    /**
     * 注册某种图表类型
     * @param name 图表的名字
     * @param chart 图表的实现
     */
    function register(name, chart){
        _registeredCharts[name] = chart;
    }

    return {
        get:get,
        register:register
    }
});
/**
 * Created by eason on 15/8/12.
 * 各种注册了的渲染器
 */

define('render/RenderLibrary',[],function(){
    var _registeredRender = Object.create(null);

    /**
     * 根据名字获得渲染器的function
     * @param name 渲染器的名字
     */
    function get(name){
        return _registeredRender[name];
    }

    function getRender(name, attrObj){
        var RenderFunction = get(name);
        if(RenderFunction){
            return new RenderFunction(attrObj);
        }
    }

    /**
     * 注册某种渲染器
     * @param name 渲染器的名字
     * @param chart 渲染器的实现
     */
    function register(name, compnent){
        _registeredRender[name] = compnent;
    }

    return {
        get:get,
        getRender:getRender,
        register:register
    }

});
/**
 * Created by eason on 15/8/13.
 */
define('render/RenderFactory',['require','./RenderLibrary','../Constants','../utils/BaseUtils'],function(require){

    var RenderLibrary = require('./RenderLibrary');

    var Constants = require('../Constants');

    var BaseUtils = require('../utils/BaseUtils');

    var SVG_MAP = {};

    SVG_MAP[Constants.VANCHART] = Constants.VANCHART_SVG;
    SVG_MAP[Constants.PIE_CHART] = Constants.PIE_SVG;
    SVG_MAP[Constants.BAR_CHART] = Constants.BAR_SVG;
    SVG_MAP[Constants.COLUMN_CHART] = Constants.BAR_SVG;
    SVG_MAP[Constants.LINE_CHART] = Constants.LINE_SVG;
    SVG_MAP[Constants.AREA_CHART] = Constants.AREA_SVG;
    SVG_MAP[Constants.GAUGE_CHART] = Constants.GAUGE_SVG;
    SVG_MAP[Constants.RADAR_CHART] = Constants.RADAR_SVG;
    SVG_MAP[Constants.BUBBLE_CHART] = Constants.BUBBLE_SVG;
    SVG_MAP[Constants.SCATTER_CHART] = Constants.SCATTER_SVG;
    SVG_MAP[Constants.MAP_CHART] = Constants.MAP_SVG;


    SVG_MAP[Constants.TITLE_COMPONENT] = Constants.TITLE_SVG;
    SVG_MAP[Constants.DRILL_TOOLS] = Constants.DRILL_TOOLS_SVG;
    SVG_MAP[Constants.LEGEND_COMPONENT] = Constants.LEGEND_SVG;
    SVG_MAP[Constants.TOOLBAR_COMPONENT] = Constants.TOOLBAR_SVG;
    SVG_MAP[Constants.X_AXIS_COMPONENT] = Constants.AXIS_RENDER;
    SVG_MAP[Constants.Y_AXIS_COMPONENT] = Constants.AXIS_RENDER;
    SVG_MAP[Constants.RADIUS_AXIS_COMPONENT] = Constants.AXIS_RENDER;
    SVG_MAP[Constants.ANGLE_AXIS_COMPONENT] = Constants.AXIS_RENDER;
    SVG_MAP[Constants.RADIUS_AXIS_RENDER] = Constants.RADIUS_AXIS_SVG;
    SVG_MAP[Constants.ANGLE_AXIS_RENDER] = Constants.ANGLE_AXIS_SVG;
    SVG_MAP[Constants.CATEGORY_AXIS_COMPONENT] = Constants.CATEGORY_AXIS_SVG;
    SVG_MAP[Constants.VALUE_AXIS_COMPONENT] = Constants.VALUE_AXIS_SVG;
    SVG_MAP[Constants.DATE_AXIS_COMPONENT] = Constants.DATE_AXIS_SVG;
    SVG_MAP[Constants.ZOOM_COMPONENT] = Constants.ZOOM_SVG;
    SVG_MAP[Constants.DATA_SHEET_COMPONENT] = Constants.DATA_SHEET_SVG;
    SVG_MAP[Constants.RANGE_LEGEND_COMPONENT] = Constants.RANGE_LEGEND_SVG;

    var VML_MAP = {};
    VML_MAP[Constants.VANCHART] = Constants.VANCHART_VML;
    VML_MAP[Constants.PIE_CHART] = Constants.PIE_VML;
    VML_MAP[Constants.BAR_CHART] = Constants.BAR_VML;
    VML_MAP[Constants.COLUMN_CHART] = Constants.BAR_VML;
    VML_MAP[Constants.LINE_CHART] = Constants.LINE_VML;
    VML_MAP[Constants.AREA_CHART] = Constants.AREA_VML;
    VML_MAP[Constants.GAUGE_CHART] = Constants.GAUGE_VML;
    VML_MAP[Constants.RADAR_CHART] = Constants.RADAR_VML;
    VML_MAP[Constants.BUBBLE_CHART] = Constants.BUBBLE_VML;
    VML_MAP[Constants.SCATTER_CHART] = Constants.SCATTER_VML;
    VML_MAP[Constants.MAP_CHART] = Constants.MAP_VML;

    VML_MAP[Constants.TITLE_COMPONENT] = Constants.TITLE_VML;
    VML_MAP[Constants.DRILL_TOOLS] = Constants.DRILL_TOOLS_VML;
    VML_MAP[Constants.LEGEND_COMPONENT] = Constants.LEGEND_VML;
    VML_MAP[Constants.TOOLBAR_COMPONENT] = Constants.TOOLBAR_VML;
    VML_MAP[Constants.X_AXIS_COMPONENT] = Constants.AXIS_RENDER;
    VML_MAP[Constants.Y_AXIS_COMPONENT] = Constants.AXIS_RENDER;
    VML_MAP[Constants.RADIUS_AXIS_COMPONENT] = Constants.AXIS_RENDER;
    VML_MAP[Constants.ANGLE_AXIS_COMPONENT] = Constants.AXIS_RENDER;
    VML_MAP[Constants.RADIUS_AXIS_RENDER] = Constants.RADIUS_AXIS_VML;
    VML_MAP[Constants.ANGLE_AXIS_RENDER] = Constants.ANGLE_AXIS_VML;
    VML_MAP[Constants.CATEGORY_AXIS_COMPONENT] = Constants.CATEGORY_AXIS_VML;
    VML_MAP[Constants.VALUE_AXIS_COMPONENT] = Constants.VALUE_AXIS_VML;
    VML_MAP[Constants.DATE_AXIS_COMPONENT] = Constants.DATE_AXIS_VML;
    VML_MAP[Constants.DATA_SHEET_COMPONENT] = Constants.DATA_SHEET_VML;
    VML_MAP[Constants.RANGE_LEGEND_COMPONENT] = Constants.RANGE_LEGEND_VML;

    function getRender(componentTpe, attrObj){

        var renderName = BaseUtils.isSupportSVG() ?
                                SVG_MAP[componentTpe] : VML_MAP[componentTpe];

        return RenderLibrary.getRender(renderName, attrObj);
    }

    return {
        getRender:getRender
    }

});
/**
 * Created by eason on 16/5/26.
 */

define('dom/Browser',['require'],function(require){

    var ua = navigator.userAgent.toLowerCase(),
        doc = document.documentElement,

        ie = 'ActiveXObject' in window,

        webkit    = ua.indexOf('webkit') !== -1,
        phantomjs = ua.indexOf('phantom') !== -1,
        android23 = ua.search('android [23]') !== -1,
        chrome    = ua.indexOf('chrome') !== -1,
        gecko     = ua.indexOf('gecko') !== -1  && !webkit && !window.opera && !ie,

        mobile = typeof orientation !== 'undefined' || ua.indexOf('mobile') !== -1,
        msPointer = !window.PointerEvent && window.MSPointerEvent,
        pointer = window.PointerEvent || msPointer,

        ie3d = ie && ('transition' in doc.style),
        webkit3d = ('WebKitCSSMatrix' in window) && ('m11' in new window.WebKitCSSMatrix()) && !android23,
        gecko3d = 'MozPerspective' in doc.style,
        opera12 = 'OTransition' in doc.style;

    var touch = !window.L_NO_TOUCH && (pointer || 'ontouchstart' in window ||
        (window.DocumentTouch && document instanceof window.DocumentTouch));

    return {
        ie: ie,

        // @property ielt9: Boolean
        // `true` for Internet Explorer versions less than 9.
        ielt9: ie && !document.addEventListener,

        // @property edge: Boolean
        // `true` for the Edge web browser.
        edge: 'msLaunchUri' in navigator && !('documentMode' in document),

        // @property webkit: Boolean
        // `true` for webkit-based browsers like Chrome and Safari (including mobile versions).
        webkit: webkit,

        // @property gecko: Boolean
        // `true` for gecko-based browsers like Firefox.
        gecko: gecko,

        // @property android: Boolean
        // `true` for any browser running on an Android platform.
        android: ua.indexOf('android') !== -1,

        // @property android23: Boolean
        // `true` for browsers running on Android 2 or Android 3.
        android23: android23,

        // @property chrome: Boolean
        // `true` for the Chrome browser.
        chrome: chrome,

        // @property safari: Boolean
        // `true` for the Safari browser.
        safari: !chrome && ua.indexOf('safari') !== -1,


        // @property ie3d: Boolean
        // `true` for all Internet Explorer versions supporting CSS transforms.
        ie3d: ie3d,

        // @property webkit3d: Boolean
        // `true` for webkit-based browsers supporting CSS transforms.
        webkit3d: webkit3d,

        // @property gecko3d: Boolean
        // `true` for gecko-based browsers supporting CSS transforms.
        gecko3d: gecko3d,

        // @property opera12: Boolean
        // `true` for the Opera browser supporting CSS transforms (version 12 or later).
        opera12: opera12,

        // @property any3d: Boolean
        // `true` for all browsers supporting CSS transforms.
        any3d: !window.L_DISABLE_3D && (ie3d || webkit3d || gecko3d) && !opera12 && !phantomjs,


        // @property mobile: Boolean
        // `true` for all browsers running in a mobile device.
        mobile: mobile,

        // @property mobileWebkit: Boolean
        // `true` for all webkit-based browsers in a mobile device.
        mobileWebkit: mobile && webkit,

        // @property mobileWebkit3d: Boolean
        // `true` for all webkit-based browsers in a mobile device supporting CSS transforms.
        mobileWebkit3d: mobile && webkit3d,

        // @property mobileOpera: Boolean
        // `true` for the Opera browser in a mobile device.
        mobileOpera: mobile && window.opera,

        // @property mobileGecko: Boolean
        // `true` for gecko-based browsers running in a mobile device.
        mobileGecko: mobile && gecko,


        // @property touch: Boolean
        // `true` for all browsers supporting [touch events](https://developer.mozilla.org/docs/Web/API/Touch_events).
        touch: !!touch,

        // @property msPointer: Boolean
        // `true` for browsers implementing the Microsoft touch events model (notably IE10).
        msPointer: !!msPointer,

        // @property pointer: Boolean
        // `true` for all browsers supporting [pointer events](https://msdn.microsoft.com/en-us/library/dn433244%28v=vs.85%29.aspx).
        pointer: !!pointer,


        // @property retina: Boolean
        // `true` for browsers on a high-resolution "retina" screen.
        retina: (window.devicePixelRatio || (window.screen.deviceXDPI / window.screen.logicalXDPI)) > 1
    };
    
});

/**
 * Created by eason on 16/5/26.
 * 尝试换一种dom事件的实现方式
 */

define('dom/DomEvent',['require','../utils/BaseUtils','./Browser'],function(require){

    var eventsKey = '_vanchart_events';

    var BaseUtils = require('../utils/BaseUtils');
    var Browser = require('./Browser');

    var DomEvent = {

        // @function on(el: HTMLElement, types: String, fn: Function, context?: Object): this
        // Adds a listener function (`fn`) to a particular DOM dom type of the
        // element `el`. You can optionally specify the context of the listener
        // (object the `this` keyword will point to). You can also pass several
        // space-separated types (e.g. `'click dblclick'`).

        // @alternative
        // @function on(el: HTMLElement, eventMap: Object, context?: Object): this
        // Adds a set of type/listener pairs, e.g. `{click: onClick, mousemove: onMouseMove}`
        on: function (obj, types, fn, context) {

            // types can be a map of types/handlers
            if (typeof types === 'object') {
                for (var type in types) {
                    // we don't process space-separated events here for performance;
                    // it's a hot path since Layer uses the on(obj) syntax
                    this._on(obj, type, types[type], fn);
                }
            } else {
                // types can be a string of space-separated words
                types = BaseUtils.splitWords(types);

                for (var i = 0, len = types.length; i < len; i++) {
                    this._on(obj, types[i], fn, context);
                }
            }

            return this;
        },

        // @function off(el: HTMLElement, types: String, fn: Function, context?: Object)
        // Removes a previously added listener function. If no function is specified,
        // it will remove all the listeners of that particular DOM dom from the element.
        // Note that if you passed a custom context to on, you must pass the same
        // context to `off` in order to remove the listener.

        // @alternative
        // @function off(el: HTMLElement, types: eventMap: Object, context?: Object): this
        off: function (obj, types, fn, context) {

            if (!types) {
                // clear all listeners if called without arguments
                delete this._events;

            } else if (typeof types === 'object') {
                for (var type in types) {
                    this._off(obj, type, types[type], fn);
                }

            } else {
                types = BaseUtils.splitWords(types);

                for (var i = 0, len = types.length; i < len; i++) {
                    this._off(obj, types[i], fn, context);
                }
            }

            return this;
        },

        _on: function (obj, type, fn, context) {
            var id = type + BaseUtils.stamp(fn) + (context ? '_' + BaseUtils.stamp(context) : '');

            if (obj[eventsKey] && obj[eventsKey][id]) { return this; }

            var handler = function (e) {
                return fn.call(context || obj, e || window.event);
            };

            var originalHandler = handler;

            // if (Browser.pointer && type.indexOf('touch') === 0) {
            //     this.addPointerListener(obj, type, handler, id);
            //
            // } else if (Browser.touch && (type === 'dblclick') && this.addDoubleTapListener) {
            //     this.addDoubleTapListener(obj, handler, id);
            //
            // }

            if ('addEventListener' in obj) {

                if (type === 'mousewheel') {
                    obj.addEventListener('onwheel' in obj ? 'wheel' : 'mousewheel', handler, false);

                } else if ((type === 'mouseenter') || (type === 'mouseleave')) {
                    handler = function (e) {
                        e = e || window.event;
                        if (DomEvent._isExternalTarget(obj, e)) {
                            originalHandler(e);
                        }
                    };
                    obj.addEventListener(type === 'mouseenter' ? 'mouseover' : 'mouseout', handler, false);

                } else {
                    if (type === 'click' && Browser.android) {
                        handler = function (e) {
                            return DomEvent._filterClick(e, originalHandler);
                        };
                    }
                    obj.addEventListener(type, handler, false);
                }

            } else if ('attachEvent' in obj) {
                obj.attachEvent('on' + type, handler);
            }

            obj[eventsKey] = obj[eventsKey] || {};
            obj[eventsKey][id] = handler;

            return this;
        },

        _off: function (obj, type, fn, context) {

            var id = type + BaseUtils.stamp(fn) + (context ? '_' + BaseUtils.stamp(context) : ''),
                handler = obj[eventsKey] && obj[eventsKey][id];

            if (!handler) { return this; }

            // if (Browser.pointer && type.indexOf('touch') === 0) {
            //     this.removePointerListener(obj, type, id);
            //
            // } else if (Browser.touch && (type === 'dblclick') && this.removeDoubleTapListener) {
            //     this.removeDoubleTapListener(obj, id);
            //
            // }

            if ('removeEventListener' in obj) {

                if (type === 'mousewheel') {
                    obj.removeEventListener('onwheel' in obj ? 'wheel' : 'mousewheel', handler, false);

                } else {
                    obj.removeEventListener(
                        type === 'mouseenter' ? 'mouseover' :
                            type === 'mouseleave' ? 'mouseout' : type, handler, false);
                }

            } else if ('detachEvent' in obj) {
                obj.detachEvent('on' + type, handler);
            }

            obj[eventsKey][id] = null;

            return this;
        },

        // @function stopPropagation(ev: DOMEvent): this
        // Stop the given dom from propagation to parent elements. Used inside the listener functions:
        // ```js
        // DomEvent.on(div, 'click', function (ev) {
        // 	DomEvent.stopPropagation(ev);
        // });
        // ```
        stopPropagation: function (e) {

            if (e.stopPropagation) {
                e.stopPropagation();
            } else if (e.originalEvent) {  // In case of Leaflet dom.
                e.originalEvent._stopped = true;
            } else {
                e.cancelBubble = true;
            }

            DomEvent._skipped(e);

            return this;
        },

        // @function disableScrollPropagation(el: HTMLElement): this
        // Adds `stopPropagation` to the element's `'mousewheel'` events (plus browser variants).
        disableScrollPropagation: function (el) {
            return DomEvent.on(el, 'mousewheel', DomEvent.stopPropagation);
        },

        // @function disableClickPropagation(el: HTMLElement): this
        // Adds `stopPropagation` to the element's `'click'`, `'doubleclick'`,
        // `'mousedown'` and `'touchstart'` events (plus browser variants).
        disableClickPropagation: function (el) {
            var stop = DomEvent.stopPropagation;

            DomEvent.on(el, Draggable.START.join(' '), stop);

            return DomEvent.on(el, {
                click: DomEvent._fakeStop,
                dblclick: stop
            });
        },

        // @function preventDefault(ev: DOMEvent): this
        // Prevents the default action of the DOM Event `ev` from happening (such as
        // following a link in the href of the a element, or doing a POST request
        // with page reload when a `<form>` is submitted).
        // Use it inside listener functions.
        preventDefault: function (e) {

            if (e.preventDefault) {
                e.preventDefault();
            } else {
                e.returnValue = false;
            }
            return this;
        },

        // @function stop(ev): this
        // Does `stopPropagation` and `preventDefault` at the same time.
        stop: function (e) {
            return DomEvent.preventDefault(e).stopPropagation(e);
        },

        // @function getWheelDelta(ev: DOMEvent): Number
        // Gets normalized wheel delta from a mousewheel DOM dom, in vertical
        // pixels scrolled (negative if scrolling down).
        // Events from pointing devices without precise scrolling are mapped to
        // a best guess of between 50-60 pixels.
        getWheelDelta: function (e) {
            return (e.deltaY && e.deltaMode === 0) ? -e.deltaY :        // Pixels
                (e.deltaY && e.deltaMode === 1) ? -e.deltaY * 18 :   // Lines
                    (e.deltaY && e.deltaMode === 2) ? -e.deltaY * 52 :   // Pages
                        (e.deltaX || e.deltaZ) ? 0 :	// Skip horizontal/depth wheel events
                            e.wheelDelta ? (e.wheelDeltaY || e.wheelDelta) / 2 : // Legacy IE pixels
                                (e.detail && Math.abs(e.detail) < 32765) ? -e.detail * 18 : // Legacy Moz lines
                                    e.detail ? e.detail / -32765 * 52 : // Legacy Moz pages
                                        0;
        },

        _skipEvents: {},

        _fakeStop: function (e) {
            // fakes stopPropagation by setting a special dom flag, checked/reset with DomEvent._skipped(e)
            DomEvent._skipEvents[e.type] = true;
        },

        _skipped: function (e) {
            var skipped = this._skipEvents[e.type];
            // reset when checking, as it's only used in map container and propagates outside of the map
            this._skipEvents[e.type] = false;
            return skipped;
        },

        // check if element really left/entered the dom target (for mouseenter/mouseleave)
        _isExternalTarget: function (el, e) {

            var related = e.relatedTarget;

            if (!related) { return true; }

            try {
                while (related && (related !== el)) {
                    related = related.parentNode;
                }
            } catch (err) {
                return false;
            }
            return (related !== el);
        },

        // this is a horrible workaround for a bug in Android where a single touch triggers two click events
        _filterClick: function (e, handler) {
            var timeStamp = (e.timeStamp || (e.originalEvent && e.originalEvent.timeStamp)),
                elapsed = DomEvent._lastClick && (timeStamp - DomEvent._lastClick);

            // are they closer together than 500ms yet more than 100ms?
            // Android typically triggers them ~300ms apart while multiple listeners
            // on the same dom should be triggered far faster;
            // or check if click is simulated on the element, and if it is, reject any non-simulated events

            if ((elapsed && elapsed > 100 && elapsed < 500) || (e.target._simulatedClick && !e._simulated)) {
                DomEvent.stop(e);
                return;
            }

            DomEvent._lastClick = timeStamp;

            handler(e);
        }
    };

    DomEvent.addListener = DomEvent.on;

    DomEvent.removeListener = DomEvent.off;

    return DomEvent;

});

/**
 * Created by eason on 16/5/26.
 */

define('dom/Evented',['require','../utils/QueryUtils','../utils/BaseUtils'],function(require){

    var QueryUtils = require('../utils/QueryUtils');
    var BaseUtils = require('../utils/BaseUtils');

    return {
        /* @method on(type: String, fn: Function, context?: Object): this
         * Adds a listener function (`fn`) to a particular event type of the object. You can optionally specify the context of the listener (object the this keyword will point to). You can also pass several space-separated types (e.g. `'click dblclick'`).
         *
         * @alternative
         * @method on(eventMap: Object): this
         * Adds a set of type/listener pairs, e.g. `{click: onClick, mousemove: onMouseMove}`
         */
        on: function (types, fn, context) {

            // types can be a map of types/handlers
            if (typeof types === 'object') {
                for (var type in types) {
                    // we don't process space-separated events here for performance;
                    // it's a hot path since Layer uses the on(obj) syntax
                    this._on(type, types[type], fn);
                }

            } else {
                // types can be a string of space-separated words
                types = BaseUtils.splitWords(types);

                for (var i = 0, len = types.length; i < len; i++) {
                    this._on(types[i], fn, context);
                }
            }

            return this;
        },

        /* @method off(type: String, fn?: Function, context?: Object): this
         * Removes a previously added listener function. If no function is specified, it will remove all the listeners of that particular event from the object. Note that if you passed a custom context to `on`, you must pass the same context to `off` in order to remove the listener.
         *
         * @alternative
         * @method off(eventMap: Object): this
         * Removes a set of type/listener pairs.
         *
         * @alternative
         * @method off: this
         * Removes all listeners to all events on the object.
         */
        off: function (types, fn, context) {

            if (!types) {
                // clear all listeners if called without arguments
                delete this._events;

            } else if (typeof types === 'object') {
                for (var type in types) {
                    this._off(type, types[type], fn);
                }

            } else {
                types = BaseUtils.splitWords(types);

                for (var i = 0, len = types.length; i < len; i++) {
                    this._off(types[i], fn, context);
                }
            }

            return this;
        },

        // attach listener (without syntactic sugar now)
        _on: function (type, fn, context) {

            var events = this._events = this._events || {},
                contextId = context && context !== this && BaseUtils.stamp(context);

            if (contextId) {
                // store listeners with custom context in a separate hash (if it has an id);
                // gives a major performance boost when firing and removing events (e.g. on map object)

                var indexKey = type + '_idx',
                    indexLenKey = type + '_len',
                    typeIndex = events[indexKey] = events[indexKey] || {},
                    id = BaseUtils.stamp(fn) + '_' + contextId;

                if (!typeIndex[id]) {
                    typeIndex[id] = {fn: fn, ctx: context};

                    // keep track of the number of keys in the index to quickly check if it's empty
                    events[indexLenKey] = (events[indexLenKey] || 0) + 1;
                }

            } else {
                // individual layers mostly use "this" for context and don't fire listeners too often
                // so simple array makes the memory footprint better while not degrading performance

                events[type] = events[type] || [];
                events[type].push({fn: fn});
            }
        },

        _off: function (type, fn, context) {
            var events = this._events,
                indexKey = type + '_idx',
                indexLenKey = type + '_len';

            if (!events) { return; }

            if (!fn) {
                // clear all listeners for a type if function isn't specified
                delete events[type];
                delete events[indexKey];
                delete events[indexLenKey];
                return;
            }

            var contextId = context && context !== this && BaseUtils.stamp(context),
                listeners, i, len, listener, id;

            if (contextId) {
                id = BaseUtils.stamp(fn) + '_' + contextId;
                listeners = events[indexKey];

                if (listeners && listeners[id]) {
                    listener = listeners[id];
                    delete listeners[id];
                    events[indexLenKey]--;
                }

            } else {
                listeners = events[type];

                if (listeners) {
                    for (i = 0, len = listeners.length; i < len; i++) {
                        if (listeners[i].fn === fn) {
                            listener = listeners[i];
                            listeners.splice(i, 1);
                            break;
                        }
                    }
                }
            }

            // set the removed listener to noop so that's not called if remove happens in fire
            if (listener) {
                listener.fn = BaseUtils.falseFn;
            }
        },

        // @method fire(type: String, data?: Object, propagate?: Boolean): this
        // Fires an event of the specified type. You can optionally provide an data
        // object — the first argument of the listener function will contain its
        // properties. The event might can optionally be propagated to event parents.
        fire: function (type, data, propagate) {
            if (!this.listens(type, propagate)) { return this; }

            var event = BaseUtils.extend({}, data, {type: type, target: this}),
                events = this._events;

            if (events) {
                var typeIndex = events[type + '_idx'],
                    i, len, listeners, id;

                if (events[type]) {
                    // make sure adding/removing listeners inside other listeners won't cause infinite loop
                    listeners = events[type].slice();

                    for (i = 0, len = listeners.length; i < len; i++) {
                        listeners[i].fn.call(this, event);
                    }
                }

                // fire event for the context-indexed listeners as well
                for (id in typeIndex) {
                    typeIndex[id].fn.call(typeIndex[id].ctx, event);
                }
            }

            if (propagate) {
                // propagate the event to parents (set with addEventParent)
                this._propagateEvent(event);
            }

            return this;
        },

        // @method listens(type: String): Boolean
        // Returns `true` if a particular event type has any listeners attached to it.
        listens: function (type, propagate) {
            var events = this._events;

            if (events && (events[type] || events[type + '_len'])) { return true; }

            if (propagate) {
                // also check parents for listeners if event propagates
                for (var id in this._eventParents) {
                    if (this._eventParents[id].listens(type, propagate)) { return true; }
                }
            }
            return false;
        },

        // @method once(…): this
        // Behaves as [`on(…)`](#evented-on), except the listener will only get fired once and then removed.
        // once: function (types, fn, context) {
        //
        //     if (typeof types === 'object') {
        //         for (var type in types) {
        //             this.once(type, types[type], fn);
        //         }
        //         return this;
        //     }
        //
        //     var handler = L.bind(function () {
        //         this
        //             .off(types, fn, context)
        //             .off(types, handler, context);
        //     }, this);
        //
        //     // add a listener that's executed once and removed after that
        //     return this
        //         .on(types, fn, context)
        //         .on(types, handler, context);
        // },

        // @method addEventParent(obj: Evented): this
        // Adds an event parent - an `Evented` that will receive propagated events
        addEventParent: function (obj) {
            this._eventParents = this._eventParents || {};
            this._eventParents[BaseUtils.stamp(obj)] = obj;
            return this;
        },

        // @method removeEventParent(obj: Evented): this
        // Removes an event parent, so it will stop receiving propagated events
        removeEventParent: function (obj) {
            if (this._eventParents) {
                delete this._eventParents[BaseUtils.stamp(obj)];
            }
            return this;
        },

        _propagateEvent: function (e) {
            for (var id in this._eventParents) {
                this._eventParents[id].fire(e.type, BaseUtils.extend({layer: e.target}, e), true);
            }
        }
    }
});
/**
 * Created by eason on 16/2/19.
 * 处理事件
 */

define('Handler',['require','./utils/BaseUtils','./Constants','./dom/DomEvent','./dom/Evented'],function(require){

    var MIN_DISTANCE = 5;

    var BaseUtils = require('./utils/BaseUtils');
    var Constants = require('./Constants');
    var DomEvent = require('./dom/DomEvent');
    var Evented = require('./dom/Evented');

    function Handler(vanchart, container){

        this.vanchart = vanchart;

        this._container = container;

        this._targets = {};

        !vanchart._leaflet && this._initEvents();
    }

    Handler.prototype = {

        _initEvents:function(){
            BaseUtils.extend(this, Evented);

            this.initTargets();

            if(BaseUtils.hasTouch()){
                this.on({
                    'touchstart':this._onContainerMouseMove,
                    'touchend':this._onContainerMouseUp
                }, this);

                DomEvent.on(this._container, 'touchstart touchend', this._handleDOMEvent, this);

            }else{
                this.on({
                    'mousemove':this._onContainerMouseMove,
                    'mousedown':this._onContainerMouseDown,
                    'mouseup':this._onContainerMouseUp,
                    'mouseout':this._onContainerMouseOut
                }, this);

                DomEvent.on(this._container, 'click dblclick mousedown mouseup ' +
                    'mouseout mouseover mousemove contextmenu keypress', this._handleDOMEvent, this);
            }
        },

        initTargets:function(){
            this._targets = {};
            this._targets[BaseUtils.stamp(this._container)] = this;
        },

        _handleDOMEvent: function (e) {
            if (DomEvent._skipped(e)) { return; }

            var type = e.type === 'keypress' && e.keyCode === 13 ? 'click' : e.type;

            this._fireDOMEvent(e, type);
        },

        _fireDOMEvent: function (e, type, targets) {

            if (e._stopped) { return; }

            // Find the layer the event is propagating from and its parents.
            targets = (targets || []).concat(this._findEventTargets(e, type));

            if (!targets.length) { return; }

            var target = targets[0];
            if (type === 'contextmenu' && target.listens(type, true)) {
                DomEvent.preventDefault(e);
            }

            var data = {
                originalEvent: e
            };

            if (e.type !== 'keypress') {
                data.containerPoint = BaseUtils.getMousePos(e, this._container);
            }

            for (var i = 0; i < targets.length; i++) {
                targets[i].fire(type, data, true);
                if (data.originalEvent._stopped) { return; }
            }
        },

        _findEventTargets: function (e, type) {
            var targets = [],
                target,
                isHover = type === 'mouseout' || type === 'mouseover' || type == 'touchstart' || type == 'touchend',
                src = e.target || e.srcElement,
                dragging = false;

            while (src) {
                target = this._targets[BaseUtils.stamp(src)];
                if (target && (type === 'click' || type === 'preclick') && !e._simulated) {
                    // Prevent firing click after you just dragged an object.
                    dragging = true;
                    break;
                }
                if (target && target.listens(type, true)) {
                    if (isHover && !DomEvent._isExternalTarget(src, e)) { break; }
                    targets.push(target);
                    if (isHover) {
                        break;
                    }
                }
                if (src === this._container) { break; }
                src = src.parentNode;
            }
            if (!targets.length && !dragging && !isHover && DomEvent._isExternalTarget(src, e)) {
                targets = [this];
            }
            return targets;
        },

        addInteractiveTarget:function(domWrapper, types, render){

            BaseUtils.extend(domWrapper, Evented);

            var domEl =  BaseUtils.isSupportSVG() ?  domWrapper.node() : domWrapper.node;

            var data = domWrapper.datum();

            this._targets[BaseUtils.stamp(domEl)] = domWrapper;
            
            this._targets[BaseUtils.stamp(data)] = domWrapper;

            domWrapper.on(types, render);
        },

        fireEventByData:function(data, type, event){
            var target = data ? this._targets[BaseUtils.stamp(data)] : null;

            target && target.fire(type, event)
        },

        _onContainerMouseOut:function(){
            var tooltip = this.vanchart.getTooltip();
            tooltip && tooltip.hide();
        },

        _onContainerMouseDown:function(event){

            var chart = this.vanchart;
            var hoverPoint = this.vanchart.hoverPoint;
            var mousePos = event.containerPoint;
            var plotBounds = chart.getPlotBounds();
            var tooltip = chart.getTooltip();

            chart.isMouseDown = true;
            chart.downPos = mousePos;

            tooltip.immediateHide();

            //饼图旋转
            if(hoverPoint){
                var seriesChart = hoverPoint.series.chart;
                this._draggingTarget = seriesChart.findDraggingTarget && seriesChart.findDraggingTarget(event);
            }

            //缩放
            if(!this._draggingTarget && this._supportCoordinateZoom() && BaseUtils.containsPoint(plotBounds, mousePos)){
                this.selectRect = this.vanchart.render.getRenderRoot().append('rect');
            }
        },

        _onContainerMouseUp:function(event){

            var chart = this.vanchart;
            var components = chart.components;
            var upPos = event.containerPoint;

            if(this.selectRect){

                if(chart.downPos && upPos){
                    if(BaseUtils.distance(chart.downPos, upPos) > MIN_DISTANCE){
                        chart.dealAxisZoom(chart.downPos, upPos);

                        if(components[Constants.TOOLBAR_COMPONENT]){
                            var toolbar = components[Constants.TOOLBAR_COMPONENT];
                            toolbar.showRefreshIconWhenZoom();
                        }
                    }
                }

                this.selectRect.remove();
                this.selectRect = null;
            }

            if(chart.isMouseDown && this._draggingTarget){
                this._draggingTarget.dragEnd(event);
                this._draggingTarget = null;
            }

            if(chart.hoverPoint && this.validClick(upPos)){
                chart.hoverPoint.onClick(event.originalEvent)
            }

            chart.isMouseDown = false;
            chart.downPos = null;
        },

        _onContainerMouseMove:function(event){

            var chart = this.vanchart;
            var currentPos = event.containerPoint;
            var hoverPoint = this.vanchart.hoverPoint;

            var plotBounds = this.vanchart.getPlotBounds();
            var options = this.vanchart.getOptions();

            var sharedAxis = chart.getSharedAxis();

            if(this.selectRect){

                var zoomType = options.zoom.zoomType;

                var x = Math.min(currentPos[0], chart.downPos[0]);
                var y = Math.min(currentPos[1], chart.downPos[1]);
                var width = Math.abs(currentPos[0] - chart.downPos[0]);
                var height = Math.abs(currentPos[1] - chart.downPos[1]);

                var isXZoom = zoomType.indexOf('x') != -1;
                var isYZoom = zoomType.indexOf('y') != -1;

                if(isXZoom && !isYZoom){
                    y = plotBounds.y;
                    height = plotBounds.height;
                }else if(isYZoom && !isXZoom){
                    x = plotBounds.x;
                    width = plotBounds.width;
                }

                this.selectRect.attr('x', x).attr('y', y)
                    .attr('width', width).attr('height', height)
                    .style({'fill':'rgba(69,114,167,0.25)'});
            }

            var tooltip = this.vanchart.getTooltip();
            var isInPlot = BaseUtils.containsPoint(plotBounds,currentPos);
            if(isInPlot) {

                // 1. Charts that don't support shared tooltip get priority.
                if (hoverPoint && !hoverPoint.series.supportSharedTooltip) {

                    sharedAxis && sharedAxis.getRender().removeHighlightBand();
                    this._setCoveredKey(null);

                } else {

                // 2. May support shared tooltip

                    // 2.1 Listen to area.
                    //     if this category(not value/datetime) has shared points,
                    //     the axis dominates coordinate's area.
                    //     i.e. ignore other normal points tooltip at this category.
                    if (sharedAxis &&
                        sharedAxis.type === Constants.CATEGORY_AXIS_COMPONENT &&
                        this._getCoveredPointsByPos(currentPos).length !== 0) {

                        this._highlightShared(event);

                    } else if (hoverPoint) {
                    // 2.2 Listen to hover point.
                    //     no shared or shared value/datetime axis listens to hover point.

                        // line & area have 'closestPoint',
                        // otherwise events fire on the shape itself
                        var seriesChart = hoverPoint.series.chart;
                        var closestPoint = seriesChart.getClosestPoint(currentPos);

                        // 2.2.1 No shared, choose single one
                        if (closestPoint && !(closestPoint.tooltip && closestPoint.tooltip.shared)) {

                            sharedAxis && sharedAxis.getRender().removeHighlightBand();
                            this._setCoveredKey(null);

                            if (closestPoint != hoverPoint) {

                                this.fireEventByData(hoverPoint, 'mouseout', event);

                                this.fireEventByData(closestPoint, 'mouseover', event);

                            }

                        } else {
                        // 2.2.2 Highlight shared points according to hovered one.

                            // hoverPoint here may not be the real hovered one,
                            // for line/area, it points out the hovered series.
                            var tmpPoint = closestPoint || hoverPoint;
                            this._highlightShared(event, tmpPoint);
                        }
                    }
                }

                //canvas的时候通过位置判断
                var scatter = chart.getChart(Constants.SCATTER_CHART) || chart.getChart(Constants.BUBBLE_CHART);
                if(scatter && scatter.isLargeMode()){
                    chart.hoverPoint = scatter.getClosestPoint(currentPos);
                }
            }

            //没有数据点共享的时候显示当前选中的数据点
            if(!this.vanchart.coveredKey){
                tooltip.showWithPoint(chart.hoverPoint);
            }

            if ((!isInPlot && this.vanchart.coveredKey) || this._draggingTarget) {
                // reset
                tooltip.hide();
                hoverPoint && this.fireEventByData(hoverPoint, 'mouseout', event);
                sharedAxis && sharedAxis.getRender().removeHighlightBand();
                this._setCoveredKey(null);
            }

            //drag operation
            if(chart.isMouseDown && this._draggingTarget){
                this._draggingTarget.onDrag(event);
            }
        },

        _getCoveredPointsByPos: function (pos, axis) {
            axis = axis || this.vanchart.getSharedAxis();
            var index = axis.getIndexByPosition(pos);
            var key = (axis.type === Constants.CATEGORY_AXIS_COMPONENT) ? axis.scale.domain()[index] : index;
            return this._getCoveredPointsByKey(key);
        },

        _getCoveredPointsByKey: function (key, axis) {
            axis = axis || this.vanchart.getSharedAxis();
            return key && axis && axis.sharedPoints[key] || [];
        },

        _setCoveredKey: function (key) {
            if (key === null) {
                if (BaseUtils.isNull(this.vanchart.coveredKey)) {
                    return;
                }

                var prePoints = this._getCoveredPointsByKey(this.vanchart.coveredKey);
                prePoints.map(function (point) {
                    this.fireEventByData(point, 'leave', event);
                },this);

            } else if (typeof key === 'string' || !isNaN(key)) {

                if (this.vanchart.coveredKey === key){
                    return;
                }

                this._setCoveredKey(null);

                var points = this._getCoveredPointsByKey(key);
                points.map(function (point) {
                    this.fireEventByData(point, 'cover', event);
                }, this);

            } else {

                throw new TypeError(key);
            }

            this.vanchart.coveredKey = key;
        },

        _highlightShared: function (event, point) {
            var axis = this.vanchart.getSharedAxis();
            if (!axis) {
                return;
            }

            var dom = this.vanchart.getParentDom();
            var pos = BaseUtils.getMousePos(event, dom);
            var tooltip = this.vanchart.getTooltip();

            var key;

            if (point) {
                key = point.category;
            } else {
                var index = axis.getIndexByPosition(pos);
                key = (axis.type === Constants.CATEGORY_AXIS_COMPONENT) ? axis.scale.domain()[index] : index;
            }

            if (this._getCoveredPointsByKey(key).length !== 0) {

                axis.getRender().drawHighlightBand(pos);
                this._setCoveredKey(key);
                this.fireEventByData(this.vanchart.hoverSeries, 'forceMouseOut', event);
                
                // todo, shouldn't calculate dim&content every time
                tooltip.showWithSharedPoints(this._getCoveredPointsByKey(this.vanchart.coveredKey));

            } else {
                axis.getRender().removeHighlightBand();
                tooltip.hide();
            }

        },

        // todo ugly method to be removed
        _supportCoordinateZoom:function(){

            var option = this.vanchart.getOptions();

            var hoverPoint = this.vanchart.hoverPoint;

            if(hoverPoint && hoverPoint.series.chart.isUpdateWithForce()){
                return;
            }

            return BaseUtils.isSupportSVG() && option.zoom && option.zoom.zoomType;
        },

        validClick:function(currentPos){

            if(this.vanchart.downPos){
                return BaseUtils.distance(this.vanchart.downPos, currentPos) < MIN_DISTANCE;
            }

            return true;
        }

    };


    return Handler;
});
/**
 * Created by eason on 15/9/7.
 */

define('utils/Formatter',['require','./BaseUtils'],function(require){

    var BaseUtils = require('./BaseUtils');

    function format(cv, fmt){

        fmt = BaseUtils.getFormatterFunction(fmt);

        return fmt ? fmt.bind(cv)(cv) : cv;
    }

    return {
        format:format
    }

});
/**
 * Created by Yuqian on 16/5/19.
 */

define('theme/options',['require','../Constants'],function (require) {
    var Constants = require('../Constants');

    var options = {};

    options[Constants.PIE_CHART] = {
        plotOptions: {

        }
    };

    options[Constants.COLUMN_CHART] = {
        plotOptions: {
            categoryGap: '20%',
            gap: '20%'
        }

    };

    options[Constants.BAR_CHART] = {
        plotOptions: {

        }

    };

    options[Constants.LINE_CHART] = options[Constants.AREA_CHART] = {

        plotOptions:{
            large:false,

            marker:{
                symbol:'null_marker'
            },

            dataLabels:{
                "enabled": false,
                "align": "outside"
            }
        }
    };

    options[Constants.GAUGE_CHART] = {
        plotOptions: {

        }

    };

    options[Constants.RADAR_CHART] = {

        plotOptions:{
            columnType:false,
            marker:{
                symbol:'null_marker'
            },

            borderWidth:1,

            borderColor:'white',

            lineWidth:1
        }

    };

    options[Constants.SCATTER_CHART] = {
        plotOptions: {

        }

    };

    options[Constants.BUBBLE_CHART] = {
        plotOptions: {

        }

    };

    options[Constants.MAP_CHART] = {

        plotOptions:{
            fillColor:'#cccccc',
            fillColorOpacity:0.75,
            borderColor:'#ffffff',
            borderWidth:1,
            borderOpacity:1
        }
    };

    return options
});
/**
 * Created by eason on 16/2/19.
 * 数据点的抽象
 */
define('component/Point',['require','../utils/QueryUtils','../utils/BaseUtils','../utils/ColorUtils','../utils/Formatter','../Constants','../theme/options'],function(require){

    var QueryUtils = require('../utils/QueryUtils');
    var BaseUtils = require('../utils/BaseUtils');
    var ColorUtils = require('../utils/ColorUtils');
    var Formatter = require('../utils/Formatter');
    var Constants = require('../Constants');
    var Options = require('../theme/options');

    var CATEGORY = 'CATEGORY';
    var SERIES = 'SERIES';
    var VALUE = 'VALUE';
    var PERCENT = 'PERCENT';

    var LABEL_GAP = 2;

    function Point(series, pointOption, index){
        if(series && pointOption){
            this.series = series;

            //排序以后的顺序根据初始状态的index确定
            this.index = index;

            this.pointOption = pointOption;

            this.updateClassName(index);

            this._init(pointOption);
        }
    }

    Point.prototype = {

        constructor:Point,

        isPoint:true,

        _init:function(pointOption){

            var series = this.series;
            var chart = this.series.chart;

            var queryList = [
                pointOption,
                series.seriesOption,
                series.chart.option.plotOptions[series.type],
                series.chart.option.plotOptions,
                Options[series.type].plotOptions
            ];

            var dataLabels = QueryUtils.queryList(queryList, 'dataLabels');
            var tooltip = QueryUtils.queryList(queryList, 'tooltip');

            var gaussValue = BaseUtils.pick(pointOption.y, pointOption[2], pointOption.value);
            var value = series.valueAxis ? series.valueAxis.getValueFromData(pointOption) : gaussValue;
            var isNull = value === '-' || value === undefined || (series.valueAxis && series.valueAxis.componentOption.log && value <= 0);
            value = isNull ? 0 : value;//用于计算

            var category = (series.baseAxis && !series.chart.isForceBubble()) ? series.baseAxis.getValueFromData(pointOption, this.index) : BaseUtils.pick( pointOption.x, series.seriesOption.name);
            var seriesName = series.name;

            //饼图要反过来
            if (series.type === Constants.PIE_CHART || series.type === Constants.GAUGE_CHART) {
                seriesName = [category, category = seriesName][0];
                seriesName = BaseUtils.isNull(seriesName) ? 'SeriesX' + this.index : seriesName; 
            }

            if (series.type === Constants.GAUGE_CHART) {
                // don't occupy default color index
                var color = '#000';
            } else {
                var color = chart.vanchart.getDefaultSeriesColor(seriesName);
            }

            //范围图例覆盖系列色
            var rangeLegend = chart.vanchart.getComponent(Constants.RANGE_LEGEND_COMPONENT);
            if(rangeLegend){
                var size = BaseUtils.pick(QueryUtils.queryList(queryList, 'size'), 0);

                size = chart.isForceBubble() ? pointOption.y : size;

                color = rangeLegend.getColorWithSize(size) || color;
            }

            color = QueryUtils.queryList(queryList, 'color') || color;
            color = series._getBandsColor(this) || color;

            var clickColor = ColorUtils.getClickColor(color);

            QueryUtils.merge(this, {
                value:value,
                y:value,
                y0:series.valueAxis ? series.valueAxis.getStartPosValue() : 0,

                category: category,
                seriesName: seriesName,
                visible : BaseUtils.pick(pointOption.visible, true),

                //todo 写到这里的感觉是,有些属性应该根据坐标轴的不同来merge
                name:pointOption.name,
                lnglat:pointOption.lnglat,

                isNull:isNull,
                style:series.style,
                color:color,
                clickColor:clickColor,
                hyperlink:QueryUtils.queryList(queryList, 'hyperlink'),
                jsonHyperlink:QueryUtils.queryList(queryList, 'jsonHyperlink'),
                click:QueryUtils.queryList(queryList, 'click'),
                borderWidth:QueryUtils.queryList(queryList, 'borderWidth') || 0,
                borderColor:QueryUtils.queryList(queryList, 'borderColor') || 'white',
                borderRadius:QueryUtils.queryList(queryList, 'borderRadius') || 0,
                image:QueryUtils.queryList(queryList, 'image'),
                imageWidth:QueryUtils.queryList(queryList, 'imageWidth') || 0,
                imageHeight:QueryUtils.queryList(queryList, 'imageHeight') || 0,
                dataLabels:isNull ? null : dataLabels,
                tooltip:tooltip,
                mouseOverColor:QueryUtils.queryList(queryList, 'mouseOverColor') || ColorUtils.getHighLightColor(color)
            }, true);

            chart.mergeDataPointAttributes(this);
        },

        updateClassName:function(index){
            this.className = 'vancharts-dataPoint-series' + this.series.index + 'point' + index;
        },

        setPercentage:function(percentage){

            this.percentage = percentage;

            //算晚百分比才能算具体的标签的内容
            if(this.dataLabels && this.dataLabels.enabled){
                QueryUtils.merge(this, this._calculateLabelInfo(this.dataLabels), true);
            }
        },

        _calculateLabelInfo:function(labelInfo){

            var dataLabels = labelInfo || {};
            var formatter =  dataLabels.formatter;
            var useHtml = dataLabels.useHtml;

            if(!formatter){
                return {};
            }

            var content = [];

            if(typeof formatter == 'object'){

                var label = formatter.identifier;

                if(label.indexOf(CATEGORY) != -1 || label.indexOf(SERIES) != -1){

                    var categoryString = Formatter.format(this.category, formatter.categoryFormat);
                    var seriesString = Formatter.format(this.seriesName, formatter.seriesFormat);

                    var text;
                    if(label.indexOf(CATEGORY) != -1 && label.indexOf(SERIES) != -1){
                        text = categoryString + ' ' + seriesString;
                    }else if(label.indexOf(CATEGORY) != -1){
                        text = categoryString;
                    }else{
                        text = seriesString;
                    }

                    var style = this.getCategorySeriesStyle(dataLabels);
                    var dim = BaseUtils.getTextDimension(text, style, useHtml);
                    content.push({
                        text:text,
                        style:style,
                        dim:dim
                    });

                }

                if(label.indexOf(VALUE) != -1 || label.indexOf(PERCENT) != -1){

                    var valueString = Formatter.format(this.value, formatter.valueFormat);

                    var percentString = Formatter.format(this.percentage, formatter.percentFormat);

                    var text = '';

                    if(label.indexOf(VALUE) != -1 && label.indexOf(PERCENT) != -1){
                        text = valueString + ' ' + percentString;
                    }else if(label.indexOf(VALUE) != -1){
                        text = valueString;
                    }else{
                        text = percentString;
                    }

                    var style = this.getValuePercentageStyle(dataLabels);
                    var dim = BaseUtils.getTextDimension(text, style, useHtml);
                    content.push({
                        text:text,
                        style:style,
                        dim:dim
                    });
                }

            }else{
                this.pushCustomLabelContent(formatter, dataLabels, useHtml, content);
            }

            var labelDim = this.calculateTextDim(content);

            return {
                labelContent:content,
                labelDim:labelDim
            };

        },

        pushCustomLabelContent:function(formatter, dataLabels, useHtml, content, defaultPosition){
            var text = BaseUtils.getFormatterFunction(formatter).call(this);
            var style = this.getValuePercentageStyle(dataLabels, defaultPosition);
            var dim = BaseUtils.getTextDimension(text, style, useHtml);

            if(dataLabels.useHtml){
                dim.width = isNaN(parseFloat(dataLabels.labelWidth)) ? dim.width : parseFloat(dataLabels.labelWidth);
                dim.height = isNaN(parseFloat(dataLabels.labelHeight)) ? dim.height : parseFloat(dataLabels.labelHeight);
            }

            content.push({
                text:text,
                style:style,
                dim:dim
            });
        },

        calculateTextDim:function(labelContent){

            var width = 0;
            var height = 0;

            if(labelContent && labelContent.length){

                for(var i = 0, count = labelContent.length; i < count; i++){
                    var dim = labelContent[i].dim;

                    width = Math.max(width, dim.width);

                    height += dim.height;
                }

                height += (count - 1) * LABEL_GAP;
            }

            return {
                width:width,
                height:height
            };
        },

        getCategorySeriesStyle:function(dataLabels, defaultPosition){

            if(dataLabels && dataLabels.style){
                return dataLabels.style;
            }

            var position = defaultPosition ||
                 (this.columnType ? Constants.INSIDE : (dataLabels.align || Constants.OUTSIDE));

            return {
                color:position == Constants.OUTSIDE ? this.color : '#ffffff',
                fontSize:'12px',
                fontFamily:'Verdana',
                fontWeight:'bold'
            }

        },

        getValuePercentageStyle:function(dataLabels, defaultPosition){

            if(dataLabels && dataLabels.style){
                return dataLabels.style;
            }

            var position = defaultPosition ||
                 (this.columnType ? Constants.INSIDE : (dataLabels.align || Constants.OUTSIDE));

            return {
                fontSize:'12px',
                fontFamily:'Verdana',
                textShadow:'1px 1px 1px rgba(0,0,0,0.15)',
                color: position == Constants.OUTSIDE ? this.color : '#ffffff'
            };
        },

        onClick:function(event){
            if(this.click){
                this.click.call(this, event);
            }else if(this.hyperlink){
                event = event || window.event;
                var hyperlink = this.hyperlink;
                if(hyperlink && window.FR){
                    FR.doHyperlink(event, (new Function("return " + hyperlink))(), true);
                }
            }
        }

    };

    return Point;
});

/**
 * Created by eason on 16/2/19.
 * 系列的抽象
 */
define('component/Series',['require','../utils/BaseUtils','../utils/QueryUtils','../Constants','./Point','../theme/options'],function(require){

    var BaseUtils = require('../utils/BaseUtils');
    var QueryUtils = require('../utils/QueryUtils');
    var Constants = require('../Constants');
    var Point = require('./Point');
    var Options = require('../theme/options');


    function Series(chart, seriesOption, index){

        this.chart = chart;

        this.index = index;

        this._init(seriesOption);
    }


    Series.prototype = {

        constructor:Series,

        isSeries:true,

        _init:function(seriesOption){

            var vanchart = this.chart.vanchart;

            var plotOptions = this.chart.option.plotOptions;

            this.type = this.chart.componentType;

            var queryList = [
                seriesOption,
                plotOptions[this.type],
                plotOptions,
                Options[this.type].plotOptions
            ];

            this.seriesOption = seriesOption;

            this.name = BaseUtils.pick(seriesOption.name, 'Series' + this.index);

            this.className = 'vancharts-series-' + this.index;

            // pie charts have colors inside 
            if (this.type !== Constants.PIE_CHART && this.type !== Constants.GAUGE_CHART) {
                this.color = QueryUtils.queryList(queryList, 'color') || this.chart._getDefaultSeriesColor(this.name);
            }

            this.visible = QueryUtils.queryList(queryList, 'visible');
            this.stack = QueryUtils.queryList(queryList, 'stack');
            this.stackByPercent = QueryUtils.queryList(queryList, 'stackByPercent');
            this.style = QueryUtils.queryList(queryList, 'style');
            this.trendLine = QueryUtils.queryList(queryList, 'trendLine');
            this.bands = QueryUtils.queryList(queryList, 'bands');

            this.tooltip = QueryUtils.queryList(queryList, 'tooltip');

            this.supportSharedTooltip = false;
            if ([
                    Constants.BAR_CHART,
                    Constants.COLUMN_CHART,
                    Constants.LINE_CHART,
                    Constants.AREA_CHART,
                    Constants.RADAR_CHART
                ].indexOf(this.type) !== -1 ) {
                this.supportSharedTooltip = true;
            }

            var marker = BaseUtils.clone(QueryUtils.queryList(queryList, 'marker'));
            //ie暂时不支持图片
            if(marker && (!BaseUtils.isSupportSVG() || BaseUtils.isIE()) && BaseUtils.isImageMarker(marker.symbol)){
                marker.symbol = Constants.CIRCLE;
            }
            this.marker = marker;

            switch (this.type) {
                case Constants.PIE_CHART:
                    break;
                case Constants.GAUGE_CHART:
                    this.gaugeAxis = vanchart.gaugeAxis(QueryUtils.queryList(queryList, 'gaugeAxis'));
                    break;
                case Constants.RADAR_CHART:
                    
                    var isColumnType = QueryUtils.queryList(queryList, 'columnType');
                    if (isColumnType) {
                        this.stack = Constants.RADAR_CHART;
                    }

                    this.polar = vanchart.polar(QueryUtils.queryList(queryList, 'polar'));

                    this.radiusAxis = this.polar.radiusAxis;
                    this.angleAxis = this.polar.angleAxis;

                    // compatible
                    if (this.radiusAxis && this.angleAxis) {
                        this.baseAxis = this.angleAxis;
                        this.baseAxis.isBaseAxis = true;
                        this.valueAxis = this.radiusAxis;
                    }
                    break;

                default:

                    this.xAxis = vanchart.xAxis(QueryUtils.queryList(queryList, 'xAxis'));
                    this.yAxis = vanchart.yAxis(QueryUtils.queryList(queryList, 'yAxis'));

                    if (this.xAxis && this.yAxis) {
                        this.baseAxis = this._getBaseAxis();
                        this.baseAxis.isBaseAxis = true;
                        this.valueAxis = this._getValueAxis();
                    }
            }

            this.chart.mergeSeriesAttributes(this);

            this.points = [];
            this.visiblePoints = [];//为了饼图还是加上吧

            var rangeLegend = this.chart.vanchart.getComponent(Constants.RANGE_LEGEND_COMPONENT);
            var data = seriesOption.data;

            var self = this;
            this.points =
                data.map(function (datum, i) {
                        return new Point(self, datum, i);
                    })
                    .filter(function (point) {
                        return self._isValidPoint(rangeLegend, point);
                    });

            this.updateVisiblePoints();
        },

        _isValidPoint: function (rangeLegend, point) {
            return !this._isBubbleAndNegative(point) && !this._isNullPoint(point) && !this._isOutRangeLegend(rangeLegend, point);
        },

        _isBubbleAndNegative: function (p) {
            var isBubble = p.series.type == Constants.BUBBLE_CHART;
            var isNegative = !p.displayNegative && p.size < 0;
            return isBubble && isNegative;
        },

        _isNullPoint: function (p) {
            var isBubbleNull = p.series.type == Constants.BUBBLE_CHART && (p.size == '-' || p.isNull);
            var isScatterNull = p.series.type == Constants.SCATTER_CHART && p.isNull;
            return isBubbleNull || isScatterNull;
        },

        _isOutRangeLegend: function (rangeLegend, p) {
            if(rangeLegend){
                return !rangeLegend.getColorWithSize(p.size);
            } else {
                return false;
            }
        },

        updateVisiblePoints:function(){

            this.visiblePoints =
                this.points.filter(function (point) {
                    return point.visible;
                });

        },

        //排序以后,根据排序的效果,需要更新className
        updateClassName:function(){

            if(this.baseAxis && this.baseAxis.type == Constants.CATEGORY_AXIS_COMPONENT){

                var categories = this.baseAxis.categories;

                var newPoints = [];

                this.points.forEach(function(point){

                    var newPoint = QueryUtils.merge(new Point(), point);

                    newPoint.updateClassName(BaseUtils.indexInArray(categories, point.category));

                    newPoints.push(newPoint);
                });

                this.points = newPoints;

                if(this.originalPoints){
                    this.originalPoints = this.points;
                }
            }

        },

        getDataPointCount:function(){
            return this.seriesOption.data.length;
        },

        getSeryTotalValue:function(){

            var total = 0;

            this.points.forEach(function(point){
                total += point.value;
            });

            return total;
        },

        getLocation:function(){

            return this.baseAxis ? this.baseAxis.getPosition() : Constants.BOTTOM;

        },

        isValueAxisBased:function(){
            var c_name = Constants.CATEGORY_AXIS_COMPONENT;
            return (this.xAxis && this.xAxis.type != c_name) && (this.yAxis && this.yAxis.type != c_name);
        },

        _getBaseAxis:function(){
            var c_name = Constants.CATEGORY_AXIS_COMPONENT;
            if(this.xAxis.type == c_name){
                return this.xAxis;
            }else if(this.yAxis.type == c_name){
                return this.yAxis;
            }else{
                return this.type == Constants.BAR_CHART ? this.yAxis : this.xAxis;
            }
        },

        _getValueAxis:function(){
            var c_name = Constants.CATEGORY_AXIS_COMPONENT;
            if(this.xAxis.type == c_name){
                return this.yAxis;
            }else if(this.yAxis.type == c_name){
                return this.xAxis;
            }else{
                return this.type == Constants.BAR_CHART ? this.xAxis : this.yAxis;
            }
        },

        //根据bands的定义获取颜色
        _getBandsColor:function(point){

            var bands = this.bands;

            if(bands){
                bands = BaseUtils.isArray(bands) ? bands : [bands];

                for(var i = 0, count = bands.length; i < count; i++){

                    var band = bands[i];

                    if(band.axis){

                        var axis = band.axis == 'x' ? this.xAxis : this.yAxis;
                        var value = axis.getValueFromData(point.pointOption);
                        var from = band.from;
                        var to = band.to;

                        if(axis.type == Constants.CATEGORY_AXIS_COMPONENT){
                            value = axis.indexOfLabel(value);
                            from = from ? axis.indexOfLabel(from) : from;
                            to = to ? axis.indexOfLabel(from) : to;
                        }

                        var largerThanFrom = BaseUtils.hasDefined(from) ? value >= from : true;
                        var smallerThanTo = BaseUtils.hasDefined(to) ? value <= to : true;

                        if(largerThanFrom && smallerThanTo){
                            return band.color;
                        }

                    }else{

                        var from = Math.min(band.from, band.to);
                        var to = Math.max(band.from, band.to);

                        if(point.value >= from && point.value < to){
                            return band.color;
                        }

                    }
                }

                if(BaseUtils.hasDefined(point.valueInDomain)){

                    for(var i = 0, len = bands.length; i < len; i++){

                        var band = bands[i];

                        var from = Math.min(band.from, band.to);
                        var to = Math.max(band.from, band.to);

                        if(point.valueInDomain >= from && point.valueInDomain <= to){
                            return band.color;
                        }
                    }
                }
                
            }
        }
    };

    return Series;
});

/**
 * Created by eason on 15/8/17.
 */

define('render/LegendIconFactory',['require','../Constants'],function(require){

    var Constants = require('../Constants');

    var LegendPath = {};
    var LegendSize = {};

    LegendPath[Constants.PIE_ICON] = 'M15.795,7.943L7.909,12.5L0.205,8.052C1.756,5.333,4.68,3.5,8.032,3.5C11.338,3.5,14.23,5.287,15.795,7.943z';
    LegendSize[Constants.PIE_ICON] = {
        width:16,
        height:16
    };

    LegendPath[Constants.DONUT_ICON] = 'M8.945,11.107c1.671,0,3.181,0.684,4.269,1.786l4.271-4.271c-4.686-4.686-12.284-4.686-16.971,0l4.216,4.216C5.815,11.768,7.302,11.107,8.945,11.107z';
    LegendSize[Constants.DONUT_ICON] = {
        width:18,
        height:18
    };

    LegendPath[Constants.NORMAL_ICON] = 'M0,0L12,0L12,12L0,12Z';
    LegendSize[Constants.NORMAL_ICON] = {
        width:12,
        height:12
    };

    LegendPath[Constants.BUBBLE_ICON] = "M6,11.5c-1.47,0-2.851-0.572-3.889-1.611C1.072,8.851,0.5,7.47,0.5,6s0.572-2.851,1.611-3.889C3.149,1.072,4.53,0.5,6,0.5s2.851,0.572,3.889,1.611C10.928,3.149,11.5,4.53,11.5,6s-0.572,2.851-1.611,3.889C8.851,10.928,7.47,11.5,6,11.5z";
    LegendSize[Constants.BUBBLE_ICON] = {
        width:11,
        height:11
    };

    LegendPath[Constants.NULL_MARKER] = 'M1,8L1,8c0-0.552,0.448-1,1-1h12c0.552,0,1,0.448,1,1v0c0,0.552-0.448,1-1,1H2C1.448,9,1,8.552,1,8z';
    LegendSize[Constants.NULL_MARKER] = {
        width:16,
        height:16
    };

    LegendPath[Constants.CIRCLE] = 'M11,8c0,1.657-1.343,3-3,3S5,9.657,5,8s1.343-3,3-3S11,6.343,11,8z M14,7h-2.142C11.942,7.322,12,7.653,12,8s-0.058,0.678-0.142,1H14c0.552,0,1-0.448,1-1C15,7.448,14.552,7,14,7z M4,8c0-0.347,0.058-0.678,0.142-1H2C1.448,7,1,7.448,1,8c0,0.552,0.448,1,1,1h2.142C4.058,8.678,4,8.347,4,8z';
    LegendSize[Constants.CIRCLE] = {
        width:16,
        height:16
    };

    LegendPath[Constants.SCATTER_ICON + Constants.NULL_MARKER] = 'M0,0L12,0L12,12L0,12Z';
    LegendSize[Constants.SCATTER_ICON + Constants.NULL_MARKER] = {
        width:12,
        height:12
    };

    LegendPath[Constants.SCATTER_ICON + Constants.NORMAL_ICON] = 'M0,0L12,0L12,12L0,12Z';
    LegendSize[Constants.SCATTER_ICON + Constants.NORMAL_ICON] = {
        width:12,
        height:12
    };

    LegendPath[Constants.SCATTER_ICON + Constants.CIRCLE] = "M4,8C2.897,8,1.897,7.551,1.173,6.827S0,5.103,0,4s0.449-2.103,1.173-2.827S2.897,0,4,0s2.103,0.449,2.827,1.173S8,2.897,8,4S7.551,6.103,6.827,6.827S5.103,8,4,8";
    LegendSize[Constants.SCATTER_ICON + Constants.CIRCLE] = {
        width:8,
        height:8
    };

    LegendPath[Constants.SQUARE] = 'M11,11H5V5h6V11z M14,7h-2v2h2c0.552,0,1-0.448,1-1C15,7.448,14.552,7,14,7z M4,7H2C1.448,7,1,7.448,1,8c0,0.552,0.448,1,1,1h2V7z';
    LegendSize[Constants.SQUARE] = {
        width:16,
        height:16
    };
    LegendPath[Constants.SCATTER_ICON + Constants.SQUARE] = "M0,0h8c0,0,0,3.889,0,8C4,8,0,8,0,8V0z";
    LegendSize[Constants.SCATTER_ICON + Constants.SQUARE] = {
        width:8,
        height:8
    };

    LegendPath[Constants.DIAMOND] = 'M8,11L5,8l3-3l3,3L8,11z M14,7h-2.586l1,1l-1,1H14c0.552,0,1-0.448,1-1C15,7.448,14.552,7,14,7z M3.586,8l1-1H2C1.448,7,1,7.448,1,8c0,0.552,0.448,1,1,1h2.586L3.586,8z';
    LegendSize[Constants.DIAMOND] = {
        width:16,
        height:16
    };
    LegendPath[Constants.SCATTER_ICON + Constants.DIAMOND] = "M0,4.5L4.502,0l4.5,4.5c0,0,0,0-4.5,4.5C0,4.5,0,4.5,0,4.5z";
    LegendSize[Constants.SCATTER_ICON + Constants.DIAMOND] = {
        width:9,
        height:9
    };

    LegendPath[Constants.TRIANGLE] = 'M5,10l3-5.196L11,10H5z M14,7h-3.577l1.155,2H14c0.552,0,1-0.448,1-1C15,7.448,14.552,7,14,7z M5.577,7H2C1.448,7,1,7.448,1,8c0,0.552,0.448,1,1,1h2.423L5.577,7z';
    LegendSize[Constants.TRIANGLE] = {
        width:16,
        height:16
    };
    LegendPath[Constants.SCATTER_ICON + Constants.TRIANGLE] = "M4.5,0L9,8c0,0-4.617,0-9,0L4.5,0z";
    LegendSize[Constants.SCATTER_ICON + Constants.TRIANGLE] = {
        width:9,
        height:8
    };

    LegendPath[Constants.CIRCLE_HOLLOW] = 'M4.142,9H2C1.448,9,1,8.552,1,8c0-0.552,0.448-1,1-1h2.142C4.058,7.322,4,7.653,4,8S4.058,8.678,4.142,9zM14,7h-2.142C11.942,7.322,12,7.653,12,8s-0.058,0.678-0.142,1H14c0.552,0,1-0.448,1-1C15,7.448,14.552,7,14,7z M8,7C7.449,7,7,7.449,7,8s0.449,1,1,1s1-0.449,1-1S8.551,7,8,7 M8,5c1.657,0,3,1.343,3,3s-1.343,3-3,3S5,9.657,5,8S6.343,5,8,5L8,5z';
    LegendSize[Constants.CIRCLE_HOLLOW] = {
        width:16,
        height:16
    };
    LegendPath[Constants.SCATTER_ICON + Constants.CIRCLE_HOLLOW] = "M4,2c1.102,0,2,0.898,2,2S5.102,6,4,6S2,5.102,2,4S2.898,2,4,2 M4,0C1.791,0,0,1.791,0,4s1.791,4,4,4s4-1.791,4-4S6.209,0,4,0";
    LegendSize[Constants.SCATTER_ICON + Constants.CIRCLE_HOLLOW] = {
        width:8,
        height:8
    };

    LegendPath[Constants.SQUARE_HOLLOW] = 'M4,9H2C1.448,9,1,8.552,1,8c0-0.552,0.448-1,1-1h2V9z M14,7h-2v2h2c0.552,0,1-0.448,1-1C15,7.448,14.552,7,14,7z M9,7H7v2h2V7 M11,5v6H5V5H11L11,5z';
    LegendSize[Constants.SQUARE_HOLLOW] = {
        width:16,
        height:16
    };
    LegendPath[Constants.SCATTER_ICON + Constants.SQUARE_HOLLOW] = "M6,6H2V2h4V6z M8,0H0v8h8V0z";
    LegendSize[Constants.SCATTER_ICON + Constants.SQUARE_HOLLOW] = {
        width:8,
        height:8
    };

    LegendPath[Constants.DIAMOND_HOLLOW] = 'M4.157,9H2C1.448,9,1,8.552,1,8c0-0.552,0.448-1,1-1h2.157l-1,1L4.157,9z M14,7h-2.157l1,1l-1,1H14c0.552,0,1-0.448,1-1C15,7.448,14.552,7,14,7z M8,5.986L5.986,8L8,10.014L10.014,8L8,5.986 M8,4.571L11.429,8L8,11.429L4.571,8L8,4.571L8,4.571z';
    LegendSize[Constants.DIAMOND_HOLLOW] = {
        width:16,
        height:16
    };
    LegendPath[Constants.SCATTER_ICON + Constants.DIAMOND_HOLLOW] = "M2.121,4.999L5,2.121l2.878,2.878L5,7.879L2.121,4.999z M5,0L0,4.999L5,10l4.999-5.001L5,0z";
    LegendSize[Constants.SCATTER_ICON + Constants.DIAMOND_HOLLOW] = {
        width:10,
        height:10
    };

    LegendPath[Constants.TRIANGLE_HOLLOW] = 'M4.5,9H2C1.448,9,1,8.552,1,8s0.448-1,1-1h3.655L4.5,9z M14,7h-3.655L11.5,9H14c0.552,0,1-0.448,1-1S14.552,7,14,7z M8,6.938L6.232,10h3.536L8,6.938 M8,4.938L11.5,11h-7L8,4.938L8,4.938z';
    LegendSize[Constants.TRIANGLE_HOLLOW] = {
        width:16,
        height:16
    };
    LegendPath[Constants.SCATTER_ICON + Constants.TRIANGLE_HOLLOW] = "M5.001,3.34L7.402,7.5H2.598L5.001,3.34z M5.001,0.34L0,9h10L5.001,0.34z";
    LegendSize[Constants.SCATTER_ICON + Constants.TRIANGLE_HOLLOW] = {
        width:10,
        height:9
    };

    function getLegendIconPath(name){
        return LegendPath[name];
    }

    function getLegendIconSize(name){
        return LegendSize[name];
    }

    function hasIcon(name){
        return LegendPath[name];
    }


    return {
        getLegendIconPath:getLegendIconPath,
        getLegendIconSize:getLegendIconSize,
        hasIcon:hasIcon
    }
});
/**
 * Created by eason on 16/5/26.
 *
 * try to use Behavior Delegation
 */

define('utils/Class',['require','./QueryUtils'],function(require){

    var QueryUtils = require('./QueryUtils');

    function Class(){};

    Class.extend = function(props){

        // @function extend(props: Object): Function
        // [Extends the current class](#class-inheritance) given the properties to be included.
        // Returns a Javascript function that is a class constructor (to be called with `new`).
        var NewClass = function () {

            // call the constructor
            if (this.initialize) {
                this.initialize.apply(this, arguments);
            }

            // call all constructor hooks
            this.callInitHooks();
        };

        var parentProto = NewClass.__super__ = this.prototype;

        var proto = Object.create(parentProto);
        proto.constructor = NewClass;

        NewClass.prototype = proto;

        // inherit parent's statics
        for (var i in this) {
            if (this.hasOwnProperty(i) && i !== 'prototype') {
                NewClass[i] = this[i];
            }
        }

        //todo 暂时不知道用不用得上,先留着
        // // mix static properties into the class
        // if (props.statics) {
        //     L.extend(NewClass, props.statics);
        //     delete props.statics;
        // }
        //
        // // mix includes into the prototype
        // if (props.includes) {
        //     L.Util.extend.apply(null, [proto].concat(props.includes));
        //     delete props.includes;
        // }
        //
        // // merge options
        // if (proto.options) {
        //     props.options = L.Util.extend(L.Util.create(proto.options), props.options);
        // }

        // mix given properties into the prototype
        QueryUtils.merge(proto, props, true);

        proto._initHooks = [];

        // add method for calling all hooks
        proto.callInitHooks = function () {

            if (this._initHooksCalled) { return; }

            if (parentProto.callInitHooks) {
                parentProto.callInitHooks.call(this);
            }

            this._initHooksCalled = true;

            for (var i = 0, len = proto._initHooks.length; i < len; i++) {
                proto._initHooks[i].call(this);
            }
        };

        return NewClass;
    };

    // @function addInitHook(fn: Function)
    // Adds a [constructor hook](#class-constructor-hooks) to the class.
    Class.addInitHook = function (fn) { // (Function) || (String, args...)
        var args = Array.prototype.slice.call(arguments, 1);

        var init = typeof fn === 'function' ? fn : function () {
            this[fn].apply(this, args);
        };

        this.prototype._initHooks = this.prototype._initHooks || [];
        this.prototype._initHooks.push(init);
        return this;
    };

    return Class;
});


/**
 * Created by eason on 15/5/4.
 * 图表中所有可以显现的内容都作为一个组件
 */
define('component/Base',['require','../utils/BaseUtils','../utils/ColorUtils','../Constants','../render/RenderFactory','../utils/QueryUtils','../utils/Formatter','../render/LegendIconFactory','../utils/Class'],function(require){
    var BaseUtils = require('../utils/BaseUtils');
    var ColorUtils = require('../utils/ColorUtils');
    var Constants = require('../Constants');
    var RenderFactory = require('../render/RenderFactory');
    var QueryUtils = require('../utils/QueryUtils');
    var Formatter = require('../utils/Formatter');
    var LegendIconFactory = require('../render/LegendIconFactory');

    var Class = require('../utils/Class');

    var LABEL_GAP = 2;
    var CATEGORY = 'CATEGORY';
    var SERIES = 'SERIES';
    var VALUE = 'VALUE';
    var PERCENT = 'PERCENT';

    var DEFAULT_MARKER_RADIUS = 4.5;

    var Base = Class.extend({

        initialize:function(vanchart, option, componentType, componentOption){
            this.vanchart = vanchart;
            this.option = option;
            this.componentType = componentType;
            this.componentOption = componentOption || option[componentType];

            //this.type在prototype里,主要是坐标轴value还是category
            var renderType;
            if (this.type) {
                switch (componentType) {
                    case Constants.RADIUS_AXIS_COMPONENT:
                        renderType = Constants.RADIUS_AXIS_RENDER;
                        break;
                    case Constants.ANGLE_AXIS_COMPONENT:
                        renderType = Constants.ANGLE_AXIS_RENDER;
                        break;
                    default:
                        renderType = this.type;
                }
            } else {
                renderType = componentType;
            }

            this.render = RenderFactory.getRender(renderType, this);

            this.isFloat = false;
            this._needLayout = true;

            this._floatX = 0;
            this._floatY = 0;
            this.bounds = {x:0, y:0, width:0, height:0};

            this.refresh(option, this.componentOption);
        },

        refresh:function(option, componentOption){
            if(option){
                this.option = option;
                this.componentOption = componentOption ? componentOption : option[this.componentType];
            }

            componentOption = this.componentOption;
            if(componentOption){
                this.isFloat = componentOption.floating;
                this._floatX = this._getPercentValue(componentOption.x, this.vanchart.chartWidth());
                this._floatY = this._getPercentValue(componentOption.y, this.vanchart.chartHeight());
            }

            this._refresh && this._refresh();
        },

        //确定占据的大小
        doLayout:function(){

        },

        //根据绘图区的位置确定组件的位置
        fixBoundsByPlot:function(){

        },

        initAttributesWithSeries:function(){

        },

        remove:function(){
            this.render && this.render.remove();
        },

        groupDataByClassName:function(){
            return BaseUtils.pick(this.option.byClassName, true);
        },

        //在图形创建之前就要知道
        getMaxBubbleRadius:function(){

            var maxSize = 0;

            //配置的系列
            var series = this.vanchart.series;
            series.forEach(function(sery){
                if(sery.visible && sery.type == Constants.BUBBLE_CHART){
                    maxSize = Math.max(maxSize, sery.maxSize);
                }
            });

            return maxSize/2;
        },

        //默认的系列颜色
        _getDefaultSeriesColor:function(seriesName){
            return this.vanchart.getDefaultSeriesColor(seriesName);
        },

        _getLegendType:function(sery){

            var marker = sery.marker;

            var icon = '';

            switch (sery.type) {
                case Constants.PIE_CHART:
                    if (sery.innerRadius || (sery.innerRadius && parseFloat(sery.innerRadius) > 0)) {
                        icon = Constants.DONUT_ICON;
                    }else{
                        icon = Constants.PIE_ICON;
                    }
                    break;
                case Constants.BUBBLE_CHART:
                    icon = Constants.BUBBLE_ICON;
                    break;

                // line type series have specific markers
                case Constants.SCATTER_CHART:
                    icon = Constants.SCATTER_ICON;
                case Constants.RADAR_CHART:
                    if (sery.columnType) {
                        icon = Constants.NORMAL_ICON;
                        break;
                    }
                case Constants.LINE_CHART:
                case Constants.AREA_CHART:
                    icon += this._getLegendTypeFromMarker(marker) || Constants.NULL_MARKER;
                    break;

                default:
                    icon = Constants.NORMAL_ICON;
            }
            return icon;
        },

        _getLegendTypeFromMarker:function(marker){

            if (marker && LegendIconFactory.hasIcon(marker.symbol)) {
                return marker.symbol;
            }

            return null;
        },

        _isLineTypeSeries:function(type){
            return type == Constants.LINE_CHART
                || type == Constants.AREA_CHART
                || type == Constants.RADAR_CHART
                || type == Constants.SCATTER_CHART;
        },

        //用百分比表示或者数字表示的值
        _getPercentValue:function(value, total){
            if(value){
                value += '';
                if(value.indexOf('%') != -1){
                    value = parseFloat(value) * total / 100;
                }
                return parseFloat(value);
            }
            return 0;
        },

        _setComponentBounds:function(position, usedSize){
            if(this.isFloat){
                this._updateFloatBounds(position, usedSize);
            }else{
                this._updateComponentBounds(position, usedSize);
            }
        },

        _updateFloatBounds:function(position, usedSize){
            usedSize = Math.ceil(usedSize);

            var originBounds = this.vanchart.getPlotBounds();

            var x = this._floatX;
            var y = this._floatY;

            var width = originBounds.x + originBounds.width - x;
            var height = originBounds.y + originBounds.height - y;

            switch (position){
                case Constants.TOP:
                    this.bounds = {x:x, y:y, width:width, height:usedSize};
                    break;
                case Constants.BOTTOM:
                    this.bounds = {x:x, y:y, width:width, height:usedSize};
                    break;
                case Constants.LEFT:
                    this.bounds = {x:x, y:y, width:usedSize, height:height};
                    break;
                case Constants.RIGHT_TOP:
                case Constants.RIGHT:
                    this.bounds = {x:x, y:y, width:usedSize, height:height};
                    break
            }

        },

        /**
         * 从原始区域裁减出一块区域以后作为组件区域，并且更新原始区域
         * @param position{string} 位置
         * @para usedSize 占据的大小
         * @private
         */
        _updateComponentBounds:function(position, usedSize){
            usedSize = Math.ceil(usedSize);

            var originBounds = this.vanchart.getPlotBounds();
            var x = originBounds.x;
            var y = originBounds.y;
            var width = originBounds.width;
            var height = originBounds.height;

            switch (position){
                case Constants.TOP:
                    this.bounds = {x:x, y:y, width:width, height:usedSize};
                    break;
                case Constants.BOTTOM:
                    this.bounds = {x:x, y:y+height-usedSize, width:width, height:usedSize};
                    break;
                case Constants.LEFT:
                    this.bounds = {x:x, y:y, width:usedSize, height:height};
                    break;
                case Constants.RIGHT_TOP:
                case Constants.RIGHT:
                    this.bounds = {x:x+width-usedSize, y:y, width:usedSize, height:height};
                    break
            }
            this.vanchart.setPlotBounds(originBounds);

            this._clipPlotBounds(position, usedSize);
        },

        _clipPlotBounds:function(position, usedSize){

            usedSize = Math.ceil(usedSize);

            var originBounds = this.vanchart.getPlotBounds();
            var x = originBounds.x;
            var y = originBounds.y;
            var width = originBounds.width;
            var height = originBounds.height;

            switch (position){
                case Constants.TOP:
                    originBounds = {x:x, y:y+usedSize, width:width, height:height - usedSize};
                    break;
                case Constants.BOTTOM:
                    originBounds = {x:x, y:y, width:width, height:height - usedSize};
                    break;
                case Constants.LEFT:
                    originBounds = {x:x+usedSize, y:y, width:width-usedSize, height:height};
                    break;
                case Constants.RIGHT_TOP:
                case Constants.RIGHT:
                    originBounds = {x:x, y:y, width:width-usedSize, height:height};
                    break
            }
            this.vanchart.setPlotBounds(originBounds);
        },

        _getBackgroundColor:function(){

            var opt = this.option;

            var plotColor = (typeof opt.plotBackgroundColor == 'string');

            var chartColor = (typeof opt.backgroundColor == 'string');

            var color =  plotColor ? opt.plotBackgroundColor : (chartColor ? opt.backgroundColor : 'white');

            return ColorUtils.colorToHex(color);
        },

        getPosition:function(){
            return this.componentOption.position;
        },

        isHorizontal:function(){
            return this.componentOption.position == Constants.TOP
                || this.componentOption.position == Constants.BOTTOM;
        },

        getMousePos:function(event){

            var el = this.vanchart.getParentDom();

            return BaseUtils.getMousePos(event, el);
        },

        isLargeMode:function(){
            return this.option.plotOptions.large;
        },

        _maxHeight:function(){
            var maxHeight = this.vanchart.chartHeight();

            if(this.componentOption.maxHeight){
                return this._getPercentValue(this.componentOption.maxHeight, maxHeight);
            }

            return maxHeight;
        },

        _maxWidth:function(){
            var maxWidth = this.vanchart.chartWidth();

            if(this.componentOption.maxWidth){
                return this._getPercentValue(this.componentOption.maxWidth, maxWidth);
            }

            return maxWidth;
        },

        //每种类型都在一行
        _calculateSingleLineLabelContent:function(formatter, data){

            if(!formatter){
                return '';
            }

            if(typeof formatter == 'object'){
                var content = '';
                var label = formatter.identifier;
                var categoryString = Formatter.format(data.category, formatter.categoryFormat);
                var seriesString = Formatter.format(data.seriesName, formatter.seriesFormat);

                if(label.indexOf(CATEGORY) != -1 || label.indexOf(SERIES) != -1){
                    if(label.indexOf(CATEGORY) != -1 && label.indexOf(SERIES) != -1){
                        content += (categoryString + ' ' + seriesString);
                    }else if(label.indexOf(CATEGORY) != -1){
                        content += categoryString;
                    }else{
                        content += seriesString;
                    }
                }

                if(label.indexOf(VALUE) != -1 || label.indexOf(PERCENT) != -1){

                    if(!BaseUtils.isEmpty(content)){
                        content += ':';
                    }

                    var valueString = Formatter.format(data.value, formatter.valueFormat);
                    var percentString = Formatter.format(data.percentage, formatter.percentFormat);

                    if(label.indexOf(VALUE) != -1 && label.indexOf(PERCENT) != -1){
                        content += (valueString + ' ' + percentString);
                    }else if(label.indexOf(VALUE) != -1){
                        content += valueString;
                    }else{
                        content += percentString;
                    }
                }
                return content;
            }else{
                return BaseUtils.getFormatterFunction(formatter).call(data);
            }

        },

        _createMultiLineLabelContent:function(formatter, data){
            if(!formatter){
                return [];
            }

            if(typeof formatter == 'object'){
                var content = [];

                var label = formatter.identifier;
                var categoryString = Formatter.format(data.category, formatter.categoryFormat);
                var seriesString = Formatter.format(data.seriesName, formatter.seriesFormat);
                var valueString = Formatter.format(data.value, formatter.valueFormat);
                var percentString = Formatter.format(data.percentage, formatter.percentFormat);

                if(label.indexOf(CATEGORY) != -1){
                    content.push(categoryString);
                }

                if(label.indexOf(SERIES) != -1){
                    content.push(seriesString)
                }

                if(label.indexOf(VALUE) != -1){
                    content.push(valueString);
                }

                if(label.indexOf(PERCENT) != -1){
                    content.push(percentString);
                }

                return content;
            }else{
                return [BaseUtils.getFormatterFunction(formatter).call(data)];
            }

        },

        _getTickContent:function(tick, formatter){

            if(!formatter){
                return tick;
            }

            return Formatter.format(tick, formatter);
        },

        getLabelGap:function(){
            return LABEL_GAP;
        },

        getDefaultMarkerRadius:function(){
            return DEFAULT_MARKER_RADIUS;
        },

        getPlotBounds:function(){
            return this.vanchart.getPlotBounds();
        },

        getChartBounds:function(){
            return this.vanchart.getChartBounds();
        },

        getVanchartRender:function(){
            return this.vanchart.getRender();
        },

        getRender:function(){
            return this.render;
        },

        getParentDom:function(){
            return this.vanchart.getParentDom();
        },

        getTooltipComponent:function(){
            return this.vanchart.components.tooltip;
        }
    });

    return Base;
});
/**
 * Created by eason on 15/5/4.
 * 标题组建，包括图表标题和坐标轴标题
 */
define('component/Title',['require','./Base','../utils/BaseUtils','../Constants','../ComponentLibrary'],function(require){
    var Base = require('./Base');
    var BaseUtils = require('../utils/BaseUtils');
    var Constants = require('../Constants');

    var LINE_GAP_PERCENT = 0.2;
    var PADDING = 5;

    var Title = Base.extend({
        doLayout:function(){

            var cfg = this.componentOption;

            var originBounds = this.vanchart.getPlotBounds();

            var remainWidth = originBounds.width;
            var remainHeight = originBounds.height;

            var textDim;

            // get maximal area
            if (this.isFloat) {

                remainWidth -= (this._floatX - originBounds.x);
                remainHeight -= (this._floatY - originBounds.y);

            } else {

                this.initBarWidth = BaseUtils.pick(this.initBarWidth, this.vanchart.getToolbarWidth());
                remainWidth -= this.initBarWidth;

                if (cfg.align === 'center') {
                    remainWidth -= this.initBarWidth;
                }
            }

            // cut padding to place text
            remainWidth -= 2 * PADDING;
            remainHeight -= 2 * PADDING;

            // try to get minimal text width
            textDim = BaseUtils.getTextWrapDimension(cfg.text, cfg.style, cfg.useHtml);

            // wrap text when too long
            if (textDim.width > remainWidth) {
                var newStyle = BaseUtils.clone(cfg.style);
                newStyle.width = remainWidth + 'px';
                textDim = BaseUtils.getTextWrapDimension(cfg.text, newStyle, cfg.useHtml);
            } else {
                textDim.width += 0.5;
            }

            // title and text height are the same and should be minimal
            textDim.height = Math.min(this._maxHeight(), remainHeight, textDim.height);

            // while widths are different
            // floating title width is text width
            // fixed title width remains plot width; cut toolbar is text width
            if (this.isFloat) {

                this.bounds = {
                    x: this._floatX,
                    y: this._floatY,
                    // contract floating title's background width
                    width: textDim.width + 2 * PADDING,
                    height: textDim.height + 2 * PADDING
                };

            } else {

                var height = textDim.height + 2 * PADDING;

                this._setComponentBounds(Constants.TOP, height);

                // extend to title except toolbar
                if (cfg.align !== 'center') {
                    textDim.width = remainWidth;
                }
            }

            this.textDim = textDim;

        },

        getPadding:function(){
            return PADDING;
        },

        getLineGapPercent:function(){
            return LINE_GAP_PERCENT;
        },

        translateX:function(width) {
            this.render.translateX(width);
        },

        changeTextRightSpace: function (changes) {
            this.render.changeTextRightSpace(changes);
        }
    });
    
    require('../ComponentLibrary').register(Constants.TITLE_COMPONENT, Title);
    return Title;
});
/**
 * Created by eason on 16/5/17.
 */
define('component/DrillTools',['require','./Base','../utils/BaseUtils','../utils/ColorUtils','../Constants','../ComponentLibrary'],function(require){
    var Base = require('./Base');
    var BaseUtils = require('../utils/BaseUtils');
    var ColorUtils = require('../utils/ColorUtils');
    var Constants = require('../Constants');

    var PADDING = 2;
    var FIRST_LEFT_PADDING = 0.417;
    var LEFT_PADDING = 0.583;
    var RIGHT_PADDING = 0.25;
    var ARROW_SIZE = 0.333;
    var TOP_PADDING = 0.1665;

    var DrillTools = Base.extend({
        doLayout:function(){
            var cfg = this.componentOption;
            this._setComponentBounds(Constants.TOP, BaseUtils.getTextHeight(cfg.style) * (TOP_PADDING * 2 + 1));
        },

        addIconData:function(data){
            this.iconData.push(data);
            data.aniStart = this.getMarkAnimationStartPos(data);
            data.aniEnd = this.getMarkPos(data);
        },

        deleteIconData:function(series){
            var data;
            while((data = this.iconData[this.iconData.length - 1]) && data.series != series){
                this.iconData.pop();
            }
        },

        getIconData:function(){
            return this.iconData;
        },

        getBookMarkPath:function(d){

            var style = this.componentOption.style;
            var dim = BaseUtils.getTextDimension(d.geo.geoName, style);

            var index = d.layerIndex;

            var rectWidth = (index == 0 ? FIRST_LEFT_PADDING : LEFT_PADDING) + RIGHT_PADDING;
            rectWidth = dim.height * rectWidth + dim.width;
            var arrowWidth = dim.height * ARROW_SIZE;
            var rectHeight = (1 + TOP_PADDING * 2) * dim.height;

            var ltop = [0,0], rtop = [rectWidth, 0], cp = [rectWidth + arrowWidth, rectHeight/2];
            var rbottom = [rectWidth, rectHeight], lbottom = [0, rectHeight];

            return 'M' + ltop + 'L' + rtop + 'L' + cp + 'L' + rbottom + 'L' + lbottom + 'Z';
        },

        isCurrent:function(d){
            return this.iconData[this.iconData.length - 1] == d;
        },

        textColor:function(d){
            var cfg = this.componentOption;
            return this.isCurrent(d) ? cfg.currentColor : cfg.style.color;
        },

        mouseOverColor:function(d){
            var mouseOverColor;
            if(!(mouseOverColor = this.componentOption.mouseOverColor)){
                var textColor = this.textColor(d);
                var rgba = ColorUtils.getRGBAColorArray(textColor);
                var hsb = ColorUtils.rgb2hsb(rgba[0], rgba[1], rgba[2]);
                var rgb = ColorUtils.hsb2rgb(hsb[0], hsb[1]/2, (hsb[2] + 1)/2);
                mouseOverColor = ColorUtils.toColor(rgb, 'rgb');
            }

            return mouseOverColor;
        },

        leftPadding:function(d){
            return d.layerIndex == 0 ? FIRST_LEFT_PADDING : LEFT_PADDING;
        },

        topPadding:function(){
            return TOP_PADDING;
        },

        calculateExitAnimation:function(exitData){

            exitData.reverse();

            var time = 600;
            var i = 0, len = exitData.length;
            for(; i < len; i++){
                exitData[i].time = time;
                time = Math.max(time - 100, 0);
            }

            var delay = 0;
            for(i = len - 1; i >= 0; i--){
                if(exitData[i].time){
                    exitData[i].delay = delay;
                    delay += 200;
                }else{
                    exitData[i].delay = 0;
                }
            }
        },

        getMarkPos:function(d){
            var x = 0;
            for(var i = 0; i < d.layerIndex; i++){
                x += this.getBookMarkLength(this.iconData[i], i);
            }
            return x;
        },

        getMarkAnimationStartPos:function(d){
            var index = d.layerIndex;
            return index == 0 ? 0 : (this.getMarkPos(this.iconData[index - 1]) - this.getBookMarkLength(d, index));
        },

        getBookMarkLength:function(data, index){
            var cfg = this.componentOption;
            var textHeight = BaseUtils.getTextHeight(cfg.style);
            var length = BaseUtils.getTextDimension(data.geo.geoName, cfg.style).width;
            var padding = (index == 0 ? FIRST_LEFT_PADDING : LEFT_PADDING) + RIGHT_PADDING;
            return length + padding * textHeight;
        }
    });

    DrillTools.addInitHook(function(){this.iconData = [];});

    require('../ComponentLibrary').register(Constants.DRILL_TOOLS, DrillTools);
    return DrillTools;
});
/**
 * Created by eason on 15/8/7.
 */
//管理标签位置
define('utils/BoundsManager',['require','./BaseUtils'],function(require){

    var BaseUtils = require('./BaseUtils');

    function BoundsManager(){
        this.addedBounds = [];
    }

    BoundsManager.prototype = {

        constructor:BoundsManager,

        addBounds:function(bounds){
            this.addedBounds.push(bounds);
        },

        isOverlapped:function(bounds){
            for (var i = 0, len = this.addedBounds.length; i < len; i++){
                if (BaseUtils.rectangleOverlapped(bounds, this.addedBounds[i])){
                    return true;
                }
            }
            return false;
        },

        isEmpty:function(){
            return this.addedBounds.length == 0;
        }

    };

    return BoundsManager;
});
/**
 * Created by eason on 15/6/24.
 */
//
//Copyright (c) 2014 Ga?tan Renaudeau
//
//Permission is hereby granted, free of charge, to any person
//obtaining a copy of this software and associated documentation
//files (the "Software"), to deal in the Software without
//restriction, including without limitation the rights to use,
//    copy, modify, merge, publish, distribute, sublicense, and/or sell
//copies of the Software, and to permit persons to whom the
//Software is furnished to do so, subject to the following
//conditions:
//
//    The above copyright notice and this permission notice shall be
//included in all copies or substantial portions of the Software.
//
//    THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
//    EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES
//OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
//NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT
//HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY,
//    WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
//FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR
//OTHER DEALINGS IN THE SOFTWARE.

define('utils/BezierEasing',[],function(){
    var global = this;

    // These values are established by empiricism with tests (tradeoff: performance VS precision)
    var NEWTON_ITERATIONS = 4;
    var NEWTON_MIN_SLOPE = 0.001;
    var SUBDIVISION_PRECISION = 0.0000001;
    var SUBDIVISION_MAX_ITERATIONS = 10;

    var kSplineTableSize = 11;
    var kSampleStepSize = 1.0 / (kSplineTableSize - 1.0);

    var float32ArraySupported = 'Float32Array' in global;

    function A (aA1, aA2) { return 1.0 - 3.0 * aA2 + 3.0 * aA1; }
    function B (aA1, aA2) { return 3.0 * aA2 - 6.0 * aA1; }
    function C (aA1)      { return 3.0 * aA1; }

    // Returns x(t) given t, x1, and x2, or y(t) given t, y1, and y2.
    function calcBezier (aT, aA1, aA2) {
        return ((A(aA1, aA2)*aT + B(aA1, aA2))*aT + C(aA1))*aT;
    }

    // Returns dx/dt given t, x1, and x2, or dy/dt given t, y1, and y2.
    function getSlope (aT, aA1, aA2) {
        return 3.0 * A(aA1, aA2)*aT*aT + 2.0 * B(aA1, aA2) * aT + C(aA1);
    }

    function binarySubdivide (aX, aA, aB, mX1, mX2) {
        var currentX, currentT, i = 0;
        do {
            currentT = aA + (aB - aA) / 2.0;
            currentX = calcBezier(currentT, mX1, mX2) - aX;
            if (currentX > 0.0) {
                aB = currentT;
            } else {
                aA = currentT;
            }
        } while (Math.abs(currentX) > SUBDIVISION_PRECISION && ++i < SUBDIVISION_MAX_ITERATIONS);
        return currentT;
    }

    function BezierEasing (mX1, mY1, mX2, mY2) {
        // Validate arguments
        if (arguments.length !== 4) {
            throw new Error("BezierEasing requires 4 arguments.");
        }
        for (var i=0; i<4; ++i) {
            if (typeof arguments[i] !== "number" || isNaN(arguments[i]) || !isFinite(arguments[i])) {
                throw new Error("BezierEasing arguments should be integers.");
            }
        }
        if (mX1 < 0 || mX1 > 1 || mX2 < 0 || mX2 > 1) {
            throw new Error("BezierEasing x values must be in [0, 1] range.");
        }

        var mSampleValues = float32ArraySupported ? new Float32Array(kSplineTableSize) : new Array(kSplineTableSize);

        function newtonRaphsonIterate (aX, aGuessT) {
            for (var i = 0; i < NEWTON_ITERATIONS; ++i) {
                var currentSlope = getSlope(aGuessT, mX1, mX2);
                if (currentSlope === 0.0) return aGuessT;
                var currentX = calcBezier(aGuessT, mX1, mX2) - aX;
                aGuessT -= currentX / currentSlope;
            }
            return aGuessT;
        }

        function calcSampleValues () {
            for (var i = 0; i < kSplineTableSize; ++i) {
                mSampleValues[i] = calcBezier(i * kSampleStepSize, mX1, mX2);
            }
        }

        function getTForX (aX) {
            var intervalStart = 0.0;
            var currentSample = 1;
            var lastSample = kSplineTableSize - 1;

            for (; currentSample != lastSample && mSampleValues[currentSample] <= aX; ++currentSample) {
                intervalStart += kSampleStepSize;
            }
            --currentSample;

            // Interpolate to provide an initial guess for t
            var dist = (aX - mSampleValues[currentSample]) / (mSampleValues[currentSample+1] - mSampleValues[currentSample]);
            var guessForT = intervalStart + dist * kSampleStepSize;

            var initialSlope = getSlope(guessForT, mX1, mX2);
            if (initialSlope >= NEWTON_MIN_SLOPE) {
                return newtonRaphsonIterate(aX, guessForT);
            } else if (initialSlope === 0.0) {
                return guessForT;
            } else {
                return binarySubdivide(aX, intervalStart, intervalStart + kSampleStepSize, mX1, mX2);
            }
        }

        var _precomputed = false;
        function precompute() {
            _precomputed = true;
            if (mX1 != mY1 || mX2 != mY2)
                calcSampleValues();
        }

        var f = function (aX) {
            if (!_precomputed) precompute();
            if (mX1 === mY1 && mX2 === mY2) return aX; // linear
            // Because JavaScript number are imprecise, we should guarantee the extremes are right.
            if (aX === 0) return 0;
            if (aX === 1) return 1;
            return calcBezier(getTForX(aX), mY1, mY2);
        };

        f.getControlPoints = function() { return [{ x: mX1, y: mY1 }, { x: mX2, y: mY2 }]; };

        var args = [mX1, mY1, mX2, mY2];
        var str = "BezierEasing("+args+")";
        f.toString = function () { return str; };

        //var css = "cubic-bezier("+args+")";
        //f.toCSS = function () {?return css; };

        return f;
    }

    // CSS mapping
    BezierEasing.css = {
        "ease":        BezierEasing(0.25, 0.1, 0.25, 1.0),
        "linear":      BezierEasing(0.00, 0.0, 1.00, 1.0),
        "ease-in":     BezierEasing(0.42, 0.0, 1.00, 1.0),
        "ease-out":    BezierEasing(0.00, 0.0, 0.58, 1.0),
        "ease-in-out": BezierEasing(0.42, 0.0, 0.58, 1.0),
        "swing":       BezierEasing(0.02, 0.01,0.47, 1.0),
        "ease-in-quart":BezierEasing(0.895, 0.03, 0.685, 0.22),
        "ease-out-back":BezierEasing(0.175, 0.885, 0.32, 1.275)
    };

    return BezierEasing;
});
/**
 * Created by eason on 15/6/18.
 */
define('component/BaseAxis',['require','../Constants','../utils/BaseUtils','../utils/QueryUtils','../utils/Formatter','../utils/BoundsManager','./Base','../utils/BezierEasing'],function(require){
    var Constants = require('../Constants');
    var BaseUtils = require('../utils/BaseUtils');
    var QueryUtils = require('../utils/QueryUtils');
    var Formatter = require('../utils/Formatter');
    var BoundsManager = require('../utils/BoundsManager');

    var Base = require('./Base');
    var BezierEasing = require('../utils/BezierEasing');

    var LABEL_LINE_GAP = 3;
    var TICK_LENGTH = 5;
    var TITLE_LABEL_GAP = 5;

    var TICK_COUNT = 5;
    var RADAR_TICK_COUNT = 4;
    var MIN_MAX_GAP = 100;

    var PADDING = 5;

    var PADDING_GAP = 10;
    var LABEL_BORDER_GAP = 8;

    var TOP = 'radar-top';
    var BOTTOM = 'radar-bottom';
    var LEFT = 'radar-left';
    var RIGHT = 'radar-right';

    var ARROW_SIZE = 15;

    var BaseAxis = Base.extend({
        
        init: function () {
            this.sharedPoints = {};
        },
        
        getSharedPointsFromSeries: function (series) {
            if (!this.isBaseAxis) {
                return;
            }
            this.sharedPoints = {};
            var self = this;
            series.map(function (seriesItem) {
                if (seriesItem.baseAxis === self &&
                    seriesItem.tooltip &&
                    seriesItem.tooltip.shared &&
                    self._isSeriesVisible(seriesItem)) {
                    if (seriesItem.type === Constants.BAR_CHART || 
                        seriesItem.type === Constants.COLUMN_CHART ||
                        seriesItem.stack === Constants.RADAR_CHART ) {
                        self.highlightType = 'band';
                    }
                    seriesItem.points.map(function (point) {
                        self._getSharedPoints(point);
                    })
                }
            });
        },
        
        _getSharedPoints: function (point) {
            var series = point.series;
            
            if (series.supportSharedTooltip &&
                series.visible && 
                series.tooltip && 
                series.tooltip.shared && 
                !point.isNull &&
                point.visible
            ) {
                this.sharedPoints[point.category] || (this.sharedPoints[point.category] = []);
                this.sharedPoints[point.category].push(point);
            }
        },

        doLayout:function(){
            switch (this.componentType) {
                case Constants.X_AXIS_COMPONENT:
                case Constants.Y_AXIS_COMPONENT:
                    this._updateAxisBounds();
                    break;
                case Constants.RADIUS_AXIS_COMPONENT:
                case Constants.ANGLE_AXIS_COMPONENT:
                    this._updatePolarBounds();
                    break;
                default:
            }
            this.getSharedPointsFromSeries(this.vanchart.series);
        },

        refreshPolar: function (option, axisOption) {
            this.refresh(option, axisOption);

            switch (this.componentType) {
                case Constants.RADIUS_AXIS_COMPONENT:
                    this.polar = this.vanchart.polar(axisOption.axisIndex);
                    this.polar.radiusAxis = this;
                    break;
                case Constants.ANGLE_AXIS_COMPONENT:
                    this.polar = this.vanchart.polar(axisOption.axisIndex);
                    this.polar.angleAxis = this;
                    break;
                default:
            }
        },

        _updatePolarBounds: function () {

            if (this.componentType != Constants.ANGLE_AXIS_COMPONENT) {
                return;
            }

            if (this.polar.radius) {
                return;
            }

            // no radius setting, auto adjust
            var plotBounds = this.vanchart.getPlotBounds();
            var center = this.polar.center;

            var tmpBounds = [
                // 0 top
                center[1] - plotBounds.y,
                // 1 right
                plotBounds.x + plotBounds.width - center[0],
                // 2 bottom
                plotBounds.y + plotBounds.height - center[1],
                // 3 left
                center[0] - plotBounds.x
            ];

            var radius = Math.min.apply(null, tmpBounds);
            radius -= PADDING_GAP;

            var testBounds = {
                x: - tmpBounds[3],
                y: - tmpBounds[0],
                width: plotBounds.width,
                height: plotBounds.height
            };

            if (this.componentOption.showLabel) {
                if (!this._testRadius(radius, testBounds)) {
                    radius = this._findNiceRadius(testBounds);
                    this._testRadius(radius, testBounds);
                }
            }

            this.polar.setRadius(radius);

        },

        _updateAxisBounds:function(){

            var axisOption = this.componentOption;

            this.tickLabelLength = this._getTickLabelLength();

            var axisTileLength = this._getAxisTitleLength() + TITLE_LABEL_GAP;

            var usedSize = this.tickLabelLength + axisTileLength;

            var startSize = 0, endSize = 0;

            var isHorizontal = this.isHorizontal();

            if(this.tickData && this.tickData.length > 1){
                var t_s, t_e;
                if(this.isAxisReversed()){
                    t_s = this.tickData[this.tickData.length - 1].tickDim;
                    t_e = this.tickData[0].tickDim;
                }else{
                    t_s = this.tickData[0].tickDim;
                    t_e = this.tickData[this.tickData.length - 1].tickDim;
                }
                startSize = isHorizontal ? t_s.width : t_s.height;
                endSize = isHorizontal ? t_e.width : t_s.height
            }

            if(isHorizontal){
                usedSize = axisOption.maxHeight ? Math.min(this._maxHeight(), usedSize) : usedSize;
            }else{
                usedSize = axisOption.maxWidth ? Math.min(this._maxWidth(), usedSize) : usedSize;
            }

            //没有定义具体位置的时候
            if(axisOption.onZero){

                var otherAxis = this.componentType == Constants.X_AXIS_COMPONENT ?
                    Constants.Y_AXIS_COMPONENT : Constants.X_AXIS_COMPONENT;

                otherAxis = this.vanchart[otherAxis]();

                axisOption.position = otherAxis.isHorizontal() ? Constants.RIGHT : Constants.BOTTOM;

                isHorizontal = axisOption.position == Constants.BOTTOM;

                this._updateFloatBounds(axisOption.position, usedSize);

            }else if(this.getRender()){
                this._setComponentBounds(axisOption.position, usedSize);
            }

            var plotBounds = this.vanchart.getPlotBounds();
            var chartWidth = this.vanchart.chartWidth();
            var chartHeight = this.vanchart.chartHeight();

            if(isHorizontal){

                var leftDet =  Math.round(startSize/2) + PADDING;
                var rightDet =  Math.round(endSize/2) + PADDING;

                this._clipPlotBounds(Constants.LEFT, Math.max(leftDet - plotBounds.x, 0));
                this._clipPlotBounds(Constants.RIGHT, Math.max(rightDet - (chartWidth - plotBounds.x - plotBounds.width), 0));

            }else{

                var topDet = Math.round(endSize/2);

                var bottomDet = Math.round(startSize/2);
                bottomDet = Math.max(bottomDet - (chartHeight - plotBounds.y - plotBounds.height), 0);

                this._clipPlotBounds(Constants.TOP, topDet);
                this._clipPlotBounds(Constants.BOTTOM, bottomDet);
            }
        },

        dealOnZero:function(){

            var cfg = this.componentOption;

            if(cfg.onZero){

                var axisIndex = cfg.onZero === true ? 0 : cfg.onZero;

                var relyOn = this.componentType == Constants.X_AXIS_COMPONENT ?
                    Constants.Y_AXIS_COMPONENT : Constants.X_AXIS_COMPONENT;

                relyOn = this.vanchart.getComponent(relyOn).getAxis(axisIndex);

                var pos;
                if (relyOn.type === Constants.CATEGORY_AXIS_COMPONENT) {
                    pos = 0;
                } else {
                    pos = relyOn.scale(0);
                }

                var plotBounds = this.vanchart.getPlotBounds();

                var x, y, width, height;
                if(this.isHorizontal()){
                    x = plotBounds.x;
                    y = pos + plotBounds.y;
                    width = plotBounds.width;
                    height = this.bounds.height;
                }else{
                    x = pos + plotBounds.x;
                    y = plotBounds.y;
                    width = this.bounds.width;
                    height = plotBounds.height;
                }

                this.bounds = {
                    x:x,
                    y:y,
                    width:width,
                    height:height
                };

            }
        },

        //坐标轴的标签占据的大小
        _getTickLabelLength:function(){

            var axisOption = this.componentOption;

            var tickLength = axisOption.tickPadding || LABEL_LINE_GAP;

            if(axisOption.enableTick){
                tickLength += axisOption.tickLength || TICK_LENGTH;
            }

            var isHorizontal = this.isHorizontal();

            var maxLabelLength  = 0;
            if(axisOption.showLabel && this.tickData.length){
                this.tickData.forEach(function(t){
                    var labelDim = t.tickDim;
                    maxLabelLength = Math.max(maxLabelLength, isHorizontal ? labelDim.height : labelDim.width);
                });
            }

            return tickLength + maxLabelLength;
        },

        //不考虑step和自动间隔
        _updateOriginTickData:function(){
            var labels = this._getTickValues();
            var axisOption = this.componentOption;
            var formatter = axisOption.formatter;

            this.tickData = [];
            for(var i = 0, len = labels.length; i < len; i++){
                var tickValue = labels[i];
                var tickContent = this._getTickContent(tickValue, formatter);
                var labelDim = BaseUtils.getTextDimensionWithRotation(tickContent, axisOption.labelStyle,
                    axisOption.useHtml, axisOption.labelRotation);

                if(axisOption.useHtml){
                    labelDim.width = isNaN(parseFloat(axisOption.labelWidth)) ? labelDim.width : parseFloat(axisOption.labelWidth);
                    labelDim.height = isNaN(parseFloat(axisOption.labelHeight)) ? labelDim.height : parseFloat(axisOption.labelHeight);
                }

                this.tickData.push({
                    tickValue:tickValue,
                    tickContent:tickContent,
                    tickDim:labelDim
                });
            }

            if (axisOption.min && axisOption.min !== labels[0]) {
                var tickValue = axisOption.min;
                var tickContent = '';
                var labelDim = BaseUtils.getTextDimensionWithRotation(tickContent, axisOption.labelStyle,
                    axisOption.useHtml, axisOption.labelRotation);

                if(axisOption.useHtml){
                    labelDim.width = isNaN(parseFloat(axisOption.labelWidth)) ? labelDim.width : parseFloat(axisOption.labelWidth);
                    labelDim.height = isNaN(parseFloat(axisOption.labelHeight)) ? labelDim.height : parseFloat(axisOption.labelHeight);
                }

                this.tickData.unshift({
                    tickValue:tickValue,
                    tickContent:tickContent,
                    tickDim:labelDim
                });
            }
        },

        //确定scale以后计算内容,改变scale的话要重新计算originTickData
        _calculateTickData:function(){

            if (this.componentType === Constants.ANGLE_AXIS_COMPONENT) {

                var radius = this.polar.radius;
                this.tickData.map(function (t) {
                    this._getCateLabelBounds(radius, t);
                }, this);

            } else {
                this._updateTickContent();
            }

            //只有分类轴会走这边
            var startIndex = this._getStartIndex();
            var endIndex = this._getEndIndex() + 1;

            this.usedTickData = [];
            for(var i = startIndex; i < endIndex; i++){
                this.usedTickData.push(this.tickData[i]);
            }

            this.minorTickData = [];
            if(this.componentOption.enableMinorTick && this.usedTickData.length){
                this.type == Constants.CATEGORY_AXIS_COMPONENT ? this._updateCategoryMinorTickData() : this._updateValueMinorTickData();
            }
        },

        _getAxisTitleLength:function(){
            var title = this.componentOption.title;
            var usedSize = 0;
            if(title){
                var dim = BaseUtils.getTextDimensionWithRotation(title.text, title.style, title.useHtml, title.rotation);
                usedSize = this.isHorizontal() ? dim.height : dim.width;
            }
            return usedSize;
        },

        //坐标轴占据的空间
        getAxisTitleBounds:function(){

            var bounds = this.bounds;

            var tickLength = this.tickLabelLength + TITLE_LABEL_GAP;;

            var position = this.componentOption.position;

            var x = bounds.x;
            var y = bounds.y;
            var width = bounds.width;
            var height = bounds.height;

            switch (position){
                case Constants.LEFT:
                    width -= tickLength;
                    break;

                case Constants.BOTTOM:
                    y += tickLength;
                    height -= tickLength;
                    break;

                case Constants.RIGHT:
                    x += tickLength;
                    width -= tickLength;
                    break;

                case Constants.TOP:
                    height -= tickLength;
                    break;
            }

            return {
                x:x,
                y:y,
                width:width,
                height:height
            }
        },

        _updateRange:function(){
            this.scale.rangeRound(this._getRange());
        },

        //边界确定以后,更新domain
        _updateDomainWhenSizeFixed:function(){

        },

        _getRange:function(){
            switch (this.componentType) {
                case Constants.RADIUS_AXIS_COMPONENT:
                    return [0, this.polar.radius];
                default:
                    var plotBounds = this.vanchart.getPlotBounds();
                    var cfg = this.componentOption;

                    if(this.isHorizontal()){
                        return cfg.reversed ? [plotBounds.width, 0] : [0, plotBounds.width];
                    }else{
                        return cfg.reversed ? [0, plotBounds.height] : [plotBounds.height, 0];
                    }
            }
        },

        _preCalculatePlotLines:function(){
            var plotLines = this.componentOption.plotLines || [];
            var position = this.componentOption.position;
            var plotBounds = this.vanchart.getPlotBounds();
            var axisBounds = this.bounds;

            var scale = this.scale;
            var isDate = this.type == Constants.DATE_AXIS_COMPONENT ;

            var result = [];

            plotLines.forEach(function(d){

                var pos = scale(isDate ? BaseUtils.object2date(d.value) : d.value) + (scale.rangeBand ? scale.rangeBand()/2 : 0);
                var startPos;
                var endPos;

                pos = BaseUtils.lineSubPixelOpt(pos, d.width);

                switch (position){
                    case Constants.TOP:
                        startPos = {x:pos, y: axisBounds.y + axisBounds.height - plotBounds.y};
                        endPos = {x:pos, y: plotBounds.height};
                        break;
                    case Constants.BOTTOM:
                        startPos = {x:pos, y:0};
                        endPos = {x:pos, y: axisBounds.y - plotBounds.y};
                        break;
                    case Constants.LEFT:
                        startPos = {x: axisBounds.x + axisBounds.width - plotBounds.x, y:pos};
                        endPos = {x:plotBounds.width, y:pos};
                        break;
                    case Constants.RIGHT:
                        startPos = {x: axisBounds.x - plotBounds.x, y:pos};
                        endPos = {x:0, y:pos};
                        break;
                }

                var textX, textY, text, style;
                textX = textY = 0, text = '', style = {};

                var minX = Math.min(startPos.x, endPos.x);
                var maxX = Math.max(startPos.x, endPos.x);
                var minY = Math.min(startPos.y, endPos.y);
                var maxY = Math.max(startPos.y, endPos.y);

                if(position == Constants.TOP || position == Constants.BOTTOM){
                    if(minX < 0 || maxX > plotBounds.width){
                        return;
                    }
                }else{
                    if(minY < 0 || maxY > plotBounds.height){
                        return;
                    }
                }

                if(d.label && d.label.text && d.label.style){
                    style = d.label.style;
                    text = d.label.text;
                    var align = d.label.align;
                    var textDim = BaseUtils.getTextDimension(text, style, d.label.useHtml);

                    if(d.label.useHtml){
                        textDim.width = BaseUtils.pick(d.label.labelWidth, textDim.width);
                        textDim.height = BaseUtils.pick(d.label.labelHeight, textDim.height);
                    }

                    switch (align){
                        case Constants.TOP:
                            textX = minX - textDim.width;
                            textY = minY;
                            break;
                        case Constants.BOTTOM:
                            textX = minX - textDim.width;
                            textY = maxY - textDim.height;
                            break;
                        case Constants.LEFT:
                            textX = minX;
                            textY = minY - textDim.height - LABEL_LINE_GAP;
                            break;
                        case Constants.RIGHT:
                            textX = maxX - textDim.width;
                            textY = minY - textDim.height - LABEL_LINE_GAP;
                            break;
                    }
                }

                result.push({
                    color: d.color,
                    startPos:startPos,
                    endPos:endPos,
                    width: d.width,
                    dataArray:Constants.DASH_TYPE[d.dashStyle],

                    text:text,
                    textDim:textDim,
                    style:style,
                    textX:textX,
                    textY:textY
                });
            });

            return result;
        },

        _preCalculatePlotBands:function(){

            var plotBands = this._getPlotBands();
            var scale = this.scale;
            var isRangeBand = !!scale.rangeBand;
            var rangeBand = isRangeBand ? scale.rangeBand() : 0;

            var result = [];
            var plotBounds = this.vanchart.getPlotBounds();
            var self = this;

            var domain = this.scale.domain();

            plotBands.forEach(function(d){

                var from, to;

                var t_f = scale(d.from);
                var t_t = scale(d.to);

                from = Math.min(t_f, t_t);
                to = Math.max(t_f, t_t);

                to += rangeBand;

                var x = 0, y = 0, width = plotBounds.width, height = plotBounds.height;

                if(self.isHorizontal()){
                    from = Math.max(x, from);
                    to = Math.min(width + x, to);
                    x = from;
                    width = to - from;
                }else{
                    from = Math.max(y, from);
                    to = Math.min(height + y, to);
                    y = from;
                    height = to - from;
                }

                if (width <= 0 || height <= 0) {
                    return;
                }

                result.push({x:x, y:y, width:width, height:height, color: d.color});
            });

            return result;
        },

        _getPlotBands:function(){

            var plotBands = this.componentOption.plotBands;
            var scale = this.scale;
            var isRangeBand = !!scale.rangeBand;

            if(typeof plotBands == 'string'){

                var color = plotBands;
                plotBands = [];

                var labels = this._getTickValuesWithEndValue();

                var endIndex = isRangeBand ? -1 : 0;

                for(var index = labels.length - 1; index > endIndex; index -= 2){
                    plotBands.push({
                        color:color,
                        from:isRangeBand ? labels[index] : labels[index - 1],
                        to:labels[index]
                    });
                }

            }else{

                plotBands = plotBands || [];

                var result = [];

                for(var i = 0, count = plotBands.length; i < count; i++){

                    var t_bands = plotBands[i];

                    if(BaseUtils.hasDefined(t_bands.from) && BaseUtils.hasDefined(t_bands.to)){
                        result.push(t_bands);
                    }

                }

                plotBands = result;
            }

            return plotBands;

        },

        //考虑tickFormat的作用
        _getTickValues:function(){
            return [];
        },

        _getTickInterval:function(){

            //考虑一开始的区间不满一个tick
            if(this.valueList.length > 2){
                return BaseUtils.accAdd(this.valueList[2], -this.valueList[1]);
            }else{
                return BaseUtils.accAdd(this.valueList[1], -this.valueList[0])
            };

        },

        _getTickValuesWithEndValue:function(){
            return this._getTickValues();
        },

        //画的时候计算自定义标签间隔等
        getTickData:function(){
            return this.usedTickData;
        },

        getMaxTickWidth:function(){
            var maxWidth = 0;

            this.usedTickData.forEach(function(data){

                maxWidth = Math.max(maxWidth, data.tickDim.width);

            });
            return maxWidth;
        },

        getTickHeight:function(){

            if(this.componentOption.labelStyle){
                return BaseUtils.getTextHeight(this.componentOption.labelStyle);
            }

            return 0;

        },

        getMinorTickData:function(){
            return this.minorTickData;
        },

        //todo 这个方法要删掉
        getMainTickData:function(){

            var cfg = this.componentOption;

            var update = !cfg.log && !this.byPercent && this.type == Constants.VALUE_AXIS_COMPONENT;

            if(update){

                var interval = this._getTickInterval();

                if(this.usedTickData.length > 3){

                    var secondMin = this.usedTickData[1].tickValue;

                    var secondMax = this.usedTickData[this.usedTickData.length - 2].tickValue;

                    var startIndex = 0;
                    var endIndex = this.usedTickData.length;

                    if(BaseUtils.hasDefined(cfg.min) && BaseUtils.accAdd(secondMin, -interval) < cfg.min){
                        startIndex += 1;
                    }

                    if(BaseUtils.hasDefined(cfg.max) && BaseUtils.accAdd(secondMax, interval) > cfg.max){
                        endIndex -= 1;
                    }

                    var mainTickData = [];
                    for(var i = startIndex; i < endIndex; i++){
                        mainTickData.push(this.usedTickData[i]);
                    }

                    return mainTickData;
                }

            }

            return this.getTickData();
        },

        _updateCategoryMinorTickData:function(){
            var minorTickLength = Math.round(this.getTickLength() / 5);
            var endIndex = this.usedTickData.length;
            endIndex = this.scale.rangeBand ? endIndex : endIndex - 1;
            for(var i = 0; i < endIndex; i++){
                var startPos = this.usedTickData[i].tickPos;
                for(var j = 1; j < 5; j++){
                    this.minorTickData.push(
                        startPos + minorTickLength * j
                    );
                }
            }
        },

        _updateValueMinorTickData:function(){

            var cfg = this.componentOption;
            var interval = this._getTickInterval();
            var minorInterval = cfg.minorTickInterval ? cfg.minorTickInterval : interval / 5;

            for(var i = 0, count = this.usedTickData.length; i < count - 1; i++){

                var start = this.usedTickData[i].tickValue;

                var end = this.usedTickData[i + 1].tickValue;

                var isDate = (start instanceof Date && end instanceof Date);

                start = isDate ? BaseUtils.date2int(start) : start;
                end = isDate ? BaseUtils.date2int(end) : end;

                if(i == 0){
                    for(var value = BaseUtils.accAdd(end, -minorInterval); value > start; value = BaseUtils.accAdd(value, -minorInterval)){
                        this.minorTickData.push(isDate ? BaseUtils.int2date(value) : value);
                    }
                }else{
                    for(var value = BaseUtils.accAdd(start,minorInterval); value < end; value = BaseUtils.accAdd(value, minorInterval)){
                        this.minorTickData.push(isDate ? BaseUtils.int2date(value) : value);
                    }
                }
            }

            var endValue = this.tickData[this.tickData.length - 1].tickValue;
            var maxValue = this.scale.domain()[1];

            var isDate = (endValue instanceof Date) && (maxValue instanceof Date);
            endValue = isDate ? BaseUtils.date2int(endValue) : endValue;
            maxValue = isDate ? BaseUtils.date2int(maxValue) : maxValue;

            if(endValue < maxValue){
                for(var value = endValue + minorInterval; value <= maxValue; value += minorInterval){
                    this.minorTickData.push(isDate ? BaseUtils.int2date(value) : value);
                }
            }
        },

        _updateTickContent:function(){
            var axisOption = this.componentOption;
            var scale = this.scale;

            var det = scale.rangeBand ? scale.rangeBand()/2 : 0;
            this.tickData.forEach(function(t){
                t.tickPos = scale(t.tickValue);
                t.tickLabelPos = t.tickPos + det;
            });

            if(!axisOption.showLabel){
                this.tickData.forEach(function(t){
                    t.tickContent = '';
                })
            }else if(axisOption.step){
                var index = 0;
                this.tickData.forEach(function(t){
                    if(index++ % axisOption.step){
                        t.tickContent = '';
                    }
                });
            }else{
                var manager = new BoundsManager();
                var isHorizontal = this.isHorizontal();

                var testStep = 1;
                var longestStep = 1;

                this.tickData.forEach(function(t){

                    var pos = isHorizontal ? {x:scale(t.tickValue), y:0} : {x:0, y:scale(t.tickValue)};
                    var bounds = BaseUtils.makeBounds(pos, t.tickDim);

                    if(manager.isOverlapped(bounds)){

                        testStep++;
                        longestStep = Math.max(longestStep, testStep);

                    }else{
                        testStep = 1;
                        manager.addBounds(bounds);
                    }
                });

                var index = 0;
                this.tickData.forEach(function(t){
                    if(index++ % longestStep){
                        t.tickContent = '';
                    }
                });
            }
        },

        _getStartIndex:function(){
            return BaseUtils.pick(this.componentOption.startIndex, 0);
        },

        _getEndIndex:function(){
            return BaseUtils.pick(this.componentOption.endIndex, this.tickData.length - 1);
        },

        _getOriginDet:function(){
            var plotOrigin = this._getPlotOriginPoint();
            var axisOrigin = this._getAxisOriginPoint();
            return {x:plotOrigin.x - axisOrigin.x, y:plotOrigin.y - axisOrigin.y};
        },

        //坐标轴如果靠近plotBounds的话的原点位置，考虑多个坐标轴的的时候
        _getPlotOriginPoint:function(){
            var plotBounds = this.vanchart.getPlotBounds();
            var position = this.componentOption.position;
            var x,y;

            switch(position){
                case Constants.TOP:
                    x = plotBounds.x;
                    y = plotBounds.y;
                    break;

                case Constants.BOTTOM:
                    x = plotBounds.x;
                    y = plotBounds.y + plotBounds.height;
                    break;

                case Constants.LEFT:
                    x = plotBounds.x;
                    y = plotBounds.y;
                    break;

                case Constants.RIGHT:
                    x = plotBounds.x + plotBounds.width;
                    y = plotBounds.y;
                    break;
            }

            return {x:x, y:y};
        },

        _getAxisOriginPoint:function(){
            var axisBounds = this.bounds;
            var position = this.componentOption.position;
            var x,y;

            switch(position){
                case Constants.TOP:
                    x = axisBounds.x;
                    y = axisBounds.y + axisBounds.height;
                    break;

                case Constants.BOTTOM:
                    x = axisBounds.x;
                    y = axisBounds.y;
                    break;

                case Constants.LEFT:
                    x = axisBounds.x + axisBounds.width;
                    y = axisBounds.y;
                    break;

                case Constants.RIGHT:
                    x = axisBounds.x;
                    y = axisBounds.y;
                    break;
            }

            return {x:x, y:y};
        },

        getTickScale:function(){
            return this.scale;
        },

        axisZoom:function(downPos, upPos){

        },

        _initZoomStatus:function(){

        },

        isAxisReversed:function(){
            return this.componentOption.reversed;
        },

        isOnZero:function(){
            return this.componentOption.onZero;
        },

        getLineWidth:function(){
            return this.componentOption.lineWidth;
        },

        showArrow:function(){
            return this.componentOption.showArrow;
        },

        getTitleLabelGap:function(){
            return TITLE_LABEL_GAP;
        },

        getAxisIndex:function(){
            return this.componentOption.axisIndex;
        },

        //普通的值轴
        _calculateValueNiceDomain:function(minValue, maxValue, fixedMin, fixedMax, zoomFix){

            var fromZero = this.type == Constants.VALUE_AXIS_COMPONENT;

            var axisOption = this.componentOption;

            minValue = fromZero ? Math.min(0, minValue) : minValue;

            minValue = BaseUtils.hasDefined(fixedMin) ? fixedMin : minValue;
            maxValue = BaseUtils.hasDefined(fixedMax) ? fixedMax : maxValue;

            // if any exceeded min, adjust max to min + 100
            if(minValue >= maxValue){
                maxValue = minValue + MIN_MAX_GAP * (this.type === Constants.DATE_AXIS_COMPONENT ? 1000 : 1);
            }

            var tickInterval = axisOption.tickInterval || this._linearTickInterval(minValue, maxValue);

            var domain = this._linearNiceDomain(minValue, maxValue, tickInterval);
            minValue = BaseUtils.hasDefined(fixedMin) ? fixedMin : domain[0];
            maxValue = BaseUtils.hasDefined(fixedMax) ? fixedMax : domain[1];

            if(minValue >= maxValue){
                maxValue = minValue + MIN_MAX_GAP * (this.type === Constants.DATE_AXIS_COMPONENT ? 1000 : 1);
            }

            var start = domain[0];

            if(BaseUtils.hasDefined(fixedMin)){

                // ceil( (fixedMin - start) / tickInterval ) * tickInterval
                var diff = BaseUtils.accMul(
                    Math.ceil(
                        BaseUtils.accDiv(BaseUtils.accAdd(fixedMin, -start), tickInterval)
                    ),
                    tickInterval
                );

                start = BaseUtils.accAdd(start, diff);
            }

            this.valueList = [];

            for(; start <= maxValue; start = BaseUtils.accAdd(start, tickInterval)){
                this.valueList.push(start);
            }

            this.lastScale = this.scale && this.scale.copy();

            this.scale = this.scale ?
                this.scale.domain([minValue, maxValue]) : d3.scale.linear().domain([minValue, maxValue]);

            return {minValue: minValue, maxValue: maxValue};
        },

        _linearTickInterval:function(minValue, maxValue, m){

            m = m || this._getDefaultTickCount();
            var span = maxValue - minValue;
            var step = Math.pow(10, Math.floor(Math.log(span / m) / Math.LN10));
            var err = m / span * step;

            if (err <= .15) step *= 10; else if (err <= .35) step *= 5; else if (err <= .75) step *= 2;

            return step;
        },

        _linearNiceDomain:function(minValue, maxValue, tickInterval){

            minValue = BaseUtils.accMul(Math.floor(minValue / tickInterval), tickInterval);

            maxValue = BaseUtils.accMul(Math.ceil(maxValue / tickInterval), tickInterval);

            return [minValue, maxValue];
        },

        _getDefaultTickCount:function(){
            return this.option.chartType == Constants.RADAR_CHART ? RADAR_TICK_COUNT : TICK_COUNT;
        },

        _isSeriesVisible:function(sery){
            var queryList = [
                sery,
                this.option.plotOptions[sery.type],
                this.option.plotOptions
            ];
            return BaseUtils.pick(QueryUtils.queryList(queryList, 'visible'), true);
        },

        //gauge,radar的时候不用画
        getRender:function(){

            var chartType = this.option.chartType;

            if (chartType === Constants.GAUGE_CHART
                || this.option.plotOptions.force) {
                return null;
            }

            return this.render;

        },

        // Polar's

        getPolarInitPoint: function () {
            // begin from 0 at present
            return BaseUtils.getArcPoint(this.polar.radius, 0);
        },

        getRadiusPlotBands:function(){

            var plotBands = this._getPlotBands();

            var result = [];

            var self = this;

            plotBands.forEach(function(d){
                result.push({
                    path: self._getRadiusPlotBandsPath(d.from, d.to),
                    color: d.color
                });
            });

            return result;
        },

        _getRadiusPlotBandsPath: function (from, to) {

            var shape = this.option.plotOptions.shape || Constants.CIRCLE_RADAR;

            if (shape === Constants.POLYGON_RADAR) {
                return this._getRadiusGridPath(Math.min(from, to)) + this._getRadiusGridPath(Math.max(from, to), true)
            } else {
                var arc = d3.svg.arc().startAngle(0).endAngle(2 * Math.PI);
                return arc.innerRadius(this.scale(Math.min(from, to)))
                    .outerRadius(this.scale(Math.max(from, to)))();
            }

        },

        getPlotLines:function(){

            var plotLines = this.componentOption.plotLines || [];
            var self = this;

            var result = [];
            plotLines.forEach(function(d){

                var text, style, align;
                if(d.label && d.label.text && d.label.style){
                    text = d.label.text;
                    style = d.label.style;
                    align = d.label.align;
                }

                result.push({
                    color: d.color,
                    value: d.value,
                    width: d.width,
                    dataArray:Constants.DASH_TYPE[d.dashStyle],
                    text:text,
                    baseY:-self.scale(d.value),
                    textAnchor:align == Constants.LEFT ? 'end' : 'start',
                    style:style
                });
            });

            return result;
        },

        // radius grids are circles
        _getRadiusGridPath: function (value, reversed) {

            var data = this._getRadiusGridData(value, reversed);

            return this._getRadiusGridPathByData(data);
        },

        _getRadiusGridData: function (value, reversed, scale) {

            var radiusScale = scale || this.scale;
            var angleAxis = this.polar.angleAxis;

            var shape = this.option.plotOptions.shape || Constants.CIRCLE_RADAR;

            if (shape === Constants.POLYGON_RADAR) {

                var points = [];

                var cateScale = angleAxis.scale;
                var categories = cateScale.domain();

                categories.forEach(function(category){

                    var radian = cateScale(category) * angleAxis.piece;

                    var r = radiusScale(value);

                    points.push(BaseUtils.getArcPoint(r, radian));

                });

                if (reversed) {
                    points.reverse();
                }

                return points;

            } else {
                return radiusScale(value);
            }
        },

        _getRadiusGridPathByData: function(data) {

            if(BaseUtils.isArray(data)){

                var path = "";

                if(data.length){
                    for(var i = 0, count = data.length; i < count; i++){

                        var mOrl = i ? 'L' : 'M';

                        path += (mOrl + BaseUtils.dealFloatPrecision(data[i][0]) + "," + BaseUtils.dealFloatPrecision(data[i][1]));
                    }

                    path += 'Z';
                }

                return path;

            }else{

                var arc = d3.svg.arc().startAngle(0).endAngle(2 * Math.PI).innerRadius(0);

                return arc.outerRadius(data)();
            }

        },

        getAngleGridLineData: function () {

            var points = [];

            var angleAxis = this.polar.angleAxis;
            var categories = angleAxis.scale.domain();
            var self = this;

            categories.forEach(function(category){

                var radian = angleAxis.scale(category) * angleAxis.piece;

                var r = self.polar.radius;

                points.push(BaseUtils.getArcPoint(r, radian));

            });

            points = points.length ? points : [BaseUtils.getArcPoint(this.polar.radius, 0)];

            return points;
        },

        _testRadius:function(radius, testBounds){

            for(var i = 0, count = this.tickData.length; i < count; i++){

                var tick = this.tickData[i];
                var labelBounds = this._getCateLabelBounds(radius, tick);

                if(!BaseUtils.containsRect(testBounds, labelBounds)){
                    return false;
                }

            }
        },

        _getCateLabelBounds:function(radius, cateTick){

            var category = cateTick.tickValue;
            var tickDim = cateTick.tickDim;
            var domain = this.scale.domain();
            var index = domain.indexOf(category);
            var arcPoint = BaseUtils.getArcPoint(radius + PADDING_GAP, index * this.piece);
            var pos;

            var position = this._getPolarPosition(category);

            switch (position){

                case TOP:

                    pos = {
                        x:-tickDim.width/2,
                        y:-radius - tickDim.height * 0.65 - PADDING_GAP
                    };

                    break;

                case RIGHT:

                    pos = {
                        x:arcPoint[0],
                        y:arcPoint[1] - tickDim.height/2
                    };

                    break;

                case BOTTOM:

                    pos = {
                        x:-tickDim.width/2,
                        y:radius + PADDING_GAP
                    };

                    break;

                case LEFT:

                    pos = {
                        x:arcPoint[0] - tickDim.width,
                        y:arcPoint[1] - tickDim.height/2
                    };

                    break;
            }

            cateTick.tickPos = pos;
            return BaseUtils.makeBounds(pos, tickDim);
        },

        _getPolarPosition:function(category){

            var domain = this.scale.domain();
            var index = domain.indexOf(category);
            var midIndex = domain.length / 2;

            if(index == 0){
                return TOP;
            }else if(index > 0 && index < midIndex){
                return RIGHT;
            }else if(index == midIndex){
                return BOTTOM;
            }else if(index > midIndex){
                return LEFT;
            }

        },

        _findNiceRadius:function(testBounds){

            var tmpBounds = [
                - testBounds.y,
                testBounds.width - testBounds.x,
                testBounds.height + testBounds.y,
                - testBounds.x
            ];

            var minRadius = Math.min.apply(null, tmpBounds);

            var domain = this.scale.domain();
            var self = this;

            this.tickData.forEach(function(cateTick){
                if(cateTick.tickContent){

                    var category = cateTick.tickValue;
                    var tickDim = cateTick.tickDim;

                    var index = domain.indexOf(category);
                    var position = self._getPolarPosition(category);

                    var radius;
                    switch (position) {
                        case TOP:
                            radius = tmpBounds[0] - tickDim.height;
                            break;
                        case RIGHT:
                            radius = (tmpBounds[1] - tickDim.width) / Math.abs(Math.sin(index * self.piece));
                            break;
                        case BOTTOM:
                            radius = tmpBounds[2] - tickDim.height;
                            break;
                        case LEFT:
                            radius = (tmpBounds[3] - tickDim.width) / Math.abs(Math.sin(index * self.piece));
                            break;
                        default:
                    }

                    minRadius = Math.min(minRadius, radius);
                }
            });

            return minRadius - PADDING_GAP;
        },

        getIndexByPosition: function (pos) {
            var plotBounds = this.getPlotBounds();
            var scale = this.scale;
            var startX = scale(
                this.isAxisReversed() ?
                    scale.domain()[scale.domain().length - 1] :
                    scale.domain()[0]
            );
            var x = pos[0] - plotBounds.x - startX;

            var index;
            switch (this.type) {
                case Constants.DATE_AXIS_COMPONENT:
                    index = BaseUtils.date2int(scale.invert(x));
                    break;
                default:
                    index = scale.invert(x);
            }

            index = Math.round(index);
            return index;
        }
    });

    //todo to be deleted
    // function BaseAxis(vanchart, option, componentType){
    //     Base.call(this, vanchart, option, componentType);
    //     this.scale = null;
    //     this.lastScale = null;
    //
    //     this.tickLabelLength = 0;
    //
    //     this.tickData = [];
    //     this.minorTickData = [];
    //     this.usedTickData = [];
    //
    //     this.polar = null;
    // }

    BaseAxis.addInitHook(BaseAxis.prototype.init);
    
    return BaseAxis;
});
/**
 * Created by eason on 15/5/18.
 * 分类轴的定义
 */
define('component/CategoryAxis',['require','./Base','./BaseAxis','../utils/BaseUtils','../Constants','../ComponentLibrary'],function(require){
    var Base = require('./Base');
    var BaseAxis = require('./BaseAxis');
    var BaseUtils = require('../utils/BaseUtils');
    var Constants = require('../Constants');
    
    var CategoryAxis = BaseAxis.extend({

        type:Constants.CATEGORY_AXIS_COMPONENT,
        
        init: function () {
            this.isRangePoints = null;
            this.piece = null;
            this.highlightType = null;
        },

        initAttributesWithSeries:function(){

            var axisOption = this.componentOption;

            var series = this.vanchart.series;
            var stored = {};
            var isBaseAxis = this.isBaseAxis;

            var categories = axisOption.categories || [];

            categories.forEach(function(category){
                stored[category] = true;
            });

            this.isRangePoints = true;
            this.highlightType = 'line';

            for(var i = 0, len = series.length; i < len; i++){

                var sery = series[i];

                var byAxis = sery[this.componentType];

                if(byAxis == this){
                    var points = sery.originalPoints || sery.points;
                    points.forEach(function(point){
                        var label =  isBaseAxis ? point.category : point.value;
                        if(BaseUtils.hasDefined(label) && !stored[label]){
                            categories.push(label);
                            stored[label] = true;
                        }
                    });
                    if (!this._isSeriesVisible(sery)) {
                        continue;
                    }
                    if (sery.type !== Constants.AREA_CHART) {
                        this.isRangePoints = false;
                    }
                }
            }
            
            this.categories = categories;

            this.scale = d3.scale.ordinal().domain(this.categories);

            switch(this.componentType) {
                case Constants.ANGLE_AXIS_COMPONENT:
                    this.isRangePoints = true;
                    this.piece = (Math.PI * 2) / Math.max(categories.length, 1);
                    break;
                default:
            }

            this._updateOriginTickData();
        },

        updateCategories:function(newCategories){

            this.categories = newCategories;

            this.scale.domain(newCategories);

            this._updateOriginTickData();
        },

        _updateIndex:function(start, end){
            this.componentOption.startIndex = start;
            this.componentOption.endIndex = end;
        },

        getCategoryCount:function(){
            return this.categories.length;
        },

        indexOfLabel:function(label){
            return BaseUtils.indexInArray(this.categories, label);
        },

        getTickLength:function(){

            var domain = this.scale.domain();

            var range = this.scale.rangeExtent();

            var cateLength = Math.abs(range[1] - range[0]);

            if(this.isRangePoints && domain.length <= 1){
                return cateLength;
            }

            return  this.isRangePoints ? cateLength / (domain.length - 1) : this.scale.rangeBand();
        },

        _updateRange:function(){
            this.updateAxisScale(this._getStartIndex(), this._getEndIndex());
        },

        getValueFromData:function(datum, dIndex){

            var categories = this.componentOption.categories;

            var valueIndex = this.isBaseAxis ? 0 : 1;

            var map = {
                'xAxis': 'x',
                'yAxis': 'y',
                'angleAxis': 'x',
                'radiusAxis': 'y',
                'gaugeAxis': 'y'
            };
            var valueKey = map[this.componentType];

            var cateory = BaseUtils.isArray(datum) ? datum[valueIndex] : datum[valueKey];

            return BaseUtils.hasDefined(cateory) ? cateory : categories[dIndex];
        },

        //考虑tickFormat的作用
        _getTickValues:function(){
            return this.scale.domain();
        },

        getCategories:function(){
            return this.scale.domain();
        },

        axisZoom:function(downPos, upPos){

            var startPos, endPos;

            var plotBounds = this.vanchart.getPlotBounds();

            //坐标轴是横向的
            if(this.isHorizontal()){
                startPos = Math.min(downPos[0], upPos[0]) - plotBounds.x;
                endPos = Math.max(downPos[0], upPos[0]) - plotBounds.x;
            }else{
                startPos = Math.min(downPos[1], upPos[1]) - plotBounds.y;
                endPos = Math.max(downPos[1], upPos[1]) - plotBounds.y;
            }

            var domain = this.scale.domain();
            var range = this.scale.rangeExtent();

            range = this._getRangeWithMinMax(range[0], range[1]);

            var tmpScale = d3.scale.quantize().domain(range).range(domain);

            var start = BaseUtils.indexInArray(this.categories, tmpScale(startPos));
            var end = BaseUtils.indexInArray(this.categories, tmpScale(endPos));

            this.updateAxisScale(Math.min(start, end), Math.max(start, end));
        },

        updateAxisScale:function(start, end){
            var domain = this.scale.domain();

            if (start == -1 || end == -1) {
                return;
            }

            var range;
            if (this.componentType === Constants.ANGLE_AXIS_COMPONENT) {
                range = [0, this.categories.length - 1];
            } else {

                var tmp = [];

                for (var index = start; index <= end; index++) {
                    tmp.push(domain[index]);
                }

                this._updateIndex(start, end);

                var plotRange = this._getRange();

                var rangeBands;
                if (this.isRangePoints) {
                    rangeBands = Math.abs(plotRange[0] - plotRange[1]) / Math.max(tmp.length - 1, 1);
                } else {
                    rangeBands = Math.abs(plotRange[0] - plotRange[1]) / tmp.length
                }

                var minValue = Math.min(plotRange[0], plotRange[1]);
                var maxValue = Math.max(plotRange[0], plotRange[1]);
                var t_s = start;
                var t_e = end;
                if (this.isAxisReversed()) {
                    var totalCount = this.categories.length - 1;
                    t_s = Math.min(totalCount - start, totalCount - end);
                    t_e = Math.max(totalCount - start, totalCount - end);
                }

                if (this.isHorizontal()) {
                    minValue -= t_s * rangeBands;
                    maxValue += (this.categories.length - t_e - 1) * rangeBands;
                } else {
                    minValue -= (this.categories.length - t_e - 1) * rangeBands;
                    maxValue += t_s * rangeBands;
                }

                range = this._getRangeWithMinMax(minValue, maxValue);
            }

            this.isRangePoints ? this.scale.rangePoints(range) : this.scale.rangeBands(range);

            this._updateOriginTickData();
            this._calculateTickData();

        },

        _getRangeWithMinMax:function(min, max){
            var cfg = this.componentOption;

            if(this.isHorizontal()){
                return cfg.reversed ? [max, min] : [min, max];
            }else{
                return cfg.reversed ? [min, max] : [max, min];
            }
        },

        _initZoomStatus:function(){
            var zoom = this.vanchart.getComponent(Constants.ZOOM_COMPONENT);
            if(zoom && zoom.zoomToolEnabled() && BaseUtils.isSupportSVG()){

                if(this.vanchart.isInitOrRestoreState()){

                    var start = 0;
                    var end = this.categories.length - 1;

                    var zoomTool = zoom.componentOption.zoomTool;

                    if(zoomTool.from && BaseUtils.indexInArray(this.categories, zoomTool.from) != -1){
                        start = BaseUtils.indexInArray(this.categories, zoomTool.from);
                    }

                    if(zoomTool.to && BaseUtils.indexInArray(this.categories, zoomTool.to) != -1){
                        end = BaseUtils.indexInArray(this.categories, zoomTool.to);
                    }

                    this.updateAxisScale(Math.min(start, end), Math.max(start, end));

                }else{
                    this.updateAxisScale(this._getStartIndex(), this._getEndIndex());
                }
            }
        },

        getHighlightType: function () {
            return this.highlightType;
        },

        getIndexByPosition: function (pos) {

            switch (this.componentType) {
                case Constants.X_AXIS_COMPONENT:
                case Constants.Y_AXIS_COMPONENT:

                    return this._getIndexByXYCoordinate(pos);

                case Constants.ANGLE_AXIS_COMPONENT:

                    return this._getIndexByPolarCoordinate(pos);
            }

        },

        _getIndexByPolarCoordinate: function (pos) {
            var center = this.polar.center;
            var r = this.polar.radius;
            var isReversed = this.isAxisReversed();

            var x = pos[0]-center[0];
            var y = center[1]-pos[1];

            if ((x*x + y*y) > r*r) {
                return -1;
            }

            var arc = BaseUtils.getArcByPoint(x, y);

            var index;
            var categories = this.getCategories();
            if (categories.length > 1) {
                var unitLength = 2 * Math.PI / categories.length;
                index = isReversed ? categories.length - 1 - arc / unitLength : arc / unitLength;
            } else {
                index = 0;
            }

            index = Math.round(index);

            index = index % categories.length;

            return index;
        },

        _getIndexByXYCoordinate: function (pos) {
            var plotBounds = this.getPlotBounds();
            var scale = this.scale;
            var isY = this.componentType === Constants.Y_AXIS_COMPONENT;
            var isReversed = this.isAxisReversed() ^ isY;

            var startX = scale(
                isReversed ?
                    scale.domain()[scale.domain().length - 1] :
                    scale.domain()[0]
            );

            var x;

            if (isY) {
                x = pos[1] - plotBounds.y - startX;
            } else {
                x = pos[0] - plotBounds.x - startX;
            }

            var index;
            var categories = this.getCategories();
            if (categories.length > 1) {
                var unitLength = Math.abs(scale(scale.domain()[1]) - scale(scale.domain()[0]));
                index = isReversed ? categories.length - 1 - x / unitLength : x / unitLength;
            } else {
                index = 0;
            }

            if (this.getHighlightType() === 'line' && this.isRangePoints) {
                index = Math.round(index);
            } else {
                index = isReversed ? Math.ceil(index) : Math.floor(index);
            }

            return index;
        },

        _getBandByIndex: function (index){
            switch (this.componentType) {
                case Constants.X_AXIS_COMPONENT:
                case Constants.Y_AXIS_COMPONENT:

                    return this._getXYBandByIndex(index);

                case Constants.ANGLE_AXIS_COMPONENT:

                    return this._getPolarBandByIndex(index);
            }
        },

        _getPolarBandByIndex: function (index) {
            var scale = this.scale;
            var domain = scale.domain();

            var r = this.polar.radius;
            var center = this.polar.center;
            var radian = scale(domain[index]) / domain.length * 2 * Math.PI;

            var band;
            if (this.getHighlightType() === 'line') {
                var point = BaseUtils.getArcPoint(r, radian);

                band = {
                    x: point[0],
                    y: point[1]
                };
            } else {
                var halfSize = 1 / domain.length * 2 * Math.PI * 0.5;
                var startRadian = radian - halfSize;
                var endRadian = radian + halfSize;

                // var shape = this.option.plotOptions.shape || Constants.CIRCLE_RADAR;
                // if (shape === Constants.POLYGON_RADAR) {
                //     var point1 = BaseUtils.getArcPoint(r, startRadian);
                //     var point2 = BaseUtils.getArcPoint(r, endRadian);
                //
                //     var path = 'M' + center[0] + ',' + center[1];
                //
                //     path += 'L' + point1[0] + ',' + point1[1] +
                //             'L' + point2[0] + ',' + point2[1];
                //
                //     path += 'Z';
                //
                //     band = {
                //         d: path
                //     }
                //
                // }

                var arc = d3.svg.arc()
                    .innerRadius(0)
                    .outerRadius(r)
                    .startAngle(startRadian)
                    .endAngle(endRadian);

                band = {
                    d: arc()
                }

            }

            return band;
        },

        _getXYBandByIndex: function (index) {
            var plotBounds = this.getPlotBounds();
            var ticks = this._getTickValuesWithEndValue();
            var scale = this.scale;
            var domain = scale.domain();
            var isY = this.componentType === Constants.Y_AXIS_COMPONENT;
            var isReversed = this.isAxisReversed() ^ isY;
            var from;
            var to;

            from = scale(domain[index]);

            var boundary = isY ? plotBounds.height : plotBounds.width;

            switch (this.getHighlightType()) {
                case 'band':
                    if (isReversed) {
                        if (index === 0) {
                            to = boundary;
                        } else {
                            to = scale(domain[index - 1]);
                        }
                    } else {
                        if (index + 1 === ticks.length) {
                            to = boundary;
                        } else {
                            to = scale(domain[index + 1]);
                        }
                    }
                    break;
                case 'line':
                default:
                    var det = this.isRangePoints ? 0 : scale.rangeBand()/2;
                    from += det;
                    to = from;
            }

            var band;

            if (this.componentType === Constants.X_AXIS_COMPONENT) {
                band = {
                    x: plotBounds.x + from,
                    y: plotBounds.y,
                    width: Math.abs(to - from),
                    height: plotBounds.height
                };
            } else if (this.componentType === Constants.Y_AXIS_COMPONENT) {
                band = {
                    x: plotBounds.x,
                    y: plotBounds.y + from,
                    width: plotBounds.width,
                    height: Math.abs(to - from)
                }
            }

            return band;
        },

        _getBandByPosition: function (pos) {
            var index = this.getIndexByPosition(pos);
            return this._getBandByIndex(index);
        }
    });
    
    // function (vanchart, option, axisOption, componentType){
    //     BaseAxis.call(this, vanchart, option, componentType);
    //     this.isRangePoints = false;
    //     this.piece = null;
    //     this.refresh(option, axisOption);
    // }
    CategoryAxis.addInitHook(CategoryAxis.prototype.init);

    require('../ComponentLibrary').register(Constants.CATEGORY_AXIS_COMPONENT, CategoryAxis);
    return CategoryAxis;
});
/**
 * Created by eason on 15/5/18.
 * 值轴的定义
 */
define('component/ValueAxis',['require','./Base','./BaseAxis','../utils/BaseUtils','../utils/QueryUtils','../Constants','../Constants','../ComponentLibrary'],function(require){
    var Base = require('./Base');
    var BaseAxis = require('./BaseAxis');
    var BaseUtils = require('../utils/BaseUtils');
    var QueryUtils = require('../utils/QueryUtils');
    var Constants = require('../Constants');
    var Constants = require('../Constants');

    var ValueAxis = BaseAxis.extend({

        type:Constants.VALUE_AXIS_COMPONENT,

        initAttributesWithSeries:function(){

            this._hasInited = true;

            //确定是不是byPercent
            var series = this.vanchart.series;
            this.byPercent = false;
            for(var i = 0,len = series.length; i < len && !this.byPercent; i++){
                var sery = series[i];

                var byAxis = sery[this.componentType];

                if(byAxis == this && sery.visible){
                    this.byPercent = sery.stackByPercent && !this.isBaseAxis;
                }
            }
            
            var minMax = this._calculateMinMaxValue();

            var axisOption = this.componentOption;

            this.originalDomain =
                this._calculateNiceDomain(minMax.minValue, minMax.maxValue, axisOption.min, axisOption.max);

            this._updateOriginTickData();
        },

        _updateDomainWhenSizeFixed:function(){

            var maxRadius = this.getMaxBubbleRadius();

            if(maxRadius && this.type == Constants.VALUE_AXIS_COMPONENT && this._hasInited){

                this._hasInited = false;

                var scale = this.scale;

                var domain = scale.domain();
                var range = scale.range();

                var minMax = this._calculateMinMaxValue();

                var maxRadiusNumber = Math.abs(maxRadius * (domain[0] - domain[1])/(range[1] - range[0]));

                var min = minMax.minValue - maxRadiusNumber;
                var max = minMax.maxValue + maxRadiusNumber;

                var axisOption = this.componentOption;

                this.originalDomain = this._calculateNiceDomain(min, max, axisOption.min, axisOption.max);

                this._updateOriginTickData();
            }

        },

        _calculateNiceDomain:function(minValue, maxValue, fixedMin, fixedMax, zoomFix){

            var axisOption = this.componentOption;

            if(axisOption.log && axisOption.log != 1){
                return this._calculateLogNiceDomain(minValue, maxValue);
            }else if(this.byPercent){
                return this._calculatePercentValueDomain();
            }else{
                return this._calculateValueNiceDomain(minValue, maxValue, fixedMin, fixedMax, zoomFix);
            }

        },

        _calculateLogNiceDomain:function(minValue, maxValue, ignoreMinMax){
            var axisOption = this.componentOption;

            var logBase = axisOption.log;

            var tickInterval = parseInt(BaseUtils.pick(axisOption.tickInterval, 1));

            this.valueList = [];

            minValue = minValue >= 1 ? 1 : minValue;
            minValue = minValue <= 0 ? 1 : minValue;

            minValue = ignoreMinMax ? minValue : BaseUtils.pick(axisOption.min, minValue);
            maxValue = ignoreMinMax ? maxValue : BaseUtils.pick(axisOption.max, maxValue);

            minValue = Math.pow(logBase, Math.floor(BaseUtils.log(logBase, minValue)));
            maxValue = Math.pow(logBase, Math.ceil(BaseUtils.log(logBase, maxValue)));


            this.scale = this.scale ? this.scale.domain([minValue, maxValue])
                : d3.scale.log().base(logBase).domain([minValue, maxValue]);

            var i = 0;
            while(minValue * Math.pow(logBase, i) <= maxValue){
                this.valueList.push(minValue * Math.pow(logBase, i));
                i += tickInterval;
            }

            return {minValue: minValue, maxValue: maxValue};
        },

        _calculatePercentValueDomain:function(){

            var axisOption = this.componentOption;

            var min = BaseUtils.pick(axisOption.min, 0);

            var max = BaseUtils.pick(axisOption.max, 1);

            var interval = BaseUtils.pick(axisOption.tickInterval, 0.25);

            this.valueList = [];

            for(var start = min; start <= max; start = BaseUtils.accAdd(start, interval)){
                this.valueList.push(start);
            }

            this.scale = this.scale ?
                this.scale.domain([min, max]) : d3.scale.linear().domain([min, max]);

            return {minValue: min, maxValue: max};
        },

        //从数据中计算最大最小值
        _calculateMinMaxValue:function(){

            var minValue = Number.MAX_VALUE;
            var maxValue = -minValue;
            var emptyData = true;

            var series = this.vanchart.series;
            var dataMap = {};

            for(var i = 0, len = series.length; i < len; i++){
                var sery = series[i];

                var byAxis = sery[this.componentType];

                if(byAxis == this && sery.visible){
                    this._getSeriesValue(dataMap, sery);
                }
            }

            for(var key in dataMap){
                var data = dataMap[key];
                for(var j = 0, dataCount = data.length; j < dataCount; j++){
                    if(!isNaN(data[j]) && !(this.componentOption.log && data[j] <= 0)){
                        minValue = Math.min(minValue, data[j]);
                        maxValue = Math.max(maxValue, data[j]);

                        emptyData = false;
                    }
                }
            }

            if(emptyData){
                minValue = 0;
                maxValue = 100;
            }

            return {
                minValue:minValue,
                maxValue:maxValue
            };
        },

        //获取系列的值，如果是堆积的话获取系列的和
        _getSeriesValue:function(dataMap, sery){

            var seriesName = sery.name || '';

            var isBaseAxis = this.isBaseAxis;

            if(BaseUtils.hasNotDefined(sery.stack) || isBaseAxis){
                dataMap[seriesName] = dataMap[seriesName] || [];

                sery.points.forEach(function(point){
                    dataMap[seriesName].push(isBaseAxis ? point.category : point.value);
                });

            }else{
                var PK = sery.stack + sery.type + 'STACK_POSITIVE';
                var NK = sery.stack + sery.type + 'STACK_NEGATIVE';
                dataMap[PK] = dataMap[PK] || [];
                dataMap[NK] = dataMap[NK] || [];

                sery.points.forEach(function(point, i){

                    var value = isBaseAxis ? point.category : point.value;

                    if(value > 0){
                        if(dataMap[PK][i] != null && dataMap[PK][i] != undefined){
                            dataMap[PK][i] += value;
                        }else{
                            dataMap[PK][i] = value;
                        }
                    }else{
                        if(dataMap[NK][i] != null && dataMap[NK][i] != undefined){
                            dataMap[NK][i] += value;
                        }else{
                            dataMap[NK][i] = value;
                        }
                    }

                });
            }
        },

        //'-'符号表示空值
        getValueFromData:function(datum){
            var valueIndex = this.componentType == Constants.X_AXIS_COMPONENT ? 0 : 1;
            var valueKey = this.componentType == Constants.X_AXIS_COMPONENT ? 'x' : 'y';

            var value = BaseUtils.isArray(datum) ? datum[valueIndex] : datum[valueKey];

            value = BaseUtils.pick(value, datum);

            value = +value;
            return isNaN(value) ? '-' : value;
        },

        //考虑有正负值的时候的0值对齐的功能
        getStartPos:function(){
            return this.scale(this.getStartPosValue());
        },

        getStartPosValue:function(){

            var axisOption = this.componentOption;

            return axisOption.log && axisOption.log != 1 ? Number.MIN_VALUE : 0;
        },

        getOriginalDomain: function () {
            return this.originalDomain;
        },

        //考虑tickFormat的作用
        _getTickValues:function(){
            return this.valueList;
        },

        _getTickValuesWithEndValue:function(){

            var result = BaseUtils.clone(this.valueList);

            var max = this.scale.domain()[1];

            if(result.length && result[result.length - 1] < max){
                result.push(max);
            }

            return result;
        },

        axisZoom:function(downPos, upPos){

            var startPos, endPos;

            var plotBounds = this.vanchart.getPlotBounds();

            //坐标轴是横向的
            if(this.isHorizontal()){
                startPos = Math.min(downPos[0], upPos[0]) - plotBounds.x;
                endPos = Math.max(downPos[0], upPos[0]) - plotBounds.x;

                startPos = Math.max(startPos, 0);
                endPos = Math.min(endPos, plotBounds.width);
            }else{
                startPos = Math.min(downPos[1], upPos[1]) - plotBounds.y;
                endPos = Math.max(downPos[1], upPos[1]) - plotBounds.y;

                startPos = Math.max(startPos, 0);
                endPos = Math.min(endPos, plotBounds.height);
            }

            var startValue = this.scale.invert(startPos);
            var endValue = this.scale.invert(endPos);

            this.updateAxisScale(Math.min(startValue, endValue), Math.max(startValue, endValue), true);
        },

        updateAxisScale:function(min, max, zoomFix){

            var cfg = this.componentOption;

            //值轴为底轴的时候,固定最大最小值才有效
            var minMax = this._calculateNiceDomain(min, max, this.isBaseAxis ? min : cfg.min, this.isBaseAxis ? max : cfg.max, zoomFix && this.isBaseAxis);

            if(this.isBaseAxis){
                this.componentOption.min = minMax.minValue;
                this.componentOption.max = minMax.maxValue;
            }

            this._updateOriginTickData();

            this._calculateTickData();
        },

        _initZoomStatus:function(){
            var zoom = this.vanchart.getComponent(Constants.ZOOM_COMPONENT);
            if(zoom && zoom.zoomToolEnabled() && BaseUtils.isSupportSVG() && this.isBaseAxis){

                if(this.vanchart.isInitOrRestoreState()){

                    var revisedDomain = zoom.getRevisedDomain();

                    var domain = this.scale.domain();

                    var from = domain[0];

                    var to = domain[1];

                    if(revisedDomain.from){
                        from = parseFloat(revisedDomain.from);
                    }

                    if(revisedDomain.to){
                        to = parseFloat(revisedDomain.to);
                    }

                    this.updateAxisScale(from, to);
                }

            }
        }
    });

    require('../ComponentLibrary').register(Constants.VALUE_AXIS_COMPONENT, ValueAxis);
    return ValueAxis;
});
/**
 * Created by eason on 15/11/2.
 */
define('component/DateAxis',['require','./Base','./BaseAxis','../utils/BaseUtils','../Constants','../utils/Formatter','../ComponentLibrary'],function(require){

    var Base = require('./Base');
    var BaseAxis = require('./BaseAxis');
    var BaseUtils = require('../utils/BaseUtils');
    var Constants = require('../Constants');
    var Formatter = require('../utils/Formatter');
    var TICK_COUNT = 5;

    var DAY = 1000 * 60 * 60 * 24;
    var MONTH = DAY * 31;
    var YEAR = 365 * MONTH;

    var DateAxis = BaseAxis.extend({

        type:Constants.DATE_AXIS_COMPONENT,

        initAttributesWithSeries:function(){

            this.scale = d3.time.scale();

            var minMax = this._calculateMinMaxValue();

            var min = minMax.minValue;
            var max = minMax.maxValue;

            var cfg = this.componentOption;

            var domain = this._calculateValueNiceDomain(min, max, cfg.min, cfg.max);

            min = BaseUtils.int2date(domain.minValue);

            max = BaseUtils.int2date(domain.maxValue);

            this.originalDomain = {minValue:min, maxValue:max};

            this.scale = this.scale ?
                this.scale.domain([min, max]) : d3.time.scale().domain([min, max]);

            this._calculateDateFormat();

            this._updateOriginTickData();
        },

        getOriginalDomain: function () {
            return this.originalDomain;
        },

        _calculateDateFormat:function(){
            var tickInterval = this._getTickInterval();

            var format = 'Dyyyy-MM-dd';

            if(tickInterval < DAY){
                format = 'Dyyyy-M-d H:mm'
            }else if(tickInterval < MONTH){
                format = 'Dyyyy-M-d'
            }else{
                format = 'Dyyyy-MM'
            }

            this.dateFormat = format;
        },

        _getTickContent:function(tick, formatter){

            if(!formatter || formatter == "function(){return arguments[0]}"){
                //todo 换成d3的格式
                var tmpFormat = this.dateFormat;
                formatter = function(){return window.FR ? FR.contentFormat(arguments[0], tmpFormat) : arguments[0]}
            }

            return Formatter.format(tick, formatter)
        },

        _getTickValues:function(){
            var result = [];
            this.valueList.forEach(function(date){
                result.push(BaseUtils.int2date(date));
            });

            return result;
        },

        _calculateMinMaxValue:function(){

            var minValue = Math.ceil(Number.MAX_VALUE);
            var maxValue = -minValue;

            var series = this.vanchart.series;
            var hasData = false;

            for(var i = 0, len = series.length; i < len; i++){
                var sery = series[i];
                var byAxis = sery[this.componentType];
                if(byAxis == this && this._isSeriesVisible(sery)){
                    var data = sery.seriesOption.data;
                    for(var i = 0,len = data.length; i < len; i++){
                        var value = this.getValueFromData(data[i]);

                        if(value.getTime){
                            hasData = true;
                            value = BaseUtils.date2int(value);
                            minValue = Math.min(minValue, value);
                            maxValue = Math.max(maxValue, value);
                        }

                    }
                }
            }

            if(!hasData){
                minValue = maxValue = (new Date()).getTime();
            }

            maxValue = minValue >= maxValue ? minValue + 1000 : maxValue;

            return {
                minValue:minValue,
                maxValue:maxValue
            };
        },

        getValueFromData:function(datum){
            var valueIndex = this.componentType == Constants.X_AXIS_COMPONENT ? 0 : 1;
            var valueKey = this.componentType == Constants.X_AXIS_COMPONENT ? 'x' : 'y';

            var value = BaseUtils.isArray(datum) ? datum[valueIndex] : datum[valueKey];

            return BaseUtils.object2date(value);
        },

        axisZoom:function(downPos, upPos){

            var startPos, endPos;

            var plotBounds = this.vanchart.getPlotBounds();

            //坐标轴是横向的
            if(this.isHorizontal()){
                startPos = Math.min(downPos[0], upPos[0]) - plotBounds.x;
                endPos = Math.max(downPos[0], upPos[0]) - plotBounds.x;
            }else{
                startPos = Math.min(downPos[1], upPos[1]) - plotBounds.y;
                endPos = Math.max(downPos[1], upPos[1]) - plotBounds.y;
            }

            var startValue = this.scale.invert(startPos);
            var endValue = this.scale.invert(endPos);

            startValue = BaseUtils.date2int(startValue);
            endValue = BaseUtils.date2int(endValue);

            var min = Math.min(startValue, endValue);
            var max = Math.max(startValue, endValue);

            this._updateDomain(min, max, true);
        },

        //min, max是毫秒数
        _updateDomain:function(min, max, zoomFix){

            var domain = this._calculateValueNiceDomain(min, max, min, max, zoomFix);

            var minValue = BaseUtils.int2date(domain.minValue);

            var maxValue = BaseUtils.int2date(domain.maxValue);

            this.scale = this.scale ?
                this.scale.domain([minValue, maxValue]) : d3.time.scale().domain([minValue, maxValue]);

            this._calculateDateFormat();

            this._updateOriginTickData();
        },

        updateAxisScale:function(minValue, maxValue, zoomFix){

            minValue = BaseUtils.date2int(minValue);

            maxValue = BaseUtils.date2int(maxValue);

            this.componentOption.min = minValue;
            this.componentOption.max = maxValue;

            this._updateDomain(minValue, maxValue, zoomFix);
        },

        _initZoomStatus:function(){
            var zoom = this.vanchart.getComponent(Constants.ZOOM_COMPONENT);
            if(zoom && zoom.zoomToolEnabled() && BaseUtils.isSupportSVG() && this.isBaseAxis){
                if(this.vanchart.isInitOrRestoreState()){

                    var revisedDomain = zoom.getRevisedDomain();

                    var domain = this.scale.domain();

                    var from = BaseUtils.date2int(domain[0]);

                    var to = BaseUtils.date2int(domain[1]);

                    if(revisedDomain.from){
                        from = BaseUtils.object2date(revisedDomain.from);
                        from = BaseUtils.date2int(from);
                    }

                    if(revisedDomain.to){
                        to = BaseUtils.object2date(revisedDomain.to);
                        to = BaseUtils.date2int(to);
                    }

                    this._updateDomain(from, to);
                }

            }
        }
    });

    require('../ComponentLibrary').register(Constants.DATE_AXIS_COMPONENT, DateAxis);
    return DateAxis;

});
define('component/Polar',['require','../Constants','../utils/BaseUtils','../utils/QueryUtils','../utils/Formatter','../utils/BoundsManager','./Base','../utils/BezierEasing','../ComponentLibrary'],function(require) {
    var Constants = require('../Constants');
    var BaseUtils = require('../utils/BaseUtils');
    var QueryUtils = require('../utils/QueryUtils');
    var Formatter = require('../utils/Formatter');
    var BoundsManager = require('../utils/BoundsManager');

    var Base = require('./Base');
    var BezierEasing = require('../utils/BezierEasing');

    var PADDING_GAP = 10;

    var Polar = Base.extend({
        doLayout: function () {
            var option = this.componentOption;

            var radius = option.radius;
            var center = option.center;

            // keep origin radius (include null)
            // adjust radius by angleAxis later

            if (!center || center.length === 0) {
                var plotBounds = this.vanchart.getPlotBounds();
                center = [
                    plotBounds.width / 2 + plotBounds.x,
                    plotBounds.height / 2 + plotBounds.y
                ];
            }

            this.setRadius(radius);
            this.setCenter(center);
        },

        /**
         * set polar radius and update radiusAxis scale
         * @param {number|string} radius
         */
        setRadius: function (radius) {
            if (!radius) {
                return;
            }

            this.radius = this._numPctHelper(
                radius,
                Math.min(this.vanchart.chartWidth(), this.vanchart.chartHeight()) / 2
            );

            this.radiusAxis && this.radiusAxis._updateRange();
        },

        /**
         * set polar center
         * @param {number[]|string[]} center
         */
        setCenter: function (center) {
            if (!center) {
                return;
            }

            this.center = [];

            this.center[0] = this._numPctHelper(center[0], this.vanchart.chartWidth());

            this.center[1] = this._numPctHelper(center[1], this.vanchart.chartHeight());
        },

        /**
         * convert number or percent to number value
         * @param {number|string} value
         * @param {number} ref Percentage reference
         * @returns {*}
         * @private
         */
        _numPctHelper: function (value, ref) {
            if (!value || !ref) {
                return null;
            }

            if (!isNaN(value)) {
                return value;
            }

            if (typeof(value) === 'string'
                && value.indexOf('%') != -1) {
                return this._getPercentValue(value, ref);
            }
            return null;
        }
    });
    
    require('../ComponentLibrary').register(Constants.POLAR_COMPONENT, Polar);
    return Polar;
});
/**
 * Created by eason on 15/8/16.
 */

define('utils/LabelDivManager',['require','./BaseUtils','./ColorUtils','./BezierEasing'],function(require){

    var BaseUtils = require('./BaseUtils');
    var ColorUtils = require('./ColorUtils');
    var BezierEasing = require('./BezierEasing');

    var DEFAULT_KEY = 'div-label-key'

    function LabelDivManager(dom){
        this.dom = dom;
        this.labelList = {};
    }


    LabelDivManager.prototype = {
        constructor:LabelDivManager,

        //bounds是绝对坐标
        addLabel:function(label, posOrDim, style, key, wrap, useHTML){
            // to keep previous default behavior
            if (typeof wrap === 'undefined') {
                wrap = false;
            }
            
            if (typeof useHTML === 'undefined') {
                useHTML = true;
            }

            key = key || DEFAULT_KEY;

            if(!this.labelList[key]){
                this.labelList[key] = [];
            }

            var labelArray = this.labelList[key];

            var div = document.createElement('div');
            if (useHTML) {
                div.innerHTML = label;
            } else {
                div.textContent ?
                    (div.textContent = label) :
                    (div.innerText = label);
            }

            div.style.position = 'absolute';
            div.style.left = posOrDim.x + 'px';
            div.style.top = posOrDim.y + 'px';
            div.style.overflow = 'hidden';
            if (wrap) {
                div.style.whiteSpace = "normal";
                div.style.wordWrap = 'break-word';
            } else {
                div.style.whiteSpace = 'nowrap';
            }

            if(BaseUtils.hasDefined(posOrDim.width) && BaseUtils.hasDefined(posOrDim.height)){
                div.style.width = posOrDim.width + 'px';
                div.style.height = posOrDim.height + 'px';
            }

            for(var fontStyle in style){
                //ie789的color属性只能是16进制的值
                if(fontStyle == 'color' && !BaseUtils.isSupportSVG()){
                    div.style.color = ColorUtils.colorToHex(style.color);
                }else {
                    div.style[fontStyle] = style[fontStyle];
                }

            }

            this.dom.appendChild(div);
            labelArray.push(div);

            return div;
        },


        addLabelWidthBounds:function(label, bounds, style, key, wrap, useHTML){

            var div = this.addLabel(label, bounds, style, key, wrap, useHTML);

            div.style.width = bounds.width + 'px';
            div.style.height = bounds.height + 'px';

            return div;
        },

        clearLabels:function(key){
            key = key || DEFAULT_KEY;

            var labelArray = this.labelList[key] || [];

            for(var i = 0, len = labelArray.length; i < len; i++){
                this.dom.removeChild(labelArray[i]);
            }

            this.labelList[key] = [];
        },

        //删除所有层级的div标签
        clearAllLabels:function(){
            for(var key in this.labelList){
                this.clearLabels(key);
            }
        },

        translateLabelsHorizontal:function(transX, key){

            key = key || DEFAULT_KEY;
            var labelArray = this.labelList[key] || [];

            for(var i = 0, len = labelArray.length; i < len; i++){
                var label = labelArray[i];
                var left = parseFloat(label.style.left);
                left += transX;

                if(BaseUtils.isSupportSVG()){

                    d3.select(label)
                        .transition()
                        .ease(BezierEasing.css.swing)
                        .duration(300)
                        .style('left', left + 'px')

                }else{
                    label.style.left = left + 'px';
                }
            }
        },

        /**
         * change labels' size and position
         * @param {object} [changes] style key - change value
         * (key: left, top, right, bottom, width, height)
         * @param [key] label key
         */
        changeLabelDim: function (changes, key) {
            if (!changes) {
                return;
            }

            key = key || DEFAULT_KEY;
            var labelArray = this.labelList[key] || [];

            labelArray.map(function (label) {
                var changedValues = {};
                for (var name in changes) {
                    var value = parseFloat(label.style[name]);
                    changedValues[name] = value + changes[name] + 'px';
                }

                if(BaseUtils.isSupportSVG()){

                    d3.select(label)
                        .transition()
                        .ease(BezierEasing.css.swing)
                        .duration(300)
                        .style(changedValues);

                }else{
                    for (var name in changedValues) {
                        label.style[name] = changedValues[name];
                    }
                }
            })
        },

        setLabelOpacity: function (key, opacity) {
            var labelArray = this.labelList[key] || [];

            for(var i = 0, len = labelArray.length; i < len; i++){
                var label = labelArray[i];
                label.style.opacity = opacity;
            }
        }
    };


    return LabelDivManager;

});
/**
 * Created by eason on 16/3/23.
 */

define('render/CanvasRender',['require','../utils/BaseUtils','../Constants'],function(require){

    var BaseUtils = require('../utils/BaseUtils');
    var Constants = require('../Constants');


    function CanvasRender(dom, vanchart){

        this._init(dom, vanchart)
    }

    CanvasRender.prototype = {

        constructor:CanvasRender,

        _init:function(dom, vanchart){

            var plotBounds = vanchart.getPlotBounds();

            this.width = plotBounds.width;
            this.height = plotBounds.height;

            this.dom = this._createCanvas(dom, plotBounds);
            this.ctx = this.dom.getContext("2d");
        },

        _createCanvas:function(dom, plotBounds){

            var canvas = document.createElement('canvas');
            var width = plotBounds.width;
            var height = plotBounds.height;

            canvas.style.position = 'absolute';
            canvas.style.left = plotBounds.x + 'px';
            canvas.style.top = plotBounds.y + 'px';
            canvas.style.width = width + 'px';
            canvas.style.height = height + 'px';

            canvas.width = width;
            canvas.height = height;

            canvas.onselectstart = function(){return false};
            canvas.style['-webkit-user-select'] = 'none';
            canvas.style['user-select'] = 'none';
            canvas.style['-webkit-touch-callout'] = 'none';

            dom.appendChild(canvas);

            //excanvas
            window.vmlCanvasManager && vmlCanvasManager.initElement(canvas);

            return canvas;
        },

        clearAll:function(){
            this.ctx.clearRect(0, 0, this.width, this.height);
        },

        addBubbleSeries:function(series){
            var ctx = this.ctx;
            ctx.save();

            for(var i = 0, len = series.points.length; i < len; i++){
                var point = series.points[i];

                if(point.visible){

                    ctx.fillStyle = point.color;
                    ctx.globalAlpha = point.fillColorOpacity;

                    ctx.beginPath();
                    ctx.arc(point.posX, point.posY, point.radius, 0, 2 * Math.PI);
                    ctx.fill();
                }
            }

            ctx.restore();
        },

        addScatterSeries:function(series){
            var ctx = this.ctx;
            ctx.save();
            for(var i = 0, len = series.points.length; i < len; i++){
                var point = series.points[i];
                if(point.visible){
                    var markerType = point.marker.symbol;
                    var radius =  point.marker.radius || 4.5;
                    var color = point.marker.fillColor || point.color;

                    ctx.translate(point.posX, point.posY);
                    ctx.fillStyle = color;
                    ctx.strokeStyle = color;
                    ctx.globalAlpha = point.fillColorOpacity;

                    this._drawMarker(ctx, markerType, radius);

                    ctx.translate(-point.posX, -point.posY);
                }
            }
            ctx.restore();
        },

        addSeries:function(series){

            series.chart.componentType == Constants.SCATTER_CHART ?
                                        this.addScatterSeries(series) : this.addBubbleSeries(series);
        },

        _drawMarker:function(ctx, markerType, R){

            if(markerType.indexOf(Constants.CIRCLE) != -1){

                ctx.beginPath();
                ctx.arc(0, 0, R, 0, 2 * Math.PI);

            }else if(markerType.indexOf(Constants.SQUARE) != -1){

                ctx.beginPath();
                ctx.moveTo(-R, -R);
                ctx.lineTo(R, -R);
                ctx.lineTo(R, R);
                ctx.lineTo(-R, R);
                ctx.closePath();

            }else if(markerType.indexOf(Constants.DIAMOND) != -1){

                R = R * 2 / Math.sqrt(2);
                ctx.beginPath();
                ctx.moveTo(-R, 0);
                ctx.lineTo(0, -R);
                ctx.lineTo(R, 0);
                ctx.lineTo(0, R);
                ctx.closePath();

            }else if(markerType.indexOf(Constants.TRIANGLE) != -1){

                ctx.beginPath();
                ctx.moveTo(-R, R/Math.sqrt(3));
                ctx.lineTo(0, -(2 * Math.sqrt(3) / 3) * R);
                ctx.lineTo(R, R/Math.sqrt(3));
                ctx.closePath();

            }else{

                ctx.beginPath();
                ctx.arc(0, 0, R, 0, 2 * Math.PI);

            }

            if(markerType.indexOf('hollow') == -1){
                //满填充
                ctx.fill();
            }else{
                ctx.fillStyle = 'white';
                ctx.lineWidth = 2;

                ctx.fill();
                ctx.stroke();
            }

        }
    };



    return CanvasRender;
});

/**
 * Created by eason on 15/8/13.
 */

define('render/BaseRender',['require','../utils/BaseUtils','../utils/LabelDivManager','../utils/ColorUtils','../utils/Class','../Constants','./CanvasRender'],function(require){

    var BaseUtils = require('../utils/BaseUtils');
    var LabelDivManager = require('../utils/LabelDivManager');
    var ColorUtils = require('../utils/ColorUtils');
    var Class = require('../utils/Class');
    var Constants = require('../Constants');
    var CanvasRender = require('./CanvasRender');

    var MARKER_G = 'markerG';
    var MARKER = 'markerPath';
    var MARKER_STROKE = 'markerStrokePath';
    var MIN_MARKER_R = 2;

    var BaseRender = Class.extend({

        initialize:function(component){

            this.component = component;

            if(component && component.getParentDom){
                this.labelDivManager = new LabelDivManager(component.getParentDom());
            }

            this.drawLabelTimeOut = {};
        },

        _createHorizontalLinearGradient:function(defs, id, startColor, endColor){
            this._createLinearGradient(defs, id, startColor, endColor, true);
        },

        _createVerticalLinearGradient:function(defs, id, startColor, endColor){
            this._createLinearGradient(defs, id, startColor, endColor, false);
        },

        _createLinearGradient:function(defs, id, startColor, endColor, isHorizontal){

            var  x2 = '0%', y2 = '0%';

            isHorizontal ? x2 = '100%' : y2 = '100%';

            var gradient = defs.append('linearGradient')
                .attr('x1', '0%').attr('y1', '0%')
                .attr('x2', x2).attr('y2', y2)
                .attr("id", id);

            gradient.append("stop").attr("offset", '0%').style("stop-color", startColor);

            gradient.append('stop').attr('offset', '100%').style('stop-color', endColor);
        },

        _createDropShadowFilter:function(defs, id, dx, dy, alpha, deviation){
            var dropFilter = defs.append('filter')
                .attr('id', id)
                .attr('x', '-50%')
                .attr('y', '-50%')
                .attr('width', '200%')
                .attr('height', '200%');

            dropFilter
                .append('feOffset')
                .attr('in', 'SourceAlpha')
                .attr('dx', dx)
                .attr('dy', dy)
                .attr('result', 'offOut');

            dropFilter
                .append('feColorMatrix')
                .attr('in', 'offOut')
                .attr('type', 'matrix')
                .attr('values', '0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 '+alpha+' 0')
                .attr('result', 'matrixOut');

            dropFilter
                .append('feGaussianBlur')
                .attr('in', 'matrixOut')
                .attr('stdDeviation', deviation)
                .attr('result', 'blurOut');

            dropFilter
                .append('feBlend')
                .attr('in', 'SourceGraphic')
                .attr('in2', 'blurOut')
                .attr('mode', 'normal');
        },

        _createInnerShadowFilter:function(defs, id, dx, dy, alpha, deviation){

            var innerFilter = defs.append('filter')
                .attr('id', id)
                .attr('x', '-50%')
                .attr('y', '-50%')
                .attr('width', '200%')
                .attr('height', '200%');

            innerFilter.append('feComponentTransfer')
                .attr('in', 'SourceAlpha')
                .append('feFuncA')
                .attr('type', 'table')
                .attr('tableValues', '1 0');

            innerFilter.append('feGaussianBlur')
                .attr('stdDeviation', deviation);

            innerFilter.append('feOffset')
                .attr('dx', dx)
                .attr('dy', dy)
                .attr('result', 'offsetblur');

            innerFilter.append('feFlood')
                .attr('flood-color', 'black')
                .attr('flood-opacity', alpha)
                .attr('result', 'color');

            innerFilter.append('feComposite')
                .attr('in2', 'offsetblur')
                .attr('operator', 'in');

            innerFilter.append('feComposite')
                .attr('in2', 'SourceAlpha')
                .attr('operator', 'in');

            var merge = innerFilter.append('feMerge');
            merge.append('feMergeNode').attr('in', 'SourceGraphic');
            merge.append('feMergeNode');
        },

        _createVmlMarker:function(paper, point, position){

            var plotBounds = this.component.getPlotBounds();

            var defaultRadius = this.component.getDefaultMarkerRadius();
            var radius =  point.marker.radius;

            if(BaseUtils.hasDefined(radius) && radius < MIN_MARKER_R){
                return {};
            }

            radius = radius || defaultRadius;


            if(BaseUtils.outsideRect(plotBounds, BaseUtils.makeBounds(position, [radius, radius]))){
                return {};
            }

            var markerType = point.marker.symbol;
            var isNullMarker = markerType == Constants.NULL_MARKER;
            var backgroundColor = this.component._getBackgroundColor();

            var markerRadius = this._isHollowMarker(markerType) ? radius - 1 : radius;
            var opacity = ColorUtils.getColorOpacityWithoutDefault(point.marker.fillColor);
            opacity = BaseUtils.hasDefined(opacity) ? opacity : point.fillColorOpacity;

            var marker = paper.path(this._getMarkerPath(markerType, markerRadius))
                .attr({
                    'fill':(this._isHollowMarker(markerType) || isNullMarker) ? backgroundColor : point.marker.fillColor,
                    'fill-opacity':isNullMarker ? 0 : opacity,
                    'stroke':point.marker.fillColor,
                    'stroke-width':this._isHollowMarker(markerType) ? 2 : 0
                })
                .datum(point)
                .transform(BaseUtils.makeTranslate(position));

            var strokeMarker;
            if(this.component.type == Constants.LINE_CHART){
                strokeMarker = paper.path(this._getMarkerPath(markerType, radius + 1))
                    .attr({
                        'stroke-width':isNullMarker ? 0 : 2,
                        'stroke': backgroundColor,
                        'fill':'none'
                    })
                    .transform(BaseUtils.makeTranslate(position));
            }

            this.addShapeEventHandler(marker);

            return {
                marker:marker,
                strokeMarker:strokeMarker
            }
        },

        _getMarkerGroupClass:function(d){
            return d.className + ' ' + MARKER_G;
        },

        _createSvgMarker:function(updateS){
            var self = this;
            var defaultRadius = this.component.getDefaultMarkerRadius();
            var backgroundColor = this.component._getBackgroundColor();

            updateS.enter().append('g')
                .attr('class', function(d){
                    return self._getMarkerGroupClass(d);
                })
                .filter(function(d){
                    var radius = d.marker.radius;
                    return d.visible && (BaseUtils.hasNotDefined(radius) || radius >= MIN_MARKER_R);
                })
                .each(function(data){

                    if(data.isNull){
                        return;
                    }

                    var markerG = d3.select(this);
                    var markerType = data.marker.symbol;
                    var isNullMarker = markerType == Constants.NULL_MARKER;

                    if(BaseUtils.isImageMarker(markerType)){
                        //创建图片的标记点
                        self._createImageMarker(markerType, function(width, height){
                            var width = data.marker.width || width;
                            var height = data.marker.height || height;
                            data.marker.width = width;
                            data.marker.height = height;

                            markerG
                                .append('image')
                                .attr('preserveAspectRatio', 'none')
                                .attr('xlink:href', markerType)
                                .attr('x', -width/2)
                                .attr('y', -height/2)
                                .attr('width', width)
                                .attr('height', height);
                        });
                    }else{
                        markerG
                            .append('path')
                            .attr('class', MARKER)
                            .attr('d', function(d){
                                var radius =  d.marker.radius || defaultRadius;

                                if(self._isHollowMarker(markerType))
                                    radius -= 1;

                                return self._getMarkerPath(markerType, radius);
                            })
                            .style('fill', function(d){
                                return self._isHollowMarker(markerType) ? backgroundColor : d.marker.fillColor;
                            })
                            .style('fill-opacity', isNullMarker ? 0 : function (d) {
                                return d.fillColorOpacity;
                            })
                            .style('stroke', function(d){
                                return d.marker.fillColor;
                            })
                            .style('stroke-width', function(){
                                return self._isHollowMarker(markerType) ? 2 : 0;
                            });

                        if(self.component.type == Constants.LINE_CHART){
                            markerG
                                .append('path')
                                .attr('class', MARKER_STROKE)
                                .attr('d', function(d){
                                    var radius =  d.marker.radius || defaultRadius;
                                    return self._getMarkerPath(markerType, radius + 1);
                                })
                                .style('stroke-width', isNullMarker ? 0 : 2)
                                .style('stroke', backgroundColor)
                                .style('fill', 'none')
                        }
                    }

                    self.addShapeEventHandler(markerG);
                });
        },

        _createImageMarker:function(src, callBack){
            var img = new Image();
            img.onload = function() {
                callBack(this.width, this.height);
            };
            img.src = src;
        },

        _getMarkerClass:function(){
            return MARKER_G;
        },

        _makeVmlMarkerChosenState:function(d){

            var markerType = d.marker.symbol;
            var radius =  d.marker.radius || this.component.getDefaultMarkerRadius();
            var pathR = this._isHollowMarker(markerType) ? radius - 1 : radius;
            var backgroundColor = this.component._getBackgroundColor();

            var makerSet = this.getElementByData(d);

            if(!makerSet || !makerSet.marker){
                return;
            }

            var marker = makerSet.marker;
            var strokeMarker = makerSet.strokeMarker;

            marker.attr({
                'path':this._getMarkerPath(markerType, pathR + 2),
                'fill':!this._isHollowMarker(markerType) ? d.marker.fillColor : backgroundColor,
                'fill-opacity':1
            });

            if(strokeMarker){
                strokeMarker.attr({
                    'path':this._getMarkerPath(markerType, radius + 3)
                });
            }
        },

        _cancelVmlMarkerChosenState:function(d){

            var markerType = d.marker.symbol;
            var isNullMarker = markerType == Constants.NULL_MARKER;
            var radius =  d.marker.radius || this.component.getDefaultMarkerRadius();
            var pathR = this._isHollowMarker(markerType) ? radius - 1 : radius;
            var backgroundColor = this.component._getBackgroundColor();

            var makerSet = this.getElementByData(d);

            if(!makerSet || !makerSet.marker){
                return;
            }

            var marker = makerSet.marker;
            var strokeMarker = makerSet.strokeMarker;

            marker.attr({
                'path':this._getMarkerPath(markerType, pathR),
                'fill':(this._isHollowMarker(markerType) || isNullMarker) ? backgroundColor : d.marker.fillColor,
                'fill-opacity':isNullMarker ? 0 : 1
            });

            if(strokeMarker){
                strokeMarker.attr({
                    'path':this._getMarkerPath(markerType, radius + 1),
                    'stroke-width': isNullMarker ? 0 : 2
                });
            }

        },

        _makeMarkerClickedState:function(parentS, d){
            var markerG = parentS.select('g.' + d.className);

            var backgroundColor = this.component._getBackgroundColor();
            var markerFillColor = d.marker.fillColor;

            backgroundColor = ColorUtils.getClickColor(backgroundColor);
            markerFillColor = ColorUtils.getClickColor(markerFillColor);

            var markerType = d.marker.symbol;

            markerG
                .select('path.' + MARKER)
                .style('fill',  this._isHollowMarker(markerType) ? backgroundColor : markerFillColor)
                .style('stroke', markerFillColor);

            markerG
                .select('path.' + MARKER_STROKE).style('stroke', backgroundColor);
        },

        _cancelMarkerClickedState:function(markerG, d){
            
            var backgroundColor = this.component._getBackgroundColor();
            var markerFillColor = d.marker.fillColor;

            var markerType = d.marker.symbol;

            markerG
                .select('path.' + MARKER)
                .style('fill',  this._isHollowMarker(markerType) ? backgroundColor : markerFillColor)
                .style('stroke', markerFillColor);

            markerG
                .select('path.' + MARKER_STROKE).style('stroke', backgroundColor);

        },

        _makeMarkerChosenState:function(markerG, d, addSize, animationTime){
            addSize = addSize || 2;
            animationTime = animationTime || 0;

            var markerType = d.marker.symbol;
            var radius =  d.marker.radius || this.component.getDefaultMarkerRadius();
            var isNullMarker = markerType == Constants.NULL_MARKER;

            var pathR = radius;
            var backgroundColor = ColorUtils.getHighLightColor(this.component._getBackgroundColor());
            var markerHighlightColor = ColorUtils.getHighLightColor(d.marker.fillColor);

            var self = this;

            if(this._isHollowMarker(markerType))
                pathR -= 1;

            if(markerG){
                markerG
                    .select('path.' + MARKER)
                    .style('fill', !this._isHollowMarker(markerType) ? markerHighlightColor : backgroundColor)
                    .style('fill-opacity', isNullMarker ? 1 : BaseUtils.pick(d.fillColorOpacity, 1))
                    .interrupt(Constants.SELECT_ANIMATION)
                    .transition(Constants.SELECT_ANIMATION)
                    .duration(animationTime)
                    .ease('ease-out-expo')
                    .attr('d', self._getMarkerPath(markerType, isNullMarker ? pathR : (pathR + addSize)))
                ;

                markerG
                    .select('path.' + MARKER_STROKE)
                    .attr('d', self._getMarkerPath(markerType, isNullMarker ? radius : (radius + 3)))
                    .style('stroke-width', 2);

                var image = markerG.select('image');
                if(!image.empty()){
                    var width = d.marker.width + 4;
                    var height = d.marker.height + 4;
                    image
                        .attr('x', -width/2)
                        .attr('y', -height/2)
                        .attr('width', width)
                        .attr('height', height)
                }
            }

        },

        _cancelMarkerChosenState:function(markerG, d){

            var backgroundColor = this.component._getBackgroundColor();

            var markerType = d.marker.symbol;
            var isNullMarker = markerType == Constants.NULL_MARKER;
            var radius =  d.marker.radius || this.component.getDefaultMarkerRadius();
            var self = this;

            var pathR = radius;
            if(this._isHollowMarker(markerType))
                pathR -= 1;

            if(markerG){
                //stop animation
                markerG
                    .select('path.' + MARKER)
                    .interrupt(Constants.SELECT_ANIMATION)
                    .transition(Constants.SELECT_ANIMATION);

                markerG
                    .select('path.' + MARKER)
                    .attr('d', self._getMarkerPath(markerType, pathR))
                    .style('fill', self._isHollowMarker(markerType) ? backgroundColor : d.marker.fillColor)
                    .style('fill-opacity', isNullMarker ? 0 : BaseUtils.pick(d.fillColorOpacity, 1));

                markerG
                    .select('path.' + MARKER_STROKE)
                    .attr('d', function(){
                        return self._getMarkerPath(markerType, radius + 1);
                    })
                    .style('stroke-width', isNullMarker ? 0 : 2);

                var image = markerG.select('image');
                if(!image.empty()){
                    var width = d.marker.width;
                    var height = d.marker.height;
                    image
                        .interrupt()
                        .attr('x', -width/2)
                        .attr('y', -height/2)
                        .attr('width', width)
                        .attr('height', height);
                }
            }
        },

        _renderDivLabels:function(points, transX, transY, key){

            var plotBounds = this.component.getPlotBounds();

            var isPieChart = this.component.componentType == Constants.PIE_CHART;

            for(var i = 0, len = points.length; i < len; i++){
                var p = points[i];
                if(p.visible && p.dataLabels && p.dataLabels.enabled && p.dataLabels.useHtml && p.labelPos && p.labelContent.length){

                    var labelX = p.labelPos.x + transX;
                    var labelY = p.labelPos.y + transY;
                    var labelContent = p.labelContent;

                    //ie低版本字体会出现大小
                    for(var index = 0, count = labelContent.length; index < count; index++){

                        var label = labelContent[index];

                        var labelDim = label.dim;

                        var pos = {x:labelX, y:labelY};

                        if(!BaseUtils.outsideRect(plotBounds, BaseUtils.makeBounds(pos, labelDim))){
                            var div = this.labelDivManager.addLabel(label.text, BaseUtils.makeBounds(pos, labelDim) , label.style, key);
                        }

                        labelY += (labelDim.height + this.component.getLabelGap());
                    }


                }
            }
        },

        _removeSvgDataLabels:function(parentG, key){

            parentG.selectAll('text').remove();
            parentG.selectAll('path').remove();

            this.labelDivManager.clearLabels(key);
        },


        _updateChartBodyTranslate:function(GlyphArray, supportAnimation, animationTime) {
            var plotBounds = this.component.getPlotBounds();
            var clipID = this.component.vanchart.getBodyClipID();

            GlyphArray.forEach(function (Glyph) {
                Glyph
                    .attr('clip-path', "url(#" + clipID +")")
                    .transition()
                    .duration(supportAnimation ? animationTime : 0)
                    .ease('back-out')
                    .attr('transform', 'translate('+plotBounds.x+','+plotBounds.y+')');

            });
        },

        _drawNormalChartLabels: function (parentG, delay) {
            var seriesS = this.component.getVisibleChartData();

            var plotBounds = this.component.getPlotBounds();

            var allPoints = [];
            seriesS.forEach(function(sery){
                allPoints = allPoints.concat(sery.points);
            });

            var validPoints = [];
            var tmpBounds = BaseUtils.makeBounds(0, 0, plotBounds.width, plotBounds.height);
            allPoints.forEach(function(point){
                if(point.labelPos && point.labelDim){

                    var x = point.labelPos.x + point.labelDim.width/2;
                    var y = point.labelPos.y + point.labelDim.height/2;

                    if(BaseUtils.containsPoint(tmpBounds, [x, y])){
                        validPoints.push(point);
                    }
                }
            });

            this._drawSvgDataLabels(parentG, validPoints, plotBounds.x, plotBounds.y, delay);
        },

        _drawSvgDataLabels:function(parentG, points, transX, transY, delay, key){

            delay = delay || 0;

            key = key || 'default-label-key';

            clearTimeout(this.drawLabelTimeOut[key]);

            var self = this;

            this._removeSvgDataLabels(parentG, key);

            this.drawLabelTimeOut[key] = setTimeout(function(){
                parentG
                    .style('opacity', 0)
                    .selectAll('text')
                    .data(points)
                    .enter()
                    .append('text')
                    .filter(function(d){
                        return d.visible
                            && d.labelPos
                            && d.dataLabels
                            && d.dataLabels.enabled
                            && !d.dataLabels.useHtml ;
                    })
                    .each(function(d){

                        var labelContent = d.labelContent;

                        var centerX = d.labelPos.x + d.labelDim.width/2;

                        var startY = d.labelPos.y;

                        for(var i = 0, count = labelContent.length; i < count; i++){
                            var label = labelContent[i];

                            var labelDim = label.dim;
                            var labelText = label.text;
                            var labelStyle = label.style;

                            d3.select(this)
                                .append('tspan')
                                .attr('x', centerX)
                                .attr('y', startY + labelDim.height/2)
                                .attr('dy', '.32em')
                                .attr("text-anchor", "middle")
                                .text(labelText)
                                .call(BaseUtils.setTextStyle, labelStyle);

                            startY += (labelDim.height + self.component.getLabelGap());
                        }
                    });

                parentG
                    .transition('linear')
                    .duration(400)
                    .style('opacity', 1);

                self._renderDivLabels(points, transX, transY, key);

                if(self.component.componentType == Constants.PIE_CHART || self.component.componentType == Constants.BUBBLE_CHART){

                    //饼图气泡图标签 加。
                    parentG.selectAll('text').filter(function(d){
                        return d.dataLabels && d.dataLabels.align != Constants.OUTSIDE;
                    }).style('pointer-events', 'none');

                    parentG
                        .selectAll('path').data(points)
                        .enter()
                        .append('path')
                        .filter(function(d){
                            return d.visible
                                && d.labelPos
                                && d.dataLabels
                                && d.dataLabels.enabled
                                && d.dataLabels.align == Constants.OUTSIDE;
                        })
                        .attr('d', function(d){
                            var startPos = d.labelPos.startPos;
                            var midPos = d.labelPos.midPos;
                            var endPos = d.labelPos.endPos;

                            return 'M' + startPos.x + ',' + startPos.y
                                + 'L' + midPos.x + ',' + midPos.y
                                + 'L' + endPos.x + ',' + endPos.y;
                        })
                        .style('fill', 'none')
                        .style('stroke', function(d){
                            return d.dataLabels.connectorColor || d.color;
                        })
                        .style('stroke-width', function(d){
                            return d.dataLabels.connectorWidth || 0;
                        });
                }

            }, delay);
        },

        _createSingleDataLabel: function (d, labelG) {
            this._createSingleSvgDataLabel(d, labelG);
            this._createSingleDivDataLabel(d);
        },

        _createSingleSvgDataLabel:function(d, labelG){

            if(d.labelPos && d.dataLabels && d.dataLabels.enabled && !d.dataLabels.useHtml){

                var labelContent = d.labelContent;

                var centerX = d.labelPos.x + d.labelDim.width/2;

                var startY = d.labelPos.y;

                for(var i = 0, count = labelContent.length; i < count; i++){
                    var label = labelContent[i];

                    var labelDim = label.dim;
                    var labelText = label.text;
                    var labelStyle = label.style;

                    labelG
                        .append('tspan')
                        .attr('x', centerX)
                        .attr('y', startY + labelDim.height/2)
                        .attr('dy', '.32em')
                        .attr("text-anchor", "middle")
                        .text(labelText)
                        .call(BaseUtils.setTextStyle, labelStyle);
                    startY += (labelDim.height + this.component.getLabelGap());
                }
            }
        },

        _createSingleDivDataLabel: function (p) {
            var plotBounds = this.component.getPlotBounds();

            if(p.visible && p.dataLabels && p.dataLabels.enabled && p.dataLabels.useHtml && p.labelPos && p.labelContent.length){

                var labelX = p.labelPos.x + plotBounds.x;
                var labelY = p.labelPos.y + plotBounds.y;
                var labelContent = p.labelContent;

                //ie低版本字体会出现大小
                for(var index = 0, count = labelContent.length; index < count; index++){

                    var label = labelContent[index];

                    var labelDim = label.dim;

                    var pos = {x:labelX, y:labelY};

                    if(!BaseUtils.outsideRect(plotBounds, BaseUtils.makeBounds(pos, labelDim))){
                        var div = this.labelDivManager.addLabel(label.text, BaseUtils.makeBounds(pos, labelDim) , label.style, p.className);
                    }

                    labelY += (labelDim.height + this.component.getLabelGap());
                }
            }
        },

        _drawTitleWithHtml:function(cfg, bounds, reservedWidth){
            var style = BaseUtils.clone(cfg.style);

            var padding = this.component.getPadding();
            style.textAlign = cfg.align || 'left';

            var usedBounds = {
                x:bounds.x + padding,
                y:bounds.y + padding,
                width:bounds.width - 2 * padding - reservedWidth,
                height:bounds.height - 2 * padding
            };

            this.labelDivManager.addLabelWidthBounds(cfg.text, usedBounds, style, 0, false, true);
        },

        _drawTitle:function(cfg, bounds){
            var style = BaseUtils.clone(cfg.style);

            style.textAlign = cfg.align || 'left';

            this.labelDivManager.addLabelWidthBounds(cfg.text, bounds, style, 0, true, cfg.useHtml);
        },

        _renderVmlBackground: function (parentSet, paper, option, bounds) {
            if(option.shadow){
                var borderWidth = option.borderWidth || 0;

                var det = borderWidth % 2 == 0 ? 0.5 : 0;

                var width = [5, 3, 1];
                var opacity = [0.05, 0.1, 0.15];
                for(var i = 0; i < 3; i++){
                    parentSet.push(
                        paper.rect(bounds.x + det, bounds.y + det, bounds.width, bounds.height)
                            .attr({
                                fill: 'none',
                                stroke: 'rgb(0,0,0)',
                                'stroke-opacity':opacity[i],
                                'stroke-width': width[i],
                                'rx': option.borderRadius,
                                'ry': option.borderRadius
                            })
                            .transform('t1,1')
                    );
                }

                parentSet.push(
                    paper.rect(bounds.x, bounds.y, bounds.width, bounds.height)
                        .attr({
                            fill: 'white',
                            stroke: 'none',
                            'rx': option.borderRadius,
                            'ry': option.borderRadius
                        }));
            }

            parentSet.push(
                paper.rect(bounds.x, bounds.y, bounds.width, bounds.height)
                    .attr('class', 'legend-background')
                    .attr('rx', option.borderRadius)
                    .attr('ry', option.borderRadius)
                    .attr('fill', this._getRaphaelFill(option.backgroundColor))
                    .attr('fill-opacity', this._getFillOpacity(option.backgroundColor))
                    .attr('stroke', option.borderColor)
                    .attr('stroke-width', option.borderWidth)
            );
        },

        _renderSvgBackground:function(parentG, option, bounds, gradualID){

            if(bounds.width <= 0 || bounds.height <= 0){
                return;
            }

            if(option.backgroundColor && parentG.select('defs').empty()){
                this._createGradualDefs(parentG, option.backgroundColor, gradualID);
            }

            var borderWidth = option.borderWidth || 0;
            var borderBounds = BaseUtils.rectSubPixelOpt(0, 0, bounds.width, bounds.height, borderWidth);

            if(option.shadow){

                var det =  BaseUtils.lineSubPixelOpt(0, borderWidth);

                var width = [5, 3, 1];
                var opacity = [0.05, 0.1, 0.15];

                var shadowRect = parentG.selectAll('rect.shadow').data(width);
                shadowRect.enter().append('rect').attr('class', 'shadow');
                shadowRect.attr('x', det).attr('y', det)
                    .attr('width', bounds.width).attr('height', bounds.height)
                    .attr('rx', option.borderRadius).attr('ry', option.borderRadius)
                    .attr('transform', 'translate(1, 1)')
                    .style('fill', 'none').style('stroke', 'black')
                    .style('stroke-width', function(d){return d})
                    .style('stroke-opacity', function(d, i){return opacity[i]});

                var background = parentG.selectAll('rect.shadowBackground').data([0]);
                background.enter().append('rect').attr('class', 'shadowBackground');

                background
                    .attr('x', borderBounds.x)
                    .attr('y', borderBounds.y)
                    .attr('width', borderBounds.width)
                    .attr('height', borderBounds.height)
                    .attr('rx', option.borderRadius)
                    .attr('ry', option.borderRadius)
                    .style('fill', 'white');
            }

            var background = parentG.selectAll('rect.background').data([0]);
            background.enter().append('rect').attr('class', 'background');

            background
                .attr('x', borderBounds.x)
                .attr('y', borderBounds.y)
                .attr('width', borderBounds.width)
                .attr('height', borderBounds.height)
                .attr('rx', option.borderRadius)
                .attr('ry', option.borderRadius)
                .style('fill', option.backgroundColor ? (typeof option.backgroundColor == 'string' ? option.backgroundColor : "url(#" + gradualID + ")") : 'none')
                .style('stroke', option.borderColor)
                .style('stroke-width', option.borderWidth);
        },

        _createGradualDefs:function(gElement, color, ID){
            if(color){
                if(typeof color == 'object'){
                    var linearGradient = gElement
                        .append('defs')
                        .append('linearGradient')
                        .attr('id', ID)
                        .attr('x1', color.x1)
                        .attr('y1', color.y1)
                        .attr('x2', color.x2)
                        .attr('y2', color.y2);

                    linearGradient.append('stop')
                        .attr('offset', '0%')
                        .style('stop-color', color.startColor);

                    linearGradient.append('stop')
                        .attr('offset', '100%')
                        .style('stop-color', color.endColor);
                }
            }
        },

        //可能是渐变色
        _getRaphaelFill:function(color){
            if(color){

                if(typeof color == 'string'){
                    return color;
                }else{
                    //渐变色
                    var angle = 0;
                    var start = parseFloat(color.x1);
                    var end = parseFloat(color.x2);

                    if(color.x1 == color.x2){
                        angle = 270;
                        start = parseFloat(color.y1) * 100;
                        end = parseFloat(color.y2) * 100;
                    }

                    return angle + '-' + color.startColor + ':' + start + '-' + color.endColor + ':' + end;

                }
            }

            return 'none';
        },

        _drawVmlDataLabels:function(paper, labelSet, points, transX, transY){

            var plotBounds = this.component.getPlotBounds();

            var labelPoints = [];
            for(var i = 0, len = points.length; i < len; i++){

                var point = points[i];

                if(point && point.visible && point.dataLabels && point.dataLabels.enabled && point.labelPos){

                    var labelAbsPos = {
                        x:point.labelPos.x + transX,
                        y:point.labelPos.y + transY
                    };

                    if(BaseUtils.containsPoint(plotBounds, labelAbsPos)){
                        labelPoints.push(point);
                    }
                }
            }

            for(var i = 0, len = labelPoints.length; i < len; i++){
                var point = labelPoints[i];

                var labelContent  = point.labelContent;
                var wholeLabelDim = point.labelDim;

                var labelX = point.labelPos.x + transX;
                var labelY = point.labelPos.y + transY;

                //ie低版本字体会出现大小
                for(var index = 0, count = labelContent.length; index < count; index++){

                    var label = labelContent[index];

                    var labelDim = label.dim;

                    var midGap = (wholeLabelDim.width - labelDim.width)/2;
                    midGap = Math.max(0, midGap);

                    this.labelDivManager.addLabel(label.text, BaseUtils.makeBounds({x:labelX + midGap, y:labelY}, labelDim), label.style, point.category);

                    labelY += (labelDim.height + this.component.getLabelGap());
                }

                if(point.dataLabels.align == Constants.OUTSIDE && this.component.componentType == Constants.PIE_CHART){

                    var startPos = point.labelPos.startPos;
                    var midPos = point.labelPos.midPos;
                    var endPos = point.labelPos.endPos;

                    var leadLine = paper.path(
                            'M' + BaseUtils.dealFloatPrecision(startPos.x) + ',' + BaseUtils.dealFloatPrecision(startPos.y)
                            + 'L' + BaseUtils.dealFloatPrecision(midPos.x) + ',' + BaseUtils.dealFloatPrecision(midPos.y)
                            + 'L' + BaseUtils.dealFloatPrecision(endPos.x) + ',' + BaseUtils.dealFloatPrecision(endPos.y))
                        .transform(('t' + transX + ',' + transY))
                        .attr('fill', 'none')
                        .attr('stroke', point.dataLabels.connectorColor || point.color)
                        .attr('stroke-width', point.dataLabels.connectorWidth || 0);

                    labelSet.push(leadLine);

                }

            }

        },

        _isHollowMarker:function(markerType){
            if (!markerType) {
                return false;
            }
            return markerType.indexOf('hollow') != -1 && markerType != Constants.NULL_MARKER;
        },

        _getMarkerPath:function(markerType, R){
            switch(markerType){
                case Constants.NULL_MARKER:
                case Constants.CIRCLE:
                case Constants.CIRCLE_HOLLOW:
                    return d3.svg.arc().outerRadius(R)({startAngle:0, endAngle:2 * Math.PI});

                case Constants.SQUARE:
                case Constants.SQUARE_HOLLOW:
                    var leftTop = -R + ',' + -R;
                    var rightTop = R + ',' + -R;
                    var rightBottom = R + ',' + R;
                    var leftBottom = -R + ',' + R;
                    return 'M' + leftTop + 'L' + rightTop + 'L' + rightBottom + 'L' + leftBottom + 'Z';

                case Constants.DIAMOND:
                case Constants.DIAMOND_HOLLOW:
                    R = R * 2 / Math.sqrt(2);

                    var left = -R + ',' + 0;
                    var top = 0 + ',' + -R;
                    var right = R + ',' + 0;
                    var bottom = 0 + ',' + R;
                    return 'M' + left + 'L' + top + 'L' + right + 'L' + bottom + 'Z';

                case Constants.TRIANGLE:
                case Constants.TRIANGLE_HOLLOW:

                    var left = -R + ',' + R/Math.sqrt(3);
                    var top = 0 + ',' + -(2 * Math.sqrt(3) / 3) * R;
                    var right = R + ',' + R/Math.sqrt(3);

                    return 'M' + left + 'L' + top + 'L' + right + 'Z';
            }
        },

        //用path来构造line
        _getLinePath:function(p1, p2){
            return 'M' + this._dealWithFloat(p1[0]) + ',' + this._dealWithFloat(p1[1])
                + 'L' + this._dealWithFloat(p2[0]) + ',' + this._dealWithFloat(p2[1]);
        },

        _dealWithFloat:function(v){
            return Math.abs(v) < 1e-6 ? 0 : v;
        },

        _getFillOpacity:function(color){
            if(color && typeof color == 'string'){
                return ColorUtils.getColorOpacity(color);
            }

            return 1;
        },

        removeDivLabels:function(){
            if(this.labelDivManager){
                this.labelDivManager.clearAllLabels();
            }
        },

        addSeriesEventHandler:function(shapeS){
            var self = this;

            if(BaseUtils.isSupportSVG()){
                shapeS.each(function () {
                    self._addSingleSeriesEventHandler(d3.select(this));
                });
            }else{
                this._addSingleSeriesEventHandler(shapeS);
            }

        },

        _addSingleSeriesEventHandler:function(layer){

            var handler = this.component.vanchart.handler;

            handler.addInteractiveTarget(layer, this._getSeriesTypes(), this);
        },

        addShapeEventHandler:function(shapeS){

            var self = this;

            if(BaseUtils.isSupportSVG()){
                shapeS.each(function(){
                    self._addSingleShapeEventHandler(d3.select(this));
                });
            }else{
                this._addSingleShapeEventHandler(shapeS);
            }

        },

        _addSingleShapeEventHandler:function(layer){

            var handler = this.component.vanchart.handler;

            handler.addInteractiveTarget(layer, this._getTypes(), this);
        },

        _getTypes:function(){

            return BaseUtils.hasTouch() ? {
                'touchstart':this._touchStart,
                'forceTouchEnd':this._touchEnd
            } : {
                'mouseover':this._mouseOver,
                'mouseout':this._mouseOut,
                'mousedown':this.mouseDown,
                'mouseup':this.mouseUp,
                'cover':this.mouseOver,
                'leave':this.mouseOut
            };
        },

        _getSeriesTypes:function(){
            return BaseUtils.hasTouch() ? {
                'touchstart':this._seriesMouseOver,
                'forceMouseOut':this._seriesMouseOut
            } : {
                'mouseover':this._seriesMouseOver,
                'forceMouseOut':this._seriesMouseOut
            }
        },

        _touchStart:function(event){
            var point = event.target.datum();
            if (point.series.supportSharedTooltip &&
                point.tooltip &&
                point.tooltip.shared) {
                return;
            }
            var series = point.series,
                chart = series.chart.vanchart,
                handler = chart.handler,
                hoverPoint = chart.hoverPoint,
                hoverSeries = chart.hoverSeries;

            if (hoverSeries !== series) {
                handler.fireEventByData(hoverSeries, 'forceMouseOut', event);
                handler.fireEventByData(series, 'touchstart', event);
                chart.hoverSeries = series;
            }

            if (hoverPoint && hoverPoint !== point) {
                handler.fireEventByData(hoverPoint, 'forceTouchEnd', event);
            }

            point.series && (chart.hoverPoint = point);
            chart.getTooltip().showWithPoint(point);

            this.mouseOver(event);
        },

        _touchEnd:function(event){
            var point = event.target.datum();
            if (point.series.supportSharedTooltip &&
                point.tooltip &&
                point.tooltip.shared) {
                return;
            }
            this.mouseOut(event);
        },

        _mouseOver:function(event){

            var point = event.target.datum();
            var series = point.series,
                chart = series.chart.vanchart,
                handler = chart.handler,
                hoverPoint = chart.hoverPoint,
                hoverSeries = chart.hoverSeries;

            if (!this._shouldHover(point)) {
                chart.hoverPoint = point;
                return;
            }

            if (hoverSeries !== series) {
                handler.fireEventByData(hoverSeries, 'forceMouseOut', event);
                handler.fireEventByData(series, 'mouseover', event);
                chart.hoverSeries = series;
            }

            if (hoverPoint && hoverPoint !== point) {
                handler.fireEventByData(hoverPoint, 'mouseout', event);
            }

            point.series && (chart.hoverPoint = point);

            this.mouseOver(event);
        },

        _mouseOut:function(event){

            var point = event.target.datum();
            if (!this._shouldHover(point)) {
                this.component.vanchart.hoverPoint = null;
                return;
            }
            var series = point.series,
                chart = series.chart.vanchart;

            //标记点类型的数据点根据位置来判断
            if(chart.hoverPoint && !chart.hoverPoint.marker){
                chart.hoverPoint = null;
            }

            this.mouseOut(event);
        },

        _seriesMouseOver:function(event){

            var series = event.target.datum(),
                chart = series.chart.vanchart,
                hoverPoint = chart.hoverPoint,
                hoverSeries = chart.hoverSeries,
                handler = chart.handler;

            // set normal state to previous series
            if (hoverSeries && hoverSeries !== series) {
                handler.fireEventByData(hoverSeries, 'forceMouseOut', event);
            }
            
            chart.hoverSeries = series;
            var closestPoint = series.chart.getClosestPoint(event.containerPoint);

            if(!hoverPoint || (hoverPoint && hoverPoint.series != series)){
                handler.fireEventByData(hoverPoint, 'mouseout', event);

                if (!this._shouldHover(closestPoint)) {
                    chart.hoverPoint = null;
                    chart.hoverPoint = null;
                    return;
                }

                handler.fireEventByData(closestPoint, 'mouseover', event);

                chart.hoverPoint = closestPoint;
            }

            this.seriesMouseOver(event);
        },

        _seriesMouseOut:function(event){

            var series = event.target.datum(),
                chart = series.chart.vanchart,
                hoverSeries = chart.hoverSeries,
                hoverPoint = chart.hoverPoint,
                handler = chart.handler;

            chart.hoverSeries = null;

            this.seriesMouseOut(event);
        },

        _shouldHover: function (point) {
            if (!point) {
                return false;
            }
            var chart = this.component.vanchart;
            var handler = chart.handler;
            var sharedAxis = chart.getSharedAxis();
            if (sharedAxis && sharedAxis.type === Constants.CATEGORY_AXIS_COMPONENT &&
                handler._getCoveredPointsByKey(point.category).length !== 0) {
                return false;
            }

            return true;
        },

        _canvasRender:function(){

            var dom = this.component.vanchart.getParentDom();
            var plotBounds = this.component.getPlotBounds();

            if(!this._canvas){
                this._canvas = new CanvasRender(dom, this.component.vanchart);
            }

            this._canvas.clearAll();

            var data = this.component.getVisibleChartData();

            for(var i = 0, len = data.length; i < len; i++){
                this._canvas.addSeries(data[i], plotBounds);
            }
        },

        _drawHorizontalAxisTitleWithHtml:function(title, titleBounds){
            var rotation = title.rotation || 0;
            var textDim = BaseUtils.getTextDimension(title.text, title.style, title.useHtml);
            var x, y;
            var align = title.align || 'left';
            switch(align){
                case 'left':
                    x = titleBounds.x;
                    break;
                case 'center':
                    x = titleBounds.x + titleBounds.width/2 - textDim.width/2;
                    break;
                case 'right':
                    x = titleBounds.x + titleBounds.width - textDim.width;
                    break;
            }

            y = titleBounds.y + titleBounds.height/2 - textDim.height/2;
            var div = this.labelDivManager.addLabel(title.text, {x:x, y:y}, title.style);
            BaseUtils.divRotate(div, rotation);

            //ie8 bug
            div.style.left = x + 'px';
            div.style.top = y + 'px';
        },

        _drawVerticalAxisTitleWithHtml:function(title, titleBounds){
            var rotation = title.rotation || 0;
            var textDim = BaseUtils.getTextDimension(title.text, title.style, title.useHtml);
            var rotatedDim = BaseUtils.getTextDimensionWithRotation(title.text, title.style, title.useHtml, rotation);
            var x, y;
            x = titleBounds.x + titleBounds.width/2 - textDim.width/2;
            var align = title.align || 'top';
            switch(align){
                case 'top':
                    y = Math.max(rotatedDim.height/2 - textDim.height, 0);
                    break;
                case 'center':
                    y = (titleBounds.height - textDim.height)/2;
                    break;
                case 'bottom':
                    y = titleBounds.height - rotatedDim.height/2 - textDim.height/2;
                    break;
            }

            y += titleBounds.y;
            var div = this.labelDivManager.addLabel(title.text, {x:x, y:y}, title.style);
            BaseUtils.divRotate(div, rotation);

            //ie bug
            div.style.left = x + 'px';
            div.style.top = y + 'px';
        },

        //可能只是更新选中系列,但没有选中效果
        seriesMouseOut:function(){

        },

        seriesMouseOver:function(){

        },

        mouseDown:function(){

        },

        mouseUp:function(){

        },

        mouseOver:function(){

        },

        mouseOut:function(){

        },

        remove:function(){

        }
    });
    
    return BaseRender;
});
/**
 * Created by eason on 15/9/25.
 */
define('render/AxisRender',['require','./BaseRender','../Constants','./RenderLibrary'],function(require){

    var BaseRender = require('./BaseRender');
    var Constants = require('../Constants');

    var AxisRender = BaseRender.extend({

        render:function(){
            var axisRenders = this.component.getAxisRender();

            for(var i = 0, len = axisRenders.length; i < len ; i++){
                axisRenders[i].render();
            }

        },

        dataChangeRender:function(){
            var axisRenders = this.component.getAxisRender();
            for(var i = 0, len = axisRenders.length; i < len ; i++){
                axisRenders[i].dataChangeRender();
            }
        },

        monitorRender:function(){
            var axisRenders = this.component.getAxisRender();

            for(var i = 0, len = axisRenders.length; i < len ; i++){
                axisRenders[i].monitorRender();
            }
        }
    });

    require('./RenderLibrary').register(Constants.AXIS_RENDER, AxisRender);

    return AxisRender;

});
/**
 * Created by eason on 15/5/15.
 * 坐标轴组建的定义
 */
define('component/Axis',['require','./Base','../utils/BaseUtils','../Constants','./CategoryAxis','./ValueAxis','./DateAxis','./Polar','../render/AxisRender','../ComponentLibrary'],function(require){

    var Base = require('./Base');
    var BaseUtils = require('../utils/BaseUtils');
    var Constants = require('../Constants');

    var CategoryAxis = require('./CategoryAxis');
    var ValueAxis = require('./ValueAxis');
    var DateAxis = require('./DateAxis');
    var Polar = require('./Polar');

    require('../render/AxisRender');

    var Axis = Base.extend({
        _refresh:function(){
            this._axisList = this._axisList || [];

            var option = this.option;
            var axisOption = this.componentOption;
            if(!BaseUtils.isArray(axisOption)){
                axisOption  = [axisOption];
            }

            //最终生成的坐标轴数应该和新的option一样
            var len = axisOption.length;

            for(var axisIndex = len; axisIndex < this._axisList.length; axisIndex++){
                this._axisList[axisIndex].remove();
                this._axisList[axisIndex] = null;
            }

            this._axisList.length = len;

            for(var axisIndex = len - 1; axisIndex >= 0; axisIndex--){

                //增加一个坐标轴序号的标记
                axisOption[axisIndex].axisIndex = axisIndex;

                if(this._axisList[axisIndex] && this._axisList[axisIndex].type != axisOption[axisIndex].type){
                    this._axisList[axisIndex].remove();
                    this._axisList[axisIndex] = null;
                }

                if(this._axisList[axisIndex]){
                    this._axisList[axisIndex].refresh(option, axisOption[axisIndex]);
                }else{
                    var AxisClass;
                    if (this.componentType === Constants.POLAR_COMPONENT) {
                        AxisClass = Polar;
                    } else {
                        var axisType = axisOption[axisIndex].type || Constants.VALUE_AXIS_COMPONENT;

                        if (axisType == Constants.VALUE_AXIS_COMPONENT) {
                            AxisClass = ValueAxis;
                        } else if (axisType == Constants.CATEGORY_AXIS_COMPONENT) {
                            AxisClass = CategoryAxis;
                        } else if (axisType == Constants.DATE_AXIS_COMPONENT) {
                            AxisClass = DateAxis;
                        }
                    }

                    this._axisList[axisIndex] = new AxisClass(this.vanchart, this.option, this.componentType, axisOption[axisIndex]);
                }

                this._axisList[axisIndex].refreshPolar && this._axisList[axisIndex].refreshPolar(this.option, axisOption[axisIndex]);
            }
        },

        fixBoundsByPlot:function(){

            var plotBounds = this.vanchart.getPlotBounds();

            var map = {};

            for(var i = 0, axisCount = this._axisList.length; i < axisCount; i++){

                var axis = this._axisList[i];

                var position = axis.getPosition();

                map[position] = map[position] || [];

                map[position].push(axis);
            }

            for(var position in map){

                var axisList = map[position];
                var isHorizontal = position == Constants.TOP || position == Constants.BOTTOM;

                for(var i = 0, count = axisList.length; i < count; i++){

                    var axis = axisList[i];

                    var baseBounds = plotBounds;
                    if (i > 0 && !axisList[i-1].isOnZero() ) {
                        baseBounds = axisList[i - 1].bounds;
                    }

                    var axisBounds = axis.bounds;

                    if(isHorizontal){

                        var y = position == Constants.TOP ? baseBounds.y - axisBounds.height : baseBounds.y + baseBounds.height;
                        axis.bounds = BaseUtils.makeBounds(baseBounds.x, y, baseBounds.width, axisBounds.height);

                    }else{

                        var x = position == Constants.LEFT ? baseBounds.x - axisBounds.width : baseBounds.x + baseBounds.width;
                        axis.bounds = BaseUtils.makeBounds(x, baseBounds.y, axisBounds.width, baseBounds.height);
                    }

                    axis._updateRange();

                    axis._updateDomainWhenSizeFixed();

                    axis._calculateTickData();

                    axis._initZoomStatus();
                }
            }

        },

        calculateTickData: function () {
            this._axisList.forEach(function (axis) {
                axis._updateRange();
                axis._calculateTickData();
            });
        },

        initAttributesWithSeries:function(){
            var axisCount = this._axisList.length;
            for(var i = axisCount - 1; i >= 0; i--){
                this._axisList[i].initAttributesWithSeries();
            }
        },

        doLayout:function(){

            var axisCount = this._axisList.length;
            for(var i = axisCount - 1; i >= 0; i--){
                this._axisList[i].doLayout();
            }
        },

        getAxis:function(axisIndex){
            if (axisIndex >= this._axisList.length) {
                axisIndex = 0;
            }
            return this._axisList[axisIndex];
        },

        axisZoom:function(downPos, upPos){
            this._axisList.forEach(function(axis){
                axis.axisZoom(downPos, upPos);
            });
        },

        //处理0值对齐
        dealOnZero:function(){
            this._axisList.forEach(function(axis){

                if(axis.isOnZero()){

                    axis.dealOnZero();

                    axis._updateRange();

                    axis._calculateTickData();

                    axis._initZoomStatus();
                }
            });
        },

        getAllAxis:function(){
            return this._axisList;
        },

        getAxisRender:function(){

            var axisRenders = [];

            this._axisList.forEach(function(axis){
                var axisRender = axis.getRender();
                if(axisRender){
                    axisRenders.push(axisRender);
                }
            });

            return axisRenders;
        }
    });
    
    require('../ComponentLibrary').register(Constants.AXIS_COMPONENT, Axis);

    return Axis;
});
/**
 * Created by eason on 16/5/9.
 */
define('utils/GeoJsonLoader',['require'],function(require){

    var _loaded = {};

    function get(resource){

        if(typeof resource === 'string'){
            try{
                return JSON.parse(resource);
            }catch (e){
                d3.json(resource, function(mapData){
                    _loaded[resource] = mapData;
                })
            }
        }else if(resource && typeof resource === 'object'){
            return resource;
        }

        return _loaded[resource];
    }

    return {
        get:get
    }

});
/**
 * Created by Yuqian on 16/5/19.
 */

define('theme/Options',['require','../Constants'],function (require) {
    var Constants = require('../Constants');

    var options = {};

    options[Constants.PIE_CHART] = {
        plotOptions: {

        }
    };

    options[Constants.COLUMN_CHART] = {
        plotOptions: {
            categoryGap: '20%',
            gap: '20%'
        }

    };

    options[Constants.BAR_CHART] = {
        plotOptions: {

        }

    };

    options[Constants.LINE_CHART] = options[Constants.AREA_CHART] = {

        plotOptions:{
            large:false,

            marker:{
                symbol:'null_marker'
            },

            dataLabels:{
                "enabled": false,
                "align": "outside"
            }
        }
    };

    options[Constants.GAUGE_CHART] = {
        plotOptions: {

        }

    };

    options[Constants.RADAR_CHART] = {

        plotOptions:{
            columnType:false,
            marker:{
                symbol:'null_marker'
            },

            borderWidth:1,

            borderColor:'white',

            lineWidth:1
        }

    };

    options[Constants.SCATTER_CHART] = {
        plotOptions: {

        }

    };

    options[Constants.BUBBLE_CHART] = {
        plotOptions: {

        }

    };

    options[Constants.MAP_CHART] = {

        plotOptions:{
            fillColor:'#cccccc',
            fillColorOpacity:0.75,
            borderColor:'#ffffff',
            borderWidth:1,
            borderOpacity:1
        }
    };

    return options
});
/**
 * Created by eason on 16/5/23.
 * 地理坐标系的定义
 */

define('component/Geo',['require','./Base','../utils/BaseUtils','../utils/QueryUtils','../Constants','../utils/GeoJsonLoader','../theme/Options','../ComponentLibrary'],function(require){

    var Base = require('./Base');
    var BaseUtils = require('../utils/BaseUtils');
    var QueryUtils = require('../utils/QueryUtils');
    var Constants = require('../Constants');
    var GeoJsonLoader = require('../utils/GeoJsonLoader');
    var Options = require('../theme/Options');

    var featureID = 0;

    var Geo = Base.extend({
        getFeature:function(name){
            var mapData = this.mapData;
            for(var i = mapData.length - 1; i >= 0; i--){
                var fs = mapData[i].features || [];
                for(var j = fs.length - 1; j >= 0; j--){
                    if(fs[j].properties && fs[j].properties.name == name){
                        return fs[j];
                    }
                }
            }
        },

        getAllFeatures:function(){
            var allFeatures = [];
            this.mapData.forEach(function(data){allFeatures = allFeatures.concat(data.features);});
            return allFeatures;
        },

        getDefaultMapStyle:function(){
            var queryList = [Options[Constants.MAP_CHART].plotOptions, this.option.plotOptions];
            var style =  {
                fillColor:QueryUtils.queryList(queryList, 'fillColor'),
                fillColorOpacity:QueryUtils.queryList(queryList, 'fillColorOpacity'),
                borderWidth:QueryUtils.queryList(queryList, 'borderWidth'),
                borderColor:QueryUtils.queryList(queryList, 'borderColor'),
                borderOpacity:QueryUtils.queryList(queryList, 'borderOpacity')
            };
            return style;
        },

        getFeatureMap:function(series){
            var areaFeatures = [], bubbleFeatures = [], scatterFeatures = [], imageFeatures = [];

            var areaText = [], bubbleText = [], scatterText = [], imageText = [];

            var validArea = {};

            //计算第一个有效的系列
            for(var i = 0, len = series.length; i < len; i++){
                var sery = series[i];

                if(sery.visible){
                    if(sery.type == Constants.MAP_CHART){
                        var points = sery.points;
                        for(var pIndex = points.length - 1; pIndex >= 0; pIndex--){
                            var point = points[pIndex];
                            if(!point.feature){
                                QueryUtils.merge(point, point.feature = this.getFeature(point.name));
                            }
                            if(point.visible){
                                validArea[point.name] = true;
                                BaseUtils.extend(point, point.mapStyle);
                                areaFeatures.push(point);
                                // areaText.push(point);
                            }
                        }
                    }else if(sery.type == Constants.BUBBLE_CHART){
                        bubbleFeatures = bubbleFeatures.concat(sery.points);
                    }else{
                        sery.points.forEach(function(point){
                            var icon = {
                                iconUrl:'../../doc/example/marker-icon.png',
                                iconSize: [25, 41]
                            };
                            if(point.marker && BaseUtils.isImageMarker(point.marker.symbol)){
                                icon = {
                                    iconUrl:point.marker.symbol,
                                    iconSize:[point.marker.width, point.marker.height]
                                };
                                point.icon = icon;
                                imageFeatures.push(point);
                            }else{
                                scatterFeatures.push(point);
                            }
                        });
                    }
                }
            }

            //测试下效果
            bubbleText = bubbleFeatures;
            scatterText = scatterFeatures;
            imageText = imageFeatures;

            var features = this.getAllFeatures();
            var dStyle = this.getDefaultMapStyle();
            features.forEach(function(feature){
                if(feature.properties && !validArea[feature.properties.name]){
                    feature = QueryUtils.merge({}, feature, true);
                    QueryUtils.merge(feature, dStyle, true);
                    areaFeatures.push(feature);
                }
            });

            return {
                areaFeatures:areaFeatures,
                bubbleFeatures:bubbleFeatures,
                scatterFeatures:scatterFeatures,
                imageFeatures:imageFeatures,

                areaText:areaText,
                bubbleText:bubbleText,
                scatterText:scatterText,
                imageText:imageText
            };
        },

        getFitBounds:function(){
            var boxes = this.mapData.map(d3.geo.bounds);

            var southWest = boxes[0][0];
            var northEast = boxes[0][1];

            for(var i = boxes.length - 1; i > 0; i--){

                var fitBounds = boxes[i];

                southWest[0] = Math.min(fitBounds[0][0], southWest[0]);
                southWest[1] = Math.min(fitBounds[0][1], southWest[1]);

                northEast[0] = Math.max(fitBounds[1][0], northEast[0]);
                northEast[1] = Math.max(fitBounds[1][1], northEast[1]);
            }

            return [[southWest[1], southWest[0]], [northEast[1], northEast[0]]];
        }
    });


    Geo.addInitHook(function(){
        this.mapData = [];

        var cfg = this.componentOption;
        if(cfg.data){
            var maps = BaseUtils.isArray(cfg.data) ? cfg.data : [cfg.data];
            this.mapData = maps.map(GeoJsonLoader.get);
        }
        this.geoName = cfg.geoName;
    });
    
    require('../ComponentLibrary').register(Constants.GEO_COMPONENT, Geo);
    return Geo;
});
/**
 * Created by eason on 15/5/4.
 * 图例
 */
define('component/Legend',['require','./Base','../utils/BaseUtils','../Constants','../utils/QueryUtils','../render/LegendIconFactory','../ComponentLibrary'],function(require){
    var Base = require('./Base');
    var BaseUtils = require('../utils/BaseUtils');
    var Constants = require('../Constants');
    var QueryUtils = require('../utils/QueryUtils');
    var LegendIconFactory = require('../render/LegendIconFactory');

    var PADDING = 10;
    var GAP = 8;
    var BUTTON_HEIGHT = 12;
    var BUTTON_WIDTH = 52;
    var LINE_GAP = 4;
    var HORIZONTAL_GAP = 16;

    var Legend = Base.extend({

        initAttributesWithSeries:function(){

            this.items = [];

            this._updateLegendItems();
        },

        doLayout:function(){

            var usedSize = this._getLegendSize();

            this._setComponentBounds(this.componentOption.position || Constants.RIGHT_TOP, usedSize);

            this._resetLegendBounds();

            this._calculateVerticalPages();

            this.verticalAlign = 0;
            if(!this.hasEnoughSpace){
                var buttonWidth = BUTTON_WIDTH + 2 * PADDING;

                var moreSpace = Math.max(buttonWidth - this.bounds.width, 0);

                this.vanchart.bounds.width -= moreSpace;

                this.bounds.width += moreSpace;
                this.bounds.x -= moreSpace;

                this.verticalAlign = moreSpace/2;
            }
        },

        _updateLegendItems:function(){

            var series = this.vanchart.series;

            var namedSeries = {};

            var legend = this;

            series.map(function(sery){

                switch (sery.type) {
                    case Constants.GAUGE_CHART:
                        break;
                    case Constants.PIE_CHART:
                        sery.points.map(function (point) {
                            if(!(namedSeries[point.seriesName])){

                                var item = {color:point.color, itemName:point.seriesName, visible:point.visible, pieDataIndex:point.index};

                                legend._mergeCommonLegendAttr(sery, item);

                                namedSeries[point.seriesName] = true;

                                legend.items.push(item);
                            }
                        });
                        break;

                    default:
                        if(!(namedSeries[sery.name])) {
                            var item = {color: sery.color, itemName: sery.name, visible: sery.visible};

                            legend._mergeCommonLegendAttr(sery, item);

                            namedSeries[sery.name] = true;

                            legend.items.push(item);
                        }
                }

            });

        },

        _calculateVerticalPages:function(){

            var position = this.componentOption.position || Constants.RIGHT;
            this.pages = [];

            if(position == Constants.TOP || position == Constants.BOTTOM){
                return;
            }

            var height = this.bounds.height;

            var preHeight = this.getPreHeight(this.items.length);

            if(preHeight <= height){
                this.hasEnoughSpace = true;
                return;
            }

            this.hasEnoughSpace = false;

            var pageIndex = 0;
            var startIndex = 0;
            var preHeight = 0;
            for(var itemIndex = 0, itemCount = this.items.length; itemIndex < itemCount; itemIndex++){

                var pageHeight = preHeight;
                preHeight = this.getPreHeight(startIndex, itemIndex + 1);

                if(preHeight > height){
                    pageIndex++;
                    startIndex = itemIndex;
                    this.bounds.height = pageHeight + BUTTON_HEIGHT;
                }

                this.pages[pageIndex] = this.pages[pageIndex] || [];
                this.pages[pageIndex].push(this.items[itemIndex]);
            }
        },

        _mergeCommonLegendAttr:function(sery, item){
            var cfg = this.componentOption;
            var hiddenColor = cfg.hiddenColor;
            var hoverColor = cfg.hoverColor || cfg.style.color;

            QueryUtils.merge(item, {
                series:sery,
                hiddenColor:hiddenColor,
                hoverColor:hoverColor,
                legendIconType:this._getLegendType(sery),
                lineIndex:0//记录下如果换行的行号
            }, true);

        },

        _getLegendSize:function(){
            var cfg = this.componentOption;
            var position = cfg.position || Constants.RIGHT;
            var padding = PADDING * 2;

            if(position == Constants.TOP || position == Constants.BOTTOM){

                var legendSize = this._getTopAndBottomLegendSize() + padding;

                var maxHeight = this._maxHeight();

                return (cfg.maxHeight && legendSize > maxHeight) ? maxHeight : legendSize;

            }else{

                var legendSize = this._getLeftAndRightLegendSize() + padding;

                //预测下能否放下
                var usedHeight = this.getPreHeight() + PADDING;
                var chartHeight = this.vanchart.getPlotBounds().height;
                if(usedHeight < chartHeight){
                    legendSize = Math.max(legendSize, BUTTON_WIDTH);
                }

                var maxWidth = this._maxWidth();

                return (cfg.maxWidth && legendSize > maxWidth) ? maxWidth : legendSize;
            }
        },

        _getLeftAndRightLegendSize:function(){
            this.maxLabelWidth = 0;
            this.maxLabelHeight = 0;

            this.maxIconWidth = 0;
            this.maxIconHeight = 0;

            for(var i = 0, len = this.items.length; i < len; i++){
                var labelDim = BaseUtils.getTextDimension(this.items[i].itemName, this.componentOption.style, true);
                this.maxLabelWidth = Math.max(this.maxLabelWidth, labelDim.width);
                this.maxLabelHeight = Math.max(this.maxLabelHeight, labelDim.height);

                var iconDim = LegendIconFactory.getLegendIconSize(this.items[i].legendIconType);
                this.maxIconWidth = Math.max(this.maxIconWidth, iconDim.width);
                this.maxIconHeight = Math.max(this.maxIconHeight, iconDim.height);
            }

            return PADDING * 2 + this.maxIconWidth + GAP + this.maxLabelWidth;
        },

        _getTopAndBottomLegendSize:function(){

            this.lineHeight = [];//换行的画记录每一行的高度

            var plotBonds = this.vanchart.getPlotBounds();

            var offeredWidth = plotBonds.width - 4 * PADDING;

            var usedWidth = 0;
            var maxLineHeight = 0;
            var lineIndex = 0;

            for(var i = 0, len = this.items.length; i < len; i++){

                var item = this.items[i];

                var iconSize = LegendIconFactory.getLegendIconSize(item.legendIconType);
                var labelDim = BaseUtils.getTextDimension(item.itemName, this.componentOption.style, true);

                //限制每个图例的最大宽度不会超过整个图例区域的宽度
                var iconWidth = Math.min(iconSize.width + GAP + labelDim.width, offeredWidth - 1);

                if(usedWidth + iconWidth < offeredWidth){
                    item.lineIndex = lineIndex;
                    maxLineHeight = Math.max(maxLineHeight, labelDim.height, iconSize.height);
                    usedWidth += iconWidth + HORIZONTAL_GAP;
                } else {
                    this.lineHeight.push(maxLineHeight);
                    if (i !== 0) {
                        lineIndex++;
                    }

                    item.lineIndex = lineIndex;
                    usedWidth = iconWidth;
                    maxLineHeight = Math.max(labelDim.height, iconSize.height);
                }

                if(i == len - 1){
                    this.lineHeight.push(maxLineHeight);
                }
            }

            var totalHeight = 0;
            this.lineHeight.forEach(function(d){
                totalHeight += (d + PADDING);
            });

            this.maxLineIndex = this.lineHeight.length - 1;

            if(this.componentOption.maxHeight){
                var maxHeight = this._maxHeight();

                this.maxLineIndex = -1;

                totalHeight = 0;

                while(totalHeight < maxHeight && this.maxLineIndex < this.lineHeight.length - 1){
                    var nextLineHeight = totalHeight + this.lineHeight[this.maxLineIndex + 1] + PADDING;
                    if(nextLineHeight < maxHeight){
                        totalHeight = nextLineHeight;
                        this.maxLineIndex++;
                    }else{
                        break;
                    }
                }
            }

            return  totalHeight;
        },

        _resetLegendBounds:function(){

            var position = this.componentOption.position;

            if(position == Constants.LEFT || position == Constants.RIGHT || position == Constants.RIGHT_TOP){

                //右或者右上方的时候剪掉可能占据的工具栏的高度
                if(position == Constants.RIGHT || position == Constants.RIGHT_TOP){
                    var toolbarHeight = this.vanchart.getToolbarHeight();
                    this.bounds.y += toolbarHeight;
                    this.bounds.height -= toolbarHeight;
                }

                var x = this.bounds.x + PADDING;
                var y = this.bounds.y + PADDING;
                var height = this.bounds.height - PADDING * 2;
                var width = this.bounds.width - PADDING * 2;

                var usedHeight = this.getPreHeight();

                usedHeight = Math.min(usedHeight, height);

                y += Math.round((height - usedHeight) / 2);

                if(position == Constants.RIGHT_TOP || this.isFloat){
                    this.bounds.height = usedHeight;
                }else{
                    this.bounds = {x:x, y:y, width:width, height:usedHeight};
                }

            }else{

                var x = this.bounds.x + PADDING;
                var y = this.bounds.y + PADDING;
                var height = this.bounds.height - PADDING * 2;
                var width = this.bounds.width - PADDING * 2;

                var usedWidth = width;
                //小于一行的时候区域比计算的要小
                if(this.lineHeight.length == 1){

                    usedWidth = PADDING * 2;
                    for(var i = 0, len = this.items.length; i < len; i++) {

                        var item = this.items[i];

                        var iconSize = LegendIconFactory.getLegendIconSize(item.legendIconType);
                        var labelDim = BaseUtils.getTextDimension(item.itemName, this.componentOption.style, true);

                        usedWidth += (iconSize.width + labelDim.width + GAP);
                    }

                    usedWidth += HORIZONTAL_GAP * (this.items.length - 1);

                    x += (width - usedWidth) / 2;
                }

                this.bounds = {x:x, y:y, width:usedWidth, height:height};

                if(position == Constants.BOTTOM) {
                    var zoomComponent = this.vanchart.getComponent(Constants.ZOOM_COMPONENT);
                    if (zoomComponent && zoomComponent.zoomToolEnabled()) {
                        this.bounds.y += zoomComponent.bounds.height;
                    }
                }
            }
        },

        getLegendItems:function(){
            if(this.isHorizontal()){

                var items = [];

                var maxLineIndex = this.maxLineIndex;

                this.items.forEach(function(item){
                    if(item.lineIndex <= maxLineIndex){
                        items.push(item);
                    }
                });

                return items;

            }else{
                return this.items;
            }
        },

        getLineHeight:function(){
            return this.lineHeight;
        },

        getPadding:function(){
            return PADDING;
        },

        getGap:function(){
            return GAP;
        },

        getHorizontalGap:function(){
            return HORIZONTAL_GAP;
        },

        getPreHeight:function(){

            var startIndex = 0;
            var endIndex = this.items.length;

            if(arguments.length == 1){
                endIndex = arguments[0];
            }else if(arguments.length == 2){
                startIndex = arguments[0];
                endIndex = arguments[1];
            }

            var height = PADDING;
            var labelHeight = this.maxLabelHeight;

            for(var i = startIndex; i < endIndex; i++){
                var item = this.items[i];
                var iconSize = LegendIconFactory.getLegendIconSize(item.legendIconType);
                height += (Math.max(iconSize.height, labelHeight) + LINE_GAP)
            }

            return Math.floor(height);
        },

        getVerticalItemHeight:function(index){
            var height = PADDING;
            var labelHeight = this.maxLabelHeight;

            var item = this.items[index];
            var iconSize = LegendIconFactory.getLegendIconSize(item.legendIconType);
            height += (Math.max(iconSize.height, labelHeight) + LINE_GAP);

            return height;
        },

        getHorizontalItemWidth:function(index){
            var item = this.items[index];
            var cfg = this.componentOption;

            var iconSize = LegendIconFactory.getLegendIconSize(item.legendIconType);
            var labelDim = BaseUtils.getTextDimension(item.itemName, cfg.style, true);

            return iconSize.width + GAP + labelDim.width + HORIZONTAL_GAP;
        },

        getHorizontalItemsWidth:function(items){

            var cfg = this.componentOption;
            var usedWidth = 0;

            for(var i = 0, len = items.length; i < len; i++) {

                var item = items[i];

                var iconSize = LegendIconFactory.getLegendIconSize(item.legendIconType);
                var labelDim = BaseUtils.getTextDimension(item.itemName, cfg.style, true);

                usedWidth += (iconSize.width + labelDim.width + GAP);
            }

            usedWidth += HORIZONTAL_GAP * (items.length - 1);

            return usedWidth;
        },

        getHorizontalLineItems:function(){
            var lineItems = [];
            for(var i = 0, len = this.items.length; i < len; i++){
                var item = this.items[i];
                if(item.lineIndex <= this.maxLineIndex){
                    lineItems[item.lineIndex] = lineItems[item.lineIndex] || [];
                    lineItems[item.lineIndex].push(item);
                }
            }

            return lineItems;
        },

        getVerticalPages:function(){
            return this.pages;
        },

        hasEnoughVerticalSpace:function(){
            return this.hasEnoughSpace;
        },

        getButtonHeight:function(){
            return BUTTON_HEIGHT;
        }
    });

    require('../ComponentLibrary').register(Constants.LEGEND_COMPONENT, Legend);
    return Legend;
});
/**
 * Created by eason on 15/7/3.
 * reused and modified tooltip component from echarts
 */
//Copyright (c) 2013, Baidu Inc.
//    All rights reserved.
//
//    Redistribution and use of this software in source and binary forms, with or
//    without modification, are permitted provided that the following conditions
//are met:
//
//    Redistributions of source code must retain the above copyright notice, this
//list of conditions and the following disclaimer.
//
//    Redistributions in binary form must reproduce the above copyright notice,
//    this list of conditions and the following disclaimer in the documentation
//and/or other materials provided with the distribution.
//
//    Neither the name of Baidu Inc. nor the names of its contributors may be used
//to endorse or promote products derived from this software without specific
//prior written permission of Baidu Inc.
//
//    THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
//AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
//IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
//DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR
//ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
//(INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
//LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON
//ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
//(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
//SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.

define('component/Tooltip',['require','./Base','../utils/BaseUtils','../Constants','../utils/ColorUtils','../ComponentLibrary'],function(require){

    var Base = require('./Base');
    var BaseUtils = require('../utils/BaseUtils');
    var Constants = require('../Constants');
    var ColorUtils = require('../utils/ColorUtils');

    var DEFAULT_DURATION = 0.4;

    var Tooltip = Base.extend({

        _gCssText: 'position:absolute;display:block;border-style:solid;white-space:nowrap;z-index:1;-webkit-user-select:none;-moz-user-select:none;-o-user-select:none;user-select:none;',

        _style: function (opt) {
            if (!opt) {
                return '';
            }
            var cssText = [];
            if (opt.animation && !opt.follow) {
                var transitionText = 'left ' + DEFAULT_DURATION + 's,'
                    + 'top ' + DEFAULT_DURATION + 's';
                cssText.push(
                    'transition:' + transitionText
                );
                cssText.push(
                    '-moz-transition:' + transitionText
                );
                cssText.push(
                    '-webkit-transition:' + transitionText
                );
                cssText.push(
                    '-o-transition:' + transitionText
                );
            }

            if(opt.style){
                var fontStyle = BaseUtils.cssNormalization(opt.style);

                for(var styleName in fontStyle){
                    if(styleName == 'color'){
                        cssText.push(styleName + ':' + ColorUtils.colorToHex(fontStyle[styleName]));
                    }else{
                        cssText.push(styleName + ':' + fontStyle[styleName]);
                    }
                }
            }

            if (opt.backgroundColor) {
                if(typeof opt.backgroundColor == 'string'){
                    if(BaseUtils.isSupportSVG()){
                        cssText.push('background-Color:' + opt.backgroundColor);
                    }else{
                        var hexAlpha = ColorUtils.colorToHexAlpha(opt.backgroundColor);
                        cssText.push('background-Color:' + hexAlpha.hex);
                        cssText.push('filter:alpha(opacity=' + hexAlpha.alpha + ')')
                    }
                }else if(typeof opt.backgroundColor == 'object'){

                    var color = opt.backgroundColor;
                    var startColor = ColorUtils.colorToHex(color.startColor);
                    var endColor = ColorUtils.colorToHex(color.endColor);

                    var start = 'left';

                    var startPos = 'left top';
                    var endPos = 'right top';
                    var type = 1;

                    if(color.x1 == color.x2){
                        start = 'top';

                        startPos = 'left top';
                        endPos = 'left bottom';

                        type = 0;
                    }

                    cssText.push('background: -ms-linear-gradient(' + start + ', '+ startColor +', '+ endColor +')');

                    cssText.push('background-image: -moz-linear-gradient(' + start + ', '+ startColor +', '+ endColor +')');

                    cssText.push('background-image: -webkit-gradient(linear, '+startPos+', '+endPos+', color-stop(0, '+ startColor +'), color-stop(1, '+ endColor+'))');

                    cssText.push('filter: progid:DXImageTransform.Microsoft.gradient(startColorstr='+startColor + ', endColorstr='+endColor+', GradientType='+type+')');
                }
            }

            if (opt.borderWidth != null) {
                cssText.push('border-width:' + opt.borderWidth + 'px');
            }

            if (opt.borderColor != null) {
                cssText.push('border-color:' + opt.borderColor);
            }

            if (opt.borderRadius != null) {
                cssText.push(
                    'border-radius:' + opt.borderRadius + 'px'
                );
                cssText.push(
                    '-moz-border-radius:' + opt.borderRadius + 'px'
                );
                cssText.push(
                    '-webkit-border-radius:' + opt.borderRadius + 'px'
                );
                cssText.push(
                    '-o-border-radius:' + opt.borderRadius + 'px'
                );
            }

            if(opt.shadow){
                cssText.push('box-shadow:1px 1px 2px rgba(0,0,0,0.2)');
            }

            var padding = opt.padding;
            if (padding != null && padding != undefined) {
                padding = BaseUtils.reformCssArray(padding);
                cssText.push(
                    'padding:' + padding[0] + 'px '
                    + padding[1] + 'px '
                    + padding[2] + 'px '
                    + padding[3] + 'px'
                );
            }

            cssText = cssText.join(';') + ';';

            return cssText;
        },

        doLayout:function(){
            if(!this._tDom){
                var dom = this.vanchart.dom;

                this._tDom = document.createElement('div');

                this._tDom.onselectstart = function() {
                    return false;
                };

                this._tDom.style.position = 'absolute';

                dom.appendChild(this._tDom);

                this._tooltipHideTick = null;
            }
        },

        remove:function(){
            if(this._tDom){
                var dom = this.vanchart.dom;
                dom.removeChild(this._tDom);
            }
        },

        showWithPoint:function(point){
            if(point && point.visible){
                var opt = point.tooltip;
                var tooltipDim  = this.calculateTooltipDivDim(opt, point.tooltipText);
                var pos = point.series.chart.getTooltipPos(point, tooltipDim, event);
                this.show(pos, opt, point.tooltipText);
            }
        },
        
        showWithSharedPoints: function (points) {
            if (!points || points.length === 0) {
                this.hide();
                return;
            }
            var d = points.reduce(function (prev, curr) {
                return (prev.value > curr.value) ? prev : curr;
            });
            var opt = d.tooltip;
            var text = this._calculateTooltipContent(points);
            var tooltipDim  = this.calculateTooltipDivDim(opt, text);
            var tooltipPos = d.series.chart.getTooltipPos(d, tooltipDim, event);
            this.show(tooltipPos, opt, text);
        },

        show:function(pos, opt, tooltipText){

            if(pos && opt && tooltipText && !this.vanchart.isMouseDown){
                clearTimeout(this._tooltipHideTick);

                this._tDom.innerHTML = tooltipText;

                this._tDom.style.cssText = this._gCssText
                    + this._style(opt)
                    + 'left:' + pos[0] + 'px;top:' + pos[1] + 'px;';
            }

            if(BaseUtils.hasTouch()){
                this._tooltipHideTick = setTimeout(function(){
                    this._tDom.style.display = 'none';
                }.bind(this), 3000);
            }
        },

        hide:function(){

            clearTimeout(this._tooltipHideTick);

            this._tooltipHideTick = setTimeout(function(){
                this._tDom.style.display = 'none';
            }.bind(this), 400);

        },

        immediateHide:function(){
            this._tDom.style.display = 'none';
        },

        calculateTooltipDivDim:function(opt, tooltipText){

            opt = opt || '';

            var body = document.getElementsByTagName("body")[0];
            var testDiv = document.createElement('div');
            testDiv.innerHTML = tooltipText;
            testDiv.style.cssText = this._gCssText + this._style(opt) + 'visibility:hidden;';
            body.appendChild(testDiv);
            var width = testDiv.offsetWidth;
            var height = testDiv.offsetHeight;
            body.removeChild(testDiv);
            return {
                width:width,
                height:height
            };
        },

        _calculateTooltipContent:function(points){

            var tooltip = points[0].tooltip;
            var formatter = tooltip.formatter;

            if(!formatter){
                return "";
            }

            if(typeof formatter == 'object'){

                var style = tooltip.style;
                var label = formatter.identifier;

                var content = '';

                content += points[0].series.chart._createCategoryLine(points[0], label, style, formatter);

                points.map(function(point){

                    content += '<span style="font-size:20px; font-family: verdana; color: ' + point.color + '">'+'&#9679  '+'</span>';

                    content += point.series.chart._createSeriesLine(point, label, style, formatter);

                    content += '<br />';
                });

                return content;
            }else{
                //
                return BaseUtils.getFormatterFunction(formatter).call();
            }
        }

    });

    // function (vanchart, option, componentType){
    //     Base.call(this, vanchart, option, componentType);
    //     this.refresh(option);
    // }
    
    require('../ComponentLibrary').register(Constants.TOOLTIP_COMPONENT, Tooltip);
    return Tooltip;
});
//Copyright (c) 2013 The New York Times
//
//Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the "Software"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions:
//
//    The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software.
//
//    THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE

define('utils/ExportUtils',['require','./BaseUtils'],function(require) {

    var BaseUtils = require('./BaseUtils');

    var doctype = '<?xml version="1.0" standalone="no"?><!DOCTYPE svg PUBLIC "-//W3C//DTD SVG 1.1//EN" "http://www.w3.org/Graphics/SVG/1.1/DTD/svg11.dtd">';

    window.URL = (window.URL || window.webkitURL);

    var body = document.body;

    var prefix = {
        xmlns: "http://www.w3.org/2000/xmlns/",
        xlink: "http://www.w3.org/1999/xlink",
        svg: "http://www.w3.org/2000/svg"
    };

    function cleanup() {
        var crowbarElements = document.querySelectorAll(".svg-export");

        [].forEach.call(crowbarElements, function(el) {
            el.parentNode.removeChild(el);
        });
    }


    function getSources(svg) {

        var styles =  "" ;

        svg.setAttribute("version", "1.1");

        var defsEl = document.createElement("defs");

        svg.insertBefore(defsEl, svg.firstChild);

        var styleEl = document.createElement("style")
        defsEl.appendChild(styleEl);
        styleEl.setAttribute("type", "text/css");

        svg.removeAttribute("xmlns");
        svg.removeAttribute("xlink");

        if (!svg.hasAttributeNS(prefix.xmlns, "xmlns")) {
            svg.setAttributeNS(prefix.xmlns, "xmlns", prefix.svg);
        }

        if (!svg.hasAttributeNS(prefix.xmlns, "xmlns:xlink")) {
            svg.setAttributeNS(prefix.xmlns, "xmlns:xlink", prefix.xlink);
        }

        var source = (new XMLSerializer()).serializeToString(svg).replace('</style>', '<![CDATA[' + styles + ']]></style>');

        return [doctype + source];
    }

    function toSvg(svgNode, config) {

        cleanup();

        var source = getSources(svgNode);

        var fileName = config.fileName;

        var url = window.URL.createObjectURL(new Blob(source, { "type" : "text\/xml" }));

        var a = document.createElement("a");
        body.appendChild(a);
        a.setAttribute("class", "svg-export");
        a.setAttribute("download", fileName + ".svg");
        a.setAttribute("href", url);
        a.style["display"] = "none";
        a.click();

        setTimeout(function() {
            window.URL.revokeObjectURL(url);
        }, 10);
    }

    function toImage(svgNode, config, chartDim){
        toSvg(svgNode, config, chartDim);
    }

    return {
        toImage:toImage
    };
});
/**
 * Created by eason on 15/8/24.
 */

define('render/ToolbarIconSvgRender',['require','../utils/BaseUtils','../Constants','../utils/ExportUtils','../dom/DomEvent'],function(require){

    //icon的几种状态
    var SELECTED = 'selected';
    var HOVER = 'hover';

    //icon的几种背景颜色
    var OPEN_NOMAL = 'rgba(0,0,0,0.05)';
    var OPEN_HOVER = 'rgba(0,0,0,0.1)';
    var OPEN_SELECTED = 'rgba(0,0,0,0.1)';

    var CLOSED_NORMAL = 'rgba(0,0,0,0.0)';
    var CLOSED_HOVER = 'rgba(0,0,0,0.05)';
    var CLOSED_SELECTED = 'rgba(0,0,0,0.1)';

    var RECT_R = 2;

    var BaseUtils = require('../utils/BaseUtils');
    var Constants = require('../Constants');
    var ExportUtils = require('../utils/ExportUtils');
    var DomEvent = require('../dom/DomEvent');

    function ToolbarIconSvgRender(toolbarIcon, toolbar){
        this.toolbarIcon = toolbarIcon;
        this.toolbar = toolbar;
    }

    ToolbarIconSvgRender.prototype = {
        constructor:ToolbarIconSvgRender,

        render:function(toolBarG){

            var iconSize = this.toolbar.getIconSize();
            var pos = this.toolbarIcon.getIconPos();
            var isVisible = this.toolbarIcon.visible;

            this.iconG = toolBarG
                .append('g')
                .attr('transform', 'translate('+ pos.x +','+ pos.y +')')
                .attr('visibility', isVisible ? 'visible' : 'hidden');

            this.iconG.append('rect')
                .attr('width', iconSize)
                .attr('height', iconSize)
                .attr('rx', RECT_R)
                .attr('ry', RECT_R)
                .style('fill', this._isOpen() ? OPEN_NOMAL : CLOSED_NORMAL);

            this._createIcon();

            this._addListeners();
        },

        _iconAnimation:function(moveIndex, delay, visible){

            var iconG = this.iconG;
            var pos = this.toolbarIcon.getIconPos();

            setTimeout(function(){

                if(visible){
                    iconG.attr('visibility', 'visible');
                }

                var moveDet = 4 * moveIndex;

                var leftX = pos.x - moveDet;

                iconG
                    .transition()
                    .ease('circle-out')
                    .duration(100)
                    .attr('transform', 'translate('+ leftX +','+ pos.y +')')
                    .transition()
                    .ease('circle-in')
                    .duration(100)
                    .attr('transform', 'translate('+ pos.x +','+ pos.y +')')
                    .each('end', function(){
                        d3.select(this).attr('visibility', visible ? 'visible' : 'hidden')
                    });

                iconG.select('rect')
                    .style('fill', visible ? CLOSED_NORMAL : OPEN_NOMAL)
                    .transition()
                    .ease('linear')
                    .duration(200)
                    .style('fill', visible ? OPEN_NOMAL : CLOSED_NORMAL);

                iconG.select('g')
                    .style('opacity', visible ? 0 : 1)
                    .transition()
                    .ease('linear')
                    .duration(200)
                    .style('opacity', visible ? 1 : 0);

            }, delay);

        },

        backToOrigin:function(){
            var pos = this.toolbarIcon.getIconPos();
            this.iconG.attr('transform', 'translate('+ pos.x +','+ pos.y +')');
        },

        showIcon:function(){
            if(arguments.length){
                this._iconAnimation(arguments[0], arguments[1], true);
            }else{
                this.iconG.attr('visibility', 'visible');
            }

        },

        hideIcon:function(){
            if(arguments.length){
                this._iconAnimation(arguments[0], arguments[1], false);
            }else{
                this.iconG.attr('visibility', 'hidden');
            }
        },

        refreshMove:function(left, right){

            var pos = this.toolbarIcon.getIconPos();

            var translate = d3.transform(this.iconG.attr('transform')).translate;

            var currentX = translate[0];

            var leftPos = currentX - left;
            var rightPos = leftPos + right;

            this.iconG
                .transition()
                .ease('circle-out')
                .duration(220)
                .attr('transform', 'translate('+ leftPos +','+ pos.y +')')
                .transition()
                .ease('circle-in')
                .duration(220)
                .attr('transform', 'translate('+ rightPos +','+ pos.y +')');
        },

        refreshMoveWithoutAnimation:function(left, right){

            var pos = this.toolbarIcon.getIconPos();
            var translate = d3.transform(this.iconG.attr('transform')).translate;

            var currentX = translate[0];

            var rightPos = currentX - left + right;

            this.iconG
                .attr('transform', 'translate('+ rightPos +','+ pos.y +')');

        },

        _isOpen:function(){
            return this.toolbar.isOpen;
        },

        _addListeners:function(){
            var iconG = this.iconG;
            var self = this;

            var toolBar = this.toolbar;
            var vanchart = toolBar.vanchart;
            var toolBarOption = toolBar.componentOption;
            var dom = toolBar.vanchart.getParentDom();
            var svgRoot = this.toolbar.getVanchartRender().getRenderRoot();

            var icon = this.toolbarIcon;
            var refreshIcon = toolBar.getRefreshIcon();

            var chartDim = {width:vanchart.chartWidth(), height:vanchart.chartHeight()};

            iconG
                .style('cursor', 'pointer')
                .on('click', function(){
                    switch (icon.iconType){
                        case Constants.REFRESH_ICON:
                            vanchart.refreshRestore();
                            refreshIcon.hideIcon();
                            break;
                        case Constants.INCREASE_ICON:
                            icon.iconType = Constants.DECREASE_ICON;
                            iconG.select('path').attr('d', icon.getDecreaseIconPath());
                            vanchart.refreshIncreaseOrder();
                            refreshIcon.showIcon();
                            break;
                        case Constants.DECREASE_ICON:
                            icon.iconType = Constants.INCREASE_ICON;
                            iconG.select('path').attr('d', icon.getIncreaseIconPath());
                            vanchart.refreshDecreaseOrder();
                            refreshIcon.showIcon();
                            break;
                        case Constants.EXPORT_ICON:
                            ExportUtils.toImage(svgRoot.node(), toolBarOption['toImage'], chartDim);
                            break;
                        case Constants.MAX_ICON:
                            BaseUtils.showLightBox(toolBar.option);
                            break;
                        case Constants.MIN_ICON:
                            BaseUtils.hideLightBox(dom);
                            break;
                        case Constants.MENU_ICON:
                            toolBar.showOrHide();
                            break;
                    }
                })
                .on('mouseenter', function(){

                    iconG.select('rect').style('fill', self._isOpen() ? OPEN_HOVER : CLOSED_HOVER);

                })
                .on('mouseleave', function(){

                    iconG.select('rect').style('fill', self._isOpen() ? OPEN_NOMAL : CLOSED_NORMAL);

                })
                .on('mouseup', function(){
                    DomEvent.stopPropagation(d3.event);
                })
                .on('mousedown', function(){
                    DomEvent.stopPropagation(d3.event);
                });

        },

        _createIcon:function(){
            var iconG = this.iconG;

            var icon = this.toolbarIcon;
            var iconType = icon.iconType;

            switch (iconType){
                case Constants.REFRESH_ICON:
                    iconG.append('path')
                        .attr('d', icon.getRefreshIconPath())
                        .style('fill', '#FF9933');
                    break;
                case Constants.INCREASE_ICON:
                    iconG.append('path')
                        .attr('d', icon.getIncreaseIconPath())
                        .style('fill', '#33CCFF');
                    break;
                case Constants.DECREASE_ICON:
                    iconG.append('path')
                        .attr('d', icon.getDecreaseIconPath())
                        .style('fill', '#33CCFF');
                    break;
                case Constants.EXPORT_ICON:
                    iconG.append('path')
                        .attr('d', icon.getExportIconPath())
                        .style('fill', '#6666CC');
                    break;
                case Constants.MAX_ICON:
                    iconG.append('path')
                        .attr('d', icon.getMaxIconPath())
                        .style('fill', '#33CC66');
                    break;
                case Constants.MIN_ICON:
                    iconG.append('path')
                        .attr('d', icon.getMinIconPath())
                        .style('fill', '#33CC66');
                    break;
                case Constants.MENU_ICON:
                    iconG.append('path')
                        .attr('d', icon.getMenuIconPath())
                        .style('stroke-width', 2)
                        .style('stroke', '#AAAAAA');
                    break;
            }
        }
    };

    return ToolbarIconSvgRender;

});
/**
 * Created by eason on 15/8/24.
 */

define('render/ToolbarIconVmlRender',['require','../utils/BaseUtils','../Constants','../utils/ExportUtils','../dom/DomEvent'],function(require){

    //icon的几种状态
    var SELECTED = 'selected';
    var HOVER = 'hover';

    //icon的几种背景颜色
    var OPEN_NOMAL = 'rgb(0,0,0)';
    var OPEN_NORMAL_OPACITY = 0.05;

    var OPEN_HOVER = 'rgb(0,0,0)';
    var OPEN_HOVER_OPACITY = 0.1;

    var CLOSED_NORMAL = 'rgb(0,0,0)';
    var CLOSED_NORMAL_OPACITY = 0;

    var CLOSED_HOVER = 'rgb(0,0,0)';
    var CLOSED_HOVER_OPACITY = 0.05;

    var RECT_R = 2;

    var BaseUtils = require('../utils/BaseUtils');
    var Constants = require('../Constants');
    var ExportUtils = require('../utils/ExportUtils');
    var DomEvent = require('../dom/DomEvent');

    function ToolbarIconVmlRender(toolbarIcon, toolbar){
        this.toolbarIcon = toolbarIcon;
        this.toolbar = toolbar;
        this.currentPos = [];
    }

    ToolbarIconVmlRender.prototype = {
        constructor:ToolbarIconVmlRender,

        render:function(paper){

            var toolbarPos = this.toolbar.getToolbarPos();
            var pos = this.toolbarIcon.getIconPos();
            var x = pos.x + toolbarPos.x;
            var y = pos.y + toolbarPos.y;

            this.currentPos = [x, y];

            var iconSize = this.toolbar.getIconSize();
            var isVisible = this.toolbarIcon.visible;

            this.itemSet = paper.set();

            this.background = paper.rect(0, 0, iconSize, iconSize)
                .attr('fill', this._isOpen() ? OPEN_NOMAL : CLOSED_NORMAL)
                .attr('fill-opacity', this._isOpen() ? OPEN_NORMAL_OPACITY : CLOSED_NORMAL_OPACITY)
                .attr('rx', RECT_R)
                .attr('ry', RECT_R)
                .attr('stroke-width', 0);

            this.foreground = paper.path().attr(this._getIconStyle());

            this.itemSet.push(this.background);
            this.itemSet.push(this.foreground);

            this.itemSet.transform('t' + x + ',' + y);

            if(!isVisible){
                this.itemSet.hide();
            }

            this._addListeners();
        },

        _getIconStyle:function(){
            var icon = this.toolbarIcon;
            var iconType = icon.iconType;
            switch (iconType){
                case Constants.REFRESH_ICON:
                    return {
                        path:icon.getRefreshIconPath(),
                        fill:'#FF9933',
                        'stroke-width':0
                    };
                case Constants.INCREASE_ICON:
                    return {
                        path:icon.getIncreaseIconPath(),
                        fill:'#33CCFF',
                        'stroke-width':0
                    };
                case Constants.DECREASE_ICON:
                    return {
                        path:icon.getDecreaseIconPath(),
                        fill:'#33CCFF',
                        'stroke-width':0
                    };
                case Constants.EXPORT_ICON:
                    return {
                        path:icon.getExportIconPath(),
                        fill:'#6666CC',
                        'stroke-width':0
                    };
                case Constants.MAX_ICON:
                    return {
                        path:icon.getMaxIconPath(),
                        fill:'#33CC66',
                        'stroke-width':0
                    };
                case Constants.MIN_ICON:
                    return {
                        path:icon.getMinIconPath(),
                        fill:'#33CC66',
                        'stroke-width':0
                    };
                case Constants.MENU_ICON:
                    return {
                        path:icon.getMenuIconPath(),
                        'stroke-width':2,
                        stroke:'#AAAAAA',
                        fill:'none'
                    };
            }
        },

        _addListeners:function(){
            var iconG = this.iconG;
            var self = this;

            var toolBar = this.toolbar;
            var toolBarOption = toolBar.componentOption;
            var dom = toolBar.vanchart.getParentDom();
            var paper = this.toolbar.getVanchartRender().getRenderRoot();

            var icon = this.toolbarIcon;
            var vanchart = toolBar.vanchart;
            var refreshIcon = toolBar.getRefreshIcon();

            var chartDim = {width:vanchart.chartWidth(), height:vanchart.chartHeight()};

            this.itemSet.forEach(function(comp){

                var self = this;

                comp.attr('cursor', 'pointer');

                comp.click(function(e){
                    switch (icon.iconType){
                        case Constants.REFRESH_ICON:
                            vanchart.refreshRestore();
                            refreshIcon.hideIcon();
                            break;
                        case Constants.INCREASE_ICON:
                            icon.iconType = Constants.DECREASE_ICON;
                            self.foreground.attr('path', icon.getDecreaseIconPath());
                            vanchart.refreshIncreaseOrder();
                            refreshIcon.showIcon();
                            break;
                        case Constants.DECREASE_ICON:
                            icon.iconType = Constants.INCREASE_ICON;
                            self.foreground.attr('path', icon.getIncreaseIconPath());
                            vanchart.refreshDecreaseOrder();
                            refreshIcon.showIcon();
                            break;
                        case Constants.EXPORT_ICON:
                            ExportUtils.toImage(paper, toolBarOption['toImage'], chartDim);
                            break;
                        case Constants.MAX_ICON:
                            BaseUtils.showLightBox(toolBar.option);
                            break;
                        case Constants.MIN_ICON:
                            BaseUtils.hideLightBox(dom);
                            break;
                        case Constants.MENU_ICON:
                            toolBar.showOrHide();
                            break;
                    }
                });

                comp.mouseover(function(){

                    self.background
                        .attr('fill', self._isOpen() ? OPEN_HOVER : CLOSED_HOVER)
                        .attr('fill-opacity', self._isOpen ? OPEN_HOVER_OPACITY: CLOSED_HOVER_OPACITY);

                });

                comp.mouseout(function(){

                    self.background
                        .attr('fill', self._isOpen() ? OPEN_NOMAL : CLOSED_NORMAL)
                        .attr('fill-opacity', self._isOpen() ? OPEN_NORMAL_OPACITY : CLOSED_NORMAL_OPACITY);

                });

                comp.mouseup(function(e){
                    DomEvent.stopPropagation(e);
                });

                comp.mousedown(function(e){
                    DomEvent.stopPropagation(e);
                })

            }, this);

        },

        _isOpen:function(){
            return this.toolbar.isOpen;
        },

        showIcon:function(){
            this.itemSet.show();
        },

        hideIcon:function(){
            this.itemSet.hide();
        },

        refreshMove:function(left, right){

            var det = right - left;
            this.currentPos[0] += det;

            var x = this.currentPos[0];
            var y = this.currentPos[1];

            this.itemSet.transform('t' + x + ',' + y);
        },

        refreshMoveWithoutAnimation:function(left, right){
            this.refreshMove(left, right);
        },

        backToOrigin:function(){
            var toolbarPos = this.toolbar.getToolbarPos();
            var pos = this.toolbarIcon.getIconPos();
            var x = pos.x + toolbarPos.x;
            var y = pos.y + toolbarPos.y;
            this.currentPos = [x, y];
            this.itemSet.transform('t' + x + ',' + y);
        }
    };

    return ToolbarIconVmlRender;

});
/**
 * Created by eason on 15/8/24.
 */

define('component/ToolbarIcon',['require','./Base','../utils/BaseUtils','../Constants','../utils/ExportUtils','../render/ToolbarIconSvgRender','../render/ToolbarIconVmlRender'],function(require){

    //icon的几种状态
    var SELECTED = 'selected';
    var HOVER = 'hover';

    //icon的几种背景颜色
    var OPEN_NOMAL = 'rgba(0,0,0,0.05)';
    var OPEN_HOVER = 'rgba(0,0,0,0.1)';
    var OPEN_SELECTED = 'rgba(0,0,0,0.1)';

    var CLOSED_NORMAL = 'rgba(0,0,0,0.0)';
    var CLOSED_HOVER = 'rgba(0,0,0,0.05)';
    var CLOSED_SELECTED = 'rgba(0,0,0,0.1)';

    var RECT_R = 2;
    var ICON_SIZE = 32;
    var ICON_GAP = 1;
    var GAP = ICON_SIZE + ICON_GAP;

    var Base = require('./Base');
    var BaseUtils = require('../utils/BaseUtils');
    var Constants = require('../Constants');
    var ExportUtils = require('../utils/ExportUtils');

    var SvgRender = require('../render/ToolbarIconSvgRender');
    var VmlRender = require('../render/ToolbarIconVmlRender');

    function ToolbarIcon(iconType, toolbar, pos, visible){
        this.iconType = iconType;
        this.toolbar = toolbar;
        this.visible = visible;
        this.pos = pos;
        this.iconG = null;
        this.iconRender = BaseUtils.isSupportSVG() ? new SvgRender(this, toolbar) : new VmlRender(this, toolbar);
    }

    ToolbarIcon.prototype = {
        constructor:ToolbarIcon,

        render:function(toolBarG){
            this.iconRender.render(toolBarG);
        },

        showIcon:function(){
            if (this.visible) {
                return;
            }

            if(arguments.length){
                this.iconRender.showIcon(arguments[0], arguments[1]);
            }else{
                this.iconRender.showIcon();
            }
            this.visible = true;

            var title = this.toolbar.vanchart.getComponent(Constants.TITLE_COMPONENT);

            if (this.iconType === Constants.REFRESH_ICON) {
                title && title.changeTextRightSpace(GAP);
            }
        },

        hideIcon:function(index, delay){
            if (!this.visible) {
                return;
            }

            if(arguments.length){
                this.iconRender.hideIcon(arguments[0], arguments[1]);
            }else{
                this.iconRender.hideIcon();
            }
            this.visible = false;

            var title = this.toolbar.vanchart.getComponent(Constants.TITLE_COMPONENT);

            if (this.iconType === Constants.REFRESH_ICON) {
                title && title.changeTextRightSpace(-GAP);
            }

            if(!this.toolbar.isOpen && this.iconType == Constants.REFRESH_ICON){
                this.iconRender.backToOrigin();
            }
        },

        refreshMove:function(left, right){
            this.iconRender.refreshMove(left, right);
        },

        refreshMoveWithoutAnimation:function(left, right){
            this.iconRender.refreshMoveWithoutAnimation(left, right);
        },

        getIconPos:function(){
            return this.pos;
        },

        getMaxIconPath:function(){
            return 'M24,8v6.5L21.5,12l-3,3L17,13.5l3-3L17.5,8H24z M15,18.5l-3,3l2.5,2.5H8v-6.5l2.5,2.5l3-3L15,18.5z';
        },

        getMinIconPath:function(){
            return 'M15,17v6.5L12.5,21l-3,3L8,22.5l3-3L8.5,17H15z M24,9.5l-3,3l2.5,2.5H17V8.5l2.5,2.5l3-3L24,9.5z';
        },

        getIncreaseIconPath:function(){
            return 'M8,20h16v2H8V20z M10,16h2v3h-2V16z M13,14h2v5h-2V14z M16,12h2v7h-2V12z M19,9h2v10h-2V9z';
        },

        getDecreaseIconPath:function(){
            return 'M8,20h16v2H8V20z M10,9h2v10h-2V9z M13,12h2v7h-2V12z M16,15h2v4h-2V15z M19,16h2v3h-2V16z';
        },

        getExportIconPath:function(){
            return 'M22,8H8v16h16V10L22,8z M16,10h2v4h-2V10z M22,22H10V10h1v5h9v-5h1.171L22,10.829V22z';
        },

        getRefreshIconPath:function(){
            return 'M21.656,10.344C20.209,8.896,18.209,8,16,8c-3.43,0-6.354,2.158-7.492,5.19l1.873,0.703C11.234,11.619,13.428,10,16,10c1.657,0,3.156,0.672,4.243,1.757L18,14h6V8L21.656,10.344z M16,22c-1.657,0-3.156-0.671-4.243-1.757L14,18H8v6l2.344-2.344C11.791,23.104,13.791,24,16,24c3.43,0,6.354-2.158,7.492-5.19l-1.873-0.703C20.766,20.381,18.572,22,16,22z';
        },

        getMenuIconPath:function(){
            return 'M8,10L24,10 M8,15L24,15 M8,20L24,20';
        }

    };

    return ToolbarIcon;
});
/**
 * Created by eason on 15/7/27.
 * 工具栏组建
 */
define('component/Toolbar',['require','./Base','../utils/BaseUtils','../Constants','../utils/ExportUtils','./ToolbarIcon','../ComponentLibrary'],function(require){
    var Base = require('./Base');
    var BaseUtils = require('../utils/BaseUtils');
    var Constants = require('../Constants');
    var ExportUtils = require('../utils/ExportUtils');
    var ToolbarIcon = require('./ToolbarIcon');

    var ICON_SIZE = 32;
    var ICON_GAP = 1;
    var DEFAULT_GAP = 5;

    var Toolbar = Base.extend({
        doLayout:function(){

            var option = this.componentOption;

            if(!option.enabled || !this._needLayout){
                return;
            }

            //工具栏只需要布局一次
            this._needLayout = false;

            this.toolbarIcons = [];
            this.pos = {x:0, y:0};

            var icons = [Constants.REFRESH_ICON];
            this._registerIcons('sort', Constants.INCREASE_ICON, icons);

            //ie678不支持前台导出
            if(BaseUtils.isSupportSVG() && !BaseUtils.isIE()){
                this._registerIcons('toImage', Constants.EXPORT_ICON, icons);
            }

            this._registerIcons('fullScreen', Constants.MAX_ICON, icons);
            this._registerIcons('exitFullScreen', Constants.MIN_ICON, icons);

            if(this.componentOption.hidden){
                icons.push(Constants.MENU_ICON);
            }

            var GAP = ICON_SIZE + ICON_GAP;
            var size = icons.length * GAP + DEFAULT_GAP;

            var startX = this.vanchart.chartWidth() - size;

            this.pos = {x:startX, y:DEFAULT_GAP};
            var isOpen = !this.componentOption.hidden;
            for(var iconIndex = 0, len = icons.length; iconIndex < len; iconIndex++){
                var pos = {x:iconIndex * GAP, y:0};
                var type = icons[iconIndex];

                if(type == Constants.MENU_ICON){
                    this.menuIcon = new ToolbarIcon(type, this, pos, true);
                }else if(type == Constants.REFRESH_ICON){
                    this.refreshIcon = new ToolbarIcon(type, this, pos, false);
                }else{
                    this.toolbarIcons.push(new ToolbarIcon(type, this, pos, isOpen));
                }
            }
        },

        _registerIcons:function(iconKey, iconType, icons){
            var option = this.componentOption;
            if(option[iconKey] && option[iconKey].enabled){
                icons.push(iconType);
            }
        },

        getToolbarPos:function(){
            return this.pos;
        },

        getToolbarIcons:function(){
            return this.toolbarIcons;
        },

        getRefreshIcon:function(){
            return this.refreshIcon;
        },

        showRefreshIconWhenZoom:function(){

            if(!this.refreshIcon.visible){

                if(this.menuIcon){

                    if(this.isOpen){
                        this.refreshIcon.showIcon();
                    }else{

                        this.refreshIcon.showIcon();

                        var toolbarIcons = this.toolbarIcons;
                        var iconSize = toolbarIcons.length;

                        var refreshIcon = this.refreshIcon;

                        var left = 4 * (iconSize + 1) ;
                        var right = 4 * (iconSize + 1) + 33 * iconSize;

                        if(refreshIcon.visible){
                            refreshIcon.refreshMoveWithoutAnimation(left, right);
                        }

                    }

                }else{
                    this.refreshIcon.showIcon();
                }

                var title = this.vanchart.getComponent(Constants.TITLE_COMPONENT);

                if(title && !title.isFloat){
                    //横向平移
                    var GAP = ICON_SIZE + ICON_GAP;
                    title.changeTextRightSpace(this.refreshIcon.visible ? GAP : -GAP);
                }
            }

        },

        showOrHide:function(){
            this.isOpen ? this.render.hide() : this.render.show();

            this.isOpen = !this.isOpen;

            var GAP = ICON_SIZE + ICON_GAP;

            var width = this.toolbarIcons.length * GAP;

            if(this.isOpen){
                width = -width;
            }

            var title = this.vanchart.getComponent(Constants.TITLE_COMPONENT);

            if(title && !title.isFloat){
                //横向平移
                title.changeTextRightSpace(-width);
            }

        },

        getIconSize:function(){
            return ICON_SIZE;
        },

        getToolbarWidth:function(){
            if (!this.componentOption.enabled) {
                return 0;
            }
            //每个控件
            var GAP = ICON_SIZE + ICON_GAP;

            var width = DEFAULT_GAP;

            if(this.refreshIcon && this.refreshIcon.visible){
                width += GAP;
            }

            //不收缩的时候没有菜单
            if(this.menuIcon && this.menuIcon.visible){
                width += GAP;
            }

            if(this.isOpen){
                width += this.toolbarIcons.length * GAP;
            }

            return width;
        },

        getToolbarHeight:function(){
            return ICON_SIZE;
        }
    });

    // function (vanchart, option, componentType){
    //     Base.call(this, vanchart, option, componentType);
    //     this.menuIcon = null;
    //     this.refreshIcon = null;
    //     this.pos = {x:0, y:0};
    //     this.toolbarIcons = [];
    //     this.refresh(option);
    //     this.isOpen = !this.componentOption.hidden;
    // }
    
    require('../ComponentLibrary').register(Constants.TOOLBAR_COMPONENT, Toolbar);
    return Toolbar;
});
/**
 * Created by eason on 15/7/17.
 * 用来记录所有默认的config
 */
define('theme/config',['require','../Constants'],function(require){

    var Constants = require('../Constants');

    var config = {};

    config[Constants.PIE_CHART] = {
    };

    config[Constants.COLUMN_CHART] = {

        xAxis:{
            type:'category',
            position:'bottom',

            lineWidth:1,
            lineColor:'#cccccc',
            enableTick:true,
            enableMinorTick:true,
            showLabel:true,

            minorTickColor:'#cccccc',
            minorTickWidth:1,
            minorTickLength:2,

            tickColor:'#cccccc',
            tickWidth:1,
            tickLength:4,

            tickPadding:6,
            gridLineWidth:0,
            gridLineColor:'#cccccc',
            labelStyle:{
                color:'#666666',
                fontFamily:'Verdana',
                fontSize:'16px'
            },
            formatter:"function(){return arguments[0]}"
        },

        yAxis:{
            type:'value',
            position:'left',

            lineWidth:1,
            lineColor:'#cccccc',
            enableTick:true,
            enableMinorTick:false,
            showLabel:true,

            minorTickColor:'#cccccc',
            minorTickWidth:1,
            minorTickLength:2,

            tickColor:'#cccccc',
            tickWidth:1,
            tickLength:4,

            tickPadding:6,
            gridLineWidth:1,
            gridLineColor:'#dddddd',
            labelStyle:{
                color:'#666666',
                fontFamily:'Verdana',
                fontSize:'16px'
            },
            formatter:"function(){return arguments[0]}"
        }

    };

    config[Constants.BAR_CHART] = {

        xAxis:{
            type:'value',
            position:'bottom',

            lineWidth:1,
            lineColor:'#cccccc',
            enableTick:true,
            enableMinorTick:true,
            showLabel:true,

            minorTickColor:'#cccccc',
            minorTickWidth:1,
            minorTickLength:2,

            tickColor:'#cccccc',
            tickWidth:1,
            tickLength:4,

            tickPadding:6,
            gridLineWidth:0,
            gridLineColor:'#cccccc',
            labelStyle:{
                color:'#666666',
                fontFamily:'Verdana',
                fontSize:'16px'
            },
            formatter:"function(){return arguments[0]}"
        },

        yAxis:{
            type:'category',
            position:'left',

            lineWidth:1,
            lineColor:'#cccccc',
            enableTick:true,
            enableMinorTick:false,
            showLabel:true,

            minorTickColor:'#cccccc',
            minorTickWidth:1,
            minorTickLength:2,

            tickColor:'#cccccc',
            tickWidth:1,
            tickLength:4,

            tickPadding:6,
            gridLineWidth:1,
            gridLineColor:'#dddddd',
            labelStyle:{
                color:'#666666',
                fontFamily:'Verdana',
                fontSize:'16px'
            },
            formatter:"function(){return arguments[0]}"
        }
    };

    config[Constants.LINE_CHART] = config[Constants.AREA_CHART] = {

        xAxis:{
            type:'category',
            position:'bottom',

            lineWidth:1,
            lineColor:'#cccccc',
            enableTick:true,
            showLabel:true,

            tickColor:'#cccccc',
            tickWidth:1,
            tickLength:4,
            tickPadding:6,

            minorTickColor:'#cccccc',
            minorTickWidth:1,
            minorTickLength:2,

            gridLineWidth:0,
            gridLineColor:'#cccccc',
            labelStyle:{
                color:'#666666',
                fontFamily:'Verdana',
                fontSize:'16px'
            },
            formatter:"function(){return arguments[0]}"
        },

        yAxis:{
            type:'value',
            position:'left',

            minorTickLength:2,
            lineWidth:0,
            lineColor:'#cccccc',
            enableTick:true,
            showLabel:true,

            tickColor:'#cccccc',
            tickWidth:2,
            tickLength:4,
            tickPadding:3,

            minorTickColor:'#cccccc',
            minorTickWidth:1,

            gridLineWidth:1,
            gridLineColor:'#dddddd',
            labelStyle:{
                color:'#666666',
                fontFamily:'Verdana',
                fontSize:'16px'
            },
            formatter:function(d){return d}
        }
    };

    config[Constants.GAUGE_CHART] = {

        legend:{

            enabled:false

        },

        gaugeAxis:{
            type:'value',
            showLabel:true,
            step:1,

            enableTick:true,
            tickColor:'#BBBBBB',
            tickWidth:1,

            enableMinorTick:true,
            minorTickColor:'#e2e2e2',
            minorTickWidth:1,

            labelStyle:{
                color:'#666666',
                fontFamily:'Verdana',
                fontSize:'10px'
            }

        },

        pointer:{

            tickStyle:{
                color:'#BBBBBB',
                fontSize:'8px',
                fontFamily:'Verdana'
            },

            tickWidth:1,
            tickColor:'#666666',
            minorTickWidth:1,
            minorTickColor:'#FCFCFC',

            seriesLabel:{
                enabled:true,
                align:Constants.BOTTOM,
                useHtml:false,
                style:{
                    color:'#333333',
                    fontSize:'14px',
                    fontFamily:'Verdana'
                },
                formatter:{
                    identifier: "${CATEGORY}"
                }
            },

            valueLabel:{
                enabled:true,
                useHtml:false,
                backgroundColor:'#F5F5F7',
                style:{
                    color:'#333333',
                    fontSize:'11px',
                    fontFamily:'Verdana'
                },
                formatter:{
                    identifier: "${SERIES}${VALUE}",
                    valueFormat: d3.format('.2')
                }
            },

            needle:'#E5715A',
            hinge:'#656B6D',
            hingeBackgroundColor:'#DCF2F9',
            paneBackgroundColor:'#FCFCFC'
        },

        slot:{
            percentageLabel:{
                enabled:true,
                useHtml:false,
                style:{
                    fontSize:'36px',
                    fontFamily:'Verdana',
                    fontWeight:'bold',
                    textShadow:'0px 2px 0px rgba(0,0,0,0.08)'
                },

                formatter:{
                    identifier: "${PERCENT}",
                    percentFormat: d3.format('.2%')
                }
            },

            valueLabel:{
                enabled:true,
                useHtml:false,
                style:{
                    color:'#666666',
                    fontSize:'14px',
                    fontFamily:'Verdana'
                },
                formatter:{
                    identifier: "${CATEGORY}${VALUE}",
                    valueFormat: d3.format('.2')
                }
            },

            needle:'#ffffff',
            slotBackgroundColor:'#eeeeee'
        },

        thermometer:{

            percentageLabel:{
                enabled:true,

                useHtml:false,

                align:'left',

                style:{
                    color:'#333333',
                    fontSize:'12px',
                    fontFamily:'Verdana',
                    fontWeight:'bold'
                },

                formatter:{
                    identifier: "${PERCENT}",
                    percentFormat: d3.format('.2%')
                }
            },

            valueLabel:{
                enabled:true,

                useHtml:false,

                align:'left',

                style:{
                    color:'#bababa',
                    fontSize:'12px',
                    fontFamily:'Verdana'
                },

                formatter:{
                    identifier: "${CATEGORY}${VALUE}",
                    valueFormat: d3.format('.2')
                }

            },

            needle:'#ffffff',
            slotBackgroundColor:'#eeeeee',
            thermometerLayout:'vertical'
        },

        ring:{

            percentageLabel:{
                enabled:true,

                useHtml:false,

                style:{
                    fontSize:'24px',
                    fontFamily:'Verdana',
                    fontWeight:'bold'
                },

                formatter:{
                    identifier: "${PERCENT}",
                    percentFormat: d3.format('.2%')
                }

            },

            valueLabel:{
                enabled:true,

                useHtml:false,

                style:{
                    color:'#777777',
                    fontSize:'12px',
                    fontFamily:'Verdana'
                },

                formatter:{
                    identifier: "${CATEGORY}${VALUE}",
                    valueFormat: d3.format('.2')
                }
            },

            clockwise:false,
            paneBackgroundColor:'#eeeeee',
            innerPaneBackgroundColor:'#f4f4f4'
        }
    };

    config[Constants.RADAR_CHART] = {

        polar: {

        },

        angleAxis:{
            type:'category',

            step:1,

            lineWidth:1,

            lineColor:'#cccccc',

            showLabel:true,

            gridLineWidth:1,
            gridLineColor:'#dddddd',

            labelStyle:{
                color:'#666666',
                fontFamily:'Verdana',
                fontSize:'9pt'
            },
            formatter:"function(){return arguments[0]}"
        },

        radiusAxis:{
            type:'value',

            labelRotation:0,

            step:1,

            lineWidth:1,

            lineColor:'#cccccc',

            showLabel:true,

            gridLineWidth:1,
            gridLineColor:'#dddddd',

            formatter:"function(){return arguments[0]}",

            labelStyle:{
                color:'#666666',
                fontFamily:'Verdana',
                fontSize:'9pt'
            }
        }
    };

    config[Constants.SCATTER_CHART] = {
        legend:{
            enabled:false
        },

        xAxis:{
            type:'value',
            position:'bottom',

            lineWidth:1,
            lineColor:'#cccccc',
            enableTick:true,
            enableMinorTick:true,
            showLabel:true,

            minorTickColor:'#cccccc',
            minorTickWidth:1,
            minorTickLength:2,

            tickColor:'#cccccc',
            tickWidth:1,
            tickLength:4,

            tickPadding:6,
            gridLineWidth:0,
            gridLineColor:'#cccccc',
            labelStyle:{
                color:'#666666',
                fontFamily:'Verdana',
                fontSize:'16px'
            },
            formatter:"function(){return arguments[0]}"
        },

        yAxis:{
            type:'value',
            position:'left',

            lineWidth:1,
            lineColor:'#cccccc',
            enableTick:true,
            enableMinorTick:false,
            showLabel:true,

            minorTickColor:'#cccccc',
            minorTickWidth:1,
            minorTickLength:2,

            tickColor:'#cccccc',
            tickWidth:1,
            tickLength:4,

            tickPadding:6,
            gridLineWidth:1,
            gridLineColor:'#dddddd',
            labelStyle:{
                color:'#666666',
                fontFamily:'Verdana',
                fontSize:'16px'
            },
            formatter:"function(){return arguments[0]}"
        }

    };

    config[Constants.BUBBLE_CHART] = {
        legend:{
            enabled:false
        },
        xAxis:{
            type:'value',
            position:'bottom',

            lineWidth:1,
            lineColor:'#cccccc',
            enableTick:true,
            enableMinorTick:true,
            showLabel:true,

            minorTickColor:'#cccccc',
            minorTickWidth:1,
            minorTickLength:2,

            tickColor:'#cccccc',
            tickWidth:1,
            tickLength:4,

            tickPadding:6,
            gridLineWidth:0,
            gridLineColor:'#cccccc',
            labelStyle:{
                color:'#666666',
                fontFamily:'Verdana',
                fontSize:'16px'
            },
            formatter:"function(){return arguments[0]}"
        },

        yAxis:{
            type:'value',
            position:'left',

            lineWidth:1,
            lineColor:'#cccccc',
            enableTick:true,
            enableMinorTick:false,
            showLabel:true,

            minorTickColor:'#cccccc',
            minorTickWidth:1,
            minorTickLength:2,

            tickColor:'#cccccc',
            tickWidth:1,
            tickLength:4,

            tickPadding:6,
            gridLineWidth:1,
            gridLineColor:'#dddddd',
            labelStyle:{
                color:'#666666',
                fontFamily:'Verdana',
                fontSize:'16px'
            },
            formatter:"function(){return arguments[0]}"
        }
    };

    config[Constants.MAP_CHART] = {
        legend:{
            enabled:true
        }

    };


    return config;
});
/**
 * Created by eason on 15/10/12.
 */

define('render/ZoomBarRender',['require','./BaseRender','../utils/BaseUtils','../Constants','../theme/config','./RenderLibrary'],function(require){

    var BaseRender = require('./BaseRender');
    var BaseUtils = require('../utils/BaseUtils');
    var Constants = require('../Constants');

    var ZoomBarRender = BaseRender.extend({
        render:function(){

            if(!this.component.zoomToolEnabled() || this._zoomG){
                return ;
            }

            var bounds = this.component.bounds;
            var svgRoot = this.component.getVanchartRender().getRenderRoot();

            this._zoomG = svgRoot
                .append('g')
                .attr('transform', 'translate(' + bounds.x + ',' + bounds.y + ')');

            this._initUnitLength();

            var startX = this.component.getStartX();
            var endX = this.component.getEndX();

            this._zoomG.append('g')
                .call(this._createLines.bind(this));

            this.leftRect = this._zoomG.append('g').call(this._createSideRect.bind(this), startX, true);

            this.rightRect = this._zoomG.append('g').call(this._createSideRect.bind(this), endX, false);

            this.innerRect = this._zoomG.append('g').call(this._createInnerRect.bind(this), startX, endX);

            this.leftButton = this._zoomG.append('g').call(this._createButton.bind(this), startX, true);

            this.rightButton = this._zoomG.append('g').call(this._createButton.bind(this), endX, false);

            var buttonWidth = this.component.getZoomBarWidth();
            var height = this.component.getZoomBarHeight();

            this.l_bounds = {
                x:startX,
                y:0,
                width:buttonWidth,
                height:height
            };

            this.r_bounds = {
                x:endX - buttonWidth,
                y:0,
                width:buttonWidth,
                height:height
            };

            this.c_bounds = {
                x:startX + buttonWidth,
                y:0,
                width:endX - startX - 2*buttonWidth,
                height:height
            };

            this._addEventListeners(svgRoot);
        },

        remove:function(){
            if(this._zoomG){
                this._zoomG.remove();
                this._zoomG = null;
            }
        },

        _initUnitLength:function(){
            var axis = this.component.vanchart.xAxis();

            if(axis.type == Constants.CATEGORY_AXIS_COMPONENT){
                var bounds = this.component.bounds;
                var categories = axis.getCategories();
                this.unitLength = categories.length ? bounds.width/categories.length : bounds.width;
            }else{
                this.unitLength = 1;
            }
        },

        _addEventListeners:function(svgRoot){

            var self = this;

            svgRoot
                .on('mousedown.zoom', function(){

                    var downPos = d3.mouse(self._zoomG.node());

                    if(BaseUtils.containsPoint(self.l_bounds, downPos)){
                        this.tartget = self.leftButton;
                    }else if(BaseUtils.containsPoint(self.r_bounds, downPos)){
                        this.tartget = self.rightButton;
                    }else if(BaseUtils.containsPoint(self.c_bounds, downPos)){
                        this.tartget = self.innerRect;
                    }

                    if(this.tartget){
                        this.downX = downPos[0];
                        this.initX = d3.transform(this.tartget.attr('transform')).translate[0];
                        self._zoomG.style('cursor', 'ew-resize');
                        self._initStartEndIndex();
                    }
                })
                .on('mousemove.zoom', function(){

                    if(this.tartget){

                        var component = this.tartget.attr('class');

                        switch (component){

                            case Constants.LEFT:
                                if(self.component.resizable()){
                                    self._leftButtonMove(this.downX, this.initX);
                                }
                                break;

                            case Constants.RIGHT:
                                if(self.component.resizable()){
                                    self._rightButtonMove(this.downX, this.initX);
                                }
                                break;

                            case Constants.CENTER:
                                self._centerRectMove(this.downX);
                                break;
                        };

                        self._zoomRefresh();
                    }

                })
                .on('mouseup.zoom', function(){

                    if(this.tartget){
                        this.tartget = null;
                        self._updateBounds();

                        var axis = self.component.vanchart.xAxis();
                        if(axis){
                            axis.render.render();
                        }

                    }

                });

        },

        _leftButtonMove:function(downX, initX){

            var barWidth = this.component.getZoomBarWidth();

            var minTransX = 0;

            var maxTransX = d3.transform(this.rightButton.attr('transform')).translate[0] - barWidth;

            var currentX = d3.mouse(this._zoomG.node())[0];

            var transX = initX + currentX - downX;

            transX = Math.max(Math.min(transX, maxTransX), minTransX);

            this.leftButton.attr('transform', 'translate(' + transX + ',0)');
            this.leftRect.select('rect').attr('width', transX);

            this.innerRect.selectAll('line').attr('x1', transX + barWidth);
            this.innerRect.select('rect')
                .attr('x', transX + barWidth)
                .attr('width', maxTransX - transX);
        },

        _rightButtonMove:function(downX, initX){
            var barWidth = this.component.getZoomBarWidth();

            var minTransX = d3.transform(this.leftButton.attr('transform')).translate[0] + barWidth;

            var maxTransX = this.component.getBoundsEndX() - barWidth;

            var currentX = d3.mouse(this._zoomG.node())[0];

            var transX = initX + currentX - downX;

            transX = Math.max(Math.min(transX, maxTransX), minTransX);

            this.rightButton.attr('transform', 'translate(' + transX + ',0)');
            this.rightRect.select('rect')
                .attr('x', transX + barWidth)
                .attr('width', this.component.getBoundsEndX() - (transX + barWidth));

            this.innerRect.selectAll('line').attr('x2', transX);
            this.innerRect.select('rect').attr('width', transX - minTransX);
        },

        _centerRectMove:function(downX){

            var endX = this.component.getBoundsEndX();
            var barWidth = this.component.getZoomBarWidth();

            var currentX = d3.mouse(this._zoomG.node())[0];


            var detX = currentX - downX;

            if(this.l_bounds.x + detX >=0 && this.r_bounds.x + this.r_bounds.width + detX <= endX){

                var l_transX = this.l_bounds.x + detX;

                this.leftButton.attr('transform', 'translate(' + l_transX + ',0)');

                this.leftRect.select('rect').attr('width', l_transX);

                var r_transX = this.r_bounds.x + detX;
                this.rightButton.attr('transform', 'translate(' + r_transX + ',0)');
                this.rightRect.select('rect')
                    .attr('x', r_transX + barWidth)
                    .attr('width', this.component.getBoundsEndX() - (r_transX + barWidth));


                this.innerRect.selectAll('line')
                    .attr('x1', l_transX + barWidth)
                    .attr('x2', r_transX);

                this.innerRect.select('rect')
                    .attr('x', l_transX + barWidth)
            }
        },

        _initStartEndIndex:function(){
            var l_transX = d3.transform(this.leftButton.attr('transform')).translate[0];
            var r_transX = d3.transform(this.rightButton.attr('transform')).translate[0];

            this.initStart = this._getIndexByPosition(l_transX);
            this.initEnd = this._getIndexByPosition(r_transX);
        },

        _getIndexByPosition:function(x){

            var axis = this.component.vanchart.xAxis();

            switch (axis.type) {
                case Constants.CATEGORY_AXIS_COMPONENT:
                    var categories = axis.getCategories();
                    return axis.isAxisReversed() ? categories.length - 1 - Math.floor(x/this.unitLength) : Math.floor(x/this.unitLength);
                case Constants.DATE_AXIS_COMPONENT:
                    return BaseUtils.date2int(this.xScale.invert(x));
                default:
                    return this.xScale.invert(x);
            }
        },

        _zoomRefresh:function(){

            var l_transX = d3.transform(this.leftButton.attr('transform')).translate[0];
            var r_transX = d3.transform(this.rightButton.attr('transform')).translate[0];

            var startIndex = this._getIndexByPosition(l_transX);
            var endIndex = this._getIndexByPosition(r_transX);

            if(this.initStart != startIndex || this.initEnd != endIndex){

                var axis = this.component.vanchart.xAxis();

                axis.updateAxisScale(Math.min(startIndex, endIndex), Math.max(startIndex, endIndex), true);

                var vanchart = this.component.vanchart;
                vanchart.currentOption.state = Constants.STATE_ZOOM_REFRESH;

                vanchart.layoutComponentsAndCharts();

                this.initStart = startIndex;
                this.initEnd = endIndex;
            }

        },

        _updateBounds:function(){

            var l_transX = d3.transform(this.leftButton.attr('transform')).translate[0];
            var r_transX = d3.transform(this.rightButton.attr('transform')).translate[0];

            var barWidth = this.component.getZoomBarWidth();

            this.l_bounds.x = l_transX;
            this.r_bounds.x = r_transX;

            this.c_bounds.x = l_transX + barWidth;
            this.c_bounds.width = r_transX - l_transX - barWidth;
        },

        _createSideRect:function(g, startX, isLeft){

            var barHeight = this.component.getZoomBarHeight();

            var x, width;

            if(isLeft){
                x = 0;
                width = startX;
            }else{
                x = startX;
                width = this.component.bounds.width - startX;
            }

            g.append('rect')
                .attr('x', x)
                .attr('y', 0)
                .attr('width', width)
                .attr('height', barHeight)
                .style('fill', 'rgba(220,221,221,0.4)');

        },

        _createInnerRect:function(g, startX, endX){

            var barWidth = this.component.getZoomBarWidth();
            var barHeight = this.component.getZoomBarHeight();

            g.attr('class', Constants.CENTER);

            g.append('rect')
                .attr('x', startX + barWidth)
                .attr('y', 0)
                .attr('width', endX - startX - 2 * barWidth)
                .attr('height', barHeight)
                .style('fill', 'rgba(255,255,255,0)');

            g.append('line')
                .attr('x1', startX + barWidth)
                .attr('y1', 0)
                .attr('x2', endX - barWidth)
                .attr('y2', 0);

            g.append('line')
                .attr('x1', startX + barWidth)
                .attr('y1', barHeight)
                .attr('x2', endX - barWidth)
                .attr('y2', barHeight);

            g.selectAll('line')
                .style({
                    fill:'none',
                    stroke:'#29ABE2',
                    'stroke-width':1
                });

        },

        //缩放底边上的线
        _createLines:function(g){

            var config = require('../theme/config');

            var bounds = this.component.bounds;

            var axis = this.component.vanchart.xAxis();

            this.xScale = this.component._getAxisScale();

            var xScale = this.xScale;

            var series = this.component.option.series;
            var chartType = this.component.option.chartType;
            var usedSeries = [];
            series.forEach(function(sery){
                if(!sery.xAxis && config[sery.type || chartType].xAxis){
                    usedSeries.push(sery);
                }
            });

            var lines = [];

            var minValueY = Number.MAX_VALUE;
            var maxValueY = Number.MIN_VALUE;

            usedSeries.forEach(function(sery){

                var points = [];

                lines.push(points);

                var dCount = sery.data.length;

                for (var dIndex = 0; dIndex < dCount; dIndex++) {
                    var datum = sery.data[dIndex];
                    var point = {
                        x:axis.getValueFromData(datum),
                        y:BaseUtils.pick(datum.y, datum)
                    };

                    if(isNaN(+point.y)){
                        continue;
                    }

                    points.push(point);

                    minValueY = Math.min(minValueY, point.y);
                    maxValueY = Math.max(maxValueY, point.y);
                }
            });

            minValueY = minValueY >= 0 ? 0 : minValueY;

            var det = xScale.rangeBand ? xScale.rangeBand()/2 : 0;

            var yScale = d3.scale.linear().domain([minValueY, maxValueY]).range([bounds.height, 0]);

            lines.forEach(function(points){

                points.forEach(function(point){
                    point.x = xScale(point.x) + det;
                    point.y = yScale(point.y);
                })

            });

            lines.forEach(function(points){

                points.sort(function(a, b){
                    return a.x - b.x;
                })

            });

            var lineSvg = d3.svg.line()
                .interpolate("linear")
                .x(function (d) { return d.x; })
                .y(function (d) { return d.y; });

            g.selectAll('path')
                .data(lines)
                .enter()
                .append('path')
                .attr('d', function(points){
                    return lineSvg(points);
                })
                .style({
                    fill:'none',
                    stroke:'black',
                    'stroke-width':1
                });
        },

        _createButton:function(g, startX, isLeft){

            startX = isLeft ? startX : startX - this.component.getZoomBarWidth();

            g.attr('transform', 'translate(' + startX + ',' + '0)')
                .attr('class', isLeft ? Constants.LEFT : Constants.RIGHT);

            g.append('path')
                .attr('d', isLeft ? 'M4,30h6V0L4,0C1.791,0,0,1.791,0,4v22C0,28.209,1.791,30,4,30z' : 'M6,30H0V0h6c2.209,0,4,1.791,4,4v22C10,28.209,8.209,30,6,30z')
                .style('fill', '#29ABE2');

            g.append('line')
                .attr('x1', 3)
                .attr('y1', 11)
                .attr('x2', 3)
                .attr('y2', 18);

            g.append('line')
                .attr('x1', 7)
                .attr('y1', 11)
                .attr('x2', 7)
                .attr('y2', 18);

            g.selectAll('line')
                .style({
                    fill: '#FFFFFF',
                    stroke: '#7ADAF4',
                    'stroke-width': 2,
                    'stroke-linecap': 'round',
                    'stroke-linejoin': 'round',
                    'stroke-miterlimit': 10
                });
        }
    });

    require('./RenderLibrary').register(Constants.ZOOM_SVG, ZoomBarRender);
});
/**
 * Created by eason on 15/10/12.
 */
define('component/ZoomBar',['require','../render/ZoomBarRender','./Base','../utils/BaseUtils','../Constants','../ComponentLibrary'],function(require){

    require('../render/ZoomBarRender');

    var Base = require('./Base');
    var BaseUtils = require('../utils/BaseUtils');
    var Constants = require('../Constants');

    //缩放控件默认的高度
    var HEIGHT = 30;
    var WIDTH = 10;

    var ZoomBar = Base.extend({
        doLayout:function(){

            if(this.zoomToolEnabled()){
                this._setComponentBounds(Constants.BOTTOM, HEIGHT);
            }

        },

        fixBoundsByPlot:function(){

            var plotBounds = this.vanchart.getPlotBounds();

            var zoomY = plotBounds.y + plotBounds.height;

            var xAxisComponent = this.vanchart.getComponent(Constants.X_AXIS_COMPONENT);

            if(xAxisComponent && xAxisComponent._axisList.length){
                xAxisComponent._axisList.forEach(function(axis){

                    if(axis.getPosition() == Constants.BOTTOM){

                        zoomY = Math.max(zoomY, axis.bounds.y + axis.bounds.height);
                    }

                })
            }

            this.bounds = BaseUtils.makeBounds(plotBounds.x, zoomY, plotBounds.width, HEIGHT);
        },

        // ensure they are within the axis
        getRevisedDomain: function () {
            var revisedDomain = {
                from: this.componentOption.zoomTool.from,
                to: this.componentOption.zoomTool.to
            };

            var axis = this.vanchart.xAxis();
            if (axis.type === Constants.VALUE_AXIS_COMPONENT ||
                axis.type === Constants.DATE_AXIS_COMPONENT) {

                var tmp = [this.componentOption.zoomTool.from, this.componentOption.zoomTool.to];

                if (axis.type === Constants.DATE_AXIS_COMPONENT) {
                    tmp[0] = BaseUtils.date2int(tmp[0]);
                    tmp[1] = BaseUtils.date2int(tmp[1]);
                }

                revisedDomain.from = Math.min.apply(null, tmp);
                revisedDomain.to = Math.max.apply(null, tmp);

                var axisDomain = axis.getOriginalDomain();

                revisedDomain.from =
                    Math.max(revisedDomain.from, axisDomain.minValue);
                revisedDomain.to =
                    Math.min(revisedDomain.to, axisDomain.maxValue);
            }

            return revisedDomain;
        },

        zoomToolEnabled:function(){
            var axis = this.option.xAxis;
            if(axis){
                axis = axis[0] || axis;
            }

            return this.componentOption
                && this.componentOption.zoomTool
                && this.componentOption.zoomTool.visible
                && !this.option.dataSheet
                && !this.option.plotOptions.force
                && axis;
        },

        resizable:function(){

            return this.componentOption
                && this.componentOption.zoomTool
                && this.componentOption.zoomTool.resize;

        },

        getZoomBarWidth:function(){
            return WIDTH;
        },

        getZoomBarHeight:function(){
            return HEIGHT;
        },

        _getAxisScale:function(){

            var axis = this.vanchart.xAxis();

            var scale = axis.scale.copy();

            if (axis.type == Constants.CATEGORY_AXIS_COMPONENT) {
                scale.rangeBand ? scale.rangeBands(axis._getRange()) : scale.range(axis._getRange());
            } else {
                var domain = axis.getOriginalDomain();
                scale.domain([domain.minValue, domain.maxValue]);
            }
            return scale;

        },

        getStartX:function(){
            var revisedDomain = this.getRevisedDomain();
            var startX = 0;

            var scale = this._getAxisScale();

            if(revisedDomain.from && !revisedDomain.to){
                startX = scale(revisedDomain.from);
                startX = isNaN(startX) ? 0 : startX;
            }else if(revisedDomain.from && revisedDomain.to){
                return this._getMinX();
            }

            return startX;
        },

        getEndX:function(){

            var revisedDomain = this.getRevisedDomain();
            var endX = this.bounds.width;
            var scale = this._getAxisScale();

            if(revisedDomain.to && !revisedDomain.from){
                endX = scale(revisedDomain.to) + (scale.rangeBand ? scale.rangeBand() : 0);
                endX = isNaN(endX) ? this.bounds.width : endX;
            }else if(revisedDomain.to && revisedDomain.from){
                return this._getMaxX();
            }

            return endX;
        },

        _getMinX:function(){
            var revisedDomain = this.getRevisedDomain();

            if(revisedDomain.from && revisedDomain.to){

                var scale = this._getAxisScale();

                var x1 = scale(revisedDomain.from);
                var x2 = scale(revisedDomain.to);

                var result = Math.min(x1, x2);

                return isNaN(result) ? 0 : result;
            }
        },

        _getMaxX:function(){
            var revisedDomain = this.getRevisedDomain();

            if(revisedDomain.from && revisedDomain.to){

                var scale = this._getAxisScale();

                var x1 = scale(revisedDomain.from);
                var x2 = scale(revisedDomain.to);

                var result = Math.max(x1, x2) + (scale.rangeBand ? scale.rangeBand() : 0);

                return  isNaN(result) ?  this.bounds.width : result;
            }
        },

        getBoundsEndX:function(){
            return this.bounds.width;
        }
    });
    
    require('../ComponentLibrary').register(Constants.ZOOM_COMPONENT, ZoomBar);
    return ZoomBar;

});
/**
 * Created by eason on 15/5/4.
 * 数据表
 */
define('component/DataSheet',['require','./Base','../utils/BaseUtils','../utils/Formatter','../Constants','../render/LegendIconFactory','../ComponentLibrary'],function(require){

    var Base = require('./Base');
    var BaseUtils = require('../utils/BaseUtils');
    var Formatter = require('../utils/Formatter');
    var Constants = require('../Constants');
    var LegendIconFactory = require('../render/LegendIconFactory');

    var PADDING_GAP = 4;
    var ICON_GAP = 2;
    var MAX_ICON_SIZE = 18;

    var STYLE = { color : "#666666", fontSize: "14px", fontFamily:"Verdana"};

    var DataSheet = Base.extend({

        /**
         *数据表的对象要先于坐标轴存在，但是大小需要最后确定
         */
        doLayout:function(){

            this.remove();

            var plotBounds = this.vanchart.getPlotBounds();
            var leftDet =  Math.round(this.getSeriesNameLength());
            this._clipPlotBounds(Constants.LEFT, Math.max(leftDet - plotBounds.x, 0));

            this._setComponentBounds(Constants.BOTTOM, this.getDataSheetHeight());
        },

        fixBoundsByPlot:function() {

            var plotBounds = this.vanchart.getPlotBounds();

            this.bounds = {
                x: plotBounds.x - this.maxSeriesWidth,
                y: plotBounds.y + plotBounds.height,
                width: this.maxSeriesWidth + plotBounds.width,
                height: this.sheetHeight
            };

        },
        //最长的系列名
        getSeriesNameLength:function(){

            this.seriesNames = [];
            this.maxSeriesLine = [];

            var series = this.option.series;

            var style = this._seriesStyle();

            var limitedWidth = this.vanchart.getChartBounds().width / 4 - (MAX_ICON_SIZE + ICON_GAP * 2);

            var maxWidth = 0;

            var iconSize = 0;

            for(var sIndex = 0, sCount = series.length; sIndex < sCount; sIndex++){
                this.maxSeriesLine[sIndex] = 0;

                var sery = series[sIndex];
                var width = BaseUtils.getTextDimension(sery.name, style, false).width + PADDING_GAP * 2;

                if(width > limitedWidth){

                    var s_names = BaseUtils.splitText(sery.name, style, limitedWidth, PADDING_GAP);

                    this.maxSeriesLine[sIndex] = s_names.length;

                    this.seriesNames.push(s_names);

                    maxWidth = limitedWidth;
                }else{
                    this.maxSeriesLine[sIndex] = 1;

                    this.seriesNames.push([sery.name]);

                    maxWidth = Math.max(width, maxWidth);
                }

                var iconType = this.getLegendIconTypeWithSeriesIndex(sIndex);

                iconSize = Math.max(iconSize, LegendIconFactory.getLegendIconSize(iconType).width);
            }

            this.maxSeriesWidth = Math.ceil(maxWidth + ICON_GAP * 2 + iconSize);

            return  this.maxSeriesWidth + PADDING_GAP;
        },

        getLegendIconTypeWithSeriesIndex: function (index) {
            return this._getLegendType(this.vanchart.series[index]);
        },

        getDataSheetHeight:function(){

            this.maxCateLine = 0;
            this.categoryNames = [];
            this.values = [];
            this.maxValueLine = [];

            var axis = this.vanchart.xAxis();

            var categories = axis.getCategories();

            if(axis.isAxisReversed()){
                categories = BaseUtils.clone(categories).reverse();
            }

            var cateStyle = this._categoryStyle();

            var unitLength = this.vanchart.getPlotBounds().width / categories.length;

            var self = this;

            categories.forEach(function(category){

                var sCateName = BaseUtils.splitText(category, cateStyle, unitLength, PADDING_GAP);

                self.maxCateLine = Math.max(self.maxCateLine, sCateName.length);

                self.categoryNames.push(sCateName);

            });

            var valueStyle = this._valueStyle();
            var format = this.componentOption.formatter;

            var series = this.vanchart.series;

            for(var sIndex = 0, sCount = series.length; sIndex < sCount; sIndex++){
                var seryValue = [];
                this.values.push(seryValue);

                this.maxValueLine[sIndex] = 0;

                var sery = series[sIndex];
                var points = sery.originalPoints || sery.points;
                for(var dIndex = 0, len = points.length; dIndex < len; dIndex++){
                    var point = points[dIndex];
                    var value = point.value;

                    var f_value = point.isNull ? '-' : this._getTickContent(value, format);
                    var sValue = BaseUtils.splitText(f_value, valueStyle, unitLength, PADDING_GAP);

                    seryValue[BaseUtils.indexInArray(categories, point.category)] = sValue;

                    this.maxValueLine[sIndex] = Math.max(this.maxValueLine[sIndex], sValue.length);
                }
            }


            //开始计算高度
            var cateHeight = this.getCategoryHeight();

            var valueHeight = 0;

            for(var sIndex = 0, sCount = series.length; sIndex < sCount; sIndex++){
                valueHeight += this.getSeriesHeight(sIndex);
            }

            this.sheetHeight = Math.ceil(cateHeight + valueHeight);

            return this.sheetHeight
        },

        _categoryStyle:function(){
            return this.option.xAxis.labelStyle || this.option.xAxis[0].labelStyle || STYLE;
        },

        _seriesStyle:function(){
            return this.option.legend ? this.option.legend.style : STYLE;
        },

        _valueStyle:function(){
            return this.componentOption.style;
        },

        getCategoryHeight:function(){

            var cateStyle = this._categoryStyle();

            return PADDING_GAP * 2
                + this.maxCateLine * BaseUtils.getTextHeight(cateStyle)
                + (this.maxCateLine - 1) * PADDING_GAP

        },

        getSeriesHeight:function(sIndex){

            var seriesLineHeight = BaseUtils.getTextHeight(this._seriesStyle());
            var valueLineHeight = BaseUtils.getTextHeight(this._valueStyle());

            var s_count = this.maxSeriesLine[sIndex];
            var s_height = PADDING_GAP * 2 + s_count * seriesLineHeight + (s_count - 1) * PADDING_GAP;

            var v_count = this.maxValueLine[sIndex];
            var v_height = PADDING_GAP * 2 + v_count * valueLineHeight + (v_count - 1) * PADDING_GAP;

            return Math.max(s_height, v_height);
        },

        getMaxSeriesWidth:function(){
            return this.maxSeriesWidth;
        },

        getTextPadding:function(){
            return PADDING_GAP;
        }
    });

    require('../ComponentLibrary').register(Constants.DATA_SHEET_COMPONENT, DataSheet);
    return DataSheet;
});
/**
 * Created by Mitisky on 16/3/21.
 */
define ('component/RangeLegend',['require','./Base','../utils/BaseUtils','../Constants','../utils/ColorUtils','../utils/QueryUtils','../utils/Formatter','../ComponentLibrary'],function(require){
    var Base = require('./Base');
    var BaseUtils = require('../utils/BaseUtils');
    var Constants = require('../Constants');
    var ColorUtils = require('../utils/ColorUtils');
    var QueryUtils = require('../utils/QueryUtils');
    var Formatter = require('../utils/Formatter');

    var PADDING = 10;

    var WIDTH = 15;
    var HEIGHT = 100;
    var BAR_WIDTH = 15;
    var BAR_HEIGHT = 10;
    var BAR_TEXT_GAP = 5;
    var ITEM_WIDTH = 25;
    var ITEM_GAP = 2;

    var RangeLegend = Base.extend({
        doLayout: function () {

            if(this.isIntervalLegend){
                this._setItemsPoints();
            }

            //占用绘图区的宽或者高或者没有
            var usedSize = this._calculateUsedSize();
            this._setComponentBounds(this.componentOption.position || Constants.RIGHT_TOP, usedSize);

            this._calculateRangeLegendFinalBounds(usedSize);
        },

        _refresh: function () {
            this._mergeAttr();
        },

        _mergeAttr: function () {
            if(this.vanchart.isZoomRefreshState()){
                return;
            }
            var range = this.componentOption.range;
            var self = this;

            this.isIntervalLegend = BaseUtils.isArray(range);

            if(this.isIntervalLegend) {
                var hiddenColor = this.componentOption.hiddenColor;
                var hoverColor = this.componentOption.hoverColor;
                var formatter = this.componentOption.formatter;
                this.items = [];
                range.forEach(function(band){
                    var label = self._getIntervalLabelContent(band.from, band.to, formatter);
                    self.items.push(
                        {
                            from: band.from,
                            to: band.to,
                            color: band.color,
                            label: label,
                            points: [],
                            visible: true,
                            hiddenColor: hiddenColor,
                            hoverColor: hoverColor
                        }
                    )
                });

                this.items.sort(function (itemA, itemB) {
                    var itemAMin = Math.min(itemA.from, itemA.to);
                    var itemBMin = Math.min(itemB.from, itemB.to);
                    return self.isHorizontal() ? itemAMin - itemBMin : itemBMin - itemAMin;
                });

            } else {
                this.min = BaseUtils.pick(range.min, 0);
                this.max = BaseUtils.pick(range.max, 100);
                this.valueAndColors = range.color;
                this.valueAndColors.sort(function(d1, d2){
                    return d1[0] - d2[0];
                });
                var valueArray = [];
                var colorArray = [];
                for(var i = 0, len = this.valueAndColors.length; i < len; i ++ ){
                    valueArray[i] = this.valueAndColors[i][0];
                    colorArray[i] = this.valueAndColors[i][1];
                }

                this.valueScale = d3.scale.linear()
                    .domain([this.min, this.max])
                    .range([0, 1]);

                this.colorScale = d3.scale.linear()
                    .domain(valueArray)
                    .range(colorArray);
            }
        },

        _getIntervalLabelContent:function(from, to, formatter){
            if(!formatter){
                return from + '-' + to;
            }

            return Formatter.format({'from':from,'to':to}, formatter);
        },

        _getGradientMinLabelContent: function () {
            return this._getGradientLabelWithFormatter(this.min);
        },

        _getGradientMaxLabelContent: function () {
            return this._getGradientLabelWithFormatter(this.max);
        },

        _getGradientLabelWithFormatter: function (value) {
            var formatter = this.componentOption.formatter;
            if(!formatter){
                return value;
            }

            return Formatter.format(value, formatter);
        },

        getValueAndColors: function () {
            return this.valueAndColors;
        },

        getGradientLabelContent: function (value) {
            return this._getGradientLabelWithFormatter(this._gradientScale(value));
        },

        _gradientScale: function (value) {
            var unit = BaseUtils.accDiv(BaseUtils.accAdd(this.max, -this.min), HEIGHT);
            value = BaseUtils.accMul(unit, this.isHorizontal() ? value : (HEIGHT - value));
            value = BaseUtils.accAdd(value, this.min);
            return value;
        },

        getColorWithSize: function (size) {
            if(this.isIntervalLegend){
                var item = this._getPointItem(size);
                if(item) {
                    return item.color;
                } else {
                    return null;
                }
            } else {
                if (size >= this.min && size <= this.max) {
                    return this.colorScale(this.valueScale(size));
                } else {
                    return null;
                }
            }
        },

        _setItemsPoints: function () {
            var self = this;
            var seriesS = this.vanchart.series;
            seriesS.forEach(function (sery) {
                var pointS = sery.points;
                pointS.forEach(function (point) {
                    var size = point.size;
                    var item = self._getPointItem(size);
                    if(item) {
                        item.points.push(point);
                    }
                })
            })
        },

        _getPointItem:function(size){
            for(var i = 0, len = this.items.length; i < len; i++){
                var item = this.items[i];
                var min = Math.min(item.from, item.to);
                var max = Math.max(item.from, item.to);

                if(size >= min && size <= max){
                    return item;
                }
            }
        },

        _calculateUsedSize: function () {
            var cfg = this.componentOption;
            var position = cfg.position || Constants.RIGHT;
            var size = PADDING * 4;

            if(position == Constants.TOP || position == Constants.BOTTOM){

                var maxLimitSize = this._maxHeight();

                size += this.isIntervalLegend ? this._calculateIntervalTopAndBottomSize()
                    : this._calculateGradientTopAndBottomSize();


                return cfg.maxHeight ? Math.min(size, maxLimitSize) : size;

            }else{
                var maxLimitSize = this._maxWidth();

                size += this.isIntervalLegend ? this._calculateIntervalLeftAndRightSize()
                    : this._calculateGradientLeftAndRightSize();

                return cfg.maxWidth ? Math.min(size, maxLimitSize) : size;
            }
        },

        _calculateGradientTopAndBottomSize: function () {
            var height = WIDTH + BAR_WIDTH + BAR_TEXT_GAP;
            var d = BaseUtils.getTextDimension(this._getGradientMinLabelContent(), this.componentOption.style);
            return height + d.height;
        },

        _calculateGradientLeftAndRightSize: function () {
            var width = WIDTH + BAR_WIDTH + BAR_TEXT_GAP;
            var d1 = BaseUtils.getTextDimension(this._getGradientMinLabelContent(), this.componentOption.style);
            var d2 = BaseUtils.getTextDimension(this._getGradientMaxLabelContent(), this.componentOption.style);
            return width + Math.max(d1.width, d2.width);
        },

        _calculateIntervalTopAndBottomSize: function () {
            var height = WIDTH + BAR_TEXT_GAP * 2;
            var d = BaseUtils.getTextDimension("0", this.componentOption.style);
            return height + d.height * 2;
        },

        _calculateIntervalLeftAndRightSize : function () {
            var width = 0;
            var style = this.componentOption.style;
            this.items.forEach(function (item) {
                var labelDim = BaseUtils.getTextDimension(item.label, style);
                width = Math.max(width, labelDim.width);
            });
            return width + WIDTH + BAR_TEXT_GAP;
        },

        _calculateRangeLegendFinalBounds: function () {
            var cfg = this.componentOption;
            var position = cfg.position || Constants.RIGHT;

            var temp = PADDING * 2;

            if(position == Constants.TOP || position == Constants.BOTTOM){
                temp += this.isIntervalLegend ? this._calculateIntervalTopAndBottomFinalSize()
                    : this._calculateGradientTopAndBottomFinalSize();
                temp = Math.max(this.bounds.width - temp, 0);
                this.bounds.x += temp/2;
                this.bounds.width -= temp;
            }else if(position == Constants.LEFT || position == Constants.RIGHT){
                temp += this.isIntervalLegend ? this._calculateIntervalLeftAndRightFinalSize()
                    : this._calculateGradientLeftAndRightFinalSize();
                temp = Math.max(this.bounds.height - temp, 0);
                this.bounds.y += temp/2;
                this.bounds.height -= temp;
            } else if(position == Constants.RIGHT_TOP) {
                temp += this.isIntervalLegend ? this._calculateIntervalLeftAndRightFinalSize()
                    : this._calculateGradientLeftAndRightFinalSize();
                this.bounds.height = temp;
            }

            if(!this.isFloat){
                var gap = this.componentOption.borderWidth + PADDING * 2;
                this.bounds.x += gap/2;
                this.bounds.y += gap/2;
                this.bounds.width -= gap;
                this.bounds.height -= gap;

                if(position == Constants.BOTTOM) {
                    var zoomComponent = this.vanchart.getComponent(Constants.ZOOM_COMPONENT);
                    if (zoomComponent && zoomComponent.zoomToolEnabled()) {
                        this.bounds.y += zoomComponent.bounds.height;
                    }
                }

                if(position == Constants.RIGHT || position == Constants.RIGHT_TOP){
                    var toolbarHeight = this.vanchart.getToolbarHeight();
                    this.bounds.y += toolbarHeight;
                    this.bounds.height -= toolbarHeight;
                }
            }
        },

        _calculateGradientTopAndBottomFinalSize: function() {
            var d1 = BaseUtils.getTextDimension(this._getGradientMinLabelContent(), this.componentOption.style);
            var d2 = BaseUtils.getTextDimension(this._getGradientMaxLabelContent(), this.componentOption.style);
            var gap = Math.max(d1.width, d2.width, BAR_HEIGHT);
            return HEIGHT + gap * 2;
        },

        _calculateGradientLeftAndRightFinalSize: function () {
            var d = BaseUtils.getTextDimension(this._getGradientMinLabelContent(), this.componentOption.style);
            var gap = Math.max(d.height/2, BAR_HEIGHT/2);
            gap *= 2;
            return HEIGHT + gap * 2;
        },

        _calculateIntervalTopAndBottomFinalSize: function () {
            var len = this.items.length;
            if(len > 0){
                var d1 = BaseUtils.getTextDimension(this.items[0].label, this.componentOption.style);
                var d2 = BaseUtils.getTextDimension(this.items[len - 1].label, this.componentOption.style);
                var gap = Math.max(0, d1.width - ITEM_WIDTH, d2.width - ITEM_WIDTH);
                return len * ITEM_WIDTH + (len - 1) * ITEM_GAP + gap;
            }
            return 0;
        },

        _calculateIntervalLeftAndRightFinalSize: function () {
            var len = this.items.length;
            if(len > 0){
                var d1 = BaseUtils.getTextDimension(this.items[0].label, this.componentOption.style);
                var d2 = BaseUtils.getTextDimension(this.items[len - 1].label, this.componentOption.style);
                var gap = Math.max(0, d1.height - ITEM_WIDTH, d2.height - ITEM_WIDTH);
                return len * ITEM_WIDTH + (len - 1) * ITEM_GAP + gap;
            }
            return 0;
        },

        getTopBarPath: function () {
            return 'M7.236,10H13c1.105,0,2-0.895,2-2V2c0-1.105-0.895-2-2-2L2.618,0C1.875,0,1.391,0.782,1.724,1.447l3.724,7.447C5.786,9.572,6.479,10,7.236,10z';
        },

        getBottomBarPath: function () {
            return 'M7.236,0L13,0c1.105,0,2,0.895,2,2v6c0,1.105-0.895,2-2,2H2.618c-0.743,0-1.227-0.782-0.894-1.447l3.724-7.447C5.786,0.428,6.479,0,7.236,0z';
        },

        getLeftBarPath: function () {
            return 'M0,7.236V13c0,1.105,0.895,2,2,2h6c1.105,0,2-0.895,2-2V2.618c0-0.743-0.782-1.227-1.447-0.894L1.106,5.447C0.428,5.786,0,6.479,0,7.236z';
        },

        getRightBarPath: function () {
            return 'M10,7.236V13c0,1.105-0.895,2-2,2H2c-1.105,0-2-0.895-2-2L0,2.618c0-0.743,0.782-1.227,1.447-0.894l7.447,3.724C9.572,5.786,10,6.479,10,7.236z';
        },

        refreshPoints: function (min, max) {
            var minSize = this._gradientScale(min);
            var maxSize = this._gradientScale(max);
            var vanChart = this.vanchart;
            var change = false;

            vanChart.series.forEach(function (sery) {
                sery.points.forEach(function (point) {
                    var temp = point.visible;
                    point.visible = (point.size >= minSize && point.size <= maxSize) || (point.size >= maxSize && point.size <= minSize);
                    change = change || temp != point.visible;
                });
            });

            if(change) {
                vanChart.renderOnlyCharts();
            }
        }
    });

    require('../ComponentLibrary').register(Constants.RANGE_LEGEND_COMPONENT, RangeLegend);
    return RangeLegend;

});

/**
 * Created by eason on 15/6/15.
 * 默认主题
 */
define('theme/default',[],function(){

    var config = {
        colors:['#63b2ee','#76da91','#f8cb7f','#f89588','#7cd6cf','#9192ab','#7898e1','#efa666','#eddd86','#9987ce'],

        plotOptions:{

            visible:true,

            dataLabels:{
                enabled:false
            }

        },

        tooltip:{
            enabled:true
        },

        tools:{
            enabled:true,
            "hidden": false
        },

        legend:{
            hiddenColor:'#cccccc',
            hoverColor:'green',
            style:{
                color:'#666666',
                fontFamily:'Verdana',
                fontSize:'14px'
            },
            position:'right'
        },

        rangeLegend:{
            hiddenColor:'#cccccc',
            hoverColor:'green',
            style:{
                color:'#666666',
                fontFamily:'Verdana',
                fontSize:'14px'
            },
            position:'right',
            enabled:false
        },

        backgroundColor:null,
        backgroundImage:null,
        borderColor:  '#CCCCCC',
        borderWidth: 0,
        borderRadius: 0,
        shadow: false,

        plotBackgroundColor:null,
        plotBackgroundImage:null,
        plotBorderColor:  '#CCCCCC',
        plotBorderWidth: 0,
        plotBorderRadius: 0,
        plotShadow: false
    };

    return config;
});
/**
 * Created by eason on 15/6/17.
 */
define('VanChart',['require','./utils/BaseUtils','./utils/QueryUtils','./ComponentLibrary','./ChartLibrary','./Constants','./render/RenderFactory','./Handler','./component/Series','./component/Title','./component/DrillTools','./component/Axis','./component/Geo','./component/CategoryAxis','./component/ValueAxis','./component/DateAxis','./component/Polar','./component/Legend','./component/Tooltip','./component/Toolbar','./component/ZoomBar','./component/DataSheet','./component/RangeLegend','./theme/config','./theme/default'],function(require){

    var BaseUtils = require('./utils/BaseUtils');
    var QueryUtils = require('./utils/QueryUtils');

    var ComponentLibrary = require('./ComponentLibrary');
    var ChartLibrary = require('./ChartLibrary');
    var Constants = require('./Constants');
    var RenderFactory = require('./render/RenderFactory');
    var Handler = require('./Handler');
    var Series = require('./component/Series');

    var COMPONENTS = [
        Constants.GEO_COMPONENT,
        Constants.TOOLBAR_COMPONENT,
        Constants.TITLE_COMPONENT,
        Constants.DRILL_TOOLS,
        Constants.LEGEND_COMPONENT,
        Constants.RANGE_LEGEND_COMPONENT,
        Constants.Y_AXIS_COMPONENT,
        Constants.X_AXIS_COMPONENT,
        Constants.POLAR_COMPONENT,
        Constants.RADIUS_AXIS_COMPONENT,
        Constants.ANGLE_AXIS_COMPONENT,
        Constants.GAUGE_AXIS_COMPONENT,
        Constants.ZOOM_COMPONENT,
        Constants.DATA_SHEET_COMPONENT,
        Constants.TOOLTIP_COMPONENT
    ];

    var AXES = [
        Constants.X_AXIS_COMPONENT,
        Constants.Y_AXIS_COMPONENT,
        Constants.POLAR_COMPONENT,
        Constants.RADIUS_AXIS_COMPONENT,
        Constants.ANGLE_AXIS_COMPONENT,
        Constants.GAUGE_AXIS_COMPONENT
    ];

    var PADDING = 5;

    //默认加载所有组件
    require('./component/Title');
    require('./component/DrillTools')
    require('./component/Axis');
    require('./component/Geo');
    require('./component/CategoryAxis');
    require('./component/ValueAxis');
    require('./component/DateAxis');
    require('./component/Polar');
    require('./component/Legend');
    require('./component/Tooltip');
    require('./component/Toolbar');
    require('./component/ZoomBar');
    require('./component/DataSheet');
    require('./component/RangeLegend');

    function VanChart(option, dom, vancharts){

        //组件
        this.width = this._getDomWidth(dom);
        this.height = this._getDomHeight(dom);
        this.ID_PREFIX = dom.getAttribute(Constants.INSTANCES_KEY) + vancharts.charts.length;

        dom = this._initLeafLet(option, dom);
        option.state = Constants.STATE_INIT;
        
        this.dom = dom;
        this.dom.style.cssText += ';-ms-user-select:none;-webkit-user-select:none;-moz-user-select:none;-o-user-select:none;user-select:none;';
        this.dom.onselectstart = this.dom.ondrag = function(){
            return false;
        };
        this.vancharts = vancharts;

        this.handler = new Handler(this, dom);
        this.render = RenderFactory.getRender(Constants.VANCHART, this);

        this.components = {};
        this.charts = {};

        //这两个变量不应该出现在这里
        this.series = [];

        this.colorMap = {};
        
        this.refresh(option);
    }

    VanChart.prototype = {
        constructor:VanChart,

        componentType:Constants.VANCHART,

        _initLeafLet:function(option, dom){
            if(option.chartType == Constants.MAP_CHART){
                var chart = this;
                function viewreset(){
                    chart.getChart(Constants.MAP_CHART).viewreset()
                };

                this._leaflet = this._leaflet || L.map(dom, {zoomControl:false, doubleClickZoom:false});
                this._leaflet.on('zoomend', viewreset, this._leaflet);

                //gis层级
                // L.tileLayer('https://api.tiles.mapbox.com/v4/{id}/{z}/{x}/{y}.png?access_token=pk.eyJ1IjoibWFwYm94IiwiYSI6ImNpandmbXliNDBjZWd2M2x6bDk3c2ZtOTkifQ._QA7i5Mpkd_m30IGElHziw', {
                //     id: 'mapbox.streets'
                // }).addTo(this._leaflet);
                dom = dom.getElementsByClassName("leaflet-control-container")[0];
                // return d3.select(control).append('div').style('z-index', 1000).style('position', 'absolute').node();
            }
            return dom;
        },

        //外部调用接口，传入新的配置
        refresh:function(option){
            this._init(option);

            this._refreshOptions();
        },

        refreshRestore:function(){

            this.currentOption = BaseUtils.clone(this.restoreOption);

            this.currentOption.state = Constants.STATE_RESTORE_REFRESH;

            this.scale = 1;

            this._refreshOptions();
        },

        isInitOrRestoreState: function () {
            return this.currentOption.state == Constants.STATE_INIT || this.currentOption.state == Constants.STATE_RESTORE_REFRESH;
        },

        isChangeDataState: function () {
            return this.currentOption.state == Constants.STATE_CHANGE_DATA_REFRESH;
        },

        isZoomRefreshState: function () {
            return this.currentOption.state == Constants.STATE_ZOOM_REFRESH;
        },

        dealAxisZoom:function(downPos, upPos){
            var bubble = this.getChart(Constants.BUBBLE_CHART);

            if(bubble && bubble.isForceBubble()){

                var isUpdateWithForce = bubble.isUpdateWithForce();

                if(isUpdateWithForce){
                    bubble.render.force.stop();
                }

                var plotBounds = this.getPlotBounds();

                var minX = Math.min(downPos[0], upPos[0]) - plotBounds.x;
                var minY = Math.min(downPos[1], upPos[1]) - plotBounds.y;

                var detX = Math.abs(downPos[0] - upPos[0]);
                var detY = Math.abs(downPos[1] - upPos[1]);

                var scale = Math.min(plotBounds.width/detX, plotBounds.height/detY);

                var wWidth = plotBounds.width / scale;
                var wHeight = plotBounds.height / scale;

                var shiftX = (plotBounds.width - wWidth)/2 - minX;
                var shiftY = (plotBounds.height - wHeight)/2 - minY;

                var series = bubble.getVisibleChartData();

                series.forEach(function(sery){

                    sery.points.forEach(function(point){

                        point.radius *= scale;

                        var x = point.x + shiftX;
                        var y = point.y + shiftY;

                        x -= plotBounds.width/2;
                        y -= plotBounds.height/2;

                        point.x = x * scale + plotBounds.width/2 - shiftX;
                        point.y = y * scale + plotBounds.height/2 - shiftY;

                        if(!isUpdateWithForce){
                            point.posX = point.x;
                            point.posY = point.y;
                        }

                        if(point.labelContent && point.labelDim){

                            var radius = point.radius;
                            if((point.labelDim.width > 2 * radius) || (point.labelDim.height > 2 * radius)){
                                point.labelPos = null;
                            }else{

                                point.labelPos = {
                                    x:-point.labelDim.width/2 + (isUpdateWithForce ? 0 : point.posX),
                                    y:-point.labelDim.height/2 + (isUpdateWithForce ? 0 : point.posY)
                                }
                            }
                        }
                    })
                });

                this.scale = scale * BaseUtils.pick(this.scale, 1);
                bubble.render.scaleRender();
            }else{
                this.currentOption.state = Constants.STATE_ZOOM_REFRESH;
                var zoomType = this.currentOption.zoom.zoomType;

                if(this.components.xAxis && zoomType.indexOf('x') != -1){
                    this.components.xAxis.axisZoom(downPos, upPos);
                }

                if(this.components.yAxis && zoomType.indexOf('y') != -1){
                    this.components.yAxis.axisZoom(downPos, upPos);
                }

                this.layoutComponentsAndCharts();
            }
        },

        refreshIncreaseOrder:function(){

            this.currentOption.orderType = Constants.ASCENDING;

            this.layoutComponentsAndCharts();
        },

        refreshDecreaseOrder:function(){

            this.currentOption.orderType = Constants.DESCENDING;

            this.layoutComponentsAndCharts();
        },

        //走这边的话要重画缩放控件
        _refreshOptions:function(){

            this.series = [];//置空

            this.colorMap = {};
            
            var option = this.currentOption;

            //先构建组件的对象,主要是构建坐标轴
            var ComponentClass, componentType, component;
            for(var i = 0; i < COMPONENTS.length; i++){
                componentType = COMPONENTS[i];
                component = this.components[componentType];
                if(option[componentType] && this._isComponentEnabled(option[componentType])){
                    if(component){
                        component.refresh(option);
                    }else{
                        //新建component
                        ComponentClass = ComponentLibrary.get(
                            AXES.indexOf(componentType) > -1 ?
                                Constants.AXIS_COMPONENT :
                                componentType
                        );
                        component = new ComponentClass(this, option, componentType);
                        this.components[componentType] = component;
                    }
                }else if(component){
                    component.remove();
                    this.components[componentType] = null;
                    delete this.components[componentType];
                }
            }

            //先确定构成图的种类
            var chartType = option.chartType || Constants.LINE_CHART;
            var ChartClass;
            for(var i = 0, len = option.series.length; i < len; i++){
                var sery = option.series[i];
                var seryChartType = sery.type || chartType;
                ChartClass = ChartLibrary.get(seryChartType);
                if(ChartClass){
                    var chart = this.charts[seryChartType];

                    if(chart){
                        chart.refresh(option)
                    }else{
                        chart = new ChartClass(this, option, seryChartType);
                        this.charts[seryChartType] = chart;
                    }

                    this.series.push(new Series(chart, sery, i));
                }
            }

            this.bounds = BaseUtils.makeBounds(PADDING, PADDING, this.width - 3 * PADDING, this.height - 3 * PADDING);

            var zoom = this.components[Constants.ZOOM_COMPONENT];
            if(zoom){
                zoom.doLayout();
                zoom.remove();
            }

            var map = this.charts[Constants.MAP_CHART];
            map && map.initLayerInfo();

            this.plotBounds = this.bounds;

            this.refreshComponentsAndSeries();
        },

        refreshComponentsAndSeries:function(){

            this.hoverPoint = null;
            this.hoverSeries = null;

            for(var component in this.components){
                this.components[component].initAttributesWithSeries();
            }

            this.layoutComponentsAndCharts()
        },


        layoutComponentsAndCharts:function(){

            if(this.currentOption.orderType){
                for(var chart in this.charts){
                    this.charts[chart].orderData();
                }
            }

            this.bounds = BaseUtils.clone(this.plotBounds);

            for(var component in this.components){
                if(component != Constants.ZOOM_COMPONENT){
                    this.components[component].doLayout();
                }
            }

            //坐标轴,数据表,缩放控件要根据绘图区的区域来确定边界
            var components = this.components;
            [
                Constants.GAUGE_AXIS_COMPONENT,
                Constants.Y_AXIS_COMPONENT,
                Constants.X_AXIS_COMPONENT,
                Constants.DATA_SHEET_COMPONENT
            ]
                .forEach(function(cName){

                    var component = components[cName];

                    if(component){
                        component.fixBoundsByPlot();
                    }
                });

            [
                Constants.RADIUS_AXIS_COMPONENT,
                Constants.ANGLE_AXIS_COMPONENT
            ]
                .forEach(function (cName) {
                    var component = components[cName];

                    if (component) {
                        component.calculateTickData();
                    }
                });

            //处理0值对齐的坐标轴的位置
            [Constants.Y_AXIS_COMPONENT, Constants.X_AXIS_COMPONENT]
                .forEach(function(cName){
                    var component = components[cName];
                    if(component){
                        component.dealOnZero();
                    }
                });

            [
                Constants.ZOOM_COMPONENT,
            ]
                .forEach(function(cName){

                    var component = components[cName];

                    if(component){
                        component.fixBoundsByPlot();
                    }
                });

            //缩放之前的位置
            this.plotOriginalBounds = this.plotOriginalBounds || BaseUtils.clone(this.bounds);

            for(var chart in this.charts){
                this.charts[chart].getRender() && this.charts[chart].doLayout();
            }

            this.handler.initTargets();

            this.render.render();
        },

        _init:function(option){

            option.series = (option.series && option.series.length) ? option.series : [{}];//保证series不为空

            option.series.forEach(function(sery){
                sery.data = sery.data || [];
            });

            //坐标轴可能是数组
            this.themeConfig = this._normalizeOption(this._mergeThemeConfig(option), option);

            this.restoreOption = QueryUtils.merge(BaseUtils.clone(option), this.themeConfig, false);

            if(this.restoreOption.chartType == Constants.SCATTER_CHART
                || this.restoreOption.chartType == Constants.BUBBLE_CHART){

                var sort = this.restoreOption.tools.sort || {};
                sort.enabled = false;
            }

            this.currentOption = BaseUtils.clone(this.restoreOption);
        },

        renderOnlyCharts:function() {

            var bubble = this.getChart(Constants.BUBBLE_CHART);
            if(bubble && bubble.isUpdateWithForce()) {
                bubble.render.force.stop();
            }

            for(var chart in this.charts){
                this.charts[chart].doLayout();
            }

            var charts = this.getChartRenders();
            charts.forEach(function(render){
                render.filterRender();
            });

            if(!BaseUtils.isSupportSVG()){
                var components = this.components;

                COMPONENTS.forEach(function(type){
                    if(components[type]){
                        var component = components[type];
                        if(component.isFloat){
                            var render = component.getRender();
                            if(render){
                                render.render();
                            }
                        }
                    }
                });
            }
        },

        _getDomWidth:function(root){
            var stl = root.currentStyle || document.defaultView.getComputedStyle(root);
            return ((root.clientWidth || parseInt(stl.width, 10)) - parseInt(stl.paddingLeft, 10) - parseInt(stl.paddingRight, 10)).toFixed(0) - 0;
        },

        _getDomHeight:function(root){
            var stl = root.currentStyle || document.defaultView.getComputedStyle(root);
            return ((root.clientHeight || parseInt(stl.height, 10)) - parseInt(stl.paddingTop, 10) - parseInt(stl.paddingBottom, 10)).toFixed(0) - 0;
        },

        _normalizeOption:function(themeConfig, option){

            themeConfig = BaseUtils.clone(themeConfig);

            AXES.map(function (axis) {
                if (!option[axis]) {
                    return;
                }
                
                if (!Array.isArray(option[axis])) {
                    option[axis] = [option[axis]];
                }

                if (option[axis].length) {
                    themeConfig[axis] =
                        option[axis].map(function () {
                            return themeConfig[axis];
                        });
                } else if (themeConfig[axis]) {
                    option[axis][0] = themeConfig[axis];
                }

                return null;
            });

            return themeConfig;

        },

        //默认配置，主题配置的组合
        _mergeThemeConfig:function(option){
            var defaultConfig = require('./theme/config');
            var themeConfig = require('./theme/default');

            var chartTypes = [];
            var result = {};

            if(option.chartType) {
                chartTypes.push(option.chartType);
                QueryUtils.merge(result, defaultConfig[option.chartType], true);
            }

            option.series.map(function (item) {
                var type = item.type;
                if (type && chartTypes.indexOf(type) === -1) {
                    chartTypes.push(item);
                    QueryUtils.merge(result, defaultConfig[type], true);
                }
            });
            
            if (chartTypes.length === 0) {
                QueryUtils.merge(result, defaultConfig[Constants.LINE_CHART], true);
            }

            QueryUtils.merge(result, themeConfig, true);

            return result;
        },

        _isComponentEnabled:function(componentOption){
            if(BaseUtils.hasDefined(componentOption.enabled)){
                return componentOption.enabled;
            }
            return true;
        },

        getPlotBackgroundOption:function(){
            var option = this.currentOption;
            return {
                color:option.plotBackgroundColor,
                image:option.plotBackgroundImage,
                borderColor:option.plotBorderColor,
                borderWidth:option.plotBorderWidth,
                borderRadius:option.plotBorderRadius,
                plotShadow:option.plotShadow
            }
        },

        getChartBackgroundOption:function(){
            var option = this.currentOption;

            return {
                color:option.backgroundColor,
                image:option.backgroundImage,
                borderColor:option.borderColor,
                borderWidth:option.borderWidth,
                borderRadius:option.borderRadius,
                chartShadow:option.shadow
            }

        },

        getTrendLineOption:function(){

            var trendLines = [];
            var series = this.series;

            for(var i = 0, len = series.length; i < len; i++){
                var sery = series[i];

                var trendLine = sery.trendLine;

                //堆积的系列用趋势线没意义吧
                if(!trendLine || !sery.visible){
                    continue;
                }

                var XY = sery.chart.getTrendLineXYValues(sery);
                var xValues = XY[0];
                var yValues = XY[1];
                var location = XY[2];

                if(xValues.length <= 1){
                    continue;
                }

                var x1,x2,y1,y2;

                if(location == Constants.TOP || location == Constants.BOTTOM){
                    var leastSquaresCoeff = this._leastSquares(XY[0], XY[1]);

                    x1 = xValues[0];
                    y1 = leastSquaresCoeff[0] * x1 + leastSquaresCoeff[1];
                    x2 = xValues[xValues.length - 1];
                    y2 = leastSquaresCoeff[0] * x2 + leastSquaresCoeff[1];
                }else{

                    var leastSquaresCoeff = this._leastSquares(XY[1], XY[0]);

                    y1 = yValues[0];
                    x1 = leastSquaresCoeff[0] * y1 + leastSquaresCoeff[1];
                    y2 = yValues[yValues.length - 1];
                    x2 = leastSquaresCoeff[0] * y2 + leastSquaresCoeff[1];
                }

                trendLines.push({
                    x1:x1,
                    y1:y1,
                    x2:x2,
                    y2:y2,
                    trendLine:trendLine
                })
            }

            return trendLines;
        },

        _leastSquares:function(xValues, yValues){
            var reduceSumFunc = function(prev, cur) { return prev + cur; };

            var xBar = xValues.reduce(reduceSumFunc) * 1.0 / xValues.length;
            var yBar = yValues.reduce(reduceSumFunc) * 1.0 / yValues.length;

            var ssXX = xValues.map(function(d) { return Math.pow(d - xBar, 2); })
                .reduce(reduceSumFunc);

            var ssYY = yValues.map(function(d) { return Math.pow(d - yBar, 2); })
                .reduce(reduceSumFunc);

            var ssXY = xValues.map(function(d, i) { return (d - xBar) * (yValues[i] - yBar); })
                .reduce(reduceSumFunc);

            var slope = ssXY / ssXX;
            var intercept = yBar - (xBar * slope);

            return [slope, intercept];
        },

        getParentDom:function(){
            return this.dom;
        },

        chartWidth:function(){
            return this.width;
        },

        chartHeight:function(){
            return this.height;
        },

        setPlotBounds:function(newBounds){
            this.bounds = newBounds;
        },

        getPlotClipBounds:function(){

            var x = 0;
            var y = 0;
            var width = this.bounds.width;
            var height = this.bounds.height;

            var locationMap = {};
            var all = [];
            if(this.components.xAxis){
                all = all.concat(this.components.xAxis.getAllAxis());
            }

            if(this.components.yAxis){
                all = all.concat(this.components.yAxis.getAllAxis());
            }

            all.forEach(function(axis){
                var position = axis.getPosition();
                if(!axis.isOnZero() && !locationMap[position]){
                    locationMap[position] = axis.getLineWidth();
                }
            });

            y = locationMap[Constants.TOP] ? Math.ceil(locationMap[Constants.TOP]/2) : 0;
            height -= y;
            height = locationMap[Constants.BOTTOM] ? height - Math.ceil(locationMap[Constants.BOTTOM]/2 - 0.5) : height;

            x = locationMap[Constants.LEFT] ? Math.ceil(locationMap[Constants.LEFT]/2) : 0;
            width -= x;
            width = locationMap[Constants.RIGHT] ? width - Math.ceil(locationMap[Constants.RIGHT]/2) : width;

            return {
                x:x,
                y:y,
                width:width,
                height:height
            };

        },

        getPlotBounds:function(){
            return this.bounds;
        },

        getChartBounds:function(){
            return BaseUtils.makeBounds(0, 0, this.width, this.height);
        },

        xAxis:function(axisIndex){
            if(!axisIndex){
                axisIndex = 0;
            }
            var axis = this.components.xAxis;
            return axis ? axis.getAxis(axisIndex) : null;
        },

        yAxis:function(axisIndex){
            if(!axisIndex){
                axisIndex = 0;
            }
            var axis = this.components.yAxis;
            return axis ? axis.getAxis(axisIndex) : null;
        },

        polar:function(axisIndex){
            if(!axisIndex){
                axisIndex = 0;
            }
            var axis = this.components.polar;
            return axis ? axis.getAxis(axisIndex) : null;
        },

        angleAxis: function (axisIndex) {
            if(!axisIndex){
                axisIndex = 0;
            }
            var axis = this.components.angleAxis;
            return axis ? axis.getAxis(axisIndex) : null;
        },

        radiusAxis: function (axisIndex) {
            if(!axisIndex){
                axisIndex = 0;
            }
            var axis = this.components.radiusAxis;
            return axis ? axis.getAxis(axisIndex) : null;
        },

        gaugeAxis: function (axisIndex) {
            if(!axisIndex){
                axisIndex = 0;
            }
            var axis = this.components.gaugeAxis;
            return axis ? axis.getAxis(axisIndex) : null;
        },

        getSharedAxis: function () {
            var axes = [this.xAxis(), this.yAxis(), this.angleAxis()];

            for (var i = 0; i < axes.length; i++) {
                var axis = axes[i];
                if (!axis) {
                    continue;
                }
                var sharedPointsLength = 0;
                for (var item in axis.sharedPoints) {
                    ++sharedPointsLength;
                    break;
                }

                if (sharedPointsLength) {
                    return axis;
                }
            }

            return null;
        },
        
        getRender:function(){
            return this.render;
        },

        getChartRenders:function(){
            var renders = [];
            for(var chart in this.charts){
                var render = this.charts[chart].getRender();
                if(render){
                    renders.push(render);
                }
            }
            return renders;
        },

        getComponentRenders:function(){
            var renders = [];

            var components = this.components;

            COMPONENTS.forEach(function(type){
                if(components[type]){
                    var render = components[type].getRender();
                    if(render){
                        renders.push(render);
                    }
                }
            });

            return renders;
        },

        getFixedComponentRenders:function(){

            var renders = [];
            var components = this.components;

            COMPONENTS.forEach(function(type){
                if(components[type]){
                    var component = components[type];
                    if(!component.isFloat){
                        var render = component.getRender();
                        if(render){
                            renders.push(render)
                        }
                    }

                }
            });

            return renders;
        },

        getFloatComponentRenders:function(){
            var renders = [];
            var components = this.components;

            COMPONENTS.forEach(function(type){
                if(components[type]){
                    var component = components[type];
                    if(component.isFloat){
                        var render = component.getRender();
                        if(render){
                            renders.push(render)
                        }
                    }
                }
            });

            return renders;
        },

        getToolbarWidth:function(){
            if(this.components[Constants.TOOLBAR_COMPONENT]){
                return this.components[Constants.TOOLBAR_COMPONENT].getToolbarWidth();
            }
            return 0;
        },

        //没有标题，并且图例在右上方的时候把工具栏的高度空出来
        getToolbarHeight:function(){
            var title = this.components[Constants.TITLE_COMPONENT];
            if(this.components[Constants.TOOLBAR_COMPONENT] && (!title || title.isFloat) ){
                return this.components[Constants.TOOLBAR_COMPONENT].getToolbarHeight();
            }
            return 0;
        },

        getTooltip:function(){
            return this.components.tooltip;
        },

        getComponent:function(type){
            return this.components[type];
        },

        getChart:function(type){
            return this.charts[type];
        },

        getIDPrefix:function(){
            return this.ID_PREFIX;
        },

        getBodyClipID:function(){
            return 'bodyClip' + this.getIDPrefix();
        },

        getOptions:function(){
            return this.currentOption;
        },

        /**
         * return color of previous name
         * or set new color and return
         * @param {string} [name] series item (or pie point) name
         * @returns {*}
         */
        getDefaultSeriesColor: function (name) {
            if (typeof name !== 'string') {
                throw new TypeError(name);
            }

            if (!this.colorMap[name]) {
                var colors = this.currentOption.colors;
                var length = 0;
                for (var item in this.colorMap) {
                    ++length;
                }
                // return next color
                this.colorMap[name] = colors[length % colors.length];
            }

            return this.colorMap[name];
        },

        remove:function(){
            this.render.remove();

            if(this.components[Constants.TOOLTIP_COMPONENT]){
                this.components[Constants.TOOLTIP_COMPONENT].remove();
            }
        }
    };

    return VanChart;
});
/**
 * Created by eason on 15/5/15.
 * 管里当前产生的所有
 */
define('VanCharts',['require','./utils/BaseUtils','./Constants','./VanChart'],function(require){

    var BaseUtils = require('./utils/BaseUtils');
    var Constants = require('./Constants');
    var VanChart = require('./VanChart');

    var _baseIndex = 0;

    var _instances = Object.create(null);

    function init(dom){
        var instanceKey = dom.getAttribute(Constants.INSTANCES_KEY);
        if(!instanceKey){
            instanceKey = Constants.INSTANCES_KEY + _baseIndex++;
            dom.setAttribute(Constants.INSTANCES_KEY, instanceKey);
        }

        if(_instances[instanceKey]){
            //key对应的实例已经存在的话先删掉
            var svgRoot = _instances[instanceKey].svgRoot;
            if(svgRoot){
                svgRoot.remove();
            }
        }else{
            var vanCharts = new VanCharts(dom);
            _instances[instanceKey] = vanCharts;
        }

        return _instances[instanceKey];
    }

    function VanCharts(dom){
        this.dom = dom;
        this.charts = [];
    }

    VanCharts.prototype = {
        constructor:VanCharts,

        setOptions:function(options){
            if(!BaseUtils.isArray(options)){
                options = [options];
            }
            this.options = options;

            for(var i = 0, len = options.length; i < len; i++){
                this.charts.push(new VanChart(options[i], this.dom, this));
            }
        },

        resize:function(options){

            this.clear();

            this.charts = [];

            options = options || this.options;
            this.options = options;

            this.setOptions(options);
        },

        setData:function(options){

            if(!BaseUtils.isArray(options)){
                options = [options];
            }
            this.options = options;

            if(BaseUtils.isSupportSVG()){
                this.charts.forEach(function(chart, i){
                    options[i].state = Constants.STATE_CHANGE_DATA_REFRESH;
                    chart.refresh(options[i]);
                });
            }else{
                this.resize(options);
            }
        },

        clear:function(){

            for(var i = 0, len = this.charts.length; i < len; i++){
                this.charts[i].remove();
                this.charts[i] = null;
            }
        }
    };

    return {
        init:init
    };
});
/**
 * Created by eason on 15/5/4.
 * 一些最常用的工具方法
 */
define('utils/BaseUtils',['require','./ColorUtils','../Constants','VanCharts'],function(require){

    var ColorUtils = require('./ColorUtils');
    var Constants = require('../Constants');

    var lastID = 0;

    var styleToCss = {
        color:'fill',
        font:'font',
        fontFamily:'font-family',
        fontSize:'font-size',
        fontStretch:'font-stretch',
        fontStyle:'font-style',
        fontVariant:'font-variant',
        fontWeight:'font-weight',
        letterSpacing:'letter-spacing',
        lineHeight:'line-height',
        quotes:'quotes',
        textAlign:'text-align',
        textDecoration:'text-decoration',
        textIndent:'text-indent',
        textShadow:'text-shadow',
        textTransform:'text-transform',
        whiteSpace:'white-space',
        wordSpacing:'word-spacing',
        padding:'padding'
    };

    /**
     * pick参数里第一个不为null和undefined的值
     * @returns {*}
     */
    function pick(){
        var arg, length = arguments.length;
        for (var i = 0; i < length; i++) {
            arg = arguments[i];
            if (typeof arg !== 'undefined' && arg !== null) {
                return arg;
            }
        }
        return null;
    }

    /**
     * 判断对象是否是数组
     * @param value 对象
     * @returns {boolean} 是否是数组
     */
    function isArray(value){
        return Object.prototype.toString.apply(value) === '[object Array]';
    }

    /**
     * 将具有length属性的对象转成数组
     * @param sequence 对象
     */
    function toArray(sequence){
        return Array.prototype.slice.call(sequence);
    }

    function setTextStyle(textS, style){
        style = cssNormalization(style);
        for(var attr in style){
            textS.style(attr, style[attr]);
        }
    }

    /**
     * 返回字体是fontSize(有单位，px,em)
     * @param fontSize
     */
    function getTextDimension(text, style, useHtml){
        text = pick(text, "");
        var div = document.createElement("div");
        document.getElementById('container').appendChild(div);

        div.style.visibility = "hidden";
        div.style.whiteSpace = "nowrap";
        div.style.position = 'absolute';

        var fontSize = '12px';

        for(var property in style){
            if(typeof(style[property]) != "function" && property != 'color'){
                div.style[property] = style[property];
            }

            if(property == 'fontSize'){
                fontSize = style[property];
            }
        }

        if(fontSize.indexOf('pt') != -1){
            fontSize = parseFloat(fontSize) * 4 / 3;
        }else{
            fontSize = parseFloat(fontSize);
        }

        div.innerHTML = text;
        //fireFox下面innerText的话offsetWidth为0
        //useHtml ? span.innerHTML = text : span.innerText = text;
        var width = div.offsetWidth || 0;
        var height = div.offsetHeight || 0;

        document.getElementById('container').removeChild(div);

        return {width:width, height:height};
    }

    function getTextWrapDimension(text, style, useHTML){
        text = pick(text, "");
        var div = document.createElement("div");
        document.getElementById('container').appendChild(div);

        div.style.visibility = "hidden";
        div.style.whiteSpace = "normal";
        div.style.position = 'absolute';
        div.style.wordWrap = 'break-word';

        for(var property in style){
            if(typeof(style[property]) != "function" && property != 'color'){
                div.style[property] = style[property];
            }
        }

        if (useHTML) {
            div.innerHTML = text;
        } else {
            div.textContent ?
                (div.textContent = text) :
                (div.innerText = text);
        }
        //fireFox下面innerText的话offsetWidth为0
        //useHtml ? span.innerHTML = text : span.innerText = text;
        var width = div.offsetWidth || 0;
        var height = div.offsetHeight || 0;

        document.getElementById('container').removeChild(div);

        return {width:width, height:height};
    }

    function getTextHeight(style) {

        var fontSize = style.fontSize || '12px';

        return fontSize.indexOf('pt') != -1 ? parseFloat(fontSize) * 4 / 3 : parseFloat(fontSize);
    }

    function stamp(obj){
        obj._vanchart_id = obj._vanchart_id || ++lastID;
        return obj._vanchart_id;
    }

    function falseFn() {
        return false;
    }

    //properties mix in
    function extend(dest) {
        var i, j, len, src;

        for (j = 1, len = arguments.length; j < len; j++) {
            src = arguments[j];
            for (i in src) {
                dest[i] = src[i];
            }
        }

        return dest;
    }

    function divRotate(div, rotation){

        var cssText = [];
        cssText.push('transform:rotate(' + rotation + 'deg)');
        cssText.push('-ms-transform:rotate(' + rotation + 'deg)');
        cssText.push('-webkit-transform:rotate(' + rotation + 'deg)');
        cssText.push('-moz-transform:rotate(' + rotation + 'deg)');
        cssText.push('-o-transform:rotate(' + rotation + 'deg)');

        var costheta = Math.cos(toRadian(rotation));
        var sintheta = Math.sin(toRadian(rotation));

        //ie9的时候filter和ms-transform同时生效了
        if(!isSupportSVG()){
            var filter = rotation ? ['progid:DXImageTransform.Microsoft.Matrix(M11=', costheta,
                ', M12=', -sintheta, ', M21=', sintheta, ', M22=', costheta,
                ', sizingMethod=\'auto expand\')'].join('') : 'none';
            cssText.push('filter:' + filter);
        }

        div.style.cssText += (cssText.join(';') + ';');
    }

    function splitText(text, style, offeredSize, padding){

        if(!text){
            return '';
        }

        text += '';

        padding = padding || 0;

        offeredSize -= 2*padding;

        var result = [];

        var startIndex = 0;
        var textCount = text.length;

        while(startIndex < textCount){
            var i = startIndex;
            while(getTextDimension(text.substring(i, startIndex + 1), style, false).width < offeredSize){
                startIndex++;
                if(startIndex >= textCount){
                    break;
                }
            }

            if(i == startIndex){
                //这里的情况是一个字符都放不下
                return [];
            }else{
                result.push(text.substring(i, startIndex));
            }

        }

        return result;
    }

    function getTextDimensionWithRotation(text, style, useHtml, rotation){

        var dim = getTextDimension(text, style, useHtml);
        var angle = Math.abs(toRadian(rotation || 0));

        var width = dim.width * Math.cos(angle) + dim.height * Math.sin(angle);
        var height = dim.width * Math.sin(angle) + dim.height * Math.cos(angle);

        return {
            width:width,
            height:height
        }

    }

    function clone(source) {
        if (typeof source == 'object' && source !== null) {
            var result = source;
            if (isArray(source)) {
                result = [];
                for (var i = 0, len = source.length; i < len; i++) {
                    result[i] = clone(source[i]);
                }
            }else{
                result = {};
                for (var key in source) {
                    if (source.hasOwnProperty(key)) {
                        result[key] = clone(source[key]);
                    }
                }
            }
            return result;
        }

        return source;
    }

    //style对象的表示方法转css表示
    function cssNormalization(style){
        var result = {};
        for(var attr in style){
            if(styleToCss[attr]){
                result[styleToCss[attr]] = style[attr];
            }

            if(attr == 'color'){
                result.color = style[attr];
            }

            //转px
            if(attr == 'fontSize'){
                var fontSize = style[attr];
                if(fontSize.indexOf('pt') != -1){
                    fontSize = parseFloat(fontSize) * 4 / 3;
                    result['font-size'] = fontSize + 'px';
                }
            }
        }
        return result;
    }

    /**
     * css类属性数组补全，如padding，margin等~
     */
    function reformCssArray(p) {
        if (p instanceof Array) {
            switch (p.length + '') {
                case '4':
                    return p;
                case '3':
                    return [p[0], p[1], p[2], p[1]];
                case '2':
                    return [p[0], p[1], p[0], p[1]];
                case '1':
                    return [p[0], p[0], p[0], p[0]];
                case '0':
                    return [0, 0, 0, 0];
            }
        }
        else {
            return [p, p, p, p];
        }
    }

    function lineSubPixelOpt(xOry, lineWidth){
        return lineWidth % 2 == 0 ? Math.round(xOry) : Math.round(xOry - 0.5) + 0.5;
    }

    function rectSubPixelOpt(x,y,width,height,lineWidth){
        lineWidth = lineWidth || 0;
        x = lineSubPixelOpt(x, lineWidth);
        y = lineSubPixelOpt(y, lineWidth);
        width = Math.round(width);
        height = Math.round(height);
        return {x:x, y:y, width:width, height:height};
    }

    function addArray(targetArray, sourceArray){

        var result = [];

        if(targetArray && targetArray.length){
            for(var i = 0, len = targetArray.length; i < len; i++){
                result.push(targetArray[i]);
            }
        }

        if(sourceArray && sourceArray.length){
            for(var i = 0, len = sourceArray.length; i < len; i++){
                result.push(sourceArray[i]);
            }
        }

        return result;
    }

    function toFront(el){
        if(el && el.parentNode){
            el.parentNode.appendChild(el);
        }
    }

    function toBack(el){
        if(el && el.parentNode){
            el.parentNode.insertBefore(el,el.parentNode.firstChild);
        }
    }

    function toFrontOfAll(el){
        el.ownerSVGElement.appendChild(el);
    }

    function toBackOfAll(el){
        el.ownerSVGElement.appendChild(el,el.ownerSVGElement.firstChild);
    }

    //一定是在同一个坐标原点下
    function containsRect(biggerOne, smallOne){

        return biggerOne.x <= smallOne.x
                    && biggerOne.y <= smallOne.y
                    && biggerOne.x + biggerOne.width >= smallOne.x + smallOne.width
                    && biggerOne.y + biggerOne.height >= smallOne.y + smallOne.height;

    }

    function rectangleOverlapped(aBounds, bBounds){
        if (!aBounds|| !bBounds) {
            return false;
        }
        var minx = Math.max(aBounds.x, bBounds.x);
        var miny = Math.max(aBounds.y, bBounds.y);
        var maxx = Math.min(aBounds.x + aBounds.width, bBounds.x + bBounds.width);
        var maxy = Math.min(aBounds.y + aBounds.height, bBounds.y + bBounds.height);
        return (minx <= maxx && miny <= maxy);
    }

    function outsideRect(biggerOne, smallOne){

        return !containsRect(biggerOne, smallOne) && !rectangleOverlapped(biggerOne, smallOne);

    }

    function containsPoint(rect, point){
        var x = pick(point.x || point[0]);

        var y = pick(point.y || point[1]);

        return rect.x < x && rect.x + rect.width > x
                && rect.y < y && rect.y + rect.height > y;
    }

    function isSupportSVG(){
        return !!(window.SVGSVGElement);
    }

    function makeValueInRange(min, max, value){

        var rMin = Math.min(min, max);
        var rMax = Math.max(min, max);
        var gap = rMax - rMin;

        while(value < rMin){
            value += gap;
        }

        while(value > rMax){
            value -= gap;
        }

        return value;
    }

    function getValueInDomain(value, domain){

        return Math.min(Math.max(value, domain[0]), domain[1]);

    }

    function toRadian(degree){
        return Math.PI * (degree / 180);
    }

    function toDegree(radian){
        return radian * 180 / Math.PI;
    }

    //设计器那边传过来的formatter函数是字符串
    function getFormatterFunction(formatter){

        if(formatter == null || formatter == undefined){
            return null;
        }

        if(typeof formatter == 'string'){
            return (new Function("return "+ formatter))()
        }

        return formatter;
    }

    function clone(obj) {
        // Handle the 3 simple types, and null or undefined
        if (null == obj || "object" != typeof obj) return obj;

        // Handle Date
        if (obj instanceof Date) {
            var copy = new Date();
            copy.setTime(obj.getTime());
            return copy;
        }

        // Handle Array
        if (obj instanceof Array) {
            var copy = [];
            for (var i = 0, len = obj.length; i < len; ++i) {
                copy[i] = clone(obj[i]);
            }
            return copy;
        }

        if(obj instanceof String){
            return new String(obj);
        }

        // Handle Object
        if (obj instanceof Object) {
            var copy = {};
            for (var attr in obj) {
                if (obj.hasOwnProperty(attr)) copy[attr] = clone(obj[attr]);
            }
            return copy;
        }
    }

    function isEmpty(value){
        var result = value === "" || value === null || value === undefined;
        return result;
    }

    function isNull(v){
        return v == undefined || v == null
    }

    function showLightBox(options){

        var VanCharts = require('VanCharts');

        var body = document.getElementsByTagName("body")[0];

        var boxDiv = document.createElement('div');
        boxDiv.style.position = 'absolute';
        boxDiv.style.display = 'inline';
        boxDiv.style.top = '0px';
        boxDiv.style.left = '0px';
        boxDiv.style.width = '100%';
        boxDiv.style.height = '100%';
        boxDiv.style.zIndex = 330;
        if(isSupportSVG()){
            boxDiv.style.background = 'rgba(0,0,0,0.3)';
        }else{
            boxDiv.style.backgroundColor = 'black';
            boxDiv.style.filter = 'alpha(opacity=30)'
        }

        body.appendChild(boxDiv);

        var myWidth = boxDiv.clientWidth;
        var myHeight = boxDiv.clientHeight;

        var width = 970;
        var height = 600;

        var left = (myWidth - 970) / 2;
        var top = (myHeight - 600) / 2;


        var container = document.createElement('div');
        container.style.position = 'absolute';
        container.style.display = 'inline';
        container.style.top = top + 'px';
        container.style.left = left + 'px';
        container.style.width = width + 'px';
        container.style.height = height + 'px';
        container.style.zIndex = 331;

        if(isSupportSVG()){
            container.style.background = 'white';
            container.style.boxShadow = '0px 4px 50px rgba(0,0,0,0.5)';
        }else{
            container.style.backgroundColor = 'white';
            container.style.filter = 'alpha(opacity=100)';
        }

        body.appendChild(container);

        boxDiv.onclick = function(e){
            body.removeChild(boxDiv);
            body.removeChild(container);
        };

        container.onclick = function(e){
            e = e || window.event;
            if (e.stopPropagation){
                e.stopPropagation();
            }else{
                e.cancelBubble = true
            };
        }

        var vanCharts = VanCharts.init(container);
        var newOptions = clone(options);

        newOptions.tools.exitFullScreen = newOptions.tools.fullScreen;
        newOptions.tools.fullScreen = null;
        if(newOptions.legend){
            newOptions.legend.initState = false;
        }
        vanCharts.setOptions(newOptions);

        //ie8 bug
        container.style.top = top + 'px';
        container.style.left = left + 'px';
        container.boxDiv = boxDiv;
    }

    function hideLightBox(container){
        var parent = container.parentNode;

        if(parent){
            parent.removeChild(container);
            if(container.boxDiv){
                parent.removeChild(container.boxDiv);
            }
        }
    }

    function isIE() { //ie?
        if (!!window.ActiveXObject || "ActiveXObject" in window)
            return true;
        else
            return false;
    }

    function hasNotDefined(value){
        return value == null || value == undefined;
    }

    function hasDefined(value){
        return !hasNotDefined(value);
    }

    function indexInArray(array, value){
        if(!array.length){
            return -1;
        }

        for(var i = 0, len = array.length; i < len; i++){
            if(array[i] == value){
                return i;
            }
        }

        return -1;
    }

    function makeBounds(){

        var x = 0, y = 0, width = 0, height = 0;

        if(arguments.length == 2){

            var pos = arguments[0];
            var dim = arguments[1];

            x = pick(pos.x, pos[0]);
            y = pick(pos.y, pos[1]);

            width = pick(dim.width, dim[0]);
            height = pick(dim.height, dim[1]);

        }else if(arguments.length == 4){

            x = arguments[0];
            y = arguments[1];

            width = arguments[2];
            height = arguments[3];
        }

        return {
            x:x,
            y:y,
            width:width,
            height:height
        };

    }

    function distance(p1, p2){
        var x1 = pick(p1.x, p1[0]);
        var y1 = pick(p1.y, p1[1]);

        var x2 = pick(p2.x, p2[0]);
        var y2 = pick(p2.y, p2[1]);

        var detX = x1 - x2;
        var detY = y1 - y2;

        return Math.sqrt(detX * detX + detY * detY);
    }

    function isEmptyBounds(bounds){
        return bounds.width <= 0 || bounds.height <= 0;
    }

    function log(logBase, value){
        return Math.log(value) / Math.log(logBase);
    }

    function accAdd(arg1, arg2) {
        var r1 = 0;
        var r2 = 0;
        try {
            r1 = arg1.toString().split('.')[1].length;
        }
        catch(e) {}
        try {
            r2 = arg2.toString().split('.')[1].length;
        }
        catch(e) {}

        var m = Math.pow(10, Math.max(r1, r2));
        return (Math.round(arg1 * m) + Math.round(arg2 * m)) / m;
    }

    function accDiv(arg1,arg2){
        var s1 = arg1.toString();
        var s2 = arg2.toString();
        var m = 0;
        try {
            m = s2.split('.')[1].length;
        }
        catch(e) {}
        try {
            m -= s1.split('.')[1].length;
        }
        catch(e) {}

        return (s1.replace('.', '') - 0) / (s2.replace('.', '') - 0) * Math.pow(10, m);
    }

    function accMul(arg1, arg2){
        var m = 0, s1 = arg1.toString(), s2 = arg2.toString();

        try{
            m += s1.split(".")[1].length;
        }
        catch(e){}
        try{
            m += s2.split('.')[1].length;
        }
        catch(e){}
        return Number(s1.replace(".",""))*Number(s2.replace(".",""))/Math.pow(10,m);
    }


    function objectToArray(object){
        var result = [];
        for(var key in object){
            result.push(object[key]);
        }
        return result;
    }

    function date2int(date){

        if(typeof date == 'string'){
            date = new Date(Date.parse(date.replace(/-|\./g, "/")));
        }

        var baseDate = new Date("1970/01/01");

        if(typeof date == typeof(0)){
            return date;
        }else{
            return date.getTime() - baseDate.getTime();
        }

    }

    function int2date(milliseconds){

        var baseDate = new Date("1970/01/01");

        milliseconds = milliseconds || 0;

        return new Date(milliseconds + baseDate.getTime());
    }

    function object2date(obj){

        var date = obj;

        if(typeof date == 'string'){
            date = new Date(Date.parse(date.replace(/-|\./g, "/")));
        }else if(typeof date == typeof(0)){
            date = new Date(date)
        }

        return date;
    }

    function makeTranslate(pos){
        var x = pick(pos.x, pos[0]);
        var y = pick(pos.y, pos[1]);

        return isSupportSVG() ? 'translate(' + x + ',' + y + ')' : 't' + x + ',' + y;
    }

    function isImageMarker(markerType){
        var ALL_SYMBOLS = Constants.NULL_MARKER + Constants.CIRCLE + Constants.SQUARE + Constants.DIAMOND + Constants.TRIANGLE
            + Constants.CIRCLE_HOLLOW + Constants.SQUARE_HOLLOW + Constants.DIAMOND_HOLLOW + Constants.TRIANGLE_HOLLOW;

        return ALL_SYMBOLS.indexOf(markerType) == -1;
    }

    function isNullMarker(marker){
        return marker.symbol == Constants.NULL_MARKER;
    }

    function getDefaultMarkerSymbol(seriesIndex){
        var ALL_SYMBOLS = [Constants.CIRCLE, Constants.CIRCLE_HOLLOW, Constants.SQUARE, Constants.SQUARE_HOLLOW,
            Constants.DIAMOND, Constants.DIAMOND_HOLLOW, Constants.TRIANGLE, Constants.TRIANGLE_HOLLOW];

        return ALL_SYMBOLS[seriesIndex%ALL_SYMBOLS.length];
    }

    function addEvent(el, type, fn){

        if(el.attachEvent){
            el.attachEvent('on' + type, fn);
        }else if (el.addEventListener){
            el.addEventListener(type, fn, false);
        }
    }

    function splitWords (str) {
        str = str.trim ? str.trim() : str.replace(/^\s+|\s+$/g, '');
        return str.split(/\s+/);
    }

    function removeEvent(el, type, fn){

        if (el.removeEventListener) {
            el.removeEventListener(type, fn, false);
        } else if (el.attachEvent) {
            el.detachEvent('on' + type, fn);
        }

    }

    function dealFloatPrecision(v){
        return Math.abs(v) < 1e-6 ? 0 : v;
    }

    function getMousePos(ev, el){

        var event = ev.originalEvent || ev;

        event = event.touches ?  (event.touches.length ? event.touches.item(0) : event.changedTouches[0]) : event;

        var docElem = document.documentElement,
            box = el.getBoundingClientRect();

        var top = box.top  + (window.pageYOffset || docElem.scrollTop)  - (docElem.clientTop  || 0);
        var left = box.left + (window.pageXOffset || docElem.scrollLeft) - (docElem.clientLeft || 0);

        var chartX, chartY;
        if (event.pageX == undefined) {
            chartX = Math.max(event.x, event.clientX - left);
            chartY = event.y;
        } else {
            chartX = event.pageX - left;
            chartY = event.pageY - top;
        }

        return [chartX, chartY];
    }

    function hasTouch(){
        var doc = window.document;
        return doc && doc.documentElement.ontouchstart !== undefined;
    }

    function getArcPoint(r, radian){
        return [r * Math.sin(radian), -r * Math.cos(radian)]
    }

    function getArcByPoint (x, y) {
        return (2 * Math.PI - (Math.atan2(y, x) - Math.PI/2)) % (2 * Math.PI);
    }

    return {
        getMousePos:getMousePos,
        makeTranslate:makeTranslate,
        clone:clone,
        date2int:date2int,
        int2date:int2date,
        object2date:object2date,
        log:log,
        accAdd:accAdd,
        accDiv:accDiv,
        accMul:accMul,
        dealFloatPrecision:dealFloatPrecision,
        isEmpty:isEmpty,
        isEmptyBounds:isEmptyBounds,
        objectToArray:objectToArray,
        pick:pick,
        isNull:isNull,
        getTextDimension:getTextDimension,
        getTextHeight:getTextHeight,
        splitText:splitText,
        getTextDimensionWithRotation:getTextDimensionWithRotation,
        isArray:isArray,
        indexInArray:indexInArray,
        cssNormalization:cssNormalization,
        reformCssArray:reformCssArray,
        rectSubPixelOpt:rectSubPixelOpt,
        lineSubPixelOpt:lineSubPixelOpt,
        addArray:addArray,
        toFront:toFront,
        toBack:toBack,
        toFrontOfAll:toFrontOfAll,
        toBackOfAll:toBackOfAll,
        containsRect:containsRect,
        rectangleOverlapped:rectangleOverlapped,
        outsideRect:outsideRect,
        containsPoint:containsPoint,
        isSupportSVG:isSupportSVG,
        setTextStyle:setTextStyle,
        divRotate:divRotate,
        makeValueInRange:makeValueInRange,
        getValueInDomain:getValueInDomain,
        toRadian:toRadian,
        toDegree:toDegree,
        getFormatterFunction:getFormatterFunction,
        showLightBox:showLightBox,
        hideLightBox:hideLightBox,
        isIE:isIE,
        hasTouch:hasTouch,
        hasNotDefined:hasNotDefined,
        hasDefined:hasDefined,
        distance:distance,
        makeBounds:makeBounds,
        isImageMarker:isImageMarker,
        isNullMarker:isNullMarker,
        getDefaultMarkerSymbol:getDefaultMarkerSymbol,
        addEvent:addEvent,
        removeEvent:removeEvent,
        getArcPoint:getArcPoint,
        getTextWrapDimension:getTextWrapDimension,
        stamp:stamp,
        splitWords:splitWords,
        falseFn:falseFn,
        extend:extend,
        getArcByPoint:getArcByPoint
    };

});
/**
 * Created by eason on 15/5/15.
 * 定义所有图表都有的属性
 */
define('chart/BaseChart',['require','../utils/BaseUtils','../utils/QueryUtils','../utils/ColorUtils','../component/Base','../Constants','../component/Series','../utils/Formatter','../theme/options'],function(require){

    var BaseUtils = require('../utils/BaseUtils');
    var QueryUtils = require('../utils/QueryUtils');
    var ColorUtils = require('../utils/ColorUtils');
    var Base = require('../component/Base');
    var Constants = require('../Constants');
    var Series = require('../component/Series');
    var Formatter = require('../utils/Formatter');
    var Options = require('../theme/options');

    var SERIES = '{SERIES}';
    var X = '{X}';
    var Y = '{Y}';
    var SIZE = '{SIZE}';

    var NAME = 'NAME';
    var CATEGORY = 'CATEGORY';
    var SERIES = 'SERIES';
    var VALUE = 'VALUE';
    var PERCENT = 'PERCENT';

    //折线图和面积图计算延时
    function calculateT(det){
        return det < 0.5 ? Math.sqrt(det/2) : 1 - Math.sqrt(2 - 2*det)/2;
    }

    var BaseChart = Base.extend({

        //根据分类的位置确定各个方向上需要的系列
        _buildLocationMap:function(){

            var p2s = {};//位置到系列数组
            var series = this.vanchart.series;

            //封装series
            for(var seriesIndex = 0; seriesIndex < series.length; seriesIndex++){

                var sery = series[seriesIndex];

                if(sery.chart == this){
                    var baseAxis = sery.baseAxis;
                    var location = baseAxis.getPosition();
                    var axisIndex = baseAxis.getAxisIndex();

                    p2s[location] = p2s[location] || [];
                    p2s[location][axisIndex] = p2s[location][axisIndex] || [];

                    if(sery.visible){
                        p2s[location][axisIndex].push(sery);
                    }
                }
            }

            var stackMap = {};
            var location2Series = {};//上下左右对应的系列数组

            for(var position in p2s){
                var locationMap = [];

                var seriesArray = p2s[position] || [];

                //同一个方向有多个坐标轴
                for(var axisIndex = 0; axisIndex < seriesArray.length; axisIndex++) {

                    var seriesAxis = seriesArray[axisIndex];

                    if(seriesAxis && seriesAxis.length) {
                        var barIndex = 0;
                        for(var index = 0; index < seriesAxis.length; index++){

                            var sery = seriesAxis[index];

                            var key = sery.name;
                            if(sery.stack != null && sery.stack != undefined){
                                key = sery.stack + '';
                            }

                            if(sery.stack && stackMap[key] != null && stackMap[key] != undefined){
                                locationMap[axisIndex][stackMap[key]].push(sery);
                            }else{
                                stackMap[key] = barIndex;
                                locationMap[axisIndex] = locationMap[axisIndex] || [];
                                locationMap[axisIndex][barIndex] = [sery];
                                barIndex++;
                            }
                        }
                    }
                }

                //locationMap里可能会出现空
                var tmp = [];
                locationMap.forEach(function(sameAxis){
                    if(sameAxis){
                        tmp.push(sameAxis);
                    }
                });

                location2Series[position] = tmp;
            }

            return location2Series;
        },

        _calculateValueBasedPercentageAndTooltip:function(locationMap){

            for(var i = 0, len = locationMap.length; i < len; i++){

                var stackedSeries = locationMap[i];

                var stackedMap = {};

                for(var j = 0, count = stackedSeries.length; j < count; j++){

                    var points = stackedSeries[j].points;

                    for(var dIndex = 0, dCount = points.length; dIndex < dCount; dIndex++){
                        var point = points[dIndex];
                        var category = point.category;
                        stackedMap[category] = stackedMap[category] || [];
                        stackedMap[category].push(point);
                    }
                }


                for(var category in stackedMap){

                    var points = stackedMap[category];

                    this._dealStackedPoints(points);
                }
            }
        },

        _calculateCategoryBasedPercentageAndTooltip:function(locationMap){

            var unstackedSeries = [];

            for(var i = 0, len = locationMap.length; i < len; i++){
                var stackedSeries = locationMap[i];
                if(stackedSeries.length){
                    var sery = stackedSeries[0];
                    var stack = sery.stack || sery.stackByPercent;
                    stack ? this.dealStackedSeries(stackedSeries) : unstackedSeries.push(stackedSeries[0]);
                }
            }

            this.dealStackedSeries(unstackedSeries);
        },

        //处理堆积的点或者不堆积的其他的点
        _dealStackedPoints:function(points){
            this._calculatePercentage(points);

            this._mergeTooltipAttributes(points);

            this._calculateStackedValue(points);
        },



        dealStackedSeries:function(stackedSeries){

            var pointsInCate = [];

            for(var i = 0, len = stackedSeries.length; i < len; i++){
                var points = stackedSeries[i].points;

                for(var j = 0, count = points.length; j < count; j++){
                    pointsInCate[j] = pointsInCate[j] || [];

                    pointsInCate[j].push(points[j]);
                }
            }

            var chart = this;
            pointsInCate.forEach(function(points){
                chart._dealStackedPoints(points);
            });

        },

        mergeSeriesAttributes:function(sery){

        },

        mergeDataPointAttributes:function(){

        },

        _hideTooltip:function(){
            var tooltip = this.getTooltipComponent();
            tooltip.hide();
        },

        _mergeMarkerAttributes:function(point){

            var pointOption = point.pointOption;
            var seriesOption = point.series.seriesOption;

            var queryList = [
                pointOption,
                seriesOption,
                this.option.plotOptions[this.componentType],
                this.option.plotOptions,
                Options[this.componentType].plotOptions
            ];
            var marker = BaseUtils.clone(QueryUtils.queryList(queryList, 'marker'));

            //ie暂时不支持图片
            if((!BaseUtils.isSupportSVG() || BaseUtils.isIE()) && BaseUtils.isImageMarker(marker.symbol)){
                marker = BaseUtils.clone(marker);
                marker.symbol = Constants.CIRCLE;
            }

            var baseAxis = point.series.baseAxis;

            var axisReversed = baseAxis ? baseAxis.isAxisReversed() : false;

            var dCount = point.series.getDataPointCount();
            var dIndex = point.index;

            //标记点的颜色取的顺序：colors配色、plotOptions的标记点的颜色、范围图例、条件属性系列配色、条件属性系列标记点颜色、条件属性数据点的配色、条件属性数据点的标记点的配色
            marker.fillColor = marker.fillColor || this.vanchart.getDefaultSeriesColor(point.seriesName);

            // are following necessary?
            if(BaseUtils.hasDefined(this.option.plotOptions.marker)){
                marker.fillColor = this.option.plotOptions.marker.fillColor || marker.fillColor;
            }
            var rangeLegend = this.vanchart.getComponent(Constants.RANGE_LEGEND_COMPONENT);
            if(rangeLegend){
                marker.fillColor = rangeLegend.getColorWithSize(this.isForceBubble() ? point.y : point.size) || marker.fillColor;
            }
            marker.fillColor = seriesOption.color || marker.fillColor;
            if(BaseUtils.hasDefined(seriesOption.marker)) {
                marker.fillColor = seriesOption.marker.fillColor || marker.fillColor;
            }
            marker.fillColor = pointOption.color || marker.fillColor;
            if(BaseUtils.hasDefined(pointOption.marker)) {
                marker.fillColor = pointOption.marker.fillColor || marker.fillColor;
            }

            QueryUtils.merge(point, {
                marker:marker,
                delay:calculateT((axisReversed ? (dCount - dIndex - 1) : dIndex)/ dCount) * 800
            });
        },

        getTooltipPos:function(datum, divDim, event){

            if(!datum || !datum.tooltip){
                return;
            }

            var tooltip = datum.tooltip || datum.data.tooltip;
            var svgRoot = this.getVanchartRender().getRenderRoot();

            var leftTopPos;
            if(tooltip.follow){
                var pos = event ? this.getMousePos(event) : d3.mouse(svgRoot.node());

                leftTopPos = [pos[0] + 10, pos[1] + 10];
            }else{
                leftTopPos = this._getFixedPos(datum, divDim);
            }

            //调整位置
            var chartBounds = this.vanchart.getChartBounds();
            var top = chartBounds.y;
            var bottom = chartBounds.y + chartBounds.height;
            var left = chartBounds.x;
            var right = chartBounds.x + chartBounds.width;

            var x = leftTopPos[0];
            var y = leftTopPos[1];

            if(x < left){
                x += (left - x);
            }else if(x + divDim.width > right){
                x -= (x + divDim.width - right);
            }

            if(y < top){
                y += (top - y);
            }else if(y + divDim.height > bottom){
                y -= (y + divDim.height - bottom);
            }

            return [x, y];
        },

        _getArcPoint:function(r, radian){
            return [r * Math.sin(radian), -r * Math.cos(radian)]
        },

        isSupportAnimation:function(){
            var plotOptions = this.option.plotOptions;
            if(plotOptions){
                return !!plotOptions.animation;
            }
            return false;
        },

        _calculatePercentage:function(points){
            var total = 0;
            points.forEach(function(d){
                total += Math.abs(d.value);
            });

            total = total > 0 ? total : 1;
            points.forEach(function(point){
                point.setPercentage(Math.abs(point.value) / total);
            });
        },

        _calculateStackedValue:function(points){

            //todo remove this
            if(this.componentType == Constants.BUBBLE_CHART){
                return;
            }

            if(points && points.length){

                var byPercent = points[0].series.stackByPercent;
                var stack = points[0].series.stack || byPercent;
                var valueAxis = points[0].series.valueAxis;

                var preSumP = valueAxis ? valueAxis.getStartPosValue() : 0;
                var preSumN = valueAxis ? -valueAxis.getStartPosValue() : 0;

                for(var i = 0, count = points.length; i < count; i++){

                    var point = points[i];

                    if(stack){
                        var usedValue = byPercent ? point.percentage : point.value;

                        point.y = usedValue;

                        if(usedValue >= 0){
                            point.y0 = preSumP;
                            preSumP += usedValue;
                        }else{
                            point.y0 = preSumN;
                            preSumN += usedValue;
                        }
                    }else{
                        point.y = byPercent ? point.percentage : point.value;
                        point.y0 = valueAxis ? valueAxis.getStartPosValue() : 0;
                    }
                }
            }
        },

        isForceBubble:function(){
            return this.option.plotOptions.force;
        },

        isUpdateWithForce:function(){
            return this.isForceBubble() && BaseUtils.isSupportSVG() && this.isSupportAnimation();
        },

        getNormalTrendLineXYValues:function(sery){

            var xValues = [];
            var yValues = [];

            sery.points.sort(function(p1, p2){
                return p1.x - p2.x;
            });

            sery.points.forEach(function(point){

                if(!point.isNull){
                    xValues.push(point.x);
                    yValues.push(point.y);
                }

            });

            return [xValues, yValues, Constants.BOTTOM];
        },

        getBubbleTrendLineXYValues:function(sery){

            var xValues = [];
            var yValues = [];

            sery.points.sort(function(p1, p2){
                return p1.posX - p2.posX;
            });

            sery.points.forEach(function(point){

                if(!point.isNull){
                    xValues.push(point.posX);
                    yValues.push(point.posY);
                }

            });

            return [xValues, yValues, Constants.BOTTOM];
        },
        
        //默认是按照分类总值来排序
        orderData:function(){

            var orderType = this.option.orderType;

            var location2Series = this._buildLocationMap();

            for(var location in location2Series){

                var locationMap = location2Series[location];

                for(var index = locationMap.length - 1; index >= 0; index--){

                    var sameAxisLocationMap = locationMap[index];

                    if(sameAxisLocationMap && sameAxisLocationMap.length && sameAxisLocationMap[0].length){

                        var sery = sameAxisLocationMap[0][0];
                        var cateAxis = sery.baseAxis;

                        //排序是按照分类的总和排序,底轴是横轴排序无意义
                        if(cateAxis.type != Constants.CATEGORY_AXIS_COMPONENT){
                            continue;
                        }

                        var totalValue = {};

                        for(var i = 0, len = sameAxisLocationMap.length; i < len; i++){

                            var stackedArray = sameAxisLocationMap[i];

                            for(var j = 0, count = stackedArray.length; j < count; j++){
                                var sery = stackedArray[j];

                                for(var dataIndex = 0, dataCount = sery.points.length; dataIndex < dataCount; dataIndex++){

                                    var point = sery.points[dataIndex];

                                    if(BaseUtils.hasNotDefined(totalValue[point.category])){
                                        totalValue[point.category] = 0;
                                    }

                                    totalValue[point.category] += point.value;
                                }
                            }
                        }

                        //得到每个每类上的总值以后进行排序
                        var categories = [];
                        for(var category in totalValue){
                            categories.push({
                                key:category,
                                value:totalValue[category]
                            });
                        }

                        categories.sort(function(a, b){
                            return orderType == Constants.ASCENDING ? a.value - b.value : b.value - a.value;
                        });

                        var newCategories = [];
                        categories.forEach(function(a){
                            newCategories.push(a.key);
                        });

                        cateAxis.updateCategories(newCategories);
                        //更新className
                        for(var i = 0, len = sameAxisLocationMap.length; i < len; i++){

                            var stackedArray = sameAxisLocationMap[i];

                            for(var j = 0, count = stackedArray.length; j < count; j++){
                                var sery = stackedArray[j];
                                sery.updateClassName();
                            }
                        }
                    }
                }
            }
        },

        getVisibleChartData:function(){

            var data = [];

            var series = this.vanchart.series;

            for(var i = 0, len = series.length; i < len; i++){

                var sery = series[i];

                if(sery.type == this.componentType && sery.visible && sery.points.length){
                    for(var j = 0; j < sery.points.length; ++j) {
                        if (!sery.points[j].isNull) {
                            data.push(series[i]);
                            break;
                        }
                    }
                }
            }

            //考虑到堆积的效果才要排序
            var needSort = this.componentType == Constants.RADAR_CHART
                || this.componentType == Constants.BAR_CHART
                || this.componentType == Constants.COLUMN_CHART;


            return needSort ? data.sort(function(a, b){return b.index - a.index;}) : data;
        },

        getChartData:function(){
            var data = [];
            var series = this.vanchart.series;
            for(var i = 0, len = series.length; i < len; i++){
                if(series[i].type == this.componentType){
                    data.push(series[i]);
                }
            }
            return data;
        },

        _getSeriesInterpolate: function (options) {

            var optionsList;
            if (Array.isArray(options)) {
                optionsList = options;
            } else if (typeof options === 'object') {
                optionsList = [options];
            } else {
                throw new TypeError(options);
            }

            var step = QueryUtils.queryList(optionsList, 'step');
            var curve = QueryUtils.queryList(optionsList, 'curve');

            var interpolate = 'linear';
            if(step){
                interpolate = 'step-after'
            }else if(curve){
                interpolate = 'cardinal';
            }
            return interpolate;
        },

        _getLineSvg: function (interpolate) {
            return  d3.svg.line()
                .interpolate(interpolate)
                .x(function (d) {
                    return d.x;
                })
                .y(function (d) {
                    return d.y;
                })
                .defined(function (d) {
                    return !d.isNull;
                });
        },

        _getAreaSvg: function (interpolate) {
            return d3.svg.area()
                .interpolate(interpolate)
                .x(function (d) {
                    return d.x;
                })
                .y0(function(d){
                    return d.y0;
                })
                .y1(function (d) {
                    return d.y;
                })
                .defined(function(d){
                    return !d.isNull;
                });
        },


        _calculateBubbleLabelInfo:function(point, dataLabels, defaultPosition){
            dataLabels = dataLabels || {};
            var formatter = dataLabels.formatter;
            var useHtml = dataLabels.useHtml;
            if(!formatter){
                return {};
            }

            var content = [];
            if(typeof formatter == 'object'){

                var identifier = formatter.identifier;

                if(identifier.indexOf(SERIES) != -1){
                    var seriesString = Formatter.format(point.seriesName, formatter.seriesFormat);
                    var seriesStyle = point.getCategorySeriesStyle(dataLabels, defaultPosition);
                    var seriesDim = BaseUtils.getTextDimension(seriesString, seriesStyle, useHtml);

                    content.push({
                        text:seriesString,
                        style:seriesStyle,
                        dim:seriesDim
                    });
                }

                if(identifier.indexOf(X) != -1 || identifier.indexOf(Y) != -1 || identifier.indexOf(SIZE) != -1){
                    var text = this._getXYSizeString(point, formatter, identifier);
                    var style = point.getValuePercentageStyle(dataLabels, defaultPosition);
                    var dim = BaseUtils.getTextDimension(text, style, useHtml);

                    content.push({
                        text:text,
                        style:style,
                        dim:dim
                    });
                }

            }else{
                point.pushCustomLabelContent(formatter, dataLabels, useHtml, content, defaultPosition);
            }

            var labelDim = point.calculateTextDim(content);

            QueryUtils.merge(point, {
                labelContent: content,
                labelDim: labelDim
            }, true);
        },

        _getXYSizeString:function(point, formatter, identifier) {
            var xString = Formatter.format(point.category, formatter.XFormat);
            var yString = Formatter.format(point.value, formatter.YFormat);
            var sizeString = point.size == '-' ? '-' : Formatter.format(point.size, formatter.sizeFormat);

            var text = '';

            if(identifier.indexOf(X) != -1 || identifier.indexOf(Y) != -1){
                text = '(';
                if(identifier.indexOf(X) != -1){
                    text += xString;
                    if(identifier.indexOf(Y) != -1){
                        text = text + ',' + yString;
                    }
                    text += ')';
                } else {
                    text += yString;
                    text += ')';
                }
                text += ' ';
            }

            if(identifier.indexOf(SIZE) != -1 && sizeString != '-'){
                text += sizeString;
            }
            return text;
        },

        _mergeTooltipAttributes:function(points){
            for(var i = 0, len = points.length; i < len; i++){
                var point = points[i];
                this.mergeSinglePointTooltipAttr(point, points);
            }
        },

        mergeSinglePointTooltipAttr:function(point, points){
            points = points || [point];

            var tooltip = point.tooltip;

            point.tooltipText = tooltip && tooltip.enabled ? this._calculateTooltipContent(tooltip, point, points) : null;
            point.points = points;
        },

        _calculateTooltipContent:function(tooltip, data, points){

            var formatter = tooltip.formatter;

            if(!formatter){
                return "";
            }

            if(typeof formatter == 'object'){

                var style = tooltip.style;
                var label = formatter.identifier;
                var self = this;

                var content = '';

                if(tooltip.shared){
                    content += this._createCategoryLine(data, label, style, formatter);

                    points.forEach(function(point){

                        content += '<span style="font-size:12px; color: ' + point.color + '">'+'&#9679  '+'</span>';

                        content += self._createSeriesLine(point, label, style, formatter);

                        content += '<br />';
                    });
                }else{
                    content += this._createCategoryLine(data, label, style, formatter);
                    content += self._createSeriesLine(data, label, style, formatter);
                }
                return content;
            }else{
                return BaseUtils.getFormatterFunction(formatter).call(data);
            }
        },

        _createCategoryLine:function(data, label, style, formatter){
            if(data.series.chart.componentType == Constants.BUBBLE_CHART && !this.isForceBubble()){

                return this._createBubbleTooltipSeriesLine(data, label, style, formatter);

            }else{
                var content = '';

                if(label.indexOf(CATEGORY) != -1){
                    content = Formatter.format(data.category, formatter.categoryFormat);
                }

                if(label.indexOf(NAME) != -1){
                    content = Formatter.format(data.name, formatter.nameFormat);
                }

                if(content){
                    content = (style ? '<span>' : Constants.TOOLTIP_CATEGORY_STYLE) + content +'</span>';
                    content += '<br />';
                }

                return content;
            }
        },

        _createSeriesLine:function(data, label, style, formatter){

            if(data.series.chart.componentType == Constants.BUBBLE_CHART && !this.isForceBubble()){

                return this._createBubbleTooltipXYSizeLine(data, label, style, formatter);

            }else{

                var content = '';
                var seriesString = Formatter.format(data.seriesName, formatter.seriesFormat);
                var valueString = Formatter.format(data.value, formatter.valueFormat);
                var percentString = Formatter.format(data.percentage, formatter.percentFormat);

                if(label.indexOf(SERIES) != -1 && !BaseUtils.isEmpty(seriesString)){

                    if(label.indexOf(VALUE) != -1 || label.indexOf(PERCENT) != -1){
                        seriesString += ':';
                    }

                    content += (style ? '<span >' : Constants.TOOLTIP_SERIES_STYLE) + seriesString +'</span>';
                }

                if(label.indexOf(VALUE) != -1 && label.indexOf(PERCENT) != -1){
                    content += (style ? '<span>' : Constants.TOOLTIP_VALUE_STYLE) + valueString + '  ' + percentString + '</span>';
                }else if(label.indexOf(VALUE) != -1){
                    content += (style ? '<span>' : Constants.TOOLTIP_VALUE_STYLE) + valueString + '</span>';
                }else if(label.indexOf(PERCENT) != -1){
                    content += (style ? '<span>' : Constants.TOOLTIP_VALUE_STYLE) + percentString +'</span>';
                }

                return content;
            }

        },

        //提示的第一行：气泡的系列
        _createBubbleTooltipSeriesLine:function(data, label, style, formatter){
            var content = '';

            if(label.indexOf(SERIES) != -1){

                var seriesString = Formatter.format(data.seriesName, formatter.seriesFormat);

                content += (style ? '<span >' : Constants.TOOLTIP_SERIES_STYLE) + seriesString +'</span>';

                content += '<br />';
            }

            return content;
        },

        //提示的第二行：气泡的X、Y、SIZE
        _createBubbleTooltipXYSizeLine:function(data, label, style, formatter){

            var content = '';
            if(label.indexOf(X) != -1 || label.indexOf(Y) != -1 || label.indexOf(SIZE) != -1) {
                var text = this._getXYSizeString(data, formatter, label);
                content += (style ? '<span>' : Constants.TOOLTIP_VALUE_STYLE) + text + '</span>';
            }

            return content;
        },

        getClosestPoint:function(){
            
        }
        
    });

    return BaseChart;
});
/**
 * Created by eason on 15/7/13.
 */

define('chart/Pie',['require','../Constants','../utils/BaseUtils','./BaseChart','../utils/QueryUtils','../utils/BoundsManager','../theme/options','../ChartLibrary'],function(require){

    var RIGHT_TOP = 'right-top';
    var RIGHT_BOTTOM = 'right-bottom';
    var LEFT_TOP = 'left-top';
    var LEFT_BOTTOM = 'left-bottom';

    var CIRCLE = 2 * Math.PI;
    var HOVER_PERCENT = 1.1;
    var MAGIC_DET = 3;//很奇怪的3px

    var STEP = Math.PI / 180;

    var LINE_LABEL_GAP = 2;

    var DECREASE = [0.75,0.7,0.65,0.6,0.55];

    var Constants = require('../Constants');
    var BaseUtils = require('../utils/BaseUtils');
    var BaseChart = require('./BaseChart');
    var QueryUtils = require('../utils/QueryUtils');
    var BoundsManager = require('../utils/BoundsManager');
    var Options = require('../theme/options');

    var Pie = BaseChart.extend({

        constructor:Pie,

        mergeSeriesAttributes:function(series){

            var queryList = [
                series.seriesOption,
                this.option.plotOptions[this.componentType],
                this.option.plotOptions,
                Options[this.componentType].plotOptions
            ];

            var innerRadius = QueryUtils.queryList(queryList, 'innerRadius') || 0;

            if(parseFloat(innerRadius) == 0){
                innerRadius = 0;
            }

            var center = QueryUtils.queryList(queryList, 'center');

            var startAngle = QueryUtils.queryList(queryList, 'startAngle') || 0;
            var endAngle = QueryUtils.queryList(queryList, 'endAngle') || 360;

            if(startAngle > endAngle){
                startAngle -= 360;
            }else if(startAngle == endAngle){
                startAngle = 0;
                endAngle = 360;
            }

            var roseType = QueryUtils.queryList(queryList, 'roseType');
            var rotatable = QueryUtils.queryList(queryList, 'rotatable');
            var radius = QueryUtils.queryList(queryList, 'radius') ;
            var style = this.option.style;

            QueryUtils.merge(series, {
                center:center,
                radius:radius,
                innerRadius:innerRadius,
                startAngle:startAngle,
                endAngle:endAngle,
                roseType:roseType,
                rotatable:rotatable,
                style:style
            }, true);

        },

        mergeDataPointAttributes:function(point){

            QueryUtils.merge(point,{
                visible:BaseUtils.pick(point.pointOption.visible, true),
                rotate:0
            }, true);

        },

        doLayout:function(){

            var series = this.getVisibleChartData();
            var plotOptions = this.option.plotOptions;
            var self = this;

            series.forEach(function(sery){

                var queryList = [
                    sery.seriesOption,
                    plotOptions[sery.type],
                    plotOptions,
                    Options[sery.type].plotOptions
                ];

                //重置radius属性
                sery.radius = QueryUtils.queryList(queryList, 'radius');

                self._dealStackedPoints(sery.visiblePoints);

                var pieLayout = d3.layout.pie()
                    .value(function(d){
                        return sery.roseType == Constants.SAME_ARC ? 1 : Math.abs(d.value);
                    })
                    .startAngle(BaseUtils.toRadian(sery.startAngle))
                    .endAngle(BaseUtils.toRadian(sery.endAngle))
                    .sort(null);

                sery.visiblePoints.forEach(function(point){
                    point.lastShape = self._getArcData(point);
                });

                var pieData = pieLayout(sery.visiblePoints);
                pieData.forEach(function(slice){
                    var point = slice.data;
                    point.startAngle = isNaN(slice.startAngle) ? 0 : slice.startAngle;
                    point.endAngle = isNaN(slice.endAngle) ? 0: slice.endAngle;
                });
            });

            var plotBounds = this.vanchart.getPlotBounds();

            var seriesBounds = this._calculateSeriesBounds();

            for(var i = 0, len = series.length; i < len; i++){
                var sery = series[i];
                var bounds = seriesBounds[sery.name];
                var fixedState = bounds;
                var radius = 0;
                var centerX = 0;
                var centerY = 0;

                if(fixedState == 'fixed'){
                    var centerX = series[i].center[0];
                    var centerY = series[i].center[1];

                    if(series[i].center[0].indexOf('%') != -1){
                        centerX = this._getPercentValue(series[i].center[0], this.vanchart.chartWidth());
                        centerY = this._getPercentValue(series[i].center[1], this.vanchart.chartHeight());
                    }

                    if(sery.radius){
                        radius = sery.radius;
                    }else{
                        //自定义了位置但是没自定义大小
                        var left = centerX - plotBounds.x;
                        var right = plotBounds.x + plotBounds.width - centerX;
                        var top = centerY - plotBounds.y;
                        var bottom = plotBounds.y + plotBounds.height - centerY;
                        radius = Math.min(left, right, top, bottom);
                    }

                    centerX -= plotBounds.x;
                    centerY -= plotBounds.y;

                    bounds = {x:centerX - radius, y:centerY - radius, width:radius * 2, height:radius*2};

                }else{
                    radius = Math.min(bounds.width/2, bounds.height/2);
                    centerX = bounds.x + bounds.width/2;
                    centerY = bounds.y + bounds.height/2;
                }

                QueryUtils.merge(sery,{
                    fixedState:fixedState,
                    bounds:bounds,
                    radius:radius,
                    centerX:centerX,
                    centerY:centerY
                }, true);

                //计算标签的位置,并且更新半径
                this._calculateLabelPos(sery);
            }
        },

        _getArcData:function(d){
            if(BaseUtils.hasDefined(d.startAngle)){
                return {
                    startAngle: d.startAngle,
                    endAngle: d.endAngle,
                    radius: d.radius
                };
            }
        },

        _getFixedPos:function(datum, divDim){

            var plotBounds = this.getPlotBounds();

            var pieConfig = datum.series;

            var translateX = pieConfig.centerX;
            var translateY = pieConfig.centerY;

            var centerAngle = this.getCenterAngle(datum);
            var radius = datum.radius * HOVER_PERCENT;

            var centerX = radius * Math.sin(centerAngle) + translateX + plotBounds.x;
            var centerY = radius * Math.cos(centerAngle + Math.PI) + translateY + plotBounds.y;

            if(centerAngle < Math.PI / 2){
                centerY -= divDim.height;
            }else if(centerAngle >= Math.PI && centerAngle < 3 * Math.PI / 2){
                centerX -= divDim.width;
            }else if(centerAngle >= 3 * Math.PI / 2 && centerAngle < CIRCLE){
                centerY -= divDim.height;
                centerX -= divDim.width;
            }

            return [centerX, centerY];
        },

        recalculateLabelPos:function(pieConfig, rotate){

            var points = pieConfig.visiblePoints;

            for(var i = 0, len = points.length; i < len; i++){
                points[i].labelPos = null;
                points[i].rotate = rotate;
            }

            var outPoints = [];
            var inPoints = [];

            for(var i = 0, len = points.length; i < len; i++){
                var point = points[i];
                var dataLabels = point.dataLabels;
                if(dataLabels && dataLabels.enabled){
                    dataLabels.align == Constants.OUTSIDE ? outPoints.push(point) : inPoints.push(point);
                }
            }

            this._calculateOutsideLabelBounds(outPoints, pieConfig, true);
            this._calculateLeadLineStartPos(outPoints);
            this._calculateInsideLabelBounds(inPoints, pieConfig);
        },

        _calculateLabelPos:function(pieConfig){

            var roseType = pieConfig.roseType;
            var points = pieConfig.visiblePoints;

            var outPoints = [];
            var inPoints = [];

            for(var i = 0, len = points.length; i < len; i++){
                var point = points[i];
                var dataLabels = point.dataLabels;
                if(dataLabels && dataLabels.enabled){
                    dataLabels.align == Constants.OUTSIDE ? outPoints.push(point) : inPoints.push(point);
                }
            }

            //这步会改变半径
            this._calculateOutsideLabelBounds(outPoints, pieConfig);

            if (pieConfig.fixedState !== 'fixed') {
                //有标签在里面,没有标签在外面或者不显示标签
                if ((inPoints.length && !outPoints.length) || (!inPoints.length && !outPoints.length)) {
                    pieConfig.radius = pieConfig.radius / HOVER_PERCENT - MAGIC_DET;
                }
            }

            //内径可能是半径的占比
            this._calculateInnerRadius(pieConfig);

            //玫瑰图根据最后的半径值来确定不同扇形的半径
            if(roseType){
                var points = pieConfig.visiblePoints;
                var radiusGap = pieConfig.radius - pieConfig.innerRadius;
                var maxValue = 0;
                points.forEach(function(d){
                    maxValue = Math.max(maxValue, Math.abs(d.value));
                });

                var sizePerValue = radiusGap / maxValue;

                //maxValue为0之类的情况
                if(isNaN(sizePerValue) || !isFinite(sizePerValue)){
                    sizePerValue = 0;
                }

                points.forEach(function(d){
                    d.radius = pieConfig.innerRadius + sizePerValue * Math.abs(d.value);
                })
            }else{
                var usedR = pieConfig.radius;
                pieConfig.visiblePoints.forEach(function(d){
                    d.radius = usedR;
                });
            }

            this._calculateLeadLineStartPos(outPoints);

            //确定半径以后计算标签在内的标签
            this._calculateInsideLabelBounds(inPoints, pieConfig);
        },

        _calculateInnerRadius:function(pieConfig){
            var innerRadius = pieConfig.innerRadius;

            var radius = pieConfig.radius;

            if(typeof innerRadius == 'string'){
                if(innerRadius.indexOf('%') != -1){
                    innerRadius = parseFloat(innerRadius) * radius / 100;
                }else{
                    innerRadius = parseFloat(innerRadius);
                }
            }

            pieConfig.innerRadius = innerRadius;

            var points = pieConfig.visiblePoints;

            points.forEach(function(d){
                d.innerRadius = innerRadius;
            });

        },

        _calculateLeadLineStartPos:function(outPoints){

            var self = this;
            outPoints.forEach(function(arcPoint){

                var radius = arcPoint.radius;
                var centerAngle = self.getCenterAngle(arcPoint);

                if(arcPoint.labelPos){
                    arcPoint.labelPos.startPos = {
                        x:(radius + 1)*Math.sin(centerAngle),
                        y: (radius + 1) * Math.cos(centerAngle + Math.PI)
                    }
                }

            });
        },

        _calculateOutsideLabelBounds:function(outPoints, pieConfig, isRecalculate){
            if(!outPoints.length){
                return ;
            }

            //清空计算结果
            outPoints.forEach(function(arc){
                arc.labelPos = null;
            });

            isRecalculate = isRecalculate || false;

            //先划分区域
            var rightTop = [];
            var rightBottom = [];
            var leftTop = [];
            var leftBottom = [];

            for(var i = 0, len = outPoints.length; i < len; i++){
                var point = outPoints[i];

                var center = this.getCenterAngle(point);

                if(center < Math.PI / 2){
                    rightTop.push(point)
                }else if(center >= Math.PI / 2 && center < Math.PI){
                    rightBottom.push(point);
                }else if(center >= Math.PI && center < 3 * Math.PI /2){
                    leftBottom.push(point);
                }else{
                    leftTop.push(point);
                }
            }

            isRecalculate ? this._calculateArcR(pieConfig, rightTop, rightBottom, leftTop, leftBottom)
                :this._initCalculateArcR(pieConfig, rightTop, rightBottom, leftTop, leftBottom);
        },

        _initCalculateArcR:function(pieConfig, rightTop, rightBottom, leftTop, leftBottom){
            if (pieConfig.fixedState === 'fixed') {
                var dim = {width: Number.MAX_VALUE, height: Number.MAX_VALUE};
                this._testIfAllFit(pieConfig.radius, dim, rightTop, rightBottom, leftTop, leftBottom, true);
            } else {
                var originR = pieConfig.radius;
                var usedR = originR * 0.5;

                var bounds = pieConfig.bounds;
                var dim = {width: bounds.width / 2, height: bounds.height / 2};

                //半径的下界都不能放下的话
                if (!this._testIfAllHorizontalFit(usedR, dim, rightTop, rightBottom, leftTop, leftBottom)) {
                    pieConfig.radius = usedR;

                    //计算位置
                    this._testIfAllFit(usedR, dim, rightTop, rightBottom, leftTop, leftBottom)

                    return;
                }

                for (var i = 0, len = DECREASE.length; i < len; i++) {
                    usedR = originR * DECREASE[i];

                    if (this._testIfAllFit(usedR, dim, rightTop, rightBottom, leftTop, leftBottom)) {
                        pieConfig.radius = usedR;
                        return;
                    }
                }

                this._testIfAllFit(usedR, dim, rightTop, rightBottom, leftTop, leftBottom, true);
                pieConfig.radius = usedR;
            }
        },

        _calculateArcR:function(pieConfig, rightTop, rightBottom, leftTop, leftBottom){
            if (pieConfig.fixedState === 'fixed') {
                var dim = {width: Number.MAX_VALUE, height: Number.MAX_VALUE};
                this._testIfAllFit(pieConfig.radius, dim, rightTop, rightBottom, leftTop, leftBottom, true);
            } else {
                var usedR = pieConfig.radius;
                var bounds = pieConfig.bounds;
                var dim = {width: bounds.width / 2, height: bounds.height / 2};

                this._testIfAllFit(usedR, dim, rightTop, rightBottom, leftTop, leftBottom, true);
            }
        },

        _testIfAllHorizontalFit:function(usedR, dim, rightTop, rightBottom, leftTop, leftBottom){
            var tmpRightTop = this._ignoreMinArcLabel(usedR, rightTop);
            var tmpRightBottom = this._ignoreMinArcLabel(usedR, rightBottom);
            var tmpLeftTop = this._ignoreMinArcLabel(usedR, leftTop);
            var tmpLeftBottom = this._ignoreMinArcLabel(usedR, leftBottom);

            var rightTop = this._testIfHorizontalFit(rightTop, tmpRightTop, usedR, dim, RIGHT_TOP);
            var rightBottom = this._testIfHorizontalFit(rightBottom, tmpRightBottom, usedR, dim, RIGHT_BOTTOM);
            var leftTop = this._testIfHorizontalFit(leftTop, tmpLeftTop, usedR, dim, LEFT_TOP);
            var leftBottom = this._testIfHorizontalFit(leftBottom, tmpLeftBottom, usedR, dim, LEFT_BOTTOM);

            return rightTop && rightBottom && leftTop && leftBottom;
        },

        _testIfHorizontalFit:function(arcPoints, usedR, dim, location){

            var outerR = usedR * 1.2;
            var hWidth = usedR * 0.1;
            var allLabelBounds = BaseUtils.makeBounds(-dim.width, dim.height, dim.width * 2, dim.height * 2);

            for(var i = 0, len = arcPoints.length; i < len; i++){

                var point = arcPoints[i];

                var labelDim = point.labelDim;

                var centerAngle = this.getCenterAngle(point);

                var centerX = outerR * Math.sin(centerAngle);

                var centerY = outerR * Math.cos(centerAngle + Math.PI);

                var bounds = this._getLabelBounds(location, centerX, centerY, hWidth, labelDim);

                if(bounds.x < allLabelBounds.x || (bounds.x + bounds.width > allLabelBounds.x + allLabelBounds.width)){
                    return false;
                }
            }

            return true;
        },

        _testIfAllFit:function(usedR, dim, rightTop, rightBottom, leftTop, leftBottom, forceFloat){

            var tmpRightTop = this._ignoreMinArcLabel(usedR, rightTop);
            var tmpRightBottom = this._ignoreMinArcLabel(usedR, rightBottom);
            var tmpLeftTop = this._ignoreMinArcLabel(usedR, leftTop);
            var tmpLeftBottom = this._ignoreMinArcLabel(usedR, leftBottom);

            var rightTop = this._testIfFit(rightTop, tmpRightTop, usedR, dim, RIGHT_TOP, forceFloat);
            var rightBottom = this._testIfFit(rightBottom, tmpRightBottom, usedR, dim, RIGHT_BOTTOM, forceFloat);
            var leftTop = this._testIfFit(leftTop, tmpLeftTop, usedR, dim, LEFT_TOP, forceFloat);
            var leftBottom = this._testIfFit(leftBottom, tmpLeftBottom, usedR, dim, LEFT_BOTTOM, forceFloat);

            return rightTop && rightBottom && leftTop && leftBottom;
        },

        _testIfFit:function(totalPoints, arcPoints, usedR, dim, location, forceFloat){

            return (totalPoints.length == arcPoints.length && !forceFloat) ? this._testFixedPositionIfFit(arcPoints, usedR, dim, location)
                :this._testFloatPositionIfFit(arcPoints, usedR, dim, location)

        },

        _testFixedPositionIfFit:function(arcPoints, usedR, dim, location){

            var manager = new BoundsManager();

            var outerR = usedR * 1.2;
            var hWidth = usedR * 0.1;
            var allLabelBounds = BaseUtils.makeBounds(-dim.width, -dim.height, dim.width * 2, dim.height * 2);

            for(var i = 0, len = arcPoints.length; i < len; i++){

                var point = arcPoints[i];

                var labelDim = point.labelDim;

                var centerAngle = this.getCenterAngle(point);

                var centerX = outerR * Math.sin(centerAngle);

                var centerY = outerR * Math.cos(centerAngle + Math.PI);

                var bounds = this._getLabelBounds(location, centerX, centerY, hWidth, labelDim);

                if(manager.isOverlapped(bounds) || !BaseUtils.containsRect(allLabelBounds, bounds)){
                    return false;
                }else{
                    manager.addBounds(bounds);

                    var midPos = {x:centerX, y:centerY};
                    var endPos;
                    if(location == RIGHT_TOP || location == RIGHT_BOTTOM){
                        endPos = {x:centerX + hWidth, y:centerY};
                    }else{
                        endPos = {x:centerX - hWidth, y:centerY};
                    }
                    point.labelPos = {
                        x:bounds.x,
                        y:bounds.y,

                        midPos:midPos,
                        endPos:endPos
                    };
                }
            }

            return true;
        },

        _testFloatPositionIfFit:function(arcPoints, usedR, dim, location){

            var fromStart = this._findNiceBoundsFromStartAngle(arcPoints, usedR, dim, location);

            if(!fromStart){

                arcPoints.forEach(function(arc){
                    arc.labelPos = null;
                });

                return this._findNiceBoundsFromEndAngle(arcPoints, usedR, dim, location);
            }

            return fromStart;
        },

        _findNiceBoundsFromStartAngle:function(arcPoints, usedR, dim, location){
            return this._findNiceBounds(true, arcPoints, usedR, dim, location);
        },

        _findNiceBoundsFromEndAngle:function(arcPoints, usedR, dim, location){
            return this._findNiceBounds(false, arcPoints, usedR, dim, location);
        },

        _findNiceBounds:function(isAngleIncrease, arcPoints, usedR, dim, location){

            var outerR = usedR * 1.2;
            var hWidth = usedR * 0.1;

            var manager = new BoundsManager();
            var angleRange = this._getStartAndEndAngle(location);

            var allLabelBounds = this._getPossibleLabelBoundsByLocation(dim, location);


            var searchEnd = isAngleIncrease ? angleRange.endAngle : angleRange.startAngle;
            var step = isAngleIncrease ? STEP : -STEP;


            var found = true;
            for(var i = 0, len = arcPoints.length; i < len && found; i++){

                var pointIndex = isAngleIncrease ? i : len - i - 1;

                var point = arcPoints[pointIndex];

                var labelDim = point.labelDim;

                var centerAngle = this.getCenterAngle(point);

                var centerX = outerR * Math.sin(centerAngle);

                var centerY = outerR * Math.cos(centerAngle + Math.PI);

                var bounds = this._getLabelBounds(location, centerX, centerY, hWidth, labelDim);

                if(manager.isOverlapped(bounds) || !BaseUtils.containsRect(allLabelBounds, bounds)){
                    found = false;
                    for(var angle = centerAngle + step; (isAngleIncrease ? angle < searchEnd : angle > searchEnd); angle += step){

                        centerX = outerR * Math.sin(angle);
                        centerY = outerR * Math.cos(angle + Math.PI);

                        bounds = this._getLabelBounds(location, centerX, centerY, hWidth, labelDim);

                        if(!manager.isOverlapped(bounds) && BaseUtils.containsRect(allLabelBounds, bounds)){
                            found = true;
                            break;
                        }
                    }
                }

                if(found){

                    var midPos = {x:centerX, y:centerY};
                    var endPos;
                    if(location == RIGHT_TOP || location == RIGHT_BOTTOM){
                        endPos = {x:centerX + hWidth, y:centerY};
                    }else{
                        endPos = {x:centerX - hWidth, y:centerY};
                    }

                    manager.addBounds(bounds);
                    point.labelPos = {
                        x:bounds.x,
                        y:bounds.y,

                        midPos:midPos,
                        endPos:endPos
                    };
                }
            }

            return found;
        },

        _getStartAndEndAngle:function(location){
            switch (location){
                case RIGHT_TOP:
                    return {startAngle:0, endAngle:Math.PI/2};
                case RIGHT_BOTTOM:
                    return {startAngle:Math.PI/2, endAngle:Math.PI};
                case LEFT_BOTTOM:
                    return {startAngle:Math.PI, endAngle:3 * Math.PI / 2};
                case LEFT_TOP:
                    return {startAngle:3 * Math.PI / 2, endAngle: 2 * Math.PI};
            }
        },

        _getLabelBounds:function(location, centerX, centerY, hWidth, labelDim){
            var x,y;
            if(location == RIGHT_TOP || location == RIGHT_BOTTOM){
                x = centerX + hWidth + LINE_LABEL_GAP;
            }else{
                x = centerX - hWidth - LINE_LABEL_GAP - labelDim.width;
            }

            y = centerY - labelDim.height/2;

            return {x:x, y:y, width:labelDim.width, height:labelDim.height};
        },

        getCenterAngle:function(point){
            var centerAngle = point.rotate + (point.startAngle + point.endAngle) / 2 ;
            return BaseUtils.makeValueInRange(0, 2*Math.PI, centerAngle);
        },

        //相对于圆心的标签可占用大小的坐标
        _getPossibleLabelBoundsByLocation:function(dim, location){
            var x , y;
            var width = dim.width;
            var height = dim.height;

            switch (location){
                case RIGHT_TOP:
                    x = 0;
                    y = -height;
                    break;
                case RIGHT_BOTTOM:
                    x = y = 0;
                    break;
                case LEFT_BOTTOM:
                    x = -width;
                    y = 0;
                    break;
                case LEFT_TOP:
                    x = -width;
                    y = -height;
                    break;
            }

            return {x:x, y:y, width:width, height:height};
        },

        //从高度判断是否能够放下标签
        _ignoreMinArcLabel:function(radius, arcs){

            var totalHeight = 0;

            for(var i = 0, len = arcs.length; i < len; i++){
                var labelDim = arcs[i].labelDim;
                totalHeight += labelDim.height;
            }

            //高度不够，需要省略一些标签
            if(radius < totalHeight){

                var det = totalHeight - radius;

                arcs.sort(function(a, b){
                    return a.value - b.value;
                });

                for(var i = 0, len = arcs.length; i < len; i++){
                    if(det < 0){
                        break;
                    }
                    var labelHeight = arcs[i].labelDim.height;
                    det -= labelHeight;
                }

                arcs = arcs.slice(i, arcs.length);
            }

            arcs.sort(function(a, b){
                var startA = a.startAngle;
                var startB = b.startAngle;

                if(startA < startB){
                    return -1;
                }else if(startA > startB){
                    return 1;
                }else{
                    return 0;
                }
            });

            return arcs;
        },

        //算出来的bounds都是相对于centerX和centerY
        _calculateInsideLabelBounds:function(inPoints, pieConfig){
            var innerRadius = pieConfig.innerRadius;

            for(var i = 0, len = inPoints.length; i < len; i++){
                var point = inPoints[i];
                var radius = point.radius;

                var centerAngle = this.getCenterAngle(point);

                var tmpR = innerRadius + (radius - innerRadius) / 2;

                var center = this._getArcPoint(tmpR, centerAngle);

                var x = center[0] - point.labelDim.width/2;
                var y = center[1] - point.labelDim.height/2;

                point.labelPos = {x:x, y:y};
            }
        },

        //计算每个系列的边界
        _calculateSeriesBounds:function(){
            var series = this.getVisibleChartData();
            var plotBounds = this.vanchart.getPlotBounds();
            var seriesBounds = {};

            var usedSize = 0;
            var fixedSize = 0;
            for(var i = 0, len = series.length; i < len; i++){
                if(!series[i].center && series[i].radius){
                    usedSize += (series[i].radius || 0) * 2;
                    fixedSize++;
                }
            }

            //平均半径
            var averageRadius = plotBounds.width / Math.max(1, series.length - fixedSize);
            averageRadius /= 2;

            var leftBounds = {x:0, y:0, width:plotBounds.width, height:plotBounds.height};
            for(var i = 0, len = series.length; i < len; i++){
                if(series[i].center){
                    seriesBounds[series[i].name] = 'fixed';
                }else{
                    var size = (series[i].radius || averageRadius) * 2;
                    seriesBounds[series[i].name] = {
                        x:leftBounds.x,
                        y:leftBounds.y,
                        width:size,
                        height:leftBounds.height
                    };

                    leftBounds.x += size;
                    leftBounds.width -= size;
                }
            }

            return seriesBounds;
        },

        orderData:function(){
            var series = this.getVisibleChartData();
            var chart = this;
            series.forEach(function(sery){

                sery.points.sort(function(sliceA, sliceB){

                    var valueA = sliceA.value;

                    var valueB = sliceB.value;

                    return chart.option.orderType == Constants.ASCENDING ? valueA - valueB : valueB - valueA;
                });

                sery.updateVisiblePoints();
            });

            this.option.byClassName = false;
        },

        onDrag:function(event){
            if(this._draggingSeries){
                this.render.onDrag(this._draggingSeries, event.containerPoint);
            }
        },

        dragEnd:function(event){
            if(this._draggingSeries){
                this.render.onDragEnd(this._draggingSeries, event.containerPoint);
                this._draggingSeries = null;
            }
        },

        findDraggingTarget:function(event){

            var pos = event.containerPoint;

            var plotBounds = this.getPlotBounds();

            var x = pos[0] - plotBounds.x;
            var y = pos[1] - plotBounds.y;

            var series = this.getVisibleChartData();

            for(var i = series.length - 1; i >= 0; i--){
                if(BaseUtils.containsPoint(series[i].bounds, [x,y]) && series[i].rotatable){
                    this.render.onDragStart(series[i], pos);
                    this._draggingSeries = series[i];
                    return this;
                }
            }
            
        }

    });

    require('../ChartLibrary').register(Constants.PIE_CHART, Pie);
});
/**
 * Created by eason on 15/5/4.
 */
define('chart/Bar',['require','./BaseChart','../utils/BaseUtils','../Constants','../utils/QueryUtils','../utils/BoundsManager','../theme/options','../ChartLibrary','../ChartLibrary'],function(require){
    var BaseChart = require('./BaseChart');
    var BaseUtils = require('../utils/BaseUtils');
    var Constants = require('../Constants');
    var QueryUtils = require('../utils/QueryUtils');
    var BoundsManager = require('../utils/BoundsManager');
    var Options = require('../theme/options');
    
    var TOOLTIP_GAP = 1;
    var LABEL_GAP = 3;
    var MIN_BAR_SIZE = 2;

    var Bar = BaseChart.extend({

        doLayout:function(){

            //每个方向上的柱子
            var locations2Series = this._buildLocationMap();

            for(var location in locations2Series){

                var location2Series = locations2Series[location];

                for(var i = 0, count = location2Series.length; i < count; i++) {

                    var sameAxisSeries = location2Series[i];

                    if(sameAxisSeries && sameAxisSeries.length) {

                        this._buildBars(sameAxisSeries);

                    }

                }
            }

            this._calculateLabelPos();
        },

        getTrendLineXYValues:function(sery){

            var xValues = [];
            var yValues = [];

            var points = sery.points;
            var isHorizontal = sery.baseAxis.isHorizontal();
            var valueAxis = sery.valueAxis;

            var bars = [];

            for(var i = 0, len = points.length; i < len; i++){
                var barShape = points[i];
                if(!barShape.isNull){
                    bars.push(barShape);
                }
            }

            bars.sort(function(a, b){

                return isHorizontal ? a.x - b.x : a.y - b.y;

            });

            bars.forEach(function(barShape){
                var x, y;

                if(isHorizontal){
                    x = barShape.x + barShape.width / 2;
                    y = valueAxis.isAxisReversed() ? barShape.y + barShape.height : barShape.y;
                }else{
                    x = valueAxis.isAxisReversed() ? barShape.x : barShape.x + barShape.width;
                    y = barShape.y + barShape.height/2;
                }

                xValues.push(x);
                yValues.push(y);
            });

            return [xValues, yValues, sery.baseAxis.getPosition()];
        },

        //创建水平或者垂直方向上的柱子
        _buildBars:function(locationMap){

            var sery = locationMap[0][0];

            var valueBased = sery.isValueAxisBased();

            valueBased ? this._calculateValueBasedPercentageAndTooltip(locationMap)
                : this._calculateCategoryBasedPercentageAndTooltip(locationMap);


            var barSize = valueBased ? this._getValueBasedBarSize(locationMap):this._getBarSize(locationMap);

            var centerPos = barSize.centerPos;
            var barWidth = barSize.barWidth;

            var categoryAxis = locationMap[0][0].baseAxis;
            var isHorizontal = categoryAxis.getPosition() == Constants.LEFT
                || categoryAxis.getPosition() == Constants.RIGHT;

            for(var i = 0, len = locationMap.length; i < len; i++){
                var stackedSeries = locationMap[i];

                for(var j = 0, count = stackedSeries.length; j < count; j++){

                    var sery = stackedSeries[j];

                    for(var dIndex = 0, dCount = sery.points.length; dIndex < dCount; dIndex++){

                        var point = sery.points[dIndex];

                        var pos = categoryAxis.scale(point.category) + centerPos[i] - barWidth[i][j] / 2;

                        var valueAxis = point.series.valueAxis;

                        var value = point.y;
                        var preSum = point.y0;

                        var prePos = valueAxis.scale(preSum);

                        if (preSum === Number.MIN_VALUE) {
                            prePos = valueAxis.scale.range()[0];
                        }

                        var currentPos = valueAxis.scale(value + preSum);
                        var barHeight = Math.abs(currentPos - prePos);

                        var strokeWidth = point.borderWidth;

                        var x = isHorizontal ? Math.min(prePos, currentPos) : pos;
                        var y = isHorizontal ? pos : Math.min(prePos, currentPos);
                        var width = isHorizontal ? barHeight : barWidth[i][j];
                        var height = isHorizontal ? barWidth[i][j] : barHeight;

                        width = Math.max(width, 0);
                        height = Math.max(height,0);

                        var tmpBar = BaseUtils.rectSubPixelOpt(x,y,width,height,strokeWidth);

                        QueryUtils.merge(point,
                            QueryUtils.merge(tmpBar,{
                                location:categoryAxis.getPosition(),
                                startPos:valueAxis.getStartPos(),
                                direction:this.getAnimationDirection(valueAxis, value)
                            },true),
                            true);
                    }
                }
            }
        },

        getAnimationDirection:function(valueAxis, value){

            var isPositive = value >= 0;

            if(valueAxis.isHorizontal()){
                return isPositive ^ valueAxis.isAxisReversed() ? Constants.LEFT_TO_RIGHT : Constants.RIGHT_TO_LEFT;
            }else{
                return isPositive ^ valueAxis.isAxisReversed() ? Constants.BOTTOM_TO_TOP : Constants.TOP_TO_BOTTOM;
            }
        },

        _getFixedPos:function(datum, divDim){

            var location = datum.location;

            var plotBounds = this.getPlotBounds();

            var x,y;
            if(location == Constants.TOP || location == Constants.BOTTOM){
                //柱形图
                x = plotBounds.x + datum.x + datum.width + TOOLTIP_GAP;
                y = plotBounds.y + datum.y;
            }else{
                //条形图
                x = plotBounds.x + datum.x + datum.width - divDim.width;
                y = plotBounds.y + datum.y + datum.height + TOOLTIP_GAP;
            }

            return [x, y];
        },

        mergeSeriesAttributes:function(sery){

            var queryList = [
                sery.seriesOption,
                this.option.plotOptions[this.componentType],
                this.option.plotOptions,
                Options[this.componentType].plotOptions
            ];

            QueryUtils.merge(sery, {
                width:QueryUtils.queryList(queryList, 'width')
            });

        },

        _getTotalDataPointCount:function(){

            var series = this.getVisibleChartData();
            var count = 0;
            for(var i = 0, len = series.length; i < len; i++){
                count += series[i].points.length;
            }

            return Math.max(count, 1);
        },

        _getValueBasedBarSize:function(locationMap){

            var baseAxis = locationMap[0][0].baseAxis;

            var count = this._getTotalDataPointCount();

            //处理柱子的大小
            var total = baseAxis.isHorizontal() ? baseAxis.bounds.width : baseAxis.bounds.height;
            var fixedBarWidth = this.fixedBarWidth ? this.fixedBarWidth : (total / count / 3);
            fixedBarWidth = Math.max(fixedBarWidth, MIN_BAR_SIZE);

            //缓存第一次计算的值
            this.fixedBarWidth = fixedBarWidth;

            var centerPos = [], barWidth = [];

            for(var i = 0, count = locationMap.length; i < count; i++){
                centerPos.push(0);

                for(var j = 0, len = locationMap[i].length; j < len; j++){

                    var sery = locationMap[i][j];

                    barWidth[i] = barWidth[i] || [];

                    barWidth[i].push(sery.width ? sery.width : Math.max(fixedBarWidth, MIN_BAR_SIZE));
                }
            }

            return {
                centerPos:centerPos,
                barWidth:barWidth
            }

        },

        _getBarSize:function(locationMap){

            var barCount = locationMap.length;

            var categoryAxis = locationMap[0][0].baseAxis;

            var tickLength = categoryAxis.getTickLength();

            var queryList = [
                this.option.plotOptions[this.componentType],
                this.option.plotOptions,
                Options[this.componentType].plotOptions
            ];
            var categoryGap = QueryUtils.queryList(queryList, 'categoryGap');
            var gap = QueryUtils.queryList(queryList, 'gap');

            categoryGap = this._getPercentValue(categoryGap, tickLength);

            var defaultWidth = (tickLength - categoryGap) / barCount;

            var start = categoryGap / 2;
            var centerPos = [];
            for(var i = 0; i < barCount; i++){
                centerPos.push(start + defaultWidth * (i + 0.5));
            }

            gap = this._getPercentValue(gap, defaultWidth);
            defaultWidth -= gap;

            var barWidth = [];
            for(var i = 0; i < barCount; i++){
                for(var j = 0, len = locationMap[i].length; j < len; j++){

                    var sery = locationMap[i][j];

                    barWidth[i] = barWidth[i] || [];

                    barWidth[i].push(sery.width ? sery.width : Math.max(defaultWidth, MIN_BAR_SIZE));
                }
            }

            return {
                centerPos:centerPos,
                barWidth:barWidth
            }
        },

        //计算标签的位置
        _calculateLabelPos:function(){
            var manager = new BoundsManager();
            var series = this.getVisibleChartData();
            var chart = this;

            series.forEach(function(sery){

                sery.points.forEach(function(point){

                    var dataLabels = point.dataLabels;
                    if(dataLabels && dataLabels.enabled){

                        if(dataLabels.align){
                            point.labelPos = chart._calculateAlignLabelPos(point, dataLabels.align);
                            manager.addBounds(BaseUtils.makeBounds(point.labelPos, point.labelDim));

                        }else{

                            var order = [Constants.CENTER, Constants.INSIDE, Constants.OUTSIDE];
                            for(var index = 0, len = order.length; index < len; index++){
                                var align = order[index];
                                var pos = chart._calculateAlignLabelPos(point, align);
                                if(!manager.isOverlapped(BaseUtils.makeBounds(pos, point.labelDim)) || align == Constants.OUTSIDE){
                                    point.labelPos = pos;
                                    manager.addBounds(BaseUtils.makeBounds(pos, point.labelDim));
                                    break;
                                }
                            }
                        }
                    }
                });

            });
        },

        _calculateAlignLabelPos:function(point, align){

            var labelDim = point.labelDim;

            var isVertical = point.location == Constants.TOP || point.location == Constants.BOTTOM;

            var isPositive = point.value >= 0;

            var sery = point.series;
            var valueAxis = sery.valueAxis;

            isPositive = isPositive ^ valueAxis.isAxisReversed();

            var centerX = point.x + point.width/2;
            var centerY = point.y + point.height/2;

            var x,y;

            switch (align){
                case Constants.CENTER:

                    x = centerX - labelDim.width/2;
                    y = centerY - labelDim.height/2;

                    break;
                case Constants.INSIDE:

                    if(isVertical){
                        x = centerX - labelDim.width/2;

                        y = isPositive ?
                        point.y + LABEL_GAP : point.y + point.height - LABEL_GAP - labelDim.height;

                    }else{

                        y = centerY - labelDim.height/2;

                        x = isPositive ?
                        point.x + point.width - LABEL_GAP - labelDim.width : point.x + LABEL_GAP;

                    }

                    break;
                case Constants.OUTSIDE:

                    if(isVertical){
                        x = centerX - labelDim.width/2;
                        y = isPositive ?
                        point.y - LABEL_GAP - labelDim.height : point.y + point.height + LABEL_GAP;
                    }else{

                        y = centerY - labelDim.height/2;

                        x = isPositive ?
                        point.x + point.width + LABEL_GAP : point.x - LABEL_GAP - labelDim.width;
                    }

                    break;
            }

            return {
                x:x,
                y:y
            }
        },

        getInitBarAttribute:function(d){

            var direction = d.direction || Constants.BOTTOM_TO_TOP;

            var left2right = {x: d.startPos, y: d.y, width: 0, height: d.height};
            var left2rightEnd = {x: d.startPos, y: d.y, width:d.x + d.width - d.startPos, height: d.height};

            var right2left = {x: d.startPos, y: d.y, width: 0, height: d.height};
            var right2leftEnd = {x: d.x, y: d.y, width: d.startPos - d.x, height: d.height};

            var bottom2top = {x: d.x, y: d.startPos, width: d.width, height: 0};
            var bottom2topEnd = {x: d.x, y: d.y, width: d.width, height: d.startPos - d.y};

            var top2bottom = {x: d.x, y: d.startPos, width: d.width, height: 0};
            var top2bottomEnd = {x: d.x, y: d.startPos, width: d.width, height: d.y + d.height - d.startPos};

            switch (direction){

                case Constants.BOTTOM_TO_TOP:
                    return  {
                        init:bottom2top,
                        end:bottom2topEnd
                    };

                case Constants.TOP_TO_BOTTOM:
                    return {
                        init:top2bottom,
                        end:top2bottomEnd
                    };

                case Constants.LEFT_TO_RIGHT:
                    return {
                        init:left2right,
                        end:left2rightEnd
                    };

                case Constants.RIGHT_TO_LEFT:
                    return {
                        init:right2left,
                        end:right2leftEnd
                    };

            };
        }

    });

    require('../ChartLibrary').register(Constants.BAR_CHART, Bar);
    require('../ChartLibrary').register(Constants.COLUMN_CHART, Bar);

    return Bar;
});
/**
 * Created by eason on 15/7/17.
 */

define('chart/Line',['require','../Constants','../utils/BaseUtils','../utils/QueryUtils','./BaseChart','../theme/options','../ChartLibrary'],function(require){

    var Constants = require('../Constants');
    var BaseUtils = require('../utils/BaseUtils');
    var QueryUtils = require('../utils/QueryUtils');
    var BaseChart = require('./BaseChart');
    var Options = require('../theme/options');

    var DEFAULT_AREA_ALPHA = 0.35;

    var LABEL_GAP = 2;

    var Line = BaseChart.extend({

        type:Constants.LINE_CHART,

        doLayout:function(){

            var locations2Series = this._buildLocationMap();

            for(var location in locations2Series){

                var location2Series = locations2Series[location];

                for(var i = location2Series.length - 1; i >= 0; i--) {

                    var sameAxisSeries = location2Series[i];

                    if(sameAxisSeries && sameAxisSeries.length) {

                        this._buildLines(sameAxisSeries);

                    }
                }
            }

            this._calculateLabelPos();
        },

        _buildLines:function(locationMap) {

            var large = this.option.plotOptions.large;

            var sery = locationMap[0][0];

            sery.isValueAxisBased() ? this._calculateValueBasedPercentageAndTooltip(locationMap)
                : this._calculateCategoryBasedPercentageAndTooltip(locationMap);

            var chart = this;
            for(var i = 0, count = locationMap.length; i < count; i++){
                var stackedSeries = locationMap[i];

                stackedSeries.forEach(function(series){

                    series.dataBands = chart._calculateDataBands(series);

                    var baseAxis = series.baseAxis;
                    var valueAxis = series.valueAxis;

                    var isHorizontal = series.location == Constants.LEFT || series.location == Constants.RIGHT;
                    var originalPoints = series.originalPoints || series.points;
                    var points = [].concat(originalPoints);

                    points.forEach(function(point){
                        chart._positionFix(point, baseAxis, valueAxis, isHorizontal);
                    });

                    if(large){
                        var xMap = {};
                        var yMap = {};
                        var largePoints = [];

                        points.forEach(function(point){

                            if(!xMap[point.x] || !yMap[point.y]){

                                largePoints.push(point);

                                xMap[point.x] = true;
                                yMap[point.y] = true;
                            }
                        });

                        largePoints.sort(function(pointA, pointB){
                            return pointA.x - pointB.x;
                        });
                        points = largePoints;
                    }else{
                        points.sort(function(pointA, pointB){
                            return pointA.x - pointB.x;
                        });
                    }

                    if(series.connectNulls){

                        var newPoints = [];

                        points.forEach(function(point){

                            if(!point.isNull){
                                newPoints.push(point);
                            }

                        });
                        points = newPoints;
                    }

                    series.points = points;
                    series.originalPoints = originalPoints;
                });
            }
        },

        _positionFix:function(point, baseAxis, valueAxis, isHorizontal){

            var det = baseAxis.scale.rangeBand ? baseAxis.scale.rangeBand()/2 : 0;
            var t1 = Math.round(baseAxis.scale(point.category) + det);
            var t2 = valueAxis.scale(point.y + point.y0);
            var t3 = valueAxis.scale(point.y0);

            if(isHorizontal){
                point.y = t1;
                point.x = t2;
                point.x0 = t3;
            }else{
                point.x = t1;
                point.y = t2;
                point.y0 = t3;
            }
        },

        mergeDataPointAttributes:function(point){
            this._mergeMarkerAttributes(point);
        },

        mergeSeriesAttributes:function(lineSery){

            var seriesOption = lineSery.seriesOption;

            //系列的一些属性
            var queryList = [
                seriesOption,
                this.option.plotOptions[lineSery.type],
                this.option.plotOptions,
                Options[lineSery.type].plotOptions
            ];
            var connectNulls = BaseUtils.pick(QueryUtils.queryList(queryList, 'connectNulls'), true);
            var lineWidth = QueryUtils.queryList(queryList, 'lineWidth') || 0;
            var color = QueryUtils.queryList(queryList, 'color') || this._getDefaultSeriesColor(lineSery.name);

            var fillColor = QueryUtils.queryList(queryList, 'fillColor');
            fillColor = fillColor ? (fillColor === true ? color : fillColor) : (fillColor === false ? '' : color);

            var fillColorOpacity = BaseUtils.pick(QueryUtils.queryList(queryList, 'fillColorOpacity') , DEFAULT_AREA_ALPHA);
            var stack = QueryUtils.queryList(queryList, 'stack');

            var interpolate = this._getSeriesInterpolate(queryList);
            var lineSvg = this._getLineSvg(interpolate);
            var areaSvg = this._getAreaSvg(interpolate);

            var points = [];

            QueryUtils.merge(lineSery,
                {
                    lineWidth: lineWidth,
                    color: color,
                    fillColor:fillColor,
                    fillColorOpacity:fillColorOpacity,
                    connectNulls:connectNulls,
                    lineSvg: lineSvg,
                    areaSvg:areaSvg,
                    points: points,
                    isStack:!!stack
                }
            );
        },

        _calculateDataBands:function(lineSery){

            var plotBounds = this.getPlotBounds();

            var dColor = lineSery.color;
            var dFillColor = lineSery.fillColor;
            var dFillColorOpacity = lineSery.fillColorOpacity;

            var queryList = [
                lineSery.seriesOption,
                this.option.plotOptions[lineSery.type],
                this.option.plotOptions,
                Options[lineSery.type].plotOptions
            ];

            var bands = QueryUtils.queryList(queryList, 'bands');

            var clipID = this.vanchart.getIDPrefix() + lineSery.className;

            var valueAxis = lineSery.valueAxis;

            var resultRanges = [];
            resultRanges.push({
                x:0,
                y:0,
                width:plotBounds.width,
                height:plotBounds.height,
                color:dColor,
                fillColor:dFillColor,
                fillColorOpacity:dFillColorOpacity,
                lineData:lineSery,
                clipID:clipID + '-1'
            });

            if(!bands){
                return resultRanges;
            }

            if(!BaseUtils.isArray(bands)){
                bands = [bands];
            }

            for(var i = 0, len = bands.length; i < len; i++){

                var x = 0, y = 0;
                var width = plotBounds.width;
                var height = plotBounds.height;

                var domain = valueAxis.scale.domain();

                var from = Math.max(domain[0], bands[i].from);
                var to = Math.min(domain[1], bands[i].to);

                from = valueAxis.scale(from);
                to = valueAxis.scale(to);

                var color = bands[i].color || dColor;
                var fillColor = bands[i].fillColor || dFillColor;
                var fillColorOpacity = bands[i].fillColorOpacity || dFillColorOpacity;

                if(valueAxis.isHorizontal()){
                    x = Math.min(from, to);
                    width = Math.abs(from - to);
                }else{
                    y = Math.min(from, to);
                    height = Math.abs(from - to);
                }

                resultRanges.push({
                    x:x,
                    y:y,
                    height:height,
                    width:width,
                    color:color,
                    lineData:lineSery,
                    fillColor:fillColor,
                    fillColorOpacity:fillColorOpacity,
                    clipID:clipID + i
                });
            }

            return resultRanges;
        },

        _getFixedPos:function(datum){

            var radius = datum.marker.radius || this.getDefaultMarkerRadius();

            var plotBounds = this.getPlotBounds();

            var x = plotBounds.x + datum.x + radius;
            var y = plotBounds.y + datum.y + radius;

            return [x, y];
        },

        _calculateLabelPos:function(){

            var lineData = this.getVisibleChartData();

            lineData.forEach(function(lineData){

                lineData.points.forEach(function(point){
                    var dataLabels = point.dataLabels;
                    if(dataLabels && dataLabels.enabled){
                        point.labelPos = {
                            x: point.x - point.labelDim.width/2,
                            y:point.y  - LABEL_GAP - point.labelDim.height
                        };
                    }
                });

            });
        },

        getTrendLineXYValues:function(sery){
            return this.getNormalTrendLineXYValues(sery);
        },

        getClosestPoint:function(pos){

            var selectedPoint;
            var minDistance = Number.MAX_VALUE;

            var lineData = this.vanchart.hoverSeries;

            var plotBounds = this.getPlotBounds();

            if(lineData && lineData.points){
                lineData.points.forEach(function(point){
                    var dis = Math.abs(point.x + plotBounds.x - pos[0]);
                    if(dis < minDistance && !point.isNull){
                        selectedPoint = point;
                        minDistance = dis;
                    }
                });
            }else{

                var series = this.vanchart.series;

                series.forEach(function(sery){

                    if(sery.points){
                        sery.points.forEach(function(point){
                            var dis = Math.abs(point.x + plotBounds.x - pos[0]);
                            if(dis < minDistance && !point.isNull){
                                selectedPoint = point;
                                minDistance = dis;
                            }
                        });
                    }
                });
            }
            return selectedPoint;
        }
    });
    
    require('../ChartLibrary').register(Constants.LINE_CHART, Line);

    return Line;
});
/**
 * Created by eason on 15/7/17.
 */

define('chart/Area',['require','../Constants','./Line','../ChartLibrary'],function(require){

    var Constants = require('../Constants');
    var Line = require('./Line');

    var Area = Line.extend({
        type:Constants.AREA_CHART
    });

    require('../ChartLibrary').register(Constants.AREA_CHART, Area);
    
    return Area;
});
/**
 * Created by eason on 15/12/2.
 */
define('chart/Gauge',['require','../Constants','../utils/BaseUtils','../utils/ColorUtils','./BaseChart','../utils/QueryUtils','../utils/BoundsManager','../theme/options','../ChartLibrary'],function(require){

    var Constants = require('../Constants');
    var BaseUtils = require('../utils/BaseUtils');
    var ColorUtils = require('../utils/ColorUtils');
    var BaseChart = require('./BaseChart');
    var QueryUtils = require('../utils/QueryUtils');
    var BoundsManager = require('../utils/BoundsManager');
    var Options = require('../theme/options');

    //默认半径大小
    var DEFAULT_RADIUS = 100;
    var DEFAULT_PADDING = 5;

    var TICK_SIZE = 6;
    var TICK_LABEL_GAP = 4;
    var THERMOMETER_R = 5;

    var HORIZONTAL_GAP = 0.8;
    var VERTICAL_GAP = 0.3;
    var LINE_GAP = 0.3;

    var Gauge = BaseChart.extend({

        doLayout:function(){

            var queryList = [
                this.option.plotOptions[Constants.GAUGE_CHART],
                this.option.plotOptions,
                Options[Constants.GAUGE_CHART].plotOptions
            ];

            var layout = QueryUtils.queryList(queryList, 'layout') || Constants.HORIZONTAL_LAYOUT;

            var series = this.getVisibleChartData();
            var self = this;
            series.forEach(function(sery){
                var optList = [sery.seriesOption].concat(queryList);
                //重置radius属性
                sery.radius = QueryUtils.queryList(optList, 'radius');

                var gaugeAxis = sery.gaugeAxis;
                var domain = gaugeAxis.scale.domain();
                var defaultBands = self._getDefaultBands([sery.seriesOption, optList], domain);

                sery.bands = BaseUtils.addArray(sery.bands, defaultBands);

                sery.points.forEach(function(point){
                    point.valueInDomain = BaseUtils.getValueInDomain(point.value, domain);

                    point.color = sery._getBandsColor(point) || point.color;

                    var queryList = [
                        point.pointOption,
                        sery.seriesOption,
                        sery.chart.option.plotOptions[sery.type],
                        sery.chart.option.plotOptions,
                        Options[sery.type].plotOptions
                    ];

                    point.mouseOverColor = QueryUtils.queryList(queryList, 'mouseOverColor') || ColorUtils.getHighLightColor(point.color);
                    point.clickColor = ColorUtils.getClickColor(point.color);
                });

                //过滤空值
                var points = sery.points;
                var result = [];
                for(var i = 0, len = points.length; i < len; i++){
                    if(!points[i].isNull){
                        result.push(points[i]);
                    }
                }
                sery.points = result;

                self._dealStackedPoints(sery.points);
            });

            this._dealGaugeLabels();

            this._fixCenterAndSize(layout);
        },

        mergeSeriesAttributes:function(series){

            var queryList = [
                series.seriesOption,
                this.option.plotOptions[series.type],
                this.option.plotOptions,
                Options[series.type].plotOptions
            ];

            var style = QueryUtils.queryList(queryList, 'style') || Constants.GAUGE_POINTER;
            var themeConfig = this.vanchart.themeConfig;
            var styleConfig = themeConfig[style] || themeConfig[Constants.GAUGE_POINTER];
            var seriesLabel = QueryUtils.queryList(queryList, 'seriesLabel') || {};
            var valueLabel = QueryUtils.queryList(queryList, 'valueLabel') || {};
            var percentageLabel = QueryUtils.queryList(queryList, 'percentageLabel') || {};
            var needle = QueryUtils.queryList(queryList, 'needle');
            var hinge = QueryUtils.queryList(queryList, 'hinge');
            var clockwise = QueryUtils.queryList(queryList, 'clockwise');
            var hingeBackgroundColor = QueryUtils.queryList(queryList, 'hingeBackgroundColor');
            var paneBackgroundColor = QueryUtils.queryList(queryList, 'paneBackgroundColor');
            var slotBackgroundColor = QueryUtils.queryList(queryList, 'slotBackgroundColor');
            var innerPaneBackgroundColor = QueryUtils.queryList(queryList, 'innerPaneBackgroundColor');
            var thermometerLayout = QueryUtils.queryList(queryList, 'thermometerLayout');

            var bands = QueryUtils.queryList(queryList, 'bands') || [];

            var className = series.className + style;

            BaseUtils.extend(series,
                {
                    className:className,
                    style : style,
                    bands:bands,
                    center : QueryUtils.queryList(queryList, 'center'),
                    radius : QueryUtils.queryList(queryList, 'radius'),
                    seriesLabel : QueryUtils.merge(seriesLabel, styleConfig.seriesLabel),
                    valueLabel : QueryUtils.merge(valueLabel, styleConfig.valueLabel),
                    percentageLabel : QueryUtils.merge(percentageLabel, styleConfig.percentageLabel),
                    needle : needle || styleConfig.needle,
                    hinge : hinge || styleConfig.hinge,
                    thermometerLayout:thermometerLayout || styleConfig.thermometerLayout,
                    clockwise:BaseUtils.pick(clockwise, styleConfig.clockwise),
                    hingeBackgroundColor : hingeBackgroundColor || styleConfig.hingeBackgroundColor,
                    paneBackgroundColor : paneBackgroundColor || styleConfig.paneBackgroundColor,
                    slotBackgroundColor: slotBackgroundColor || styleConfig.slotBackgroundColor,
                    innerPaneBackgroundColor: innerPaneBackgroundColor || styleConfig.innerPaneBackgroundColor
                }
            );
        },

        _getDefaultBands:function(queryList, domain){

            var color = QueryUtils.queryList(queryList, 'color');
            var bands = [];

            if(color){
                bands.push({
                    from:domain[0],
                    to:domain[1],
                    color:color
                });
            }else{
                var min = domain[0];
                var max = domain[1];
                var band = BaseUtils.accDiv((max - min), 3);
                var fStop = BaseUtils.accAdd(min, band);
                var sStop = BaseUtils.accAdd(fStop, band);
                var colors = this.option.colors;

                bands = [
                    {
                        from:min,
                        to:fStop,
                        color:colors[0]
                    },
                    {
                        from:fStop,
                        to:sStop,
                        color:colors[1]
                    },
                    {
                        from:sStop,
                        to:max,
                        color:colors[2]
                    }];
            }

            return bands;
        },

        _calculatePercentage:function(points){

            if(points.length){

                var gaugeAxis = points[0].series.gaugeAxis;

                var minMax = gaugeAxis.scale.domain();

                points.forEach(function(point){

                    point.percentage = (point.value - minMax[0]) / (minMax[1] - minMax[0]);

                });

            }

        },

        _dealGaugeLabels:function(){

            var self = this;

            var gaugeData = this.getVisibleChartData();

            gaugeData.forEach(function(singleGauge){

                var style = singleGauge.style;

                //分类标签
                if(style == Constants.GAUGE_POINTER || style == Constants.GAUGE_POINTER_SEMI){

                    singleGauge.seriesLabelContent = '';
                    singleGauge.seriesLabelDim = {width:0, height:0};

                    if(singleGauge.seriesLabel && singleGauge.seriesLabel.enabled && singleGauge.points[0]){

                        var style = singleGauge.seriesLabel.style;

                        var labelInfo = singleGauge.points[0]._calculateLabelInfo(singleGauge.seriesLabel);

                        var labelContent = labelInfo.labelContent;
                        var labelDim = labelInfo.labelDim;

                        singleGauge.seriesLabelContent = labelContent[0] ? labelContent[0].text : '';
                        singleGauge.seriesLabelStyle = style;
                        singleGauge.seriesLabelDim = labelDim;
                    }

                }else{
                    //百分比
                    singleGauge.percentageLabelContent = '';
                    singleGauge.percentageLabelDim = {width:0, height:0};

                    if(singleGauge.percentageLabel && singleGauge.percentageLabel.enabled && singleGauge.points[0]){

                        var labelStyle = BaseUtils.clone(singleGauge.percentageLabel.style);

                        if(!labelStyle.color){
                            labelStyle.color = singleGauge.points[0].color;
                        }

                        var labelInfo = singleGauge.points[0]._calculateLabelInfo(singleGauge.percentageLabel);
                        var labelContent = labelInfo.labelContent;
                        var labelDim = labelInfo.labelDim;

                        singleGauge.percentageLabelContent = labelContent[0] ? labelContent[0].text : '';
                        singleGauge.percentageLabelStyle = labelStyle;
                        singleGauge.percentageLabelDim = labelDim;
                    }

                }

                singleGauge.valueLabelContent = '';
                singleGauge.valueLabelDim = {width:0, height:0};

                if(singleGauge.valueLabel && singleGauge.valueLabel.enabled){
                    singleGauge.valueLabelContent = self._fixValueLabelContent(singleGauge);
                }

            });

        },

        _fixValueLabelContent:function(gauge){

            var valueLabel = gauge.valueLabel;
            var style = valueLabel.style;
            var useHtml = valueLabel.useHtml;
            var formatter = valueLabel.formatter;

            var valueLabelContent = [];

            if(gauge.style == Constants.GAUGE_POINTER
                || gauge.style == Constants.GAUGE_POINTER_SEMI
                || gauge.style == Constants.GAUGE_RING
                || gauge.style == Constants.GAUGE_THERMOMETER){
                for(var i = 0, len = gauge.points.length; i < len; i++){
                    var point = gauge.points[i];
                    var labelContent = this._calculateSingleLineLabelContent(formatter, point);
                    var labelDim = BaseUtils.getTextDimension(labelContent, style, useHtml);

                    valueLabelContent.push({
                        labelContent:labelContent,
                        labelDim:labelDim,
                        labelStyle:style
                    });
                }
            }else if(gauge.points[0]){
                var labelContent = this._createMultiLineLabelContent(formatter, gauge.points[0]);
                var labelStyle = valueLabel.style;
                for(var i = 0, len = labelContent.length; i < len; i++){
                    valueLabelContent.push({
                        labelContent:labelContent[i],
                        labelStyle:labelStyle,
                        labelDim:BaseUtils.getTextDimension(labelContent[i], labelStyle, useHtml)
                    });
                }
            }

            return valueLabelContent;
        },

        orderData:function(){

            var series = this.vanchart.series;

            var chart = this;

            series.sort(function(seryA, seryB){

                var totalA = seryA.getSeryTotalValue();

                var totalB = seryB.getSeryTotalValue();

                return chart.option.orderType == Constants.ASCENDING ? totalA - totalB : totalB - totalA;

            });
        },

        _getColorFromBands:function(value, bands){

            if(bands && bands.length){

                for(var i = 0, len = bands.length; i < len; i++){

                    var band = bands[i];

                    var min = Math.min(band.from, band.to);
                    var max = Math.max(band.from, band.to);

                    if(value >= min && value <= max){
                        return band.color;
                    }
                }
            }

        },

        _fixCenterAndSize:function(layout){

            var gaugeData = this.getVisibleChartData();

            //确定圆心位置的算作悬浮元素,给默认的大小
            for(var i = 0, len = gaugeData.length; i < len; i++){
                var singleGauge = gaugeData[i];

                if(singleGauge.center){
                    var plotBounds = this.vanchart.plotOriginalBounds;
                    var centerX = singleGauge.center[0];
                    var centerY = singleGauge.center[1];

                    if(centerX.indexOf('%') != -1){
                        centerX = this._getPercentValue(centerX, this.vanchart.chartWidth());
                    }

                    if(centerY.indexOf('%') != -1){
                        centerY = this._getPercentValue(centerY, this.vanchart.chartHeight());
                    }

                    centerX -= plotBounds.x;
                    centerY -= plotBounds.y;

                    singleGauge.centerX = centerX;
                    singleGauge.centerY = centerY;
                    singleGauge.radius = singleGauge.radius || DEFAULT_RADIUS;
                }
            }

            layout == Constants.HORIZONTAL_LAYOUT ?
                this._dealHorizontalLayout() : this._dealVerticalLayout();

            //确定边界以后确定圆心位置
            var self = this;
            gaugeData.forEach(function(singleGauge){

                var style = singleGauge.style;

                switch (style){
                    case Constants.GAUGE_POINTER:
                        self._fixPointerCenter(singleGauge);
                        break;

                    case Constants.GAUGE_POINTER_SEMI:
                        self._fixPointerSemiCenter(singleGauge);
                        break;

                    case Constants.GAUGE_SLOT:
                        self._fixSlotCenter(singleGauge);
                        break;

                    case Constants.GAUGE_THERMOMETER:
                        self._fixThermometerCenter(singleGauge);
                        break;

                    case Constants.GAUGE_RING:
                        self._fixRingCenter(singleGauge);
                        break;

                }
            });
        },

        _fixPointerCenter:function(gauge){

            var radius = gauge.radius;
            var align = gauge.seriesLabel.align || Constants.BOTTOM;
            if (!gauge.center) {
                var bounds = gauge.bounds;
                var labelHeight = 20 + gauge.seriesLabelDim.height;

                var usedHeight = bounds.height - labelHeight;

                var centerX = bounds.x + bounds.width / 2;
                var centerY = bounds.y + bounds.height / 2;
                radius = Math.min(bounds.width, usedHeight) / 2 - DEFAULT_PADDING;

                if (align == Constants.BOTTOM) {

                    if (centerY + radius + labelHeight > bounds.y + bounds.height) {

                        var gap = bounds.height - (radius * 2 + labelHeight);

                        if (gap >= 0) {
                            centerY = bounds.y + radius + gap / 2;
                        }
                    }

                } else {

                    if (centerY - radius - labelHeight < bounds.y) {

                        var gap = bounds.height - (radius * 2 + labelHeight);

                        if (gap >= 0) {
                            centerY = bounds.y + radius + labelHeight + gap / 2;
                        }

                    }
                }

                gauge.centerX = centerX;
                gauge.centerY = centerY;
                gauge.radius = radius;
            }


            if(gauge.seriesLabelContent){
                var dim = gauge.seriesLabelDim;

                gauge.seriesLabelPos = {
                    x: -dim.width/2,
                    y:align == Constants.BOTTOM ? (radius+20) : (-radius-20-dim.height)
                }
            }

            if(gauge.valueLabelContent){
                var gaugeAxis = gauge.gaugeAxis;
                var axisOption = gaugeAxis.componentOption;
                var domain = gaugeAxis.scale.domain();
                var scale = d3.scale.linear().domain(domain)
                    .range([BaseUtils.toRadian(-150), BaseUtils.toRadian(150)]);
                var tickHeight = BaseUtils.getTextHeight(axisOption.labelStyle);

                var startY = 0.16 * radius + tickHeight/2;
                var labelR = (1 - 0.05 - 0.1) * radius;
                var endY = labelR * Math.cos(Math.PI/6) - 2 * tickHeight;

                this._dealValueLabelContent(gauge, radius, scale, startY, endY);
            }


        },

        _getPointerTickBoundsManager:function(gaugeAxis, radius, scale, tickHeight){

            var manager = new BoundsManager();

            var labelR = (1 - 0.05 - 0.1 - 0.01) * radius;

            var tickData = gaugeAxis.getTickData();

            var gap = tickHeight * 0.5;

            var self = this;

            tickData.forEach(function(tick){

                var center = self._getPointerTickCenter(tick, labelR, scale);

                manager.addBounds({
                    x:center.x - tick.tickDim.width/2 - gap,
                    y:center.y - tick.tickDim.height/2 - gap,
                    width:tick.tickDim.width + gap,
                    height:tick.tickDim.height + gap
                })
            });

            var minorTickData = gaugeAxis.getMinorTickData();

            var minorTickR = (1 - 0.05 - 0.1) * radius;
            var minorTickSize = 0.1 * radius;

            minorTickData.forEach(function(minorTickValue){

                var radian = scale(minorTickValue);

                var point = self._getArcPoint(minorTickR, radian);

                var x, y;
                if(radian < Math.PI){
                    //右边
                    x = point[0];
                    y = point[1];

                }else{
                    //左边
                    x = point[0] - minorTickSize;
                    y = point[1];
                }

                manager.addBounds({
                    x:x,
                    y:y,
                    width:minorTickSize,
                    height:minorTickSize
                });
            });

            return manager;
        },

        //指针仪表盘刻度标签相对于圆心的标签中心的位置
        _getPointerTickCenter:function(tick, labelR, scale){

            var radian = scale(tick.tickValue);

            var joinPoint = this._getArcPoint(labelR, radian);
            var x = joinPoint[0];
            var y = joinPoint[1];

            var tickDim = tick.tickDim;

            var angle = Math.atan(tickDim.width / tickDim.height);

            var labelCenterX, labelCenterY;
            if(Math.abs(radian) < angle){

                var gap = tickDim.height/2;
                labelCenterX = x + gap * x / y;
                labelCenterY = y + gap;

            }else if(radian >= angle && radian <= (Math.PI - angle)){//右

                var gap = tickDim.width/2;
                labelCenterX = x - gap;
                labelCenterY = y - gap * y / x;

            }else if(radian >= angle - Math.PI && radian <= -angle){//左

                var gap = tickDim.width/2;
                labelCenterX = x + gap;
                labelCenterY = y + gap * y / x;

            }else{
                //下
                var gap = tickDim.height/2;
                labelCenterX = x - gap * x / y;
                labelCenterY = y - gap;
            }

            return {
                x:labelCenterX,
                y:labelCenterY
            }

        },

        _fixPointerSemiCenter:function(gauge){

            var radius = gauge.radius;
            var align = gauge.seriesLabel.align;
            if (!gauge.center) {
                var bounds = gauge.bounds;
                var labelHeight = 20 + gauge.seriesLabelDim.height;

                var usedHeight = bounds.height - labelHeight;
                radius = Math.min(bounds.width / 2, usedHeight / 1.14) - DEFAULT_PADDING;

                var centerX = bounds.x + bounds.width / 2;
                var centerY = bounds.y + bounds.height / 2 + radius / 2;

                if (align == Constants.BOTTOM) {

                    if (centerY + 0.14 * radius + labelHeight > bounds.y + bounds.height) {

                        var gap = bounds.height - (radius * 1.14 + labelHeight);

                        if (gap >= 0) {
                            centerY = bounds.y + radius + gap / 2;
                        }
                    }

                } else {

                    if (centerY - radius - labelHeight < bounds.y) {

                        var gap = bounds.height - (radius * 1.14 + labelHeight);

                        if (gap >= 0) {
                            centerY = bounds.y + radius + labelHeight + gap / 2;
                        }

                    }
                }

                gauge.centerX = centerX;
                gauge.centerY = centerY;
                gauge.radius = radius;
            }


            if(gauge.seriesLabelContent){
                var dim = gauge.seriesLabelDim;

                gauge.seriesLabelPos = {
                    x: -dim.width/2,
                    y:align == Constants.BOTTOM ? (radius * 0.14 + 20) : (-radius-20-dim.height)
                }
            }

            if(gauge.valueLabelContent){

                var gaugeAxis = gauge.gaugeAxis;
                var axisOption = gaugeAxis.componentOption;
                var domain = gaugeAxis.scale.domain();
                var scale = d3.scale.linear().domain(domain)
                    .range([BaseUtils.toRadian(-90), BaseUtils.toRadian(90)]);

                var tickHeight = BaseUtils.getTextHeight(axisOption.labelStyle);
                var labelR = (1 - 0.05 - 0.1) * radius;
                var startY = -(labelR  - 2 * tickHeight);
                var endY = -(0.11 * radius + tickHeight/2);

                this._dealValueLabelContent(gauge, radius, scale, startY, endY);
            }


        },

        _dealValueLabelContent:function(gauge, radius, scale, startY, endY){
            var gaugeAxis = gauge.gaugeAxis;
            var axisOption = gaugeAxis.componentOption;
            var tickHeight = BaseUtils.getTextHeight(axisOption.labelStyle);
            var valueLabelStyle = gauge.valueLabel.style;
            var useHtml = gauge.valueLabel.useHtml;
            var valueLabelHeight = BaseUtils.getTextHeight(valueLabelStyle);

            var boundsManager = this._getPointerTickBoundsManager(gaugeAxis, radius, scale, tickHeight);

            var count = gauge.valueLabelContent.length;

            var totalHeight = endY - startY;

            count = Math.min(Math.floor((totalHeight - valueLabelHeight/2)/(3 * valueLabelHeight/2)), count);
            count = Math.max(0, count);

            //只显示count个标签
            gauge.valueLabelContent.length = count;

            var totalHeight = valueLabelHeight * count + (count - 1) * valueLabelHeight/2;

            startY = (endY - startY - totalHeight)/2 + startY;

            var valueBackgroundY = startY - valueLabelHeight/2;
            var valueBackgroundX = Number.MAX_VALUE;

            for(var i = 0; i < count; i++){
                var singleLabel = gauge.valueLabelContent[i];

                var x = -singleLabel.labelDim.width/2;

                var tmpX = Math.min(x - valueLabelHeight/4, valueBackgroundX);

                var tmpBounds = {
                    x:tmpX,
                    y:valueBackgroundY,
                    width:2 * Math.abs(tmpX),
                    height:startY + valueLabelHeight * (1 + LINE_GAP) - valueBackgroundY
                };

                var singleLabelContent = singleLabel.labelContent;
                var hasClipped = false;
                while(boundsManager.isOverlapped(tmpBounds) && singleLabelContent.length){
                    singleLabelContent = singleLabelContent.substr(0, Math.floor(singleLabelContent.length * 0.9));
                    var tmpDim = BaseUtils.getTextDimension(singleLabelContent + '...', valueLabelStyle, useHtml);
                    x = -tmpDim.width/2;

                    tmpX = Math.min(x - valueLabelHeight/4, valueBackgroundX);

                    tmpBounds = {
                        x:tmpX,
                        y:valueBackgroundY,
                        width:2 * Math.abs(tmpX),
                        height:startY + valueLabelHeight * (1 + LINE_GAP) - valueBackgroundY
                    };

                    hasClipped = true;
                }

                if(hasClipped){
                    singleLabel.labelContent = singleLabelContent + '...';
                    singleLabel.labelDim = BaseUtils.getTextDimension(singleLabel.labelContent, valueLabelStyle, useHtml);
                    x = -singleLabel.labelDim.width/2;
                    tmpX = Math.min(x - valueLabelHeight/4, valueBackgroundX);
                }

                singleLabel.labelPos = {
                    x:x,
                    y:startY
                };

                startY += valueLabelHeight * (1 + LINE_GAP);

                valueBackgroundX = tmpX;
            }

            gauge.valueLabelBackground = {
                x:valueBackgroundX,
                y:valueBackgroundY,
                width:2 * Math.abs(valueBackgroundX),
                height:totalHeight + valueLabelHeight
            };
        },

        _fixSlotCenter:function(gauge){

            if (!gauge.center) {
                var bounds = gauge.bounds;

                var radius = Math.min(bounds.width / 2, bounds.height / 2);

                //刻度槽的宽度是0.16倍的半径
                radius = radius / 1.08 - DEFAULT_PADDING;

                var centerX = bounds.x + bounds.width / 2;
                var centerY = bounds.y + bounds.height / 2;

                gauge.centerX = centerX;
                gauge.centerY = centerY;
                gauge.radius = radius;
            }

            if(gauge.percentageLabelContent && gauge.valueLabelContent){

                gauge.percentageLabelPos = {
                    x:-gauge.percentageLabelDim.width/2,
                    y:-gauge.percentageLabelDim.height * (1 + LINE_GAP)
                };

                var startY = 0;
                for(var i = 0, count = gauge.valueLabelContent.length; i < count; i++){

                    var valueLabel = gauge.valueLabelContent[i];

                    valueLabel.labelPos = {
                        x:-valueLabel.labelDim.width/2,
                        y:startY
                    };

                    startY += (valueLabel.labelDim.height * (1 + LINE_GAP))
                }

            }else if(gauge.percentageLabelContent){

                gauge.percentageLabelPos = {
                    x:-gauge.percentageLabelDim.width/2,
                    y:-gauge.percentageLabelDim.height/2
                };

            }else if(gauge.valueLabelContent){

                var labelHeight = BaseUtils.getTextHeight(gauge.valueLabel.style);
                var labelCount = gauge.valueLabelContent.length;

                var totalHeight = labelHeight * labelCount + labelHeight * (labelCount - 1) / 2;

                var startY = - totalHeight / 2;

                for(var i = 0; i < labelCount; i++){

                    var valueLabel = gauge.valueLabelContent[i];

                    valueLabel.labelPos = {
                        x:-valueLabel.labelDim.width/2,
                        y:startY
                    };
                    startY += (labelHeight * (1 + LINE_GAP));
                }
            }

        },

        _fixThermometerCenter:function(gauge){

            var para = gauge.thermometerLayout == Constants.HORIZONTAL_LAYOUT ?
                this._fixHorizontalThermometerCenter(gauge) : this._fixVerticalThermometerCenter(gauge);

            var centerX = para.centerX;
            var centerY = para.centerY;
            var radius = para.radius;
            var showValueLabel = gauge.valueLabelContent ? gauge.valueLabelContent[0] : null;

            if(gauge.percentageLabelContent){
                gauge.percentageLabelPos.x -= centerX;
                gauge.percentageLabelPos.y -= centerY;

                //与底边对齐
                gauge.percentageLabelPos.y = Math.min(gauge.percentageLabelPos.y, radius - gauge.percentageLabelDim.height);
            }

            if(showValueLabel){
                showValueLabel.labelPos.x -= centerX;
                showValueLabel.labelPos.y -= centerY;

                var gap = (radius - showValueLabel.labelDim.height) - showValueLabel.labelPos.y;

                //与底边对齐
                if(gap < 0){
                    showValueLabel.labelPos.y += gap;

                    if(gauge.percentageLabelContent){
                        gauge.percentageLabelPos.y += gap;
                    }
                }
            }

            gauge.centerX = centerX;
            gauge.centerY = centerY;
            gauge.radius = radius;
        },

        _fixHorizontalThermometerCenter:function(gauge){

            var centerX, centerY, radius;
            var gaugeAxis = gauge.gaugeAxis;
            var percentageLabel = gauge.percentageLabel;
            var valueLabel = gauge.valueLabel;
            var showValueLabel = gauge.valueLabelContent ? gauge.valueLabelContent[0] : null;

            var totalHeight = this._getThermometerSize(gauge);
            var startY;

            if (gauge.center) {
                centerX = gauge.centerX;
                centerY = gauge.centerY;
                radius = gauge.radius;
                startY = centerY;

            } else {
                var bounds = gauge.bounds;
                startY = bounds.y + (bounds.height - totalHeight)/2;
                centerX = bounds.x + bounds.width/2;
                radius = bounds.width/2 - gaugeAxis.getMaxTickWidth() - DEFAULT_PADDING;
            }

            if(gauge.percentageLabelContent || showValueLabel){
                if(gauge.percentageLabelContent && showValueLabel
                    && percentageLabel.align == Constants.TOP && valueLabel.align == Constants.TOP){

                    if (gauge.center) {
                        startY -= (gauge.percentageLabelDim.height * (1 + LINE_GAP));
                        startY -= (showValueLabel.labelDim.height * (1 + HORIZONTAL_GAP));
                        startY -= (gaugeAxis.getTickHeight() + TICK_LABEL_GAP + TICK_SIZE + TICK_LABEL_GAP + THERMOMETER_R);
                    }

                    gauge.percentageLabelPos = {
                        x: -gauge.percentageLabelDim.width/2 + centerX,
                        y:startY
                    };

                    startY += (gauge.percentageLabelDim.height * (1 + LINE_GAP));

                    showValueLabel.labelPos = {
                        x: -showValueLabel.labelDim.width/2 + centerX,
                        y:startY
                    };

                    startY += (showValueLabel.labelDim.height * (1 + HORIZONTAL_GAP));


                }else{

                    if(gauge.percentageLabelContent && percentageLabel.align == Constants.TOP){

                        if (gauge.center) {
                            startY -= (gauge.percentageLabelDim.height * (1 + HORIZONTAL_GAP));
                            startY -= (gaugeAxis.getTickHeight() + TICK_LABEL_GAP + TICK_SIZE + TICK_LABEL_GAP + THERMOMETER_R);
                        }

                        gauge.percentageLabelPos = {
                            x: -gauge.percentageLabelDim.width/2 + centerX,
                            y:startY
                        };

                        startY += (gauge.percentageLabelDim.height * (1 + HORIZONTAL_GAP));
                    }

                    if(showValueLabel && valueLabel.align == Constants.TOP){

                        if (gauge.center) {
                            startY -= (showValueLabel.labelDim.height * (1 + HORIZONTAL_GAP));
                            startY -= (gaugeAxis.getTickHeight() + TICK_LABEL_GAP + TICK_SIZE + TICK_LABEL_GAP + THERMOMETER_R);
                        }

                        showValueLabel.labelPos = {
                            x: -showValueLabel.labelDim.width/2 + centerX,
                            y:startY
                        };

                        startY += (showValueLabel.labelDim.height * (1 + HORIZONTAL_GAP));
                    }
                }
            }

            if (gauge.center) {
                startY = centerY + 5;
            } else {
                startY += (gaugeAxis.getTickHeight() + TICK_LABEL_GAP + TICK_SIZE + TICK_LABEL_GAP + THERMOMETER_R * 2);
                centerY = startY - 5;
            }

            if(gauge.percentageLabelContent || showValueLabel){

                if(gauge.percentageLabelContent && showValueLabel
                    && percentageLabel.align == Constants.BOTTOM && valueLabel.align == Constants.BOTTOM){
                    startY += (gauge.percentageLabelDim.height * HORIZONTAL_GAP);

                    gauge.percentageLabelPos = {
                        x: -gauge.percentageLabelDim.width/2 + centerX,
                        y:startY
                    };

                    startY += (gauge.percentageLabelDim.height * (1 + LINE_GAP));

                    showValueLabel.labelPos = {
                        x: -showValueLabel.labelDim.width/2 + centerX,
                        y:startY
                    };

                }else{

                    if(gauge.percentageLabelContent && percentageLabel.align == Constants.BOTTOM){

                        startY += (gauge.percentageLabelDim.height * HORIZONTAL_GAP);

                        gauge.percentageLabelPos = {
                            x: -gauge.percentageLabelDim.width/2 + centerX,
                            y:startY
                        };

                    }

                    if(showValueLabel && valueLabel.align == Constants.BOTTOM){

                        startY += (showValueLabel.labelDim.height * HORIZONTAL_GAP);

                        showValueLabel.labelPos = {
                            x: -showValueLabel.labelDim.width/2 + centerX,
                            y:startY
                        };

                    }
                }

            }

            return {
                centerX:centerX,
                centerY:centerY,
                radius:radius
            }
        },

        _fixVerticalThermometerCenter:function(gauge){

            var centerX, centerY, radius;

            var percentageLabel = gauge.percentageLabel;
            var valueLabel = gauge.valueLabel;
            var gaugeAxis = gauge.gaugeAxis;

            var point = gauge.points[0] || {};
            var domain = gaugeAxis.scale.domain();
            var showValueLabel = gauge.valueLabelContent ? gauge.valueLabelContent[0] : null;

            //纵向布局
            var totalWidth = this._getThermometerSize(gauge);
            var startX;

            if (gauge.center) {
                centerX = gauge.centerX;
                centerY = gauge.centerY;
                radius = gauge.radius;
                startX = centerX - THERMOMETER_R * 2;

            } else {
                var bounds = gauge.bounds;
                startX = bounds.x + (bounds.width - totalWidth)/2;
                centerY = bounds.y + bounds.height/2;
                radius = bounds.height/2 - gaugeAxis.getTickHeight() - DEFAULT_PADDING;
            }

            var scale = d3.scale.linear().domain(domain).range([radius, -radius]);
            var labelY = centerY + scale(point.valueInDomain);

            if(gauge.percentageLabelDim){
                labelY -= gauge.percentageLabelDim.height/3;//差不多居中的位置
            }

            if(gauge.percentageLabelContent || showValueLabel){

                if(gauge.percentageLabelContent && showValueLabel
                    && percentageLabel.align == Constants.LEFT && valueLabel.align == Constants.LEFT){

                    if (!gauge.center) {
                        startX += Math.max(gauge.percentageLabelDim.width, showValueLabel.labelDim.width);
                        centerX = startX + THERMOMETER_R;
                    }

                    gauge.percentageLabelPos = {
                        x:startX - gauge.percentageLabelDim.width,
                        y:labelY
                    };

                    showValueLabel.labelPos = {
                        x:startX - showValueLabel.labelDim.width,
                        y:labelY + gauge.percentageLabelDim.height * (1 + LINE_GAP)
                    };

                    startX += LINE_GAP * Math.max(gauge.percentageLabelDim.height, showValueLabel.labelDim.height);

                }else{

                    if(gauge.percentageLabelContent && percentageLabel.align == Constants.LEFT){

                        if (gauge.center) {
                            startX -= (gauge.percentageLabelDim.width + LINE_GAP * gauge.percentageLabelDim.height);
                        }

                        gauge.percentageLabelPos = {
                            x:startX,
                            y:labelY
                        };

                        startX += (gauge.percentageLabelDim.width + LINE_GAP * gauge.percentageLabelDim.height);
                    }

                    if(showValueLabel && valueLabel.align == Constants.LEFT){

                        if (gauge.center) {
                            startX -= (showValueLabel.labelDim.width + LINE_GAP * showValueLabel.labelDim.height);
                        }

                        showValueLabel.labelPos = {
                            x:startX,
                            y:labelY
                        };

                        startX += (showValueLabel.labelDim.width + LINE_GAP * showValueLabel.labelDim.height);
                    }
                }
            }

            if (gauge.center) {
                startX = centerX - THERMOMETER_R;
            } else {
                centerX = startX + THERMOMETER_R;
            }

            startX += (THERMOMETER_R * 2 + TICK_LABEL_GAP + TICK_SIZE + TICK_LABEL_GAP + gaugeAxis.getMaxTickWidth());

            if(gauge.percentageLabelContent || showValueLabel){
                if(gauge.percentageLabelContent && showValueLabel
                    && percentageLabel.align == Constants.RIGHT && valueLabel.align == Constants.RIGHT){

                    startX += LINE_GAP * Math.max(gauge.percentageLabelDim.height, showValueLabel.labelDim.height);

                    gauge.percentageLabelPos = {
                        x:startX,
                        y:labelY
                    };

                    showValueLabel.labelPos = {
                        x:startX,
                        y:labelY + gauge.percentageLabelDim.height * (1 + LINE_GAP)
                    };

                }else{

                    if(gauge.percentageLabelContent && percentageLabel.align == Constants.RIGHT){
                        gauge.percentageLabelPos = {
                            x:startX + LINE_GAP * gauge.percentageLabelDim.height,
                            y:labelY
                        };
                    }

                    if(showValueLabel && valueLabel.align == Constants.RIGHT){

                        showValueLabel.labelPos = {
                            x:startX + LINE_GAP * showValueLabel.labelDim.height,
                            y:labelY
                        };

                    }
                }
            }

            return {
                centerX:centerX,
                centerY:centerY,
                radius:radius
            }
        },

        _fixRingCenter:function(gauge){

            if (!gauge.center) {
                var bounds = gauge.bounds;
                var radius = Math.min(bounds.width/2, bounds.height/2) - DEFAULT_PADDING;
                var centerX = bounds.x + bounds.width/2;
                var centerY = bounds.y + bounds.height/2;

                gauge.centerX = centerX;
                gauge.centerY = centerY;
                gauge.radius = radius;
            }

            var totalHeight = 0;
            var valueLabel = gauge.valueLabelContent ? gauge.valueLabelContent[0] : null;
            if(gauge.percentageLabelContent && valueLabel){
                totalHeight = gauge.percentageLabelDim.height * (1 + LINE_GAP) + valueLabel.labelDim.height;
            }else if(gauge.percentageLabelContent){
                totalHeight = gauge.percentageLabelDim.height;
            }else if(valueLabel){
                totalHeight = valueLabel.labelDim.height;
            }

            var startY = -totalHeight/2;

            if(gauge.percentageLabelContent){
                gauge.percentageLabelPos = {
                    x: -gauge.percentageLabelDim.width/2,
                    y:startY
                };

                startY += gauge.percentageLabelDim.height * (1 + LINE_GAP);
            }

            if(valueLabel){
                valueLabel.labelPos = {
                    x:-valueLabel.labelDim.width/2,
                    y:startY
                };
            }
        },

        _dealHorizontalLayout:function(){

            //先要判断是否都是纵向布局的试管,是的话平均分
            var isEqualThermometer = true;

            var usedSize = 0;
            var fixedSize = 0;

            var gaugeData = this.getVisibleChartData();

            gaugeData.forEach(function(singleGauge){
                if(!singleGauge.center){

                    if(singleGauge.style != Constants.GAUGE_THERMOMETER
                        || singleGauge.thermometerLayout == Constants.HORIZONTAL_LAYOUT){

                        if(singleGauge.radius){
                            usedSize += (singleGauge.radius * 2);
                            fixedSize++;
                        }else{
                            isEqualThermometer = false;
                        }

                    }

                }
            });

            if(!isEqualThermometer){
                var self = this;
                gaugeData.forEach(function(singleGauge){

                    if(!singleGauge.center
                        && singleGauge.style == Constants.GAUGE_THERMOMETER
                        && singleGauge.thermometerLayout == Constants.VERTICAL_LAYOUT){

                        usedSize += (self._getThermometerSize(singleGauge));
                        fixedSize ++;

                    }
                });
            }

            //平均半径
            var plotBounds = this.vanchart.getPlotBounds();
            var averageRadius = plotBounds.width / Math.max(1, gaugeData.length - fixedSize);
            averageRadius /= 2;

            var leftBounds = {
                x:0,
                y:0,
                width:plotBounds.width,
                height:plotBounds.height
            };

            for(var i = 0, len = gaugeData.length; i < len; i++){

                var singleGauge = gaugeData[i];

                if(!singleGauge.center){

                    var size = 0;

                    if(singleGauge.style == Constants.GAUGE_THERMOMETER){

                        if(singleGauge.thermometerLayout == Constants.HORIZONTAL_LAYOUT){

                            size = (singleGauge.radius || averageRadius) * 2;

                            singleGauge.bounds = {
                                x:leftBounds.x,
                                y:leftBounds.y,
                                width:size,
                                height:leftBounds.height
                            };

                            leftBounds.x += size;
                            leftBounds.width -= size;

                        }else{

                            if(isEqualThermometer){
                                size = averageRadius * 2;
                            }else{
                                size = this._getThermometerSize(singleGauge);
                            }

                            var height = singleGauge.radius ? singleGauge.radius * 2 : leftBounds.height;

                            height = Math.min(height, leftBounds.height);

                            singleGauge.bounds = {
                                x:leftBounds.x,
                                y:leftBounds.y,
                                width:size,
                                height:height
                            };

                            leftBounds.x += size;
                            leftBounds.width -= size;
                        }

                    }else{

                        size = (singleGauge.radius || averageRadius) * 2;

                        singleGauge.bounds = {
                            x:leftBounds.x,
                            y:leftBounds.y,
                            width:size,
                            height:leftBounds.height
                        };

                        leftBounds.x += size;
                        leftBounds.width -= size;
                    }
                }
            }
        },

        _dealVerticalLayout:function(){

            var isEqualThermometer = true;

            var usedSize = 0;
            var fixedSize = 0;

            var gaugeData = this.getVisibleChartData();

            gaugeData.forEach(function(singleGauge){
                if(!singleGauge.center){

                    if(singleGauge.style != Constants.GAUGE_THERMOMETER
                        || singleGauge.thermometerLayout == Constants.VERTICAL_LAYOUT){

                        if(singleGauge.radius){
                            usedSize += (singleGauge.radius * 2);
                            fixedSize++;
                        }else{
                            isEqualThermometer = false;
                        }

                    }

                }
            });

            if(!isEqualThermometer){
                var self = this;
                gaugeData.forEach(function(singleGauge){

                    if(!singleGauge.center
                        && singleGauge.style == Constants.GAUGE_THERMOMETER
                        && singleGauge.thermometerLayout == Constants.HORIZONTAL_LAYOUT){

                        usedSize += (self._getThermometerSize(singleGauge));
                        fixedSize ++;
                    }
                });
            }

            //平均半径
            var plotBounds = this.vanchart.getPlotBounds();
            var averageRadius = plotBounds.height / Math.max(1, gaugeData.length - fixedSize);
            averageRadius /= 2;

            var leftBounds = {
                x:0,
                y:0,
                width:plotBounds.width,
                height:plotBounds.height
            };

            for(var i = 0, len = gaugeData.length; i < len; i++){

                var singleGauge = gaugeData[i];

                if(!singleGauge.center){

                    var size = 0;

                    if(singleGauge.style == Constants.GAUGE_THERMOMETER){

                        if(singleGauge.thermometerLayout == Constants.VERTICAL_LAYOUT){

                            size = (singleGauge.radius || averageRadius) * 2;

                            singleGauge.bounds = {
                                x:leftBounds.x,
                                y:leftBounds.y,
                                width:leftBounds.width,
                                height:size
                            };

                            leftBounds.y += size;
                            leftBounds.height -= size;

                        }else{

                            if(isEqualThermometer){
                                size = averageRadius * 2;
                            }else{
                                size = this._getThermometerSize(singleGauge);
                            }

                            var width = singleGauge.radius ? singleGauge.radius * 2 : leftBounds.width;

                            width = Math.min(width, leftBounds.width);

                            singleGauge.bounds = {
                                x:leftBounds.x,
                                y:leftBounds.y,
                                width:width,
                                height:size
                            };

                            leftBounds.y += size;
                            leftBounds.height -= size;
                        }

                    }else{

                        size = (singleGauge.radius || averageRadius) * 2;

                        singleGauge.bounds = {
                            x:leftBounds.x,
                            y:leftBounds.y,
                            width:leftBounds.width,
                            height:size
                        };

                        leftBounds.y += size;
                        leftBounds.height -= size;
                    }
                }
            }

        },

        //试管仪表盘占据的大小,不算间隔
        _getThermometerSize:function(gauge){

            var showValueLabel = gauge.valueLabelContent ? gauge.valueLabelContent[0] : null;
            var percentageLabel = gauge.percentageLabel;
            var valueLabel = gauge.valueLabel;
            var gaugeAxis = gauge.gaugeAxis;

            if(gauge.thermometerLayout == Constants.HORIZONTAL_LAYOUT){

                var totalHeight = 0;

                if(gauge.percentageLabelContent && showValueLabel){
                    if(percentageLabel.align == valueLabel.align){
                        totalHeight += (gauge.percentageLabelDim.height + showValueLabel.labelDim.height);
                        totalHeight += LINE_GAP * gauge.percentageLabelDim.height;

                        totalHeight += HORIZONTAL_GAP * (valueLabel.align == Constants.TOP
                                ? showValueLabel.labelDim.height : gauge.percentageLabelDim.height);
                    }
                }else if(gauge.percentageLabelContent){
                    totalHeight += (1 + HORIZONTAL_GAP) * gauge.percentageLabelDim.height;
                }else if(showValueLabel){
                    totalHeight += (1 + HORIZONTAL_GAP) * showValueLabel.labelDim.height;
                }

                totalHeight += (THERMOMETER_R * 2 + TICK_LABEL_GAP + TICK_SIZE + TICK_LABEL_GAP + gaugeAxis.getTickHeight());

                return totalHeight;

            }else{

                var totalWidth = 0;
                if(gauge.percentageLabelContent && showValueLabel){
                    if(percentageLabel.align == valueLabel.align){
                        totalWidth += Math.max(gauge.percentageLabelDim.width, showValueLabel.labelDim.width);
                        totalWidth += VERTICAL_GAP * Math.max(gauge.percentageLabelDim.height, showValueLabel.labelDim.height);
                    }else{
                        totalWidth += (gauge.percentageLabelDim.width + showValueLabel.labelDim.width);
                        totalWidth += VERTICAL_GAP * (gauge.percentageLabelDim.height + showValueLabel.labelDim.height);
                    }
                }else if(gauge.percentageLabelContent){
                    totalWidth += (gauge.percentageLabelDim.width + VERTICAL_GAP * gauge.percentageLabelDim.height);
                }else if(showValueLabel){
                    totalWidth += (showValueLabel.labelDim.width + VERTICAL_GAP * showValueLabel.labelDim.height);
                }

                totalWidth += gaugeAxis.getMaxTickWidth();

                totalWidth += (THERMOMETER_R * 2 + TICK_LABEL_GAP + TICK_SIZE + TICK_LABEL_GAP);

                return totalWidth;
            }

            return DEFAULT_RADIUS;
        },

        _getFixedPos:function(datum, divDim){

            var gauge = datum.series || datum;

            var style = gauge.style;
            var thermometerLayout = gauge.thermometerLayout;

            var plotBounds = this.getPlotBounds();

            switch (style){
                case Constants.GAUGE_POINTER:
                case Constants.GAUGE_SLOT:
                case Constants.GAUGE_RING:

                    var x = plotBounds.x + gauge.centerX + gauge.radius + 10;
                    var y = plotBounds.y + gauge.centerY - divDim.height/2;

                    return [x, y];

                case Constants.GAUGE_POINTER_SEMI:
                    var x = plotBounds.x + gauge.centerX - divDim.width/2;
                    var y = plotBounds.y + gauge.centerY + 0.14 * gauge.radius + 10;

                    return [x, y];
                case Constants.GAUGE_THERMOMETER:

                    var x, y;

                    if(thermometerLayout == Constants.HORIZONTAL_LAYOUT){
                        x = plotBounds.x + gauge.centerX - divDim.width/2;
                        var baseY = plotBounds.y + gauge.centerY;
                        y = baseY + THERMOMETER_R + 10;

                        if(gauge.percentageLabelContent && gauge.percentageLabel.align == Constants.BOTTOM){
                            y = baseY + gauge.percentageLabelPos.y + gauge.percentageLabelDim.height + 10;
                        }

                        if(gauge.valueLabelContent && gauge.valueLabel.align == Constants.BOTTOM){
                            var valueLabel = gauge.valueLabelContent[0];
                            y = baseY + valueLabel.labelPos.y + valueLabel.labelDim.height + 10;
                        }

                    }else{

                        y = plotBounds.y + gauge.centerY - divDim.height/2;

                        var tickWidth = gauge.gaugeAxis.getMaxTickWidth();

                        var baseX = plotBounds.x + gauge.centerX;
                        x = baseX + THERMOMETER_R + TICK_LABEL_GAP + TICK_SIZE + TICK_LABEL_GAP + tickWidth + 10;

                        if(gauge.percentageLabelContent && gauge.percentageLabel.align == Constants.RIGHT){

                            x = baseX + gauge.percentageLabelPos.x + gauge.percentageLabelDim.width + 10;
                        }

                        if(gauge.valueLabelContent && gauge.valueLabel.align == Constants.RIGHT){
                            var valueLabel = gauge.valueLabelContent[0];
                            x = Math.max(x, baseX + valueLabel.labelPos.x + valueLabel.labelDim.width + 10)
                        }
                    }

                    return [x, y];
            }
        },

        getClosestPoint:function(){
            var hoverSeries = this.vanchart.hoverSeries;
            if(hoverSeries
                && hoverSeries.style != Constants.GAUGE_POINTER
                                && hoverSeries.style != Constants.GAUGE_POINTER_SEMI){
                return hoverSeries.points[0];
            }

        }
    });
    
    require('../ChartLibrary').register(Constants.GAUGE_CHART, Gauge);
    return Gauge;
});
/**
 * Created by eason on 15/12/31.
 */
define('chart/Radar',['require','./BaseChart','../utils/BaseUtils','../Constants','../utils/QueryUtils','../utils/BoundsManager','../theme/options','../ChartLibrary'],function(require){

    var BaseChart = require('./BaseChart');
    var BaseUtils = require('../utils/BaseUtils');
    var Constants = require('../Constants');
    var QueryUtils = require('../utils/QueryUtils');
    var BoundsManager = require('../utils/BoundsManager');
    var Options = require('../theme/options');

    var DELAY = 200;
    var PADDING_GAP = 10;
    var LABEL_BORDER_GAP = 8;

    var TOP = 'radar-top';
    var BOTTOM = 'radar-bottom';
    var LEFT = 'radar-left';
    var RIGHT = 'radar-right';

    var Radar = BaseChart.extend({
        constructor:Radar,

        doLayout:function(){

            var locations2Series = this._buildLocationMap();

            for(var location in locations2Series){

                var location2Series = locations2Series[location];

                for(var i = location2Series.length - 1; i >= 0; i--) {

                    var sameAxisSeries = location2Series[i];

                    if(sameAxisSeries && sameAxisSeries.length) {

                        this._buildRadarSeries(sameAxisSeries);

                    }
                }
            }

        },

        mergeDataPointAttributes:function(point){
            this._mergeMarkerAttributes(point);
            point.columnType = this.isColumnType();
        },

        mergeSeriesAttributes:function(series){

            var queryList = [
                series.seriesOption,
                this.option.plotOptions[series.type],
                this.option.plotOptions,
                Options[series.type].plotOptions
            ];

            var columnType = QueryUtils.queryList(queryList, 'columnType');

            this.columnType = columnType;

            var connectNulls = BaseUtils.pick(QueryUtils.queryList(queryList, 'connectNulls'), true);

            var lineWidth = QueryUtils.queryList(queryList, 'lineWidth') || 0;

            var fillColor = QueryUtils.queryList(queryList, 'fillColor');
            var lineColor = QueryUtils.queryList(queryList, 'color') || this._getDefaultSeriesColor(series.name);

            fillColor = fillColor ? (fillColor === true ? lineColor : fillColor) : '';

            var fillColorOpacity = BaseUtils.pick(QueryUtils.queryList(queryList, 'fillColorOpacity'), (columnType ? 1 : 0.15)) ;

            QueryUtils.merge(series,{
                lineWidth:lineWidth,
                lineColor:lineColor,
                columnType:columnType,
                connectNulls:connectNulls,
                fillColor:fillColor,
                fillColorOpacity:fillColorOpacity
            });
        },

        _buildRadarSeries:function(locationMap){

            this._calculateCategoryBasedPercentageAndTooltip(locationMap);

            var tSery = locationMap[0][0];
            var radiusAxis = tSery.radiusAxis;
            var angleAxis = tSery.angleAxis;

            this.baseAxis = angleAxis;
            this.valueAxis = radiusAxis;
            this.cateScale = angleAxis.scale;
            this.valueScale = radiusAxis.scale;
            this.center = radiusAxis.polar.center;
            this.radius = radiusAxis.polar.radius;
            this.piece = angleAxis.piece;

            var self = this;

            for(var i = 0, count = locationMap.length; i < count; i++){
                var stackedSeries = locationMap[i];

                stackedSeries.forEach(function(series){

                    //先排序
                    series.points.sort(function(pointA, pointB){
                        return self.cateScale(pointA.category) - self.cateScale(pointB.category);
                    });

                    series.points.forEach(function(point){
                        var preSum = point.y0;

                        point.y0 = self.valueScale(preSum);

                        point.y = self.valueScale(point.y + preSum);

                        point.radian = self.cateScale(point.category) * self.piece;

                        point.pos = self._getArcPoint(point.y, point.radian);

                        if(point.dataLabels && point.dataLabels.enabled){
                            series.columnType ? self._calculateColumnTypeLabelPos(point) : self._calculatePolygonTypeLabelPos(point);
                        }
                    });

                    series.pathSegment = self._getPathSegment(series.points, series.connectNulls);
                });
            }
        },

        _calculateColumnTypeLabelPos:function(point){

            var position = this._getRadarPosition(point.category);
            var pos = this._getArcPoint(point.y - LABEL_BORDER_GAP, point.radian);
            var labelDim = point.labelDim;

            switch (position){
                case TOP:

                    point.labelPos = {
                        x:-labelDim.width/2,
                        y:pos[1]
                    };

                    break;

                case RIGHT:

                    point.labelPos = {
                        x:pos[0] - labelDim.width,
                        y:pos[1] - labelDim.height/2
                    };
                    break;

                case BOTTOM:

                    point.labelPos = {
                        x:-labelDim.width/2,
                        y:pos[1] - labelDim.height
                    };

                    break;

                case LEFT:

                    point.labelPos = {
                        x:pos[0],
                        y:pos[1] - labelDim.height/2
                    };

                    break
            }
        },

        _calculatePolygonTypeLabelPos:function(point){

            var position = this._getRadarPosition(point.category);
            var pos = this._getArcPoint(point.y + LABEL_BORDER_GAP, point.radian);
            var labelDim = point.labelDim;

            switch (position){
                case TOP:

                    point.labelPos = {
                        x:-labelDim.width/2,
                        y:pos[1] - labelDim.height
                    };

                    break;

                case RIGHT:

                    point.labelPos = {
                        x:pos[0],
                        y:pos[1] - labelDim.height/2
                    };
                    break;

                case BOTTOM:

                    point.labelPos = {
                        x:-labelDim.width/2,
                        y:pos[1]
                    };

                    break;

                case LEFT:

                    point.labelPos = {
                        x:pos[0] - labelDim.width,
                        y:pos[1] - labelDim.height/2
                    };

                    break
            }

        },

        _getRadarColumnPath:function(innerRadius, radius, radian){

            var halfSize = this.piece * 0.375;

            var startRadian = radian - halfSize;

            var endRadian = radian + halfSize;

            var arc = d3.svg.arc()
                .innerRadius(innerRadius).outerRadius(radius)
                .startAngle(startRadian).endAngle(endRadian);

            return arc();
        },

        _getPathSegment:function(dataPoints, connectNulls){

            var pathSeg = [];

            var tmp = [];

            if(connectNulls){

                pathSeg.push(tmp);

                dataPoints.forEach(function(dataPoint){

                    if(!dataPoint.isNull){
                        tmp.push(dataPoint.pos);
                    }

                });
            }else{

                var startIndex = 0;
                var count = dataPoints.length;

                for(var index = count - 1; index > 0; index--){

                    var current = dataPoints[index];
                    var pre = dataPoints[index - 1];

                    if(!current.isNull && pre.isNull){
                        startIndex = index;
                    }
                }

                for(var index = 0; index < count; index++){

                    var dataPoint = dataPoints[(index + startIndex) % count];

                    if(dataPoint.isNull && tmp.length){

                        if(tmp.length > 1){
                            pathSeg.push(tmp)
                        };

                        tmp = [];
                    }else{
                        tmp.push(dataPoint.pos);
                    }

                }

                if(tmp.length){
                    pathSeg.push(tmp);
                }
            }

            return pathSeg;
        },

        _getRadarSeriesFillPath:function(pathSeg, connectNulls){
            return this._getRadarSeriesPath(pathSeg, connectNulls, true);
        },

        _getRadarSeriesStrokePath:function(pathSeg, connectNulls){
            return this._getRadarSeriesPath(pathSeg, connectNulls, false);
        },

        _getRadarSeriesPath:function(pathSeg, connectNulls, toCenter){

            var path = '';
            var tmp = [];
            if(pathSeg.length == 1){

                tmp = pathSeg[0];

                var fullShape = tmp.length == this.baseAxis.getCategoryCount() || connectNulls;

                toCenter = (!fullShape && toCenter);

                path = toCenter ? 'M0,0' : '';

                for(var i = 0, count = tmp.length; i < count; i++){

                    var mOrl = (i || toCenter) ? 'L' : 'M';

                    path += (mOrl + BaseUtils.dealFloatPrecision(tmp[i][0]) + "," + BaseUtils.dealFloatPrecision(tmp[i][1]));
                }

                path += (fullShape || toCenter) ? 'Z' : '';

            }else{
                pathSeg.forEach(function(tmp){

                    path += toCenter ? 'M0,0' : '';

                    tmp.forEach(function(pos){
                        path += ('L' + BaseUtils.dealFloatPrecision(pos[0]) + "," + BaseUtils.dealFloatPrecision(pos[1]));
                    });

                    path += toCenter ? 'Z' : '';
                });
            }

            return path;
        },

        _getRadarPosition:function(category){

            var index = this.cateScale(category);
            var domain = this.cateScale.domain();
            var midIndex = domain.length / 2;

            if(index == 0){
                return TOP;
            }else if(index > 0 && index < midIndex){
                return RIGHT;
            }else if(index == midIndex){
                return BOTTOM;
            }else if(index > midIndex){
                return LEFT;
            }

        },

        getRadarCenter:function(){
            return this.center;
        },

        getBaseAxis:function(){
            return this.baseAxis;
        },

        getValueAxis:function(){
            return this.valueAxis;
        },

        isColumnType:function(){
            return this.columnType;
        },

        getInitRadius:function(){
            return this.valueScale(this.valueAxis.getStartPosValue());
        },

        _getInitPathSegment:function(pathSeg){
            var init = [];
            pathSeg.forEach(function(seg){
                var tmp = [];
                init.push(tmp);

                seg.forEach(function(){
                    tmp.push([0,0])
                })
            });

            return init;
        },

        _getFixedPos:function(datum, divDim){

            var x, y;

            if(datum.columnType){

                var radius = datum.y;
                var centerAngle = datum.radian;

                x = radius * Math.sin(centerAngle) + this.center[0];
                y = radius * Math.cos(centerAngle + Math.PI) + this.center[1];

                if(centerAngle < Math.PI / 2){
                    y -= divDim.height;
                }else if(centerAngle >= Math.PI && centerAngle < 3 * Math.PI / 2){
                    x -= divDim.width;
                }else if(centerAngle >= 3 * Math.PI / 2 && centerAngle < Math.PI * 2){
                    y -= divDim.height;
                    x -= divDim.width;
                }

            }else{
                var radius = datum.marker.radius || this.getDefaultMarkerRadius();
                x = this.center[0] + datum.pos[0] + radius;
                y = this.center[1] + datum.pos[1] + radius;
            }

            return [x, y];
        },

        getClosestPoint:function(pos){

            if(this.isColumnType()){
                return;
            }

            var selectedPoint;
            var minDistance = Number.MAX_VALUE;
            var lineData = this.vanchart.hoverSeries;
            var center = this.center;

            if(lineData){
                lineData.points.forEach(function(point){

                    var markerPos = point.pos;

                    var detX = markerPos[0] + center[0] - pos[0];
                    var detY = markerPos[1] + center[1] - pos[1];
                    var dis = Math.sqrt(detX * detX + detY * detY);

                    if(dis < minDistance && !point.isNull){
                        selectedPoint = point;
                        minDistance = dis;
                    }
                });
            }else{
                var series = this.vanchart.series;

                series.forEach(function(sery){

                    if(sery.points){
                        sery.points.forEach(function(point){

                            var markerPos = point.pos;

                            var detX = markerPos[0] + center[0] - pos[0];
                            var detY = markerPos[1] + center[1] - pos[1];
                            var dis = Math.sqrt(detX * detX + detY * detY);

                            if(dis < minDistance && !point.isNull){
                                selectedPoint = point;
                                minDistance = dis;
                            }
                        });
                    }
                });
            }

            return selectedPoint;
        }
    });

    require('../ChartLibrary').register(Constants.RADAR_CHART, Radar);
    
    return Radar;
});
/**
 * Created by Mitisky on 16/3/14.
 */
define('chart/Bubble',['require','./BaseChart','../utils/BaseUtils','../Constants','../utils/QueryUtils','../utils/ColorUtils','../theme/options','../ChartLibrary'],function(require){
    var BaseChart = require('./BaseChart');
    var BaseUtils = require('../utils/BaseUtils');
    var Constants = require('../Constants');
    var QueryUtils = require('../utils/QueryUtils');
    var ColorUtils = require('../utils/ColorUtils');
    var Options = require('../theme/options');

    var DEFAULT_BUBBLE_ALPHA = 0.7;
    var BUBBLES_SHOW_TIME = 800;
    var NEGATIVE_COLOR = 'rgb(138, 138, 138)';

    var Bubble = BaseChart.extend({

        doLayout:function(){

            var series = this.getVisibleChartData();

            //力学气泡图的时候计算百分比和标签内容
            if(this.isForceBubble()){
                this.dealStackedSeries(series);
            }

            var allPoints = [];
            series.forEach(function(sery){
                allPoints = allPoints.concat(sery.points);
            });

            var self = this;
            this.calculateBubbleRadius();
            this._calculateBubblePosition(series, allPoints);
            allPoints.forEach(function(point){
                self._calculatePointLabelAndTooltip(point);
            });
        },

        calculateBubbleRadius:function(){
            var series = this.getVisibleChartData();
            var minSize = Number.MAX_VALUE;//所有数据的最大最小值
            var maxSize = -minSize;
            var minSizeArray = [];//每个系列数据的最大最小值
            var maxSizeArray = [];
            var self = this;
            series.forEach(function(sery, i) {
                if (sery.points.length > 0) {
                    var seriesMinSize = Number.MAX_VALUE;//当前系列数据的最大最小值
                    var seriesMaxSize = -seriesMinSize;
                    for(var index = 0, len = sery.points.length; index < len; index++){
                        var point = sery.points[index];
                        var pointS = point.size;
                        if(pointS < 0){
                            if(point.displayNegative){
                                pointS = Math.abs(pointS);
                                if(sery.chart.option.legend.enabled) {
                                    self._setNegativeColorAttr(point, sery);
                                }
                            } else {
                                continue;
                            }
                        }
                        seriesMaxSize = Math.max(seriesMaxSize, pointS);
                        seriesMinSize = Math.min(seriesMinSize, pointS);
                    }
                    minSize = Math.min(minSize, seriesMinSize);
                    maxSize = Math.max(maxSize, seriesMaxSize);
                    minSizeArray[i] = seriesMinSize;
                    maxSizeArray[i] = seriesMaxSize;
                }
            });

            var scale = BaseUtils.pick(this.vanchart.scale, 1);

            series.forEach(function(sery, i) {
                if (sery.points.length > 0) {
                    var seriesMaxDiameter = sery.maxSize;
                    var seriesMinDiameter = sery.minSize;
                    var sizeByArea = sery.sizeBy == Constants.SIZE_BY_AREA;
                    //系列条件属性设置最大最小半径，则气泡半径根据该系列最大最小size计算
                    var sizeBySeriesMinMax = BaseUtils.hasDefined(sery.seriesOption.minSize) && BaseUtils.hasDefined(sery.seriesOption.maxSize);
                    var seriesMaxSize = sizeBySeriesMinMax ? maxSizeArray[i] : maxSize;
                    var seriesMinSize = sizeBySeriesMinMax ? minSizeArray[i] : minSize;

                    var unit = 0;
                    if(seriesMaxSize != seriesMinSize){
                        unit = sizeByArea ? (seriesMaxDiameter * seriesMaxDiameter - seriesMinDiameter * seriesMinDiameter) / (seriesMaxSize - seriesMinSize)
                            : (seriesMaxDiameter - seriesMinDiameter ) / (seriesMaxSize - seriesMinSize);
                    }

                    sery.points.forEach(function(point) {
                        var temp = unit * (Math.abs(point.size) - seriesMinSize);
                        var diameter = sizeByArea ? Math.sqrt(seriesMinDiameter * seriesMinDiameter + temp)
                            : seriesMinSize + temp;
                        if(point.pointOption.minSize && point.pointOption.maxSize){
                            diameter = point.pointOption.minSize;
                        }
                        diameter = (point.size < 0 && !point.displayNegative) ? 0 : diameter;
                        point.radius = (diameter/2) * scale;
                    });
                }
            });
        },

        _calculateBubblePosition:function(series, allPoints){

            this.isForceBubble() ? this._calculateForceBubblePosition(series, allPoints)
                : this._calculateNormalBubblePosition(series, allPoints);
        },

        _calculateNormalBubblePosition:function(series, allPoints){

            series.forEach(function(sery){
                var baseAxis = sery.baseAxis;
                var valueAxis = sery.valueAxis;

                sery.points.forEach(function(point){

                    var det = baseAxis.scale.rangeBand ? baseAxis.scale.rangeBand()/2 : 0;
                    var t1 = Math.round(baseAxis.scale(point.category) + det);
                    var t2 = valueAxis.scale(point.value + point.y0);

                    QueryUtils.merge(point, {
                        posX: t1,
                        posY: t2
                    }, true);
                })
            });

            if(this.isSupportAnimation()) {

                allPoints.sort(function (pointA, pointB) {
                    return pointB.radius - pointA.radius;
                });

                var len = allPoints.length;
                if (len > 0) {
                    var unitTime = BUBBLES_SHOW_TIME / len;
                    allPoints.forEach(function (point, i) {

                        QueryUtils.merge(point, {
                            delayTime: unitTime * i
                        }, true);

                    });
                }
            }

        },

        _calculateForceBubblePosition:function(series, nodes){
            var maxRadius = 0;
            var plotBounds = this.getPlotBounds();
            var size = [plotBounds.width, plotBounds.height];

            series.forEach(function(sery){
                var cluster;
                sery.points.forEach(function(point){
                    cluster = cluster || point;
                    cluster = point.radius > cluster.radius ? point : cluster;
                    maxRadius = Math.max(maxRadius, point.radius);
                });

                sery.cluster = cluster;
            });

            //ie下需要模拟计算
            if(this.isUpdateWithForce()){
                return;
            }

            d3.layout.pack().sort(null)
                .size(size)
                .children(function(d) {
                    return d.values;
                })
                .value(function(d) {
                    return d.radius * d.radius;
                })
                .nodes({values: d3.nest()
                    .key(function(d) { return d.seriesName; })
                    .entries(nodes)});

            //模拟集聚的过程
            var start = 0.1, end = 0.005;
            var padding = 2, clusterPadding = 2;
            var paddingAlpha = 0.5;
            var gravity = 0.02;
            var friction = 0.9;

            //set px,py
            nodes.forEach(function(point){
                point.px = point.x;
                point.py = point.y;
            });

            for(var alpha = start; alpha >= end; alpha -= (alpha > 0.07 ? 0.001 : 0.0005)){

                var n = nodes.length, i, o, k, x, y;

                if (k = alpha * gravity) {
                    x = size[0] / 2;
                    y = size[1] / 2;
                    i = -1;
                    if (k) while (++i < n) {
                        o = nodes[i];
                        o.x += (x - o.x) * k;
                        o.y += (y - o.y) * k;
                    }
                }
                i = -1;
                while (++i < n) {
                    o = nodes[i];
                    o.x -= (o.px - (o.px = o.x)) * friction;
                    o.y -= (o.py - (o.py = o.y)) * friction;
                }

                nodes.forEach(function(d){
                    //集聚
                    var cluster = d.series.cluster;

                    if (cluster && cluster != d){
                        var x = d.x - cluster.x,
                            y = d.y - cluster.y,
                            l = Math.sqrt(x * x + y * y),
                            r = d.radius + cluster.radius;
                        if (l != r) {
                            l = (l - r) / l * alpha;
                            d.x -= x *= l;
                            d.y -= y *= l;
                            cluster.x += x;
                            cluster.y += y;
                        }
                    }});

                for(var i = 0; i < n; i++){
                    var d = nodes[i];

                    for(var j = 0; j < n; j++){
                        var point = nodes[j];

                        if (point !== d) {
                            var x = d.x - point.x,
                                y = d.y - point.y,
                                l = Math.sqrt(x * x + y * y),
                                r = d.radius + point.radius + (d.series.cluster === point.series.cluster ? padding : clusterPadding);
                            if (l < r) {
                                l = (l - r) / l * paddingAlpha;
                                d.x -= x *= l;
                                d.y -= y *= l;
                                point.x += x;
                                point.y += y;
                            }
                        }
                    }
                }
            }

            nodes.forEach(function(point){
                point.posX = point.x;
                point.posY = point.y;
            })
        },

        _setNegativeColorAttr:function(point, sery){
            point.color = NEGATIVE_COLOR;
            point.clickColor = ColorUtils.getClickColor(NEGATIVE_COLOR);
            var queryList = [
                point.pointOption,
                sery.seriesOption,
                sery.chart.option.plotOptions[sery.type],
                sery.chart.option.plotOptions,
                Options[sery.type].plotOptions
            ];
            point.mouseOverColor = QueryUtils.queryList(queryList, 'mouseOverColor') || ColorUtils.getHighLightColor(NEGATIVE_COLOR);
        },

        _calculatePointLabelAndTooltip:function(point){

            var withForce = this.isUpdateWithForce();

            if(this.isForceBubble()){
                //力学气泡图
                if(point.labelContent && point.labelDim){

                    var radius = point.radius;
                    if((point.labelDim.width > 2 * radius) || (point.labelDim.height > 2 * radius)){
                        point.labelPos = null;
                    }else{

                        var posX = withForce ? 0 : point.posX;
                        var posY = withForce ? 0 : point.posY;

                        point.labelPos = {
                            x:-point.labelDim.width/2 + posX,
                            y:-point.labelDim.height/2 + posY
                        }
                    }

                }

            }else{
                var dataLabels = point.dataLabels;
                if(dataLabels && dataLabels.enabled) {

                    this._calculateBubbleLabelInfo(point, dataLabels, Constants.INSIDE);

                    this._calculateLabelPos(point);
                }
            }

            this.mergeSinglePointTooltipAttr(point);
        },

        _calculateLabelPos:function(point) {
            var labelDim = point.labelDim;
            var x = point.posX - labelDim.width/2;
            var y = point.posY - labelDim.height/2;
            var labelPos = {
                x: x,
                y: y
            };
            QueryUtils.merge(point, {
                labelPos: labelPos
            }, true);
        },

        getTrendLineXYValues:function(sery){
            return this.getBubbleTrendLineXYValues(sery);
        },

        _getFixedPos:function(datum){
            var radius = datum.radius || 0;

            var plotBounds = this.getPlotBounds();

            var x = this.isForceBubble() ? datum.x : datum.posX;
            var y = this.isForceBubble() ? datum.y : datum.posY;

            var x = plotBounds.x + x + radius;
            var y = plotBounds.y + y + radius;

            return [x, y];
        },

        mergeDataPointAttributes:function(point){
            var queryList = [
                point.pointOption,
                point.series.seriesOption,
                this.option.plotOptions[this.componentType],
                this.option.plotOptions,
                Options[this.componentType].plotOptions
            ];
            var fillColorOpacity = BaseUtils.pick(QueryUtils.queryList(queryList, 'fillColorOpacity'), DEFAULT_BUBBLE_ALPHA);
            var size = BaseUtils.pick(QueryUtils.queryList(queryList, 'size'), 0);

            var isForceBubble = this.isForceBubble();

            QueryUtils.merge(point, {
                fillColorOpacity: fillColorOpacity,
                x:point.category,
                y:point.value,
                size: isForceBubble ? (point.isNull ? '-' : point.value) : size, //力学气泡图没有size的值
                shadow: QueryUtils.queryList(queryList, 'shadow'),
                displayNegative: QueryUtils.queryList(queryList, 'displayNegative'),
                delayTime:0
            }, true);

            if(isForceBubble){
                point.x = undefined;
                point.y = undefined;
            }
        },

        mergeSeriesAttributes:function(sery) {

            var queryList = [
                sery.seriesOption,
                this.option.plotOptions[this.componentType],
                this.option.plotOptions,
                Options[this.componentType].plotOptions
            ];

            QueryUtils.merge(sery,{
                sizeBy: QueryUtils.queryList(queryList, 'sizeBy'),
                maxSize: QueryUtils.queryList(queryList, 'maxSize'),
                minSize: QueryUtils.queryList(queryList, 'minSize'),
                shadow: QueryUtils.queryList(queryList, 'shadow'),
                displayNegative: QueryUtils.queryList(queryList, 'displayNegative')
            });
        },

        getClosestPoint:function(pos){

            var series = this.getVisibleChartData();

            var plotBounds = this.getPlotBounds();

            for(var sIndex = series.length - 1; sIndex >= 0; sIndex--){
                var sery = series[sIndex];

                for(var pIndex = sery.points.length - 1; pIndex >= 0; pIndex--){

                    var point = sery.points[pIndex];

                    var detX = point.posX + plotBounds.x - pos[0];

                    var detY = point.posY + plotBounds.y - pos[1];

                    var len = Math.sqrt(detX * detX + detY * detY);

                    if(len <= point.radius){
                        return point;
                    }
                }
            }
        },

        getRender:function(){
            return !this.vanchart._leaflet && this.render;
        }
        
    });

    require('../ChartLibrary').register(Constants.BUBBLE_CHART, Bubble);

    return Bubble;
});

/**
 * Created by Mitisky on 16/3/24.
 */
define('chart/Scatter',['require','./BaseChart','../utils/BaseUtils','../utils/ColorUtils','../Constants','../utils/QueryUtils','../theme/options','../ChartLibrary'],function (require) {
    var BaseChart = require('./BaseChart');
    var BaseUtils = require('../utils/BaseUtils');
    var ColorUtils = require('../utils/ColorUtils');
    var Constants = require('../Constants');
    var QueryUtils = require('../utils/QueryUtils');
    var Options = require('../theme/options');

    var POINTS_SHOW_TIME = 800;
    var DEFAULT_SCATTER_ALPHA = 1;
    var LABEL_GAP = 2;

    var Scatter = BaseChart.extend({

        constructor: Scatter,

        selfSeryIndex: 0,

        doLayout: function () {
            this.selfSeryIndex = 0;
            var self = this;
            var series = this.getVisibleChartData();
            var allPoints = [];

            series.forEach(function(sery) {
                if (sery.points.length > 0) {
                    var baseAxis = sery.baseAxis;
                    var valueAxis = sery.valueAxis;
                    sery.points.forEach(function(point) {
                        //这句是必要的，点击图例点原地消失
                        if(point.visible) {
                            var det = baseAxis.scale.rangeBand ? baseAxis.scale.rangeBand() / 2 : 0;
                            var x = Math.round(baseAxis.scale(point.category) + det);
                            var y = valueAxis.scale(point.value + point.y0);

                            QueryUtils.merge(point, {
                                posX: x,
                                posY: y
                            }, true);

                            self._calculatePointLabelAndTooltip(point);
                        }
                    });
                    allPoints = allPoints.concat(sery.points);

                    sery.points.sort(function (pA, pB) {
                        return pA.posX - pB.posX;
                    });
                }
            });

            this._calculatePointDelayTime(allPoints);
        },

        _calculatePointDelayTime:function(allPoints) {
            if(this.isSupportAnimation()) {
                var len = allPoints.length;

                if (len > 0) {
                    allPoints.forEach(function (point, i) {
                        var delayTime = d3.ease('exp-in-out')(i/len) * POINTS_SHOW_TIME;
                        QueryUtils.merge(point, {
                            delayTime: delayTime
                        }, true);

                    });
                }
            }
        },

        _calculatePointLabelAndTooltip:function(point){

            var dataLabels = point.dataLabels;
            if(dataLabels && dataLabels.enabled) {
                this._calculateBubbleLabelInfo(point, dataLabels, Constants.OUTSIDE);

                this._calculateLabelPos(point);
            }

            this.mergeSinglePointTooltipAttr(point);

        },

        _calculateLabelPos:function(point) {
            var labelDim = point.labelDim;
            var labelPos = {
                x: point.posX - labelDim.width/2,
                y: point.posY  - LABEL_GAP - labelDim.height
            };
            QueryUtils.merge(point, {
                labelPos: labelPos
            }, true);
        },

        getTrendLineXYValues:function(sery){
            return this.getBubbleTrendLineXYValues(sery);
        },

        _createCategoryLine:function(data, label, style, formatter){
            return this._createBubbleTooltipSeriesLine(data, label, style, formatter);
        },

        _createSeriesLine:function(data, label, style, formatter){
            return this._createBubbleTooltipXYSizeLine(data, label, style, formatter);
        },

        _getFixedPos:function(datum){
            var radius = datum.marker.radius || this.getDefaultMarkerRadius();

            var plotBounds = this.getPlotBounds();

            var x = plotBounds.x + datum.posX + radius;
            var y = plotBounds.y + datum.posY + radius;

            return [x, y];
        },

        mergeDataPointAttributes:function(point){
            var queryList = [
                point.pointOption,
                point.series.seriesOption,
                this.option.plotOptions[point.series.type],
                this.option.plotOptions,
                Options[point.series.type].plotOptions
            ];
            var fillColorOpacity = BaseUtils.pick(QueryUtils.queryList(queryList, 'fillColorOpacity'), DEFAULT_SCATTER_ALPHA);

            if(point.color){
                fillColorOpacity = BaseUtils.pick(ColorUtils.getColorOpacityWithoutDefault(point.color), fillColorOpacity);
            }

            var size = BaseUtils.pick(QueryUtils.queryList(queryList, 'size'), 0);

            QueryUtils.merge(point, {
                fillColorOpacity: fillColorOpacity,
                x:point.category,
                y:point.value,
                size: size
            }, true);

            //放在最后原因：会用到size
            this._mergeMarkerAttributes(point);
            if(BaseUtils.isNullMarker(point.marker)){
                point.marker.symbol = point.series.marker.symbol;
            }
        },

        mergeSeriesAttributes:function(sery){
            if(BaseUtils.isNullMarker(sery.marker) || BaseUtils.isImageMarker(sery.marker)){
                sery.marker.symbol = BaseUtils.getDefaultMarkerSymbol(this.selfSeryIndex);
                this.selfSeryIndex++;
            }

            var seriesOption = sery.seriesOption;
            var queryList = [
                seriesOption,
                this.option.plotOptions[sery.type],
                this.option.plotOptions,
                Options[sery.type].plotOptions
            ];

            var lineWidth = QueryUtils.queryList(queryList, 'lineWidth') || 0;
            var interpolate = this._getSeriesInterpolate(queryList);
            var lineSvg = d3.svg.line()
                .interpolate(interpolate)
                .x(function (d) {
                    return d.posX;
                })
                .y(function (d) {
                    return d.posY;
                })
                .defined(function (d) {
                    return !d.isNull;
                });

            QueryUtils.merge(sery,
                {
                    lineWidth: lineWidth,
                    lineSvg: lineSvg,
                    interpolate:interpolate
                }
            );
        },

        getClosestPoint:function(pos){

            var series = this.getVisibleChartData();

            var plotBounds = this.getPlotBounds();

            for(var sIndex = series.length - 1; sIndex >= 0; sIndex--){
                var sery = series[sIndex];

                for(var pIndex = sery.points.length - 1; pIndex >= 0; pIndex--){

                    var point = sery.points[pIndex];

                    var detX = point.posX + plotBounds.x - pos[0];

                    var detY = point.posY + plotBounds.y - pos[1];

                    var len = Math.sqrt(detX * detX + detY * detY);

                    var radius =  point.marker.radius || 4.5;

                    if(len <= radius){
                        return point;
                    }
                }
            }
        },

        getRender:function(){
            return !this.vanchart._leaflet && this.render;
        }

    });

    require('../ChartLibrary').register(Constants.SCATTER_CHART, Scatter);
    
    return Scatter;
});

/**
 * Created by eason on 16/5/9.
 */
define('chart/Map',['require','../Constants','../utils/BaseUtils','../utils/QueryUtils','./BaseChart','../component/Geo','../component/Series','../theme/options','../utils/Formatter','../ChartLibrary'],function(require){

    var NAME = 'NAME';
    var SERIES = 'SERIES';
    var VALUE = 'VALUE';
    var PERCENT = 'PERCENT';

    var Constants = require('../Constants');
    var BaseUtils = require('../utils/BaseUtils');
    var QueryUtils = require('../utils/QueryUtils');
    var BaseChart = require('./BaseChart');
    var Geo = require('../component/Geo');
    
    var Series = require('../component/Series');
    var Options = require('../theme/options');
    var Formatter = require('../utils/Formatter');

    var Map = BaseChart.extend({
        type:Constants.MAP_CHART,

        doLayout:function(){
            var bubble = this.vanchart.getChart(Constants.BUBBLE_CHART);
            bubble && bubble.calculateBubbleRadius();

            //百分比,标签,数据提示
            this._calculateTextRelated([Constants.MAP_CHART, Constants.BUBBLE_CHART, Constants.SCATTER_CHART]);

            this.viewreset()
        },

        //重新计算标签
        viewreset:function(){
            
        },

        _calculateTextRelated:function(chartType){

            var series = this.getChartData(chartType);

            var nameMap = {};

            //计算百分比
            for(var i = series.length - 1; i >= 0; i--){
                var total = 0;
                var points = series[i].points;

                points.forEach(function(point){
                    total = BaseUtils.accAdd(total, Math.abs(point.value));
                });

                points.forEach(function(point){
                    point.percentage = Math.abs(BaseUtils.accDiv(total, point.value));

                    nameMap[point.name] = nameMap[point.name] || [];
                    nameMap[point.name].push(point);
                });
            }

            var map = this;
            for(var name in nameMap){
                var points = nameMap[name];
                points.forEach(function(point){

                    point.points = points;
                    //标签
                    if(point.dataLabels && point.dataLabels.enabled){
                        BaseUtils.extend(point, map.calculateMapLabel(point, point.dataLabels, chartType));
                    }

                    //数据点提示
                    if(point.tooltip && point.tooltip.enabled){
                        point.tooltipText = map._calculateTooltipContent(point.tooltip, point, points);
                    }
                });
            }
        },

        calculateMapLabel:function(point, labelInfo, chartType){
            if(!formatter){
                return {};
            }
            var dataLabels = labelInfo || {};
            var formatter =  dataLabels.formatter;
            var useHtml = dataLabels.useHtml;

            var labelPosition = chartType == Constants.SCATTER_CHART ? Constants.OUTSIDE : Constants.INSIDE;

            var content = [];

            if(typeof formatter == 'object'){

                var label = formatter.identifier;

                if(label.indexOf(NAME) != -1){
                    var text = Formatter.format(point.name, formatter.nameFormat);
                    var style = this.getCategorySeriesStyle(dataLabels, labelPosition);
                    var dim = BaseUtils.getTextDimension(text, style, useHtml);
                    content.push({text:text, style:style, dim:dim});
                }

                var line = [];
                if(label.indexOf(SERIES) != -1){
                    line.push(Formatter.format(point.seriesName, formatter.seriesFormat));
                }

                if(label.indexOf(VALUE) != -1){
                    line.push(Formatter.format(point.value, formatter.valueFormat));
                }

                if(label.indexOf(PERCENT) != -1){
                    line.push(Formatter.format(point.percentage, formatter.percentFormat));
                }

                if(line.length){
                    var text = line.join(' ');
                    var style = point.getValuePercentageStyle(dataLabels, labelPosition);
                    var dim = BaseUtils.getTextDimension(text, style, useHtml);
                    content.push({text:text, style:style, dim:dim});
                }

            }else{
                point.pushCustomLabelContent(formatter, dataLabels, useHtml, content, labelPosition);
            }

            var labelDim = point.calculateTextDim(content);

            return {
                labelContent:content,
                labelDim:labelDim
            };

        },

        initLayerInfo:function(){
            this.layerMap = [];
            this.initMapData();
            var drillTools = this.vanchart.getComponent(Constants.DRILL_TOOLS);
            if(drillTools){
                drillTools.addIconData(this.layerMap[0][0]);
            }
            var geo = this.vanchart.getComponent(Constants.GEO_COMPONENT);
            this.vanchart._leaflet.fitBounds(geo.getFitBounds());
        },

        //地图因为更具geoJson的数据,不需要布局,但是需要计算标签的位置等信息
        initMapData:function(series, geo, layerIndex){
            series = series || this.vanchart.series;
            geo = geo || this.vanchart.getComponent(Constants.GEO_COMPONENT);
            layerIndex = layerIndex || 0;

            var isLeafSeries = true;
            for(var i = series.length - 1; i >= 0; i--){
                var sery = series[i];
                this._calculatePercentage(sery.points);
                this._mergeTooltipAttributes(sery.points);

                for(var j = sery.points.length - 1; j >= 0; j--){
                    var point = sery.points[j];
                    if(point.drillSeries && point.geo){
                        isLeafSeries = false;
                        this.layerMap[layerIndex] = this.layerMap[layerIndex] || [];
                        this.layerMap[layerIndex].push({geo:geo, series:series, layerIndex:layerIndex});
                        this.initMapData(point.drillSeries, point.geo, layerIndex + 1);
                    }
                }
            }

            if(isLeafSeries){
                for(var i = series.length - 1; i >= 0; i--){
                    this.layerMap[layerIndex] = this.layerMap[layerIndex] || [];
                    this.layerMap[layerIndex].push({geo:geo, series:series, layerIndex:layerIndex});
                }
            }
        },

        _getComputedMapStyle:function(queryList){
            var style =  {
                fillColor:QueryUtils.queryList(queryList, 'fillColor'),
                fillColorOpacity:QueryUtils.queryList(queryList, 'fillColorOpacity'),
                borderWidth:QueryUtils.queryList(queryList, 'borderWidth'),
                borderColor:QueryUtils.queryList(queryList, 'borderColor'),
                borderOpacity:QueryUtils.queryList(queryList, 'borderOpacity')
            };

            return style;
        },

        mergeSeriesAttributes:function(series){

            var queryList = [
                series.seriesOption,
                this.option.plotOptions[series.type],
                this.option.plotOptions,
                Options[series.type].plotOptions
            ];

            series.mapStyle = this._getComputedMapStyle(queryList);
        },

        mergeDataPointAttributes:function(point){
            var pointOption = point.pointOption;
            var queryList = [
                pointOption,
                point.series.seriesOption,
                this.option.plotOptions[point.series.type],
                this.option.plotOptions,
                Options[point.series.type].plotOptions
            ];
            var drill = QueryUtils.queryList(queryList, 'drill');

            //todo 如何指定其他的值
            var value = BaseUtils.pick(pointOption.value, pointOption[1]);

            var series, geo;
            if(drill){
                series = [];
                var map = this;
                drill.series.forEach(function(sery){
                    series.push(new Series(map, sery));
                });
                this.option.geo = drill.geo;
                geo = new Geo(this.vanchart, this.option, Constants.GEO_COMPONENT);
            }

            var style = this._getComputedMapStyle(queryList);
            style.fillColor = point.color;//todo fillColor,color属性重复

            QueryUtils.merge(point, {
                mapStyle:style,
                drillSeries:series,
                geo:geo,
                value:value
            }, true);

            point.series.validMap = point.series.validMap || {};
            point.series.validMap[location] = true;
        },

        iconDataOfMap:function(series){
            for(var i = this.layerMap.length - 1; i >= 0; i--){
                var layerArray = this.layerMap[i];

                for(var j = layerArray.length - 1; j >= 0; j--){
                    if(layerArray[j].series == series){
                        return layerArray[j];
                    }
                }
            }
        },

        drillDown:function(dataPoint){
            if(dataPoint.drillSeries){
                this.vanchart.series = dataPoint.drillSeries;
                this.vanchart.components.geo = dataPoint.geo;
                this.vanchart._leaflet.fitBounds(dataPoint.geo.getFitBounds());
                var drillTools = this.vanchart.getComponent(Constants.DRILL_TOOLS);
                var iconData = this.iconDataOfMap(dataPoint.drillSeries);
                if(drillTools && iconData){
                    drillTools.addIconData(iconData);
                }
                this.vanchart.refreshComponentsAndSeries();
            }
        },

        drillUp:function(iconData){
            this.vanchart.series = iconData.series;
            this.vanchart.components.geo = iconData.geo;
            this.vanchart._leaflet.fitBounds(iconData.geo.getFitBounds());
            var drillTools = this.vanchart.getComponent(Constants.DRILL_TOOLS);
            if(drillTools){
                drillTools.deleteIconData(iconData.series);
            }

            this.vanchart.refreshComponentsAndSeries();
        },

        _getFixedPos:function(){
            return [0,0]
        }
    });

    require('../ChartLibrary').register(Constants.MAP_CHART, Map);

    return Map;
});
/**
 * Created by eason on 15/8/13.
 */

define('render/PieSvgRender',['require','./BaseRender','../utils/BaseUtils','../utils/ColorUtils','../Constants','../utils/BezierEasing','./RenderLibrary'],function(require){

    var PATH_G = 'path-g';
    var LABEL_G = 'label-g';
    var PIE_G = 'pie-g';

    var BaseRender = require('./BaseRender');
    var BaseUtils = require('../utils/BaseUtils');
    var ColorUtils = require('../utils/ColorUtils');
    var Constants = require('../Constants');
    var Bezier = require('../utils/BezierEasing');

    var HOVER_PERCENT = 1.1;

    var ANIMATION_TIME = 1000;
    var EASE = 'bounce';

    var SORT_EASE = Bezier.css.swing;
    var SORT_TIME = 400;

    var START_STOP = 'start-gradual-stop';
    var END_STOP = 'end-gradual-stop';

    var PieSvgRender = BaseRender.extend({
        
        render:function(){

            var plotBounds = this.component.getPlotBounds();
            var svgRoot = this.component.getVanchartRender().getRenderRoot();

            if(!this._bodyG){
                this._bodyG = svgRoot.append('g');
            }

            this._bodyG.attr('transform', BaseUtils.makeTranslate(plotBounds));

            var self = this;

            var pieData = this.component.getVisibleChartData();

            var pieUpdate = this._bodyG.selectAll('g.' + PIE_G)
                .data(pieData, function(d){return d.className;});

            pieUpdate
                .attr('transform', function(d){return BaseUtils.makeTranslate([d.centerX, d.centerY])})
                .each(function(d){

                    var pieG = d3.select(this);

                    self._updateDefs(pieG.select('defs'), d);

                    self._updateSlices(pieG.select('g.' + PATH_G), d);

                    self._drawLabel(pieG.select('g.' + LABEL_G), d, ANIMATION_TIME);
                });

            var newPie = pieUpdate.enter()
                .append('g')
                .attr('class', function(d){
                    return PIE_G + ' ' + d.className;
                });

            pieUpdate.exit().remove();

            newPie.each(function(d){

                var pieG = d3.select(this)
                    .attr('transform', BaseUtils.makeTranslate([d.centerX, d.centerY]));

                pieG.append('defs');

                pieG.append('g').attr('class', PATH_G);

                pieG.append('g').attr('class', LABEL_G);

                self._updateDefs(pieG.select('defs'), d);

                self._updateSlices(pieG.select('g.' + PATH_G), d, true);

                self._drawLabel(pieG.select('g.' + LABEL_G), d, ANIMATION_TIME);
            });

        },

        _updateDefs:function(defs, config){

            if(!config.style){
                return;
            }

            if(config.style == Constants.STYLE_GRADUAL){

                var self = this;
                var points = config.visiblePoints;
                var grads = defs.selectAll("radialGradient").data(points, function(d){
                    return d.className;
                });

                var newSlice = grads.enter().append('radialGradient');
                newSlice.append('stop').attr('class', START_STOP);
                newSlice.append('stop').attr('class', END_STOP);

                grads
                    .attr("gradientUnits", "userSpaceOnUse")
                    .attr("cx", "0%")
                    .attr("cy", "0%")
                    .attr("r", function(d){
                        return Math.max(d.radius, 0) + 'px';
                    })
                    .attr("id", function(d){
                        return  self._getGradualID(d);
                    });

                grads.select("stop." + START_STOP)
                    .attr("offset", function(d){
                        return (d.series.innerRadius / Math.max(d.radius, 1)) * 100 + '%';
                    })
                    .style("stop-color", function(d){
                        return ColorUtils.getColorWithDivider(d.color, 0.8);
                    });

                grads.select("stop." + END_STOP)
                    .attr("offset", "100%")
                    .style("stop-color", function(d){
                        return d.color;
                    });
            }
        },

        _updateSlices:function(pathG, config, initPie){
            var arc = d3.svg.arc().innerRadius(config.innerRadius);
            var points = config.visiblePoints;

            var initStartAngel = Math.PI * config.startAngle / 180;
            var initEndAngle = Math.PI * config.endAngle / 180;

            var self = this;

            var slices;

            if(this.component.groupDataByClassName()){
                slices = pathG.selectAll('path').data(points, function(d){return d.className});
            }else{
                slices = pathG.selectAll('path').data(points);
            }

            var rotate = d3.transform(pathG.attr('transform')).rotate;
            this.component.recalculateLabelPos(config, BaseUtils.toRadian(rotate));

            var exitSlice = slices.exit();
            var supportAnimation = this.component.isSupportAnimation();

            var emptyExitS = exitSlice.empty() && slices.enter().empty();

            if(supportAnimation){
                exitSlice
                    .transition()
                    .ease(EASE)
                    .duration(ANIMATION_TIME)
                    .attrTween("d", function (d) {

                        //需要消失的系列
                        var dataIndex = this._dataIndex_;
                        var radius = this._current_.radius;

                        var currentArc;
                        if(dataIndex == 0){
                            currentArc = {startAngle: initStartAngel, endAngle: initStartAngel, radius: radius};
                        }else if(dataIndex >= points.length){
                            currentArc = {startAngle: initEndAngle, endAngle: initEndAngle, radius: radius};
                        }else{

                            var preArc = points[dataIndex - 1];
                            if(preArc.lastShape){
                                var preGap = Math.abs(preArc.lastShape.endAngle - preArc.endAngle);
                                var startAngle = d.startAngle + preGap;
                                currentArc = {startAngle: startAngle, endAngle: startAngle, radius: radius};
                            }else{
                                //没有前一个arc的话直接创建
                                currentArc = {startAngle: d.startAngle, endAngle: d.startAngle, radius: d.radius}
                            }
                        }

                        var interpolate = d3.interpolate(this._current_ , currentArc);

                        return function (t) {
                            return arc.outerRadius(d.radius)(interpolate(t));
                        };
                    })
                    .remove();
            }else{
                exitSlice.remove();
            }

            slices.enter().append("path");
            self.addShapeEventHandler(slices);

            var animationTime = (emptyExitS && !initPie) ? SORT_TIME : ANIMATION_TIME;
            var easeFunc = (emptyExitS && !initPie) ? SORT_EASE : EASE;

            slices.each(function(d){

                this._dataIndex_ = self._indexInVisiblePoints(d);
                var index = this._dataIndex_;

                var slice = d3.select(this)
                    .attr('class', d.className)
                    .style("fill", self._getFill(d))
                    .style('stroke', d.borderColor)
                    .style('stroke-width', d.borderWidth);

                if(supportAnimation){
                    slice
                        .transition()
                        .ease(easeFunc)
                        .duration(animationTime)
                        .attrTween("d", function (d) {

                            var currentArc = this._current_;

                            if(initPie){
                                currentArc = {startAngle: initStartAngel, endAngle: initStartAngel, radius:d.radius};
                            }else if(!currentArc){
                                if(index == 0){
                                    currentArc = {startAngle: initStartAngel, endAngle: initStartAngel, radius:d.radius};
                                }else if(index >= points.length - 1){
                                    currentArc = {startAngle: initEndAngle, endAngle: initEndAngle, radius:d.radius};
                                }else{
                                    var preArc = points[index - 1];

                                    if(preArc.lastShape){
                                        var preGap = Math.abs(preArc.lastShape.endAngle - preArc.endAngle);
                                        var startAngle = d.startAngle + preGap;
                                        currentArc = {startAngle: startAngle, endAngle: startAngle, radius: d.radius};
                                    }else{
                                        //没有前一个arc的话直接创建
                                        currentArc = {startAngle: d.startAngle, endAngle: d.startAngle, radius: d.radius}
                                    }

                                }

                            }

                            var interpolate = d3.interpolate(currentArc, self._getArcData(d));

                            this._current_ = interpolate(1);

                            return function (t) {
                                var tmp = interpolate(t);
                                return arc.outerRadius(tmp.radius)(tmp);
                            };
                        });
                }else{

                    slice.attr('d', function(d){
                        this._current_ = self._getArcData(d);
                        return arc.outerRadius(d.radius)(this._current_);
                    })

                }

            });
        },

        _drawLabel:function(labelG, config, delay){

            delay = delay || 0;
            delay = this.component.isSupportAnimation() ? delay : 0;

            var plotBounds = this.component.getPlotBounds();
            var transX = config.centerX + plotBounds.x;
            var transY = config.centerY + plotBounds.y;

            this._drawSvgDataLabels(labelG, config.visiblePoints, transX, transY, delay, config.name);
        },

        onDragStart:function(target, initPos){

            var pieG = this._bodyG.select('g.' + target.className);

            var labelG = pieG.select('g.' + LABEL_G);
            var pathG = pieG.select('g.' + PATH_G);

            //旋转的时候把标签和牵引线隐藏
            this._removeSvgDataLabels(labelG, target.category);

            this.initPos = initPos;
            this.initRotate = d3.transform(pathG.attr('transform')).rotate;
        },

        _getPositionInPie:function(absPos, target){

            var plotBounds = this.component.getPlotBounds();

            var x = absPos[0] - plotBounds.x - target.centerX;

            var y = absPos[1] - plotBounds.y - target.centerY;

            return [x, y];
        },

        onDrag:function(target, currentPos){

            var pieG = this._bodyG.select('g.' + target.className);

            var pathG = pieG.select('g.' + PATH_G);

            var startAngle = this._getAngle(this._getPositionInPie(this.initPos, target), [0,0]);

            var newAngle = this._getAngle(this._getPositionInPie(currentPos, target), [0,0]);

            var rotate = newAngle - startAngle + this.initRotate;

            pathG.attr("transform", "rotate(" + rotate + "," + 0 + "," + 0 + ")");

        },

        onDragEnd:function(target){

            var pieG = this._bodyG.select('g.' + target.className);

            var labelG = pieG.select('g.' + LABEL_G);
            var pathG = pieG.select('g.' + PATH_G);

            var rotate = d3.transform(pathG.attr('transform')).rotate;

            this.component.recalculateLabelPos(target, BaseUtils.toRadian(rotate));

            this._drawLabel(labelG, target);
        },

        _getFill:function(d){

            var gradient = this._bodyG.select('#' + this._getGradualID(d));

            gradient.select("stop." + START_STOP)
                .style("stop-color", ColorUtils.getColorWithDivider(d.color, 0.9));

            gradient.select("stop." + END_STOP).style("stop-color", d.color);

            return d.style == Constants.STYLE_GRADUAL ? "url(#" + this._getGradualID(d) + ")": d.color;
        },

        _getClickedFill:function(d){

            var gradient = this._bodyG.select('#' + this._getGradualID(d));

            gradient.select("stop." + START_STOP)
                .style("stop-color", ColorUtils.getColorWithDivider(d.clickColor, 0.9));

            gradient.select("stop." + END_STOP).style("stop-color", d.clickColor);

            return d.style == Constants.STYLE_GRADUAL ? "url(#" + this._getGradualID(d) + ")": d.clickColor;
        },

        _getMouseOverFill:function(d){
            var gradient = this._bodyG.select('#' + this._getGradualID(d));

            gradient.select("stop." + START_STOP)
                .style("stop-color", ColorUtils.getColorWithDivider(d.mouseOverColor, 0.9));

            gradient.select("stop." + END_STOP).style("stop-color", d.mouseOverColor);

            return d.style == Constants.STYLE_GRADUAL ? "url(#" + this._getGradualID(d) + ")": d.mouseOverColor;
        },

        _getGradualID:function(d){
            return d.className + this.component.vanchart.getIDPrefix();
        },

        _getArcData:function(d){
            return {
                startAngle: d.startAngle,
                endAngle: d.endAngle,
                radius: d.radius
            };
        },

        _indexInVisiblePoints:function(point){
            var points = point.series.visiblePoints;
            for(var i = 0, len = points.length; i < len; i++){
                if(points[i] == point){
                    return i;
                }
            }
            return 0;
        },

        _getAngle:function(current, center){
            return Math.atan2(current[1] - center[1], current[0] - center[0]) / (Math.PI / 180);
        },

        mouseOver:function(event){
            if(event && event.target){
                var d = event.target.datum();

                var self = this;

                var pathNode = event.target.node();
                clearTimeout(pathNode.cancelChosenTimeout);

                var arc = d3.svg.arc().innerRadius(d.series.innerRadius);

                if(pathNode && !pathNode.isChosen){
                    event.target
                        .style('fill', function(d){
                            return self._getMouseOverFill(d);
                        })
                        .transition().ease("elastic").duration(800)
                        .attrTween("d", function (d) {
                            var outerRadius = d.radius;
                            var interpolate = d3.interpolate(outerRadius, outerRadius * 1.1);
                            var arcData = self._getArcData(d);

                            return function (t) {
                                return arc.outerRadius(interpolate(t))(arcData);
                            };

                        });

                    pathNode.isChosen = true;
                }
            }
        },

        mouseOut:function(event){
            if(event && event.target){
                var d = event.target.datum();

                var arc = d3.svg.arc().innerRadius(d.series.innerRadius);

                var self = this;
                var pathNode = event.target.node();

                if(!pathNode || !pathNode.isChosen){
                    return;
                }

                clearTimeout(pathNode.cancelChosenTimeout);

                pathNode.cancelChosenTimeout = setTimeout(function(){
                    if(pathNode.isChosen){
                        event.target
                            .style('fill', function(d){
                                return self._getFill(d);
                            })
                            .transition()
                            .ease("elastic").duration(600)
                            .attrTween("d", function (d) {
                                var outerRadius = d.radius;
                                var interpolate = d3.interpolate(outerRadius * HOVER_PERCENT, outerRadius);
                                var arcData = self._getArcData(d);
                                return function (t) {
                                    return arc.outerRadius(interpolate(t))(arcData);
                                };
                            });

                        pathNode.isChosen = false;
                    }
                },50);
            }
        },

        mouseDown:function(event){
            if(event && event.target){
                var d = event.target.datum();
                event.target.style('fill', this._getClickedFill(d));
            }
        },

        mouseUp:function(event){
            if(event && event.target){
                var d = event.target.datum();
                event.target.style('fill', this._getMouseOverFill(d));
            }
        }
    });

    require('./RenderLibrary').register(Constants.PIE_SVG, PieSvgRender);

    return PieSvgRender;
});
/**
 * Created by eason on 15/9/24.
 */

define('render/BarSvgRender',['require','./BaseRender','../utils/BaseUtils','../Constants','../utils/ColorUtils','../utils/BezierEasing','./RenderLibrary'],function(require){

    var BaseRender = require('./BaseRender');
    var BaseUtils = require('../utils/BaseUtils');
    var Constants = require('../Constants');
    var ColorUtils = require('../utils/ColorUtils');
    var BezierEasing = require('../utils/BezierEasing');

    var INIT_ANIMATION_TIME = 400;
    var EXIT_ANIMATION_TIME = 150;
    var UPDATE_ANIMATION_TIME = 250;

    var CHOSEN_STROKE_WIDTH = 6;

    var START_GRADUAL_CLASS = 'start-gradual-class';
    var END_GRADUAL_CLASS = 'end-gradual-class';

    var BAR_SERIES_GROUP = 'bar-seires-group';

    var BarSvgRender = BaseRender.extend({

        render:function(){
            var svgRoot = this.component.getVanchartRender().getRenderRoot();

            if(!this._bodyG){
                this._bodyG = svgRoot.append('g');
                this._labelG = svgRoot.append('g');
                this._updateChartBodyTranslate([this._bodyG, this._labelG]);
            } else {
                this._updateChartBodyTranslate([this._bodyG, this._labelG], this.component.isSupportAnimation(), UPDATE_ANIMATION_TIME);
            }

            var barData = this.component.getVisibleChartData();

            var barSeriesS = this._bodyG.selectAll('g.' + BAR_SERIES_GROUP).data(barData, function(d){return d.className});

            this._dropSeries(barSeriesS);

            this._updateSeries(barSeriesS);

            this._createSeries(barSeriesS);

            this._drawNormalChartLabels(this._labelG);
        },

        _dropSeries:function(seriesS){

            var exitSeries = seriesS.exit();

            var supportAnimation = this.component.isSupportAnimation();

            exitSeries.each(function(){

                d3.select(this)
                    .selectAll('rect')
                    .transition()
                    .duration(supportAnimation ? EXIT_ANIMATION_TIME : 0)
                    .ease('linear')
                    .attrTween('y', function(d){

                        var y = d.y;
                        var height = d.height;
                        var bottomY = y + height;

                        return function(t){
                            var currentH = height * (1 - d3.ease('back')(t));
                            return bottomY - currentH + 'px';
                        }

                    })
                    .attrTween('height', function(d){
                        var height = d.height;

                        return function(t){
                            return height * (1 - d3.ease('back')(t)) + 'px';
                        }
                    })
                    .remove();
            });
        },

        _updateSeries:function(seriesS){

            var lastEmptySize = BaseUtils.pick(this.emptySeries, 0);
            this.emptySeries = seriesS.exit().size();

            var chart = this;

            seriesS.each(function(d){

                var barG = d3.select(this);

                chart._updateDefs(d.points, barG.select('defs'), d.getLocation());

                var barS = barG.selectAll('rect').data(d.points, function(d){return d.className;});

                var updateDelay = lastEmptySize < chart.emptySeries ? EXIT_ANIMATION_TIME : 0;
                var createDelay = lastEmptySize > chart.emptySeries ? UPDATE_ANIMATION_TIME : 0;

                barS.empty() ? chart._crateInitialBarElement(barS, createDelay) : chart._updateBarTransition(barS, updateDelay);

                //这两步是自动刷新的时候可能出现的
                if(!barS.enter().empty()){
                    chart._crateInitialBarElement(barS, updateDelay + UPDATE_ANIMATION_TIME);
                }

                chart.addShapeEventHandler(barS);

                barS.exit().remove();
            });
        },

        _createSeries:function(seriesS){

            var newSeriesG = seriesS.enter().append('g').attr('class', BAR_SERIES_GROUP);

            var chart = this;

            newSeriesG.each(function(d){

                var barG = d3.select(this);

                chart._updateDefs(d.points, barG.append('defs'), d.getLocation());

                var barS = barG.selectAll('rect').data(d.points, function(d){return d.className;});

                barS.call(chart._crateInitialBarElement.bind(chart));
            });

        },

        _updateDefs:function(points, defs, location){

            var self = this;

            if(this.component.option.style){
                var grads = defs.selectAll("linearGradient")
                    .data(points, function(d){
                        return d.className;
                    });

                var x1, y1, x2, y2;
                x1 = y1 = x2 = y2 = '0%';
                switch (location){
                    case Constants.TOP:
                        y1 = '100%';
                        break;
                    case Constants.BOTTOM:
                        y2 = '100%';
                        break;
                    case Constants.LEFT:
                        x1 = '100%';
                        break;
                    case Constants.RIGHT:
                        x2 = '100%';
                        break;
                }

                grads.enter()
                    .append('linearGradient')
                    .attr("x1", x1)
                    .attr("y1", y1)
                    .attr('x2', x2)
                    .attr('y2', y2)
                    .attr("id", function(d){
                        return self._getGradualID(d);
                    });

                grads.append("stop")
                    .attr("offset", '0%')
                    .attr('class', START_GRADUAL_CLASS)
                    .style("stop-color", function(d){
                        return ColorUtils.getColorWithDivider(d.color, 0.9);
                    });

                grads.append("stop")
                    .attr("offset", "100%")
                    .attr('class', END_GRADUAL_CLASS)
                    .style("stop-color", function(d){
                        return d.color;
                    });
            }

            var imagePoints = [];
            points.forEach(function(point){
                if(point.image){
                    imagePoints.push(point);

                    if(point.image){
                        imagePoints.push(point);

                        switch (point.location){
                            case Constants.BOTTOM:
                                point.imageX = point.x;
                                point.imageY = point.y + point.height % point.imageHeight;
                                break;

                            case Constants.TOP:
                            case Constants.LEFT:
                                point.imageX = point.x;
                                point.imageY = point.y;
                                break;

                            case Constants.RIGHT:
                                point.imageX = point.x + point.width % point.imageWidth;
                                point.imageY = point.y;
                                break;
                        }
                    }

                }
            });

            var patterns = defs
                .selectAll('pattern')
                .data(imagePoints, function(d){
                    return d.className;
                });

            var enter = patterns
                .enter()
                .append('pattern');

            enter.append('image');

            patterns
                .attr('x', function(d){return d.imageX})
                .attr('y', function(d){return d.imageY})
                .attr('width', function(d){return d.imageWidth})
                .attr('height', function(d){return d.imageHeight})
                .attr('patternUnits', 'userSpaceOnUse')
                .attr('id', function(d){return self._getImageID(d)})
                .select('image')
                .attr('x', 0)
                .attr('y', 0)
                .attr('width', function(d){return d.imageWidth})
                .attr('height', function(d){return d.imageHeight})
                .attr('xlink:href', function(d){return d.image});

        },

        _getGradualID:function(d){
            var IDPrefix = this.component.vanchart.getIDPrefix();
            return 'gradual' + d.className + IDPrefix;
        },

        _getImageID:function(d){
            var IDPrefix = this.component.vanchart.getIDPrefix();
            return 'image' + d.className + IDPrefix;
        },

        _getFillWidthColor:function(d, color){

            var gradient = this._bodyG.select('#' + this._getGradualID(d));
            gradient.select("stop." + START_GRADUAL_CLASS)
                .style("stop-color", ColorUtils.getColorWithDivider(color, 0.9));

            gradient.select("stop." + END_GRADUAL_CLASS)
                .style("stop-color", color);

            var style = this.component.option.style;
            var gradualID = "url(#" + this._getGradualID(d) + ")";
            var imageID = "url(#" + this._getImageID(d) + ")";

            return d.image ? imageID : (style == Constants.STYLE_GRADUAL ? gradualID : color);
        },

        _getMouseOverFill:function(d){
            return this._getFillWidthColor(d, d.mouseOverColor);
        },

        _getFill:function(d){
            return this._getFillWidthColor(d, d.color);
        },

        _getClickedFill:function(d){
            return this._getFillWidthColor(d, d.clickColor);
        },

        _crateInitialBarElement:function(selection, delay){

            delay = delay || 0;

            var self = this;

            var enterSelection = selection.enter().append('rect');

            //创建的时候加监听
            this.addShapeEventHandler(enterSelection);

            var supportAnimation = this.component.isSupportAnimation();

            enterSelection
                .each(function(d){

                    var barChangeInfo = self.component.getInitBarAttribute(d);

                    var initBar = supportAnimation ? barChangeInfo.init : d;
                    var endBar = barChangeInfo.end;

                    var bar = d3.select(this);

                    self._setInitBarAttributes(bar, d, initBar);

                    if(supportAnimation && d.width > 0 && d.height > 0){

                        bar
                            .transition()
                            .ease(BezierEasing.css.swing)
                            .duration(INIT_ANIMATION_TIME)
                            .delay(delay)
                            .attr('x', endBar.x)
                            .attr('y', endBar.y)
                            .attr('width', Math.max(endBar.width, 0))
                            .attr('height', Math.max(endBar.height, 0))
                            .each('end', function(){
                                bar
                                    .attr('x', d.x)
                                    .attr('y', d.y)
                                    .attr('width', Math.max(d.width, 0))
                                    .attr('height', Math.max(d.height, 0));
                            });

                    }else{

                        bar
                            .attr('x', d.x)
                            .attr('y', d.y)
                            .attr('width', Math.max(d.width, 0))
                            .attr('height', Math.max(d.height, 0));

                    }
                });
        },

        _setInitBarAttributes:function(barSelection, d, initBar){

            barSelection
                .attr('class', d.className)
                .attr('x', initBar.x)
                .attr('y', initBar.y)
                .attr('width', Math.max(initBar.width, 0))
                .attr('height', Math.max(initBar.height, 0))
                .attr('rx', d.borderRadius)
                .attr('ry', d.borderRadius)
                .style({
                    'fill': this._getFill(d),
                    'stroke': d.borderColor,
                    'stroke-width': d.borderWidth
                })
                .each(function(){
                    this._current_ = {x: d.x, y: d.y, width: d.width, height: d.height};
                });
        },

        //已经显示的系列的动画
        _updateBarTransition:function(barS, delay){

            var supportAnimation = this.component.isSupportAnimation();
            var self = this;
            var delay = delay || 0;

            if(supportAnimation){
                barS
                    .each(function(d){
                        var lastBar = this._current_ || {x: d.x, y: d.y, width: d.width, height: d.height};
                        this._current_ = {x: d.x, y: d.y, width: d.width, height: d.height};

                        d3.select(this)
                            .style({
                                'fill': self._getFill(d),
                                'stroke': d.borderColor,
                                'stroke-width': d.borderWidth
                            })
                            .transition()
                            .duration(UPDATE_ANIMATION_TIME)
                            .delay(delay)
                            .ease('linear')
                            .attrTween('x',function(){
                                return function(t){
                                    return lastBar.x + (d.x - lastBar.x)*BezierEasing.css.swing(t) + 'px';
                                }
                            })
                            .attrTween('y',function(){
                                return function(t){
                                    return lastBar.y + (d.y - lastBar.y)*BezierEasing.css.swing(t) + 'px';
                                }
                            })
                            .attrTween('width',function(){
                                return function(t){
                                    return lastBar.width + (d.width - lastBar.width)*BezierEasing.css.swing(t) + 'px';
                                }
                            })
                            .attrTween('height',function(){
                                return function(t){
                                    return lastBar.height + (d.height - lastBar.height)*BezierEasing.css.swing(t) + 'px';
                                }
                            });
                    });
            }else{
                barS.each(function(d){
                    self._setInitBarAttributes(d3.select(this), d, d);
                });
            }

        },

        mouseOver:function(event){
            if(event && event.target){
                var d = event.target.datum();
                event.target
                    .style({
                        'stroke':d.mouseOverColor,
                        'fill':this._getMouseOverFill(d),
                        'stroke-width':d.borderWidth,
                        'stroke-opacity':0.35
                    })
                    .interrupt(Constants.SELECT_ANIMATION)
                    .transition(Constants.SELECT_ANIMATION)
                    .duration(100)
                    .ease('ease-out-in')
                    .style('stroke-width', CHOSEN_STROKE_WIDTH);
            }
        },

        mouseOut:function(event){
            if(event && event.target){
                var d = event.target.datum();

                event.target
                    .interrupt(Constants.SELECT_ANIMATION)
                    .transition(Constants.SELECT_ANIMATION);

                event.target
                    .style('fill', this._getFill(d))
                    .style('stroke', d.borderColor)
                    .style('stroke-opacity', 1)
                    .style('stroke-width', d.borderWidth);
            }
        },

        mouseDown:function(event){
            if(event && event.target){
                var d = event.target.datum();
                event.target.style('fill', this._getClickedFill(d));
            }
        },

        mouseUp:function(event){
            if(event && event.target){
                var d = event.target.datum();
                event.target.style('fill', this._getMouseOverFill(d));
            }
        }
        
    });

    require('./RenderLibrary').register(Constants.BAR_SVG, BarSvgRender);
});
/**
 * Created by eason on 15/11/6.
 */
define('render/LineSvgRender',['require','./BaseRender','../utils/BaseUtils','../utils/ColorUtils','../Constants','../utils/QueryUtils','../utils/BezierEasing','./RenderLibrary'],function(require){

    var BaseRender = require('./BaseRender');
    var BaseUtils = require('../utils/BaseUtils');
    var ColorUtils = require('../utils/ColorUtils');
    var Constants = require('../Constants');

    var QueryUtils = require('../utils/QueryUtils');
    var Bezier = require('../utils/BezierEasing');

    var LINE_G_CLASS = 'lineGroupG';
    var AREA_G_CLASS = 'areaGroupG';

    var MARKER_G_CLASS = 'markerGroupG';
    var PATH_G = 'pathG';
    var AREA_G = 'areaG';

    var CLASS = 'class';

    var LINE_SHOW_TIME = 800;
    var LINE_MONITOR_TIME = 500;
    var LINE_UPDATE_TIME = 250;

    var CHOSEN_AREA_ALPHA = 0.65;


    var LineSvgRender = BaseRender.extend({
        render:function(){

            var svgRoot = this.component.getVanchartRender().getRenderRoot();

            if(!this._bodyG){
                this._bodyG = svgRoot.append('g');
                this._defsG = this._bodyG.append('g');
                this._areaG = this._bodyG.append('g');
                this._lineG = this._bodyG.append('g');
                this._labelG = this._bodyG.append('g');
                this._updateChartBodyTranslate([this._bodyG]);
            } else {
                this._updateChartBodyTranslate([this._bodyG], this.component.isSupportAnimation(), LINE_UPDATE_TIME);
            }

            this._updateLineSeries();

            this._drawNormalChartLabels(this._labelG, this.component.isSupportAnimation() ? LINE_SHOW_TIME : 0);
        },

        //animationTime, easeFunc是对update状态的线组
        _updateLineSeries:function(animationTime, easeFunc){

            var g = this._updateDataBinding();
            var defsG = g.defsG;
            var areaG = g.areaG;
            var lineG = g.lineG;

            animationTime = this.component.isSupportAnimation() ? (animationTime || LINE_UPDATE_TIME) : 0;

            easeFunc = easeFunc || Bezier.css.swing;

            //退场的折线删除
            defsG.exit().remove();
            lineG.exit().remove();
            areaG.exit().remove();

            defsG
                .selectAll('clipPath')
                .select('rect')
                .transition()
                .ease(easeFunc)
                .duration(animationTime)
                .attr('x', function(d){
                    return d.x;
                })
                .attr('y', function(d){
                    return d.y;
                })
                .attr('width', function(d){
                    return d.width;
                })
                .attr('height', function(d){
                    return d.height;
                });

            areaG
                .selectAll('path')
                .filter(function(d){
                    return d.lineData.isStack;
                })
                .transition()
                .ease(easeFunc)
                .duration(animationTime)
                .attr('d', function(d){
                    var lineData = d.lineData;
                    return lineData.areaSvg(lineData.points);
                })
                .each('end', function(){
                    d3.select(this)
                        .attr('d', function(d){
                            var lineData = d.lineData;
                            return lineData.areaSvg(lineData.points);
                        });
                });

            lineG
                .select('g.' + PATH_G)
                .selectAll('path')
                .transition()
                .ease(easeFunc)
                .duration(animationTime)
                .attr('d', function(d){
                    var lineData = d.lineData;
                    return lineData.lineSvg(lineData.points);
                })
                .each('end', function(){
                    d3.select(this)
                        .attr('d', function(d){
                            var lineData = d.lineData;
                            return lineData.lineSvg(lineData.points);
                        });
                });

            lineG
                .select('g.' + AREA_G)
                .selectAll('path')
                .filter(function(d){
                    return !d.lineData.isStack;
                })
                .transition()
                .ease(easeFunc)
                .duration(animationTime)
                .attr('d', function(d){
                    var lineData = d.lineData;
                    return lineData.areaSvg(lineData.points);
                })
                .each('end', function(){
                    d3.select(this)
                        .attr('d', function(d){
                            var lineData = d.lineData;
                            return lineData.areaSvg(lineData.points);
                        });
                });


            var self = this;
            lineG.each(function(d){

                var markers = d3.select(this)
                    .select('g.' + MARKER_G_CLASS)
                    .selectAll('g').data(d.points);

                self.addShapeEventHandler(markers);

                markers
                    .transition()
                    .ease(easeFunc)
                    .duration(animationTime)
                    .attr('transform', function(d){
                        return 'translate(' + d.x + ',' + d.y + ')';
                    })
                    .each('end', function(d){

                        var markerG = d3.select(this);

                        markerG
                            .attr('transform', function(){
                                return 'translate(' + d.x + ',' + d.y + ')';
                            });

                        d.elWrapper = markerG;

                    });

                markers.exit().remove();

                d3.select(this)
                    .transition()
                    .delay(animationTime)
                    .each('end', function(){

                        markers.call(self._createSvgMarker.bind(self))
                            .attr('transform', function(d) {
                                return 'translate(' + d.x + ',' + d.y + ')';
                            });

                    });

            });

            this.addSeriesEventHandler(areaG);
            this.addSeriesEventHandler(lineG);

            //新建折线
            this._createNewLineSeries(g);
        },

        _updateDataBinding:function(){

            var lines = this.component.getVisibleChartData();

            var lineG = this._lineG
                .selectAll('g.' + LINE_G_CLASS)
                .data(lines, function(d){return d.className});

            var areaG = this._areaG
                .selectAll('g.' + AREA_G_CLASS)
                .data(lines, function(d){return d.className});

            var defsG = this._defsG
                .selectAll('defs')
                .data(lines, function(d){
                    return d.className;
                });

            defsG
                .selectAll('clipPath')
                .data(function(d){
                    return d.dataBands;
                });

            areaG
                .selectAll('path')
                .data(function(d){
                    return d.dataBands;
                });

            lineG.select('g.' + PATH_G)
                .selectAll('path')
                .data(function(d){
                    return d.dataBands;
                });

            lineG.select('g.' + AREA_G)
                .selectAll('path')
                .data(function(d){
                    return d.dataBands;
                });

            return {
                defsG:defsG,
                areaG:areaG,
                lineG:lineG
            };
        },

        _createNewLineSeries:function(g){

            var g = this._updateDataBinding();
            var defsG = g.defsG;
            var areaG = g.areaG;
            var lineG = g.lineG;
            var self = this;

            var animationTime = this.component.isSupportAnimation() ? LINE_SHOW_TIME : 0;

            defsG
                .enter()
                .append('defs')
                .selectAll('clipPath')
                .data(function(d){
                    return d.dataBands;
                })
                .enter()
                .append('clipPath')
                .attr('id', function(d){
                    return d.clipID;
                })
                .append('rect')
                .attr('x', function(d){
                    return d.x;
                })
                .attr('y', function(d){
                    return d.y;
                })
                .attr('width', 0)
                .attr('height', function(d){
                    return d.height;
                })
                .transition()
                .ease('quad-in-out')
                .duration(animationTime)
                .attr('width', function(d){
                    return d.width;
                });

            if(this.component.componentType == Constants.AREA_CHART){

                var enterArea = areaG.enter()
                    .append('g')
                    .attr('class', function(d){
                        return AREA_G_CLASS + ' ' + (d.className);
                    });

                enterArea
                    .selectAll('path')
                    .data(function(d){
                        return d.dataBands;
                    })
                    .enter()
                    .append('path')
                    .filter(function(d){
                        return d.lineData.isStack;
                    })
                    .style('fill', function(d){
                        return d.fillColor;
                    })
                    .style('fill-opacity', function(d){
                        return d.fillColorOpacity;
                    })
                    .style('stroke', 'none')
                    .attr('d', function(d){
                        var lineData = d.lineData;
                        return lineData.areaSvg(lineData.points);
                    })
                    .attr('clip-path', function(d){
                        return "url(#"  + d.clipID +")";
                    });

                this.addSeriesEventHandler(enterArea);
            }

            var enterG = lineG.enter()
                .append('g')
                .attr('class', function(d){
                    return LINE_G_CLASS + ' ' + (d.className);
                });

            enterG.append('g')
                .attr('class', PATH_G)
                .selectAll('path')
                .data(function(d){
                    return d.dataBands;
                })
                .enter()
                .append('path')
                .style('fill', 'none')
                .style('stroke', function(d){
                    return d.color;
                })
                .style('stroke-width', function(d){
                    return d.lineData.lineWidth;
                })
                .attr('d', function(d){
                    var lineData = d.lineData;
                    return lineData.lineSvg(lineData.points);
                })
                .attr('clip-path', function(d){
                    return "url(#"  + d.clipID +")";
                });

            this.addSeriesEventHandler(enterG);

            if(this.component.componentType == Constants.AREA_CHART){
                enterG.append('g')
                    .attr('class', AREA_G)
                    .selectAll('path')
                    .data(function(d){
                        return d.dataBands;
                    })
                    .enter()
                    .append('path')
                    .filter(function(d){
                        return !d.lineData.isStack;
                    })
                    .style('fill', function(d){
                        return d.fillColor;
                    })
                    .style('fill-opacity', function(d){
                        return d.fillColorOpacity;
                    })
                    .style('stroke', 'none')
                    .attr('d', function(d){
                        var lineData = d.lineData;
                        return lineData.areaSvg(lineData.points);
                    })
                    .attr('clip-path', function(d){
                        return "url(#"  + d.clipID +")";
                    });
            }

            if(this.component.isSupportAnimation()){
                enterG
                    .append('g')
                    .attr('class', MARKER_G_CLASS)
                    .selectAll('g')
                    .data(function(d){ return d.points; })
                    .call(this._createSvgMarker.bind(this))
                    .attr('transform', function(d){
                        return 'translate('+ d.x +','+ d.y +') scale(0.01)';
                    })
                    .transition()
                    .delay(function(d){return d.delay})
                    .duration(150)
                    .ease('ease-out-in')
                    .attr('transform', function(d){
                        return 'translate('+ d.x +','+ d.y +') scale(1.5)';
                    })
                    .transition()
                    .duration(150)
                    .ease('ease-out-in')
                    .attr('transform', function(d){
                        return 'translate('+ d.x +','+ d.y +') scale(1)';
                    });
            }else{
                enterG
                    .append('g')
                    .attr('class', MARKER_G_CLASS)
                    .selectAll('g')
                    .data(function(d){return d.points;})
                    .call(this._createSvgMarker.bind(this))
                    .attr('transform', function(d){
                        return 'translate('+ d.x +','+ d.y +')';
                    });
            }
        },

        _createImageMarker:function(src, callBack){
            var img = new Image();
            img.onload = function() {
                callBack(this.width, this.height);
            };
            img.src = src;
        },

        seriesMouseOver:function(event){

            if(event && event.target){

                var d = event.target.datum();

                var seriesClass = d.className;

                this._lineG.select('g.' + seriesClass).select('g.' + AREA_G)
                    .selectAll('path').transition(Constants.SELECT_ANIMATION).duration(100).ease('swing')
                    .style('fill', function(d){
                        return ColorUtils.getHighLightColor(d.fillColor);
                    })
                    .style('fill-opacity', CHOSEN_AREA_ALPHA);

                this._lineG.select('g.' + seriesClass).select('g.' + PATH_G)
                    .selectAll('path').transition(Constants.SELECT_ANIMATION).duration(100).ease('swing')
                    .style('stroke', function(d){
                        return ColorUtils.getHighLightColor(d.color);
                    })
                    .style('stroke-width', function(d){
                        return d.lineData.lineWidth + 1;
                    });

                BaseUtils.toFront(this._lineG.select('g.' + seriesClass).node());

                this._areaG.select('g.' + seriesClass)
                    .selectAll('path').transition(Constants.SELECT_ANIMATION).duration(100).ease('swing')
                    .style('fill', function(d){
                        return ColorUtils.getHighLightColor(d.fillColor);
                    })
                    .style('fill-opacity', CHOSEN_AREA_ALPHA);
            }
        },

        seriesMouseOut:function(event){

            if(event && event.target){

                var d = event.target.datum();

                var seriesClass = d.className;

                this._lineG.select('g.' + seriesClass).select('g.' + AREA_G)
                    .selectAll('path').transition(Constants.SELECT_ANIMATION).duration(100).ease('swing')
                    .style('fill', function(d){
                        return d.fillColor;
                    })
                    .style('fill-opacity', function(d){
                        return d.fillColorOpacity;
                    });

                this._lineG.select('g.' + seriesClass).select('g.' + PATH_G)
                    .selectAll('path').transition(Constants.SELECT_ANIMATION).duration(100).ease('swing')
                    .style('stroke', function(d){
                        return d.color;
                    })
                    .style('stroke-width', function(d){
                        return d.lineData.lineWidth;
                    });

                this._areaG.select('g.' + seriesClass)
                    .selectAll('path').transition(Constants.SELECT_ANIMATION).duration(100).ease('swing')
                    .style('fill', function(d){
                        return d.fillColor;
                    })
                    .style('fill-opacity', function(d){
                        return d.fillColorOpacity;
                    });
            }
        },

        mouseOver:function(event){
            if(event && event.target){
                var d = event.target.datum();
                this._makeMarkerChosenState(event.target, d);
            }
        },

        mouseOut:function(event){
            if(event && event.target){
                var d = event.target.datum();
                this._cancelMarkerChosenState(event.target, d);
            }
        },

        mouseDown:function(event){
            if(event && event.target){
                var d = event.target.datum();
                this._makeMarkerClickedState(event.target, d);
            }
        },

        mouseUp:function(event){
            if(event && event.target){
                var d = event.target.datum();
                this._cancelMarkerClickedState(event.target, d);
            }
        }
    });

    require('./RenderLibrary').register(Constants.LINE_SVG, LineSvgRender);

    return LineSvgRender;

});
/**
 * Created by eason on 15/11/6.
 */
define('render/AreaSvgRender',['require','../Constants','./LineSvgRender','./RenderLibrary'],function(require){

    var Constants = require('../Constants');
    var LineSvgRender = require('./LineSvgRender');

    var AreaSvgRender = LineSvgRender.extend({});

    require('./RenderLibrary').register(Constants.AREA_SVG, AreaSvgRender);
});
/**
 * Created by eason on 15/12/2.
 */

define('render/GaugeSvgRender',['require','../utils/BaseUtils','../utils/ColorUtils','../Constants','./BaseRender','./RenderLibrary'],function(require){

    var BaseUtils = require('../utils/BaseUtils');
    var ColorUtils = require('../utils/ColorUtils');
    var Constants = require('../Constants');
    var BaseRender = require('./BaseRender');

    var ANIMATION_TIME = 1000;
    var THERMOMETER_R = 5;
    var MAGIC_DET = 0.001;
    var EASE_TYPE = 'quad-out';

    var GAUGE = 'gauge-class';

    var POINTER_HINGE_BACKGROUND = 'pointer-hinge-background';
    var POINTER_HINGE = 'pointer-hinge';
    var SLOT_BACKGROUND = 'slot-background';
    var THERMOMETER_BACKGROUND = 'thermometer-background';
    var RING_INNER_BACKGROUND = 'ring-inner-background';
    var RING_INNER_STROKE = 'ring-inner-stroke';
    var RING_OUTER_STROKE = 'ring-outer-stroke';
    var RING_ARC_PATH = 'ring-arc-path';

    var NEEDLE = 'gauge-needle';
    var BACKGROUND = 'gauge-background';
    var GAUGE_LABEL = 'gauge-label';
    var GAUGE_AXIS = 'gauge-axis';

    var GaugeSvgRender = BaseRender.extend({
        render:function(){

            var plotBounds = this.component.vanchart.plotOriginalBounds;
            var svgRoot = this.component.getVanchartRender().getRenderRoot();

            this._bodyG = this._bodyG || svgRoot.append('g');
            this._bodyG.attr('transform', 'translate('+plotBounds.x+','+plotBounds.y+')');
            this._bodyG.select('defs').remove();
            this._createDefs();

            this.labelDivManager.clearAllLabels();

            var data = this.component.getVisibleChartData();

            var gaugeS = this._bodyG
                .selectAll('g.' + GAUGE).data(data, function(d){
                    return GAUGE + ' ' + d.className;
                });

            gaugeS.exit().remove();

            gaugeS
                .attr('class', function(d){
                    return GAUGE + ' ' + d.className;
                })
                .call(this._updateGauge.bind(this))
                .transition()
                .duration(ANIMATION_TIME)
                .ease(EASE_TYPE)
                .attr('transform', function(d){
                    return 'translate(' + d.centerX + ',' + d.centerY + ')';
                });

            this.addSeriesEventHandler(gaugeS);

            gaugeS
                .enter()
                .append('g')
                .attr('class', function(d){
                    return GAUGE + ' ' + d.className;
                })
                .attr('transform', function(d){

                    return 'translate(' + Math.round(d.centerX) + ',' + Math.round(d.centerY) + ')';
                })
                .call(this._createGauge.bind(this));
        },

        _createDefs:function(){
            var defs= this._bodyG.append('defs');

            this._createVerticalLinearGradient(defs, this._getRingGradualID(), '#ffffff', '#dddddd');
            this._createVerticalLinearGradient(defs, this._getRingClickedGradualID(), '#dddddd', '#ffffff');

            var self = this;
            var gaugeData = this.component.getVisibleChartData();
            gaugeData.forEach(function(gauge){

                var point = gauge.points[0];

                if(!point){
                    return;
                }

                if(gauge.style == Constants.GAUGE_THERMOMETER){
                    var endColor = point.color;
                    var startColor = ColorUtils.mixColorWithHSB(endColor, 0, -0.1, 0.1);

                    var endColorClicked = ColorUtils.getColorWithDivider(endColor, 1/0.95);
                    var startColorClicked = ColorUtils.mixColorWithHSB(endColor, 0, -0.1, 0.1);

                    var endColorMouseOver = ColorUtils.getColorWithDivider(point.mouseOverColor, 1/0.95);
                    var startColorMouseOver = ColorUtils.mixColorWithHSB(point.mouseOverColor, 0, -0.1, 0.1);

                    if(gauge.thermometerLayout == Constants.HORIZONTAL_LAYOUT){

                        self._createHorizontalLinearGradient(defs, self._getThermometerGradualID(gauge), startColor, endColor);
                        self._createHorizontalLinearGradient(defs, self._getThermometerClickedGradualID(gauge), startColorClicked, endColorClicked);
                        self._createHorizontalLinearGradient(defs,  self._getThermometerMouseOverGradualID(gauge), startColorMouseOver, endColorMouseOver)

                    }else{

                        self._createVerticalLinearGradient(defs, self._getThermometerGradualID(gauge), endColor, startColor);
                        self._createVerticalLinearGradient(defs, self._getThermometerClickedGradualID(gauge), endColorClicked, startColorClicked);
                        self._createVerticalLinearGradient(defs,  self._getThermometerMouseOverGradualID(gauge), endColorMouseOver, startColorMouseOver)

                    }
                }else if(gauge.style == Constants.GAUGE_POINTER || gauge.style == Constants.GAUGE_POINTER_SEMI){

                    self._createDropShadowFilter(defs, self._getPointerDropShadowID(), 0, 2, 0.1, 2);
                    self._createInnerShadowFilter(defs, self._getPointerInnerShadowID(), 0, 2, 0.1, 2);

                }else if(gauge.style == Constants.GAUGE_SLOT){
                    self._createDropShadowFilter(defs, self._getSlotDropShadowID(), 0, 2, 0.05, 0);
                    self._createInnerShadowFilter(defs, self._getSlotInnerShadowID(), 0, 2, 0.05, 0);
                }

            });
        },

        _removeGaugeLabels:function(gaugeG){
            var labelG = gaugeG.select('g.' + GAUGE_LABEL);

            labelG.selectAll('text').remove();
            labelG.selectAll('rect').remove();
        },

        _createGauge:function(gaugeG){

            var self = this;

            gaugeG.each(function(d){

                var style = d.style;
                var gSelection = d3.select(this);

                self.addSeriesEventHandler(gSelection);

                switch (style){
                    case Constants.GAUGE_POINTER:
                        gSelection.append('path').attr('class', BACKGROUND);
                        gSelection.append('path').attr('class', POINTER_HINGE_BACKGROUND);
                        gSelection.append('g').attr('class', GAUGE_LABEL);
                        gSelection.append('g').attr('class', GAUGE_AXIS);
                        gSelection.append('g').attr('class', NEEDLE);
                        gSelection.append('path').attr('class', POINTER_HINGE);

                        self._createPointerCircle(gSelection, d);
                        break;

                    case Constants.GAUGE_POINTER_SEMI:
                        gSelection.append('path').attr('class', BACKGROUND);
                        gSelection.append('path').attr('class', POINTER_HINGE_BACKGROUND);
                        gSelection.append('g').attr('class', GAUGE_LABEL);
                        gSelection.append('g').attr('class', GAUGE_AXIS);
                        gSelection.append('g').attr('class', NEEDLE);
                        gSelection.append('path').attr('class', POINTER_HINGE);
                        self._createPointerSemi(gSelection, d);
                        break;

                    case Constants.GAUGE_SLOT:
                        gSelection.append('path').attr('class', BACKGROUND);
                        gSelection.append('path').attr('class', SLOT_BACKGROUND);
                        gSelection.append('circle').attr('class', NEEDLE);
                        gSelection.append('g').attr('class', GAUGE_LABEL);

                        self._createSlot(gSelection, d);
                        break;

                    case Constants.GAUGE_THERMOMETER:

                        gSelection.append('line').attr('class', BACKGROUND);
                        gSelection.append('line').attr('class', THERMOMETER_BACKGROUND);
                        gSelection.append('circle').attr('class', NEEDLE);
                        gSelection.append('g').attr('class', GAUGE_AXIS);
                        gSelection.append('g').attr('class', GAUGE_LABEL);

                        self._createThermometer(gSelection, d);
                        break;

                    case Constants.GAUGE_RING:
                        gSelection.append('path').attr('class', BACKGROUND);
                        gSelection.append('path').attr('class', RING_ARC_PATH);
                        gSelection.append('path').attr('class', RING_INNER_BACKGROUND);
                        gSelection.append('path').attr('class', RING_INNER_STROKE);
                        gSelection.append('path').attr('class', RING_OUTER_STROKE);
                        gSelection.append('g').attr('class', GAUGE_LABEL);

                        self._createRing(gSelection, d);
                        break;
                }

            });
        },

        _updateGauge:function(gaugeG){
            var self = this;

            gaugeG.each(function(d){

                var style = d.style;
                var gSelection = d3.select(this);

                self._removeGaugeLabels(gSelection);

                switch (style){
                    case Constants.GAUGE_POINTER:
                        self._createPointerCircle(gSelection, d);
                        break;

                    case Constants.GAUGE_POINTER_SEMI:
                        self._createPointerSemi(gSelection, d);
                        break;

                    case Constants.GAUGE_SLOT:
                        self._createSlot(gSelection, d);
                        break;

                    case Constants.GAUGE_THERMOMETER:
                        self._createThermometer(gSelection, d);
                        break;

                    case Constants.GAUGE_RING:
                        self._createRing(gSelection, d);
                        break;
                }

            });

        },

        _createPointerCircle:function(gaugeG, d){
            this._createPointer(gaugeG, d, 180, 150, 0.16, 0.07);
        },

        _createPointerSemi:function(gaugeG, d){
            this._createPointer(gaugeG, d, 98, 90, 0.11, 0.055);
        },

        _createPointer:function(gaugeG, d, baseAngle, scaleAngle, hBackground, hinge){

            var circle = d3.svg.arc().startAngle(0).endAngle(2 * Math.PI).innerRadius(0);

            var arc = d3.svg.arc().startAngle(BaseUtils.toRadian(-baseAngle))
                .endAngle(BaseUtils.toRadian(baseAngle))
                .innerRadius(0).outerRadius(d.radius).toCenter(false);

            var domain = d.gaugeAxis.scale.domain();
            var scale = d3.scale.linear().domain(domain)
                .range([BaseUtils.toRadian(-scaleAngle), BaseUtils.toRadian(scaleAngle)]);

            gaugeG
                .select('path.' + BACKGROUND)
                .attr('d', arc())
                .style('fill', d.paneBackgroundColor)
                .style('fill-opacity', ColorUtils.getColorOpacity(d.paneBackgroundColor))

            this._addFilter(gaugeG.select('path.' + BACKGROUND), this._getPointerDropShadowID());

            //枢纽背景
            circle.outerRadius(hBackground * d.radius);
            gaugeG
                .select('path.' + POINTER_HINGE_BACKGROUND)
                .attr('d', circle())
                .style('fill', d.hingeBackgroundColor)
                .style('fill-opacity', ColorUtils.getColorOpacity(d.hingeBackgroundColor));

            this._addFilter(gaugeG.select('path.' + POINTER_HINGE_BACKGROUND), this._getPointerInnerShadowID());

            this._drawGaugeLabels(gaugeG, d);

            this._drawPointerTicks(gaugeG, d, scale);

            this._drawPointerArrow(gaugeG, d, scale);

            //枢纽
            circle.outerRadius(hinge * d.radius);
            gaugeG
                .select('path.' + POINTER_HINGE)
                .attr('d', circle())
                .style('fill', d.hinge)
                .style('fill-opacity', ColorUtils.getColorOpacity(d.hinge));

            this._addFilter(gaugeG.select('path.' + POINTER_HINGE), this._getPointerDropShadowID());
        },

        _drawPointerArrow:function(gaugeG, d, scale){

            var pointerG = gaugeG.select('g.' + NEEDLE);

            var self = this;
            var domain = scale.domain();

            var arrows = pointerG
                .selectAll('path').data(d.points);

            arrows.enter().append('path');

            arrows.exit().remove();

            this.addShapeEventHandler(arrows);

            arrows.each(function(point){

                var pointer = d3.select(this);

                var rotate = self._getRotate(pointer);

                var initRadian = self.component.isSupportAnimation() ? scale(domain[0]) : scale(point.valueInDomain);

                var endRadian = scale(point.valueInDomain);

                var endDegree = BaseUtils.toDegree(endRadian - initRadian);

                pointer
                    .attr('d', self._getArrowPath(d.radius, initRadian))
                    .style('fill', d.needle)
                    .style('fill-opacity', ColorUtils.getColorOpacity(d.needle))
                    .transition()
                    .duration(ANIMATION_TIME)
                    .ease(EASE_TYPE)
                    .attrTween('transform', function(){

                        var interpolate = d3.interpolate(rotate, endDegree);

                        return function(t){
                            return "rotate(" + interpolate(t) + ")";
                        }
                    });

                self._addFilter(pointer, self._getPointerDropShadowID(), ANIMATION_TIME)
            });
        },


        //todo iie10直接加阴影会导致指针不显示
        _addFilter:function(selection, filterID, delay){
            delay = delay || 0;
            delay += 100;
            setTimeout(function(){
                if(selection){
                    selection.style("filter", 'url(#'+ filterID +')')
                }
            }, delay)
        },

        _getRotate:function(selectionG){

            var transform = selectionG.attr('transform');

            if(transform){
                var startIndex = transform.indexOf('(');
                if(startIndex != -1){
                    return parseFloat(transform.substr(startIndex + 1));
                }
            }

            return 0;

        },

        _getArrowPath:function(radius, initRadian){

            var p0 = this._getArcPoint(0.9 * radius, initRadian);

            var p1 = this._getArcPoint(0.02 * radius, initRadian + Math.PI/2);

            var p2 = this._getArcPoint(0.02 * radius, initRadian - Math.PI/2);

            return 'M' + p0[0] + ',' + p0[1] + 'L' + p1[0] + ',' + p1[1] + 'L' + p2[0] + ',' + p2[1] + 'Z';

        },

        _drawPointerTicks:function(gaugeG, d, scale){

            var axisG = gaugeG.select('g.' + GAUGE_AXIS);

            var tickData = d.gaugeAxis.getTickData();

            var axisOption = d.gaugeAxis.componentOption;
            var labelStyle = axisOption.labelStyle;
            var useHtml = axisOption.useHtml;

            var minorTickData = d.gaugeAxis.getMinorTickData();

            var self = this;

            var tickR = (1 - 0.05) * d.radius;
            var labelR = (1 - 0.05 - 0.1 - 0.01) * d.radius;

            var bands = d.bands;
            var plotBounds = this.component.getPlotBounds();
            var transX = plotBounds.x + d.centerX;
            var transY = plotBounds.y + d.centerY;

            var tick = axisG.selectAll("g.tick").data(tickData, function(d){
                return scale(d.tickValue);
            });

            tick.exit().remove();

            var enterTick = tick.enter().append('g').attr('class', 'tick');
            enterTick.append('text');
            enterTick.append('line');

            tick.each(function(tickD){

                var tickG = d3.select(this);

                var radian = scale(tickD.tickValue);
                var start = self._getArcPoint(tickR, radian);
                var end = self._getArcPoint(tickR - 0.1 * d.radius, radian);

                var color = self.component._getColorFromBands(tickD.tickValue, bands);

                tickG
                    .select('line')
                    .attr('x1', start[0])
                    .attr('y1', start[1])
                    .attr('x2', end[0])
                    .attr('y2', end[1])
                    .attr('stroke', color);

                var center = self.component._getPointerTickCenter(tickD, labelR, scale);

                if(useHtml){

                    var labelPos = {
                        x:transX + center.x - tickD.tickDim.width/2,
                        y:transY + center.y - tickD.tickDim.height/2
                    };
                    self.labelDivManager.addLabel(tickD.tickContent, labelPos, labelStyle);

                }else{
                    tickG
                        .select('text')
                        .attr('x', center.x)
                        .attr('y', center.y)
                        .attr('dy', '.35em')
                        .attr("text-anchor", "middle")
                        .text(tickD.tickContent)
                        .call(BaseUtils.setTextStyle, labelStyle);
                }

            });

            var minorTick = axisG.selectAll("line.minorTick")
                .data(minorTickData, function(d){return scale(d);});

            minorTick.enter().append('line').attr('class', 'minorTick');

            minorTick.exit().remove();

            minorTick.each(function(value){

                var radian = scale(value);
                var start = self._getArcPoint(tickR, radian);
                var end = self._getArcPoint(tickR - 0.05 * d.radius, radian);

                var color = self.component._getColorFromBands(value, bands);

                d3.select(this)
                    .attr('x1', start[0])
                    .attr('y1', start[1])
                    .attr('x2', end[0])
                    .attr('y2', end[1])
                    .attr('stroke', color);
            });

        },

        _getArcPoint:function(r, radian){
            return [r * Math.sin(radian), -r * Math.cos(radian)]
        },

        _createSlot:function(gaugeG, d){

            var arc = d3.svg.arc().startAngle(BaseUtils.toRadian(-135))
                .endAngle(BaseUtils.toRadian(135))
                .innerRadius(0).outerRadius(d.radius)
                .toCenter(false).closePath(false);

            var circle = d3.svg.arc().startAngle(BaseUtils.toRadian(-135))
                .endAngle(BaseUtils.toRadian(135))
                .innerRadius(0).outerRadius(d.radius)
                .toCenter(false).closePath(false);

            var domain = d.gaugeAxis.scale.domain();
            var scale = d3.scale.linear().domain(domain)
                .range([BaseUtils.toRadian(-135), BaseUtils.toRadian(135)]);

            var point = d.points[0];

            if(!point){
                return;
            }

            var initRadian = scale(domain[0]);
            var endRadian = scale(point.valueInDomain);
            var startStroke = this.component._getColorFromBands(domain[0], d.bands);
            var endStroke = point.color;

            var lastRotate = this._getRotate(gaugeG.select('circle.' + NEEDLE));

            var lastStroke = gaugeG.select('path.' + SLOT_BACKGROUND).attr('lastStroke');
            startStroke = BaseUtils.isEmpty(lastStroke) ? startStroke : lastStroke;

            if(!this.component.isSupportAnimation()){
                initRadian = endRadian;
                startStroke = endStroke;
            }

            gaugeG
                .select('path.' + BACKGROUND)
                .attr('d', circle())
                .style({
                    'fill':'none',
                    'stroke': d.slotBackgroundColor,
                    'stroke-linecap':'round',
                    'stroke-width': d.radius * 0.16
                });

            this._addFilter(gaugeG.select('path.' + BACKGROUND), this._getSlotInnerShadowID());

            gaugeG
                .select('path.' + SLOT_BACKGROUND)
                .attr('lastStroke', endStroke)
                .style({
                    'fill':'none',
                    'stroke': ColorUtils.colorToHex(startStroke),
                    'stroke-linecap':'round',
                    'stroke-width': d.radius * 0.16
                })
                .transition()
                .duration(ANIMATION_TIME)
                .ease(EASE_TYPE)
                .attrTween('d', function(){

                    var interpolate = d3.interpolate(initRadian + BaseUtils.toRadian(lastRotate), endRadian);

                    return function(t){
                        return arc.endAngle(interpolate(t))();
                    }
                })
                .style('stroke', ColorUtils.colorToHex(endStroke));

            //白色指针
            var cP = this._getArcPoint(d.radius, initRadian);
            gaugeG
                .select('circle.' + NEEDLE)
                .attr('cx', cP[0])
                .attr('cy', cP[1])
                .attr('r', 0.048 * d.radius)
                .style('fill', d.needle)
                .style('fill-opacity', ColorUtils.getColorOpacity(d.needle))
                .transition()
                .duration(ANIMATION_TIME)
                .ease(EASE_TYPE)
                .attrTween('transform', function(){

                    var interpolate = d3.interpolate(lastRotate, BaseUtils.toDegree(endRadian - initRadian));

                    return function(t){
                        return "rotate(" + interpolate(t) + ")";
                    }
                });

            this._addFilter(gaugeG.select('circle.' + NEEDLE), this._getSlotDropShadowID(), ANIMATION_TIME);

            this._drawGaugeLabels(gaugeG, d);
        },

        _createThermometer:function(gaugeG, d){

            var domain = d.gaugeAxis.scale.domain();
            var point = d.points[0];

            if(!point){
                return;
            }

            var valueInDomain = point.valueInDomain;
            var color = point.color;
            var radius = d.radius;
            var scale = d3.scale.linear()
                .domain(domain).range([-radius, radius]);

            var x1 = 'x1', y1 = 'y1', x2 = 'x2', y2 = 'y2';
            var cx = 'cx', cy = 'cy';

            var endX = scale(valueInDomain);
            var initX = -radius;

            if(d.thermometerLayout == Constants.VERTICAL_LAYOUT){
                x1 = 'y1'; y1 = 'x1'; x2 = 'y2'; y2 = 'x2';
                cx = 'cy'; cy = 'cx';
                initX = radius;
                endX = scale.range([radius, -radius])(valueInDomain);
            }

            gaugeG.select('line.' + BACKGROUND)
                .attr(x1, -radius)
                .attr(y1, 0)
                .attr(x2, radius)
                .attr(y2, 0)
                .style({
                    'fill':'none',
                    'stroke': d.slotBackgroundColor,
                    'stroke-width':THERMOMETER_R * 2,
                    'stroke-linecap':'round'
                });

            if(this.component.isSupportAnimation()){

                var lastX = gaugeG.select('line.' + THERMOMETER_BACKGROUND).attr(x2) || initX;
                lastX = parseFloat(lastX);

                gaugeG
                    .select('line.' + THERMOMETER_BACKGROUND)
                    .attr(x1, initX)
                    .attr(y1, 0)
                    .attr(x2, lastX)
                    .attr(y2, MAGIC_DET)
                    .style({
                        stroke:"url(#" + this._getThermometerGradualID(d) + ")",
                        'stroke-width':THERMOMETER_R * 2,
                        'stroke-linecap':'round'
                    })
                    .transition()
                    .duration(ANIMATION_TIME)
                    .ease(EASE_TYPE)
                    .attr(x2, endX);

                gaugeG
                    .select('circle.' + NEEDLE)
                    .attr(cx, lastX)
                    .attr(cy, 0)
                    .attr('r', THERMOMETER_R * 0.9)
                    .style({
                        'fill': d.needle,
                        'fill-opacity':ColorUtils.getColorOpacity(d.needle),
                        'stroke-width': THERMOMETER_R * 0.6,
                        'stroke':ColorUtils.mixColorWithHSB(color, 0, 0.1, -0.1)
                    })
                    .transition()
                    .duration(ANIMATION_TIME)
                    .ease(EASE_TYPE)
                    .attr(cx, endX);
            }else{
                gaugeG
                    .select('line.' + THERMOMETER_BACKGROUND)
                    .attr(x1, initX)
                    .attr(y1, 0)
                    .attr(x2, endX)
                    .attr(y2, MAGIC_DET)
                    .style({
                        stroke:"url(#" + this._getThermometerGradualID(d) + ")",
                        'stroke-width':THERMOMETER_R * 2,
                        'stroke-linecap':'round'
                    });

                gaugeG
                    .select('circle.' + NEEDLE)
                    .attr(cx, endX)
                    .attr(cy, 0)
                    .attr('r', THERMOMETER_R * 0.9)
                    .style({
                        'fill': d.needle,
                        'fill-opacity':ColorUtils.getColorOpacity(d.needle),
                        'stroke-width': THERMOMETER_R * 0.6,
                        'stroke':ColorUtils.mixColorWithHSB(color, 0, 0.1, -0.1)
                    });
            }

            this._drawGaugeLabels(gaugeG, d);
            this._drawThermometerTicks(gaugeG, d, scale);
        },

        _drawThermometerTicks:function(gaugeG, d, scale){

            var axisG = gaugeG.select('g.' + GAUGE_AXIS);

            var tickData = d.gaugeAxis.getTickData();

            var axisOption = d.gaugeAxis.componentOption;
            var labelStyle = axisOption.labelStyle;
            var useHtml = axisOption.useHtml;

            var plotBounds = this.component.getPlotBounds();
            var transX = plotBounds.x + d.centerX;
            var transY = plotBounds.y + d.centerY;

            var minorTickData = d.gaugeAxis.getMinorTickData();

            var x1 = 'x1', y1 = 'y1', x2 = 'x2', y2 = 'y2';
            var dx = 'dx';
            var x = 'x', y = 'y';

            var startY = -9, endY = -15, endMinorY = -13;
            var textAnchor = 'middle', textY = -19;
            var detX = '0em';

            if(d.thermometerLayout == Constants.VERTICAL_LAYOUT){
                x1 = 'y1'; y1 = 'x1'; x2 = 'y2'; y2 = 'x2';
                dx = 'dy';
                x = 'y'; y = 'x';
                startY = 9; endY = 15; endMinorY = 13;
                textAnchor = 'start'; textY = 19;
                detX = '.35em';
            }

            var tickS = axisG.selectAll("g.tick").data(tickData, function(d){
                return scale(d.tickValue);
            });

            tickS.exit().remove();

            var enterTick = tickS.enter().append('g').attr('class', 'tick');
            enterTick.append('text');
            enterTick.append('line');

            var self = this;

            tickS.each(function(tick) {

                var tickG = d3.select(this);
                var posX = scale(tick.tickValue);


                posX = BaseUtils.lineSubPixelOpt(posX,1);

                tickG
                    .select('line')
                    .attr(x1, posX)
                    .attr(y1, startY)
                    .attr(x2, posX)
                    .attr(y2, endY)
                    .style('stroke', axisOption.tickColor)
                    .style('stork-width', axisOption.tickWidth);

                if (useHtml) {
                    var labelPos;
                    if (d.thermometerLayout == Constants.HORIZONTAL_LAYOUT) {

                        labelPos = {
                            x: transX + posX - tick.tickDim.width / 2,
                            y: transY + textY - tick.tickDim.height
                        }

                    } else {

                        labelPos = {
                            x: transX + textY,
                            y: transY + posX - tick.tickDim.height / 2
                        }

                    }

                    self.labelDivManager.addLabel(tick.tickContent, labelPos, labelStyle);
                }else{
                    tickG
                        .select('text')
                        .attr(x, posX)
                        .attr(y, textY)
                        .attr("text-anchor", textAnchor)
                        .attr(dx, detX)
                        .text(tick.tickContent)
                        .call(BaseUtils.setTextStyle, labelStyle);
                }


            });

            var minorTick = axisG.selectAll("line.minorTick")
                .data(minorTickData, function(d){return scale(d);});

            minorTick.enter().append('line').attr('class', 'minorTick');

            minorTick.exit().remove();

            minorTick.each(function(value){

                var posX = scale(value);

                posX = BaseUtils.lineSubPixelOpt(posX,1);

                d3.select(this)
                    .attr(x1, posX)
                    .attr(y1, startY)
                    .attr(x2, posX)
                    .attr(y2, endMinorY)
                    .style('stroke', axisOption.minorTickColor)
                    .style('stork-width', axisOption.minorTickWidth);
            });
        },

        _createRing:function(gaugeG, d){

            var circle = d3.svg.arc()
                .startAngle(0).endAngle(2 * Math.PI)
                .innerRadius(0).outerRadius(d.radius);

            var arc = d3.svg.arc().startAngle(0)
                .innerRadius(0).outerRadius(d.radius);

            var domain = d.gaugeAxis.scale.domain();
            var point = d.points[0];

            if(!point){
                return;
            }

            var arcPercentage = Math.max(point.percentage, 0);
            var endRadian = 2 * Math.PI * arcPercentage * (d.clockwise ? 1 : -1);
            var startFill = this.component._getColorFromBands(domain[0], d.bands);
            var endFill = point.color;
            var innerR = d.radius * 0.8;
            var outerStrokeR = innerR + 2;
            var innerStrokeR = innerR - 1.5;

            gaugeG
                .select('path.' + BACKGROUND)
                .attr('d', circle())
                .style({
                    'fill':d.paneBackgroundColor,
                    'fill-opacity':ColorUtils.getColorOpacity(d.paneBackgroundColor)
                });

            if(this.component.isSupportAnimation()){

                var arcPath = gaugeG.select('path.' + RING_ARC_PATH);
                var lastRadian = arcPath.attr('lastRadian');
                if(BaseUtils.isEmpty(lastRadian)){
                    lastRadian = 0;
                }else{
                    startFill = arcPath.style('fill');
                    lastRadian = parseFloat(lastRadian);
                }

                arcPath
                    .style('fill', ColorUtils.colorToHex(startFill))
                    .style('fill-opacity', ColorUtils.getColorOpacity(startFill))
                    .transition()
                    .duration(ANIMATION_TIME)
                    .ease(EASE_TYPE)
                    .style('fill', ColorUtils.colorToHex(endFill))
                    .style('fill-opacity', ColorUtils.getColorOpacity(endFill))
                    .attrTween('d', function(){

                        var interpolate = d3.interpolate(lastRadian, endRadian);

                        return function(t){
                            return arc.endAngle(interpolate(t))();
                        }
                    })
                    .attr('lastRadian', endRadian);
            }else{
                gaugeG
                    .select('path.' + RING_ARC_PATH)
                    .style('fill', endFill)
                    .style('fill-opacity', ColorUtils.getColorOpacity(endFill))
                    .attr('d', arc.endAngle(endRadian)());
            }

            gaugeG
                .select('path.' + RING_INNER_BACKGROUND)
                .attr('d', circle.outerRadius(innerR)())
                .style('fill', d.innerPaneBackgroundColor)
                .style('fill-opacity', ColorUtils.getColorOpacity(d.innerPaneBackgroundColor));

            gaugeG
                .select('path.' + RING_OUTER_STROKE)
                .attr('d', circle.outerRadius(outerStrokeR))
                .style({
                    'fill': 'none',
                    'stroke':'#000000',
                    'stroke-opacity':0.05,
                    'stroke-width':4
                });

            gaugeG
                .select('path.' + RING_INNER_STROKE)
                .attr('d', circle.outerRadius(innerStrokeR))
                .style({
                    'fill': 'none',
                    'stroke':"url(#" + this._getRingGradualID() + ")",
                    'stroke-width':3
                });


            this._drawGaugeLabels(gaugeG, d);
        },

        _drawGaugeLabels:function(gaugeG, d){
            var labelG = gaugeG.select('g.' + GAUGE_LABEL);

            if(d.seriesLabelContent){
                this._drawLabel(labelG, d.seriesLabelContent, d.seriesLabelPos, d.seriesLabelDim,
                    d.seriesLabelStyle, d, d.seriesLabel.useHtml);
            }

            if(d.percentageLabelContent){
                this._drawLabel(labelG, d.percentageLabelContent, d.percentageLabelPos, d.percentageLabelDim,
                    d.percentageLabelStyle, d, d.percentageLabel.useHtml);
            }

            if(d.valueLabelContent && d.valueLabelContent.length){

                //指针类型的仪表盘值标签后面有背景
                if(d.valueLabelBackground){
                    labelG
                        .append('rect')
                        .attr('x', d.valueLabelBackground.x)
                        .attr('y', d.valueLabelBackground.y)
                        .attr('width', d.valueLabelBackground.width)
                        .attr('height', d.valueLabelBackground.height)
                        .attr('rx', d.radius * 0.02)
                        .attr('ry', d.radius * 0.02)
                        .style({
                            fill: d.valueLabel.backgroundColor,
                            'fill-opacity': ColorUtils.getColorOpacity(d.valueLabel.backgroundColor)
                        });

                    this._addFilter(labelG, this._getPointerInnerShadowID());
                }

                for(var i = 0, len = d.valueLabelContent.length; i < len; i++){
                    var valueLabel = d.valueLabelContent[i];
                    this._drawLabel(labelG, valueLabel.labelContent, valueLabel.labelPos, valueLabel.labelDim,
                        valueLabel.labelStyle, d, d.valueLabel.useHtml);
                }

            }

        },

        _drawLabel:function(pSelection, labelContent, labelPos, labelDim, labelStyle, gauge, useHtml){

            if(!labelPos){
                return;
            }

            if(useHtml){
                var plotBounds = this.component.getPlotBounds();
                var centerX = gauge.centerX;
                var centerY = gauge.centerY;

                labelPos = {
                    x:labelPos.x + centerX + plotBounds.x,
                    y:labelPos.y + centerY + plotBounds.y
                };

                this.labelDivManager.addLabel(labelContent, labelPos, labelStyle);

            }else{
                pSelection
                    .append('text')
                    .attr('text-anchor', 'middle')
                    .attr('dy', '0.85em')
                    .attr('x', labelPos.x + labelDim.width/2)
                    .attr('y', labelPos.y)
                    .text(labelContent)
                    .call(BaseUtils.setTextStyle, labelStyle);
            }
        },

        _getPointerInnerShadowID:function(){
            return this.component.vanchart.getIDPrefix() + Constants.GAUGE_POINTER + 'innerShadow';
        },

        _getPointerDropShadowID:function(){
            return this.component.vanchart.getIDPrefix() + Constants.GAUGE_POINTER + 'dropShadow';
        },

        _getSlotDropShadowID:function(){
            return this.component.vanchart.getIDPrefix() + Constants.GAUGE_SLOT + 'dropShadow';
        },

        _getSlotInnerShadowID:function(){
            return this.component.vanchart.getIDPrefix() + Constants.GAUGE_SLOT + 'innerShadow';
        },

        _getRingGradualID:function(){
            return this.component.vanchart.getIDPrefix() + Constants.GAUGE_RING;
        },

        _getRingClickedGradualID:function(){
            return this.component.vanchart.getIDPrefix() + Constants.GAUGE_RING + 'clicked';
        },

        _getThermometerGradualID:function(d){
            return this.component.vanchart.getIDPrefix() + d.className;
        },

        _getThermometerClickedGradualID:function(d){
            return this.component.vanchart.getIDPrefix() + d.className + 'clicked';
        },

        _getThermometerMouseOverGradualID:function(d){
            return this.component.vanchart.getIDPrefix() + d.className + 'mouseover';
        },

        seriesMouseOver:function(event){

            if(event && event.target){
                var gauge = event.target.datum();
                var d = gauge.points[0];
                var style = gauge.style;
                switch (style){
                    case Constants.GAUGE_POINTER:
                    case Constants.GAUGE_POINTER_SEMI:

                        break;
                    case Constants.GAUGE_RING:

                        event.target
                            .select('path.' + RING_ARC_PATH)
                            .style('fill', d.mouseOverColor);

                        break;
                    case Constants.GAUGE_SLOT:

                        var backgroundColor = ColorUtils.getHighLightColor(d.color);
                        var needleColor = ColorUtils.getHighLightColor(gauge.needle);

                        event.target
                            .select('path.' + SLOT_BACKGROUND)
                            .style('stroke', ColorUtils.colorToHex(backgroundColor));

                        event.target
                            .select('circle.' + NEEDLE).style('fill', needleColor);

                        break;
                    case Constants.GAUGE_THERMOMETER:

                        event.target
                            .select('line.' + THERMOMETER_BACKGROUND)
                            .style('stroke', "url(#" + this._getThermometerMouseOverGradualID(gauge) + ")");

                        event.target
                            .select('circle.' + NEEDLE)
                            .style('stroke', ColorUtils.getHighLightColor(d.color))
                            .style('fill', ColorUtils.getHighLightColor(gauge.needle));

                        break;
                }
            }
        },

        seriesMouseOut:function(event){
            if(event && event.target){
                var gauge = event.target.datum();
                var d = gauge.points[0];
                var style = gauge.style;

                switch (style){
                    case Constants.GAUGE_POINTER:
                    case Constants.GAUGE_POINTER_SEMI:

                        break;
                    case Constants.GAUGE_RING:

                        event.target
                            .select('path.' + RING_ARC_PATH)
                            .style('fill', d.color);

                        break;
                    case Constants.GAUGE_SLOT:

                        event.target
                            .select('path.' + SLOT_BACKGROUND)
                            .style('stroke', ColorUtils.colorToHex(d.color));

                        event.target
                            .select('circle.' + NEEDLE).style('fill', gauge.needle);

                        break;
                    case Constants.GAUGE_THERMOMETER:

                        event.target
                            .select('line.' + THERMOMETER_BACKGROUND)
                            .style('stroke', "url(#" + this._getThermometerGradualID(gauge) + ")");

                        event.target
                            .select('circle.' + NEEDLE)
                            .style('stroke', d.color)
                            .style('fill', gauge.needle);

                        break;
                }
            }
        },

        seriesMouseDown:function(event){
            if(event && event.target){
                var gauge = event.target.datum();
                var d = gauge.points[0];
                var style = gauge.style;
                var circle = d3.svg.arc().startAngle(0).endAngle(2 * Math.PI).innerRadius(0);

                switch (style){
                    case Constants.GAUGE_POINTER:
                    case Constants.GAUGE_POINTER_SEMI:

                        var hBackground = style == Constants.GAUGE_POINTER ? 0.16 : 0.11;
                        var hinge = style == Constants.GAUGE_POINTER ? 0.07 : 0.055;

                        circle.outerRadius(hBackground * d.series.radius * 1.25);
                        event.target.select('path.' + POINTER_HINGE_BACKGROUND).attr('d', circle());

                        //枢纽
                        circle.outerRadius(hinge * d.series.radius * 1.25);
                        event.target.select('path.' + POINTER_HINGE).attr('d', circle());

                        break;
                    case Constants.GAUGE_RING:

                        event.target
                            .select('path.' + RING_INNER_STROKE)
                            .style('stroke', "url(#" + this._getRingClickedGradualID() + ")");

                        event.target.select('path.' + RING_ARC_PATH).style('fill', d.clickColor);

                        break;
                    case Constants.GAUGE_SLOT:

                        var backgroundColor = ColorUtils.getColorWithDivider(d.color, 1/0.95);
                        var needleColor = ColorUtils.getColorWithDivider(gauge.needle, 1/0.95);

                        event.target
                            .select('path.' + SLOT_BACKGROUND)
                            .style('stroke', ColorUtils.colorToHex(backgroundColor));

                        event.target.select('circle.' + NEEDLE).style('fill', needleColor);

                        break;
                    case Constants.GAUGE_THERMOMETER:

                        event.target
                            .select('line.' + THERMOMETER_BACKGROUND)
                            .style('stroke', "url(#" + this._getThermometerClickedGradualID(gauge) + ")");

                        event.target
                            .select('circle.' + NEEDLE)
                            .style('stroke', ColorUtils.getClickColor(d.color))
                            .style('fill', ColorUtils.getClickColor(gauge.needle));

                        break;
                }
            }
        },

        seriesMouseUp:function(event){
            if(event && event.target){
                var gauge = event.target.datum();
                var d = gauge.points[0];
                var style = gauge.style;
                var circle = d3.svg.arc().startAngle(0).endAngle(2 * Math.PI).innerRadius(0);

                switch (style){
                    case Constants.GAUGE_POINTER:
                    case Constants.GAUGE_POINTER_SEMI:

                        var hBackground = style == Constants.GAUGE_POINTER ? 0.16 : 0.11;
                        var hinge = style == Constants.GAUGE_POINTER ? 0.07 : 0.055;

                        circle.outerRadius(hBackground * d.series.radius);
                        event.target.select('path.' + POINTER_HINGE_BACKGROUND).attr('d', circle());

                        //枢纽
                        circle.outerRadius(hinge * d.series.radius);
                        event.target.select('path.' + POINTER_HINGE).attr('d', circle());

                        break;
                    case Constants.GAUGE_RING:

                        event.target.select('path.' + RING_INNER_STROKE)
                            .style('stroke', "url(#" + this._getRingGradualID() + ")");

                        event.target.select('path.' + RING_ARC_PATH)
                            .style('fill', d.mouseOverColor);

                        break;
                    case Constants.GAUGE_SLOT:

                        var backgroundColor = ColorUtils.getHighLightColor(d.color);
                        var needleColor = ColorUtils.getHighLightColor(gauge.needle);

                        event.target
                            .select('path.' + SLOT_BACKGROUND)
                            .style('stroke', ColorUtils.colorToHex(backgroundColor));

                        event.target.select('circle.' + NEEDLE).style('fill', needleColor);

                        break;
                    case Constants.GAUGE_THERMOMETER:

                        event.target
                            .select('line.' + THERMOMETER_BACKGROUND)
                            .style('stroke', "url(#" + this._getThermometerMouseOverGradualID(gauge) + ")");

                        event.target
                            .select('circle.' + NEEDLE)
                            .style('stroke', ColorUtils.getHighLightColor(d.color))
                            .style('fill', ColorUtils.getHighLightColor(gauge.needle));

                        break;
                }
            }
        },

        _getSeriesTypes:function(){
            return {
                'mouseover':this._seriesMouseOver,
                'forceMouseOut':this._seriesMouseOut,
                'mousedown':this.seriesMouseDown,
                'mouseup':this.seriesMouseUp
            }
        },

        _getTypes:function(){
            return {
                'mouseover':this._mouseOver,
                'mouseout':this._mouseOut
            };
        }
    });

    require('./RenderLibrary').register(Constants.GAUGE_SVG, GaugeSvgRender);
});
/**
 * Created by eason on 15/12/31.
 */
define('render/RadarSvgRender',['require','./BaseRender','../utils/BaseUtils','../utils/LabelDivManager','../utils/ColorUtils','../Constants','./RenderLibrary'],function(require){

    var BaseRender = require('./BaseRender');
    var BaseUtils = require('../utils/BaseUtils');
    var LabelDivManager = require('../utils/LabelDivManager');
    var ColorUtils = require('../utils/ColorUtils');
    var Constants = require('../Constants');

    var CATEGORY_TEXT = 'category-axis-tick-text';
    var VALUE_TEXT = 'value-axis-tick-text';
    var GRID_LINE = 'axis-grid-line';
    var PLOT_BANDS = 'plot-bands';
    var PLOT_LINES = 'plot-lines';
    var VALUE_LINE = 'value-axis-line';
    var CATEGORY_LINE = 'category-axis-line';

    var RADAR_SERIES = 'radar-series';

    var SERIES_STROKE = 'series-stroke';
    var SERIES_FILL = 'series-fill';

    var COLUMN = 'radar-column';

    var ANIMATION_TIME = 500;
    var EASE = 'back-out';

    var EXIT_TIME = 500;
    var EXIT_EASE = 'exp-out';

    var AXIS_TIME = 300;

    var VALUE_TICK_GAP = 2;

    var RadarSvgRender = BaseRender.extend({
        render:function(){

            var svgRoot = this.component.getVanchartRender().getRenderRoot();

            if(!this._bodyG){
                this._bodyG = svgRoot.append('g');
                this._bodyG.append('defs').append('clipPath').attr('id', this._getRadarClipID());
            }

            this._updateTransform();

            this._drawRadarSeries();
        },

        _updateTransform:function(){

            var radarCenter = this.component.getRadarCenter();

            var maxValue = this.component.valueScale.domain()[1];

            var clipPath = this._bodyG.select('#' + this._getRadarClipID());

            clipPath.select('path').remove();

            clipPath.append('path').attr('d', this.component.valueAxis._getRadiusGridPath(maxValue));

            this._bodyG.attr('transform', BaseUtils.makeTranslate(radarCenter));
        },

        _drawRadarSeries:function(){

            var radarData = this.component.getVisibleChartData();

            var updateS = this._bodyG.selectAll('.' + RADAR_SERIES)
                .data(radarData, function(d){return d.className});

            this._deleteRadarSeries(updateS);

            this._updateRadarSeries(updateS);

            this._createRadarSeries(updateS);

            this._drawLabel(this.component.isSupportAnimation() ? ANIMATION_TIME : 0);
        },

        _deleteRadarSeries:function(updateS){

            var exitS = updateS.exit();

            this.component.isColumnType() ? this._deleteColumnTypeSeries(exitS)
                : this._deletePolygonTypeSeries(exitS);
        },

        _deleteColumnTypeSeries:function(exitS){

            var exitTime = this.component.isSupportAnimation() ? EXIT_TIME : 0;

            var self = this;
            exitS.each(function(d){
                var seriesG = d3.select(this);
                seriesG
                    .selectAll('path.' + COLUMN)
                    .transition()
                    .duration(exitTime)
                    .ease(EXIT_EASE)
                    .attrTween('d', function(d){

                        var interpolate = d3.interpolate(d.y, d.y0);

                        return function(t){
                            return self.component._getRadarColumnPath(d.y0, interpolate(t), d.radian);
                        }

                    })
                    .each('end', function(){
                        d3.select(this).remove();
                    });
            });

        },

        _deletePolygonTypeSeries:function(exitS){

            var self = this;

            var markerClass = this._getMarkerClass();

            var exitTime = this.component.isSupportAnimation() ? EXIT_TIME : 0;

            exitS.each(function(){

                var seriesG = d3.select(this);

                seriesG
                    .select('path.' + SERIES_STROKE)
                    .transition()
                    .duration(exitTime)
                    .ease(EXIT_EASE)
                    .attrTween('d', function(d){

                        var initPathSeg = self.component._getInitPathSegment(d.pathSegment);
                        var interpolate  = d3.interpolateArray(d.pathSegment, initPathSeg);

                        return function(t){
                            return self.component._getRadarSeriesStrokePath(interpolate(t), d.connectNulls);
                        };

                    })
                    .each('end', function(){
                        d3.select(this).remove();
                    });

                seriesG
                    .select('path.' + SERIES_FILL)
                    .transition()
                    .duration(exitTime)
                    .ease(EXIT_EASE)
                    .attrTween('d', function(d){

                        var initPathSeg = self.component._getInitPathSegment(d.pathSegment);
                        var interpolate  = d3.interpolateArray(d.pathSegment, initPathSeg);

                        return function(t){
                            return self.component._getRadarSeriesFillPath(interpolate(t), d.connectNulls);
                        };

                    })
                    .each('end', function(){
                        d3.select(this).remove();
                    });

                seriesG
                    .selectAll('g.' + markerClass)
                    .transition()
                    .duration(exitTime)
                    .ease(EXIT_EASE)
                    .attr('transform', function(){
                        return BaseUtils.makeTranslate([0,0]) + 'scale(0)';
                    })
                    .each('end', function(){
                        d3.select(this).remove();
                    });
            });

        },

        _updateRadarSeries:function(updateS){
            this.component.isColumnType() ? this._updateColumnTypeSeries(updateS)
                : this._updatePolygonTypeSeries(updateS);
        },

        _updateColumnTypeSeries:function(updateS){

            var self = this;

            this.addShapeEventHandler(updateS);

            updateS.each(function(d){

                var columnS = d3.select(this).selectAll('path.' + COLUMN).data(d.points);

                columnS.exit().remove();

                columnS.call(self._createColumn.bind(self));

                columnS.each(function(d){
                    d3.select(this)
                        .transition()
                        .duration(EXIT_TIME)
                        .ease(EXIT_EASE)
                        .attrTween('d', function(d){

                            var innerRadius = BaseUtils.pick(this._innerRadius_, d.y0);
                            var outerRadius = BaseUtils.pick(this._outerRadius_, d.y);

                            var innerInterpolate = d3.interpolate(innerRadius, d.y0);
                            var outerInterpolate = d3.interpolate(outerRadius, d.y);

                            this._innerRadius_ = d.y0;
                            this._outerRadius_ = d.y;

                            return function(t){

                                var iR = innerInterpolate(t);
                                var oR = outerInterpolate(t);
                                return self.component._getRadarColumnPath(iR, oR, d.radian);

                            }
                        });
                });

            });

        },

        _updatePolygonTypeSeries:function(updateS){

            var self = this;

            var markerClass = this._getMarkerClass();

            var animationTime = this.component.isSupportAnimation() ? ANIMATION_TIME : 0;

            updateS.each(function(d){

                var seriesG = d3.select(this);

                if(seriesG.select('path.' + SERIES_STROKE).empty()){
                    self._createPolygonStroke(seriesG, d);
                }else{
                    var strokePath = seriesG.select('path.' + SERIES_STROKE);
                    self.addSeriesEventHandler(strokePath);
                    strokePath
                        .transition()
                        .duration(animationTime)
                        .ease(EASE)
                        .attrTween('d', function(d){

                            var useLastPathSeg = !!this._pathSegment_;

                            if(useLastPathSeg && this._pathSegment_.length == d.pathSegment.length){
                                var last = this._pathSegment_;
                                for(var i = 0, count = last.length; i < count && useLastPathSeg; i++){
                                    if(last[i].length != d.pathSegment[i].length){
                                        useLastPathSeg = false;
                                    }
                                }
                            }

                            var initPathSeg = useLastPathSeg ? this._pathSegment_ : self.component._getInitPathSegment(d.pathSegment);

                            var interpolate  = d3.interpolateArray(initPathSeg, d.pathSegment);

                            this._pathSegment_ = d.pathSegment;

                            return function(t){
                                return self.component._getRadarSeriesStrokePath(interpolate(t), d.connectNulls);
                            };

                        });
                }

                if(seriesG.select('path.' + SERIES_FILL).empty()){
                    self._createPolygonFill(seriesG, d);
                }else{
                    var fillPath = seriesG.select('path.' + SERIES_FILL);
                    self.addSeriesEventHandler(strokePath);
                    fillPath
                        .transition()
                        .duration(animationTime)
                        .ease(EASE)
                        .attrTween('d', function(d){

                            var initPathSeg = this._pathSegment_ ?
                                this._pathSegment_ : self.component._getInitPathSegment(d.pathSegment);

                            var interpolate  = d3.interpolateArray(initPathSeg, d.pathSegment);

                            this._pathSegment_ = d.pathSegment;

                            return function(t){
                                return self.component._getRadarSeriesFillPath(interpolate(t), d.connectNulls);
                            };

                        });
                }


                var markers = seriesG.selectAll('g.' + markerClass)
                    .data(function(d){return d.points;});

                self.addShapeEventHandler(markers);

                markers.exit().remove();

                markers.call(self._createSvgMarker.bind(self));

                markers
                    .transition()
                    .duration(animationTime)
                    .ease(EASE)
                    .attr('transform', function(d){return BaseUtils.makeTranslate(d.pos)});

            });

        },

        _createRadarSeries:function(updateS){

            var enterS = updateS.enter().append('g')
                .attr('class', function(d){return d.className + ' ' + RADAR_SERIES})
                .attr('clip-path', "url(#" + this._getRadarClipID() +")");

            this.component.isColumnType() ? this._createColumnTypeSeries(enterS) : this._createPolygonTypeSeries(enterS);
        },

        _createColumnTypeSeries:function(enterS){

            var self = this;

            enterS.each(function(d){

                d3.select(this)
                    .selectAll('path.' + COLUMN)
                    .data(d.points)
                    .call(self._createColumn.bind(self))
                    .transition()
                    .duration(self.component.isSupportAnimation() ? ANIMATION_TIME : 0)
                    .ease(EASE)
                    .attrTween('d', function(d){

                        var initR = self.component.getInitRadius();
                        var interpolate = d3.interpolate(initR, d.y);

                        this._innerRadius_ = d.y0;
                        this._outerRadius_ = d.y;

                        return function(t){
                            return self.component._getRadarColumnPath(initR, interpolate(t), d.radian);
                        }

                    })
                    .each('end', function(d){
                        d3.select(this)
                            .attr('d', self.component._getRadarColumnPath(d.y0, d.y, d.radian))
                    });

            });

        },

        _createPolygonStroke:function(gElement, d){

            var self = this;
            var supportAnimation = this.component.isSupportAnimation();
            var para = supportAnimation ? 1 : 0;

            var strokePath = gElement.selectAll('path.' + SERIES_STROKE).data([d]);

            strokePath.enter()
                .append('path')
                .attr('class', SERIES_STROKE)
                .style({
                    'fill':'none',
                    'stroke': d.lineColor,
                    'stroke-width': d.lineWidth
                })
                .transition()
                .duration(ANIMATION_TIME * para)
                .ease(EASE)
                .attrTween('d', function(d){
                    var initSeg = self.component._getInitPathSegment(d.pathSegment);
                    var interpolate  = d3.interpolateArray(initSeg, d.pathSegment);

                    this._pathSegment_ = d.pathSegment;

                    return function(t){
                        return self.component._getRadarSeriesStrokePath(interpolate(t), d.connectNulls);
                    };
                });

            this.addSeriesEventHandler(strokePath);
        },

        _createPolygonFill:function(gElement, d){

            var self = this;
            var supportAnimation = this.component.isSupportAnimation();
            var para = supportAnimation ? 1 : 0;

            if(d.fillColor && d.fillColorOpacity){

                var fillPath = gElement.selectAll('path.' + SERIES_FILL).data([d]);

                fillPath.enter()
                    .append('path')
                    .attr('class', SERIES_FILL)
                    .style({
                        'fill': d.fillColor,
                        'fill-opacity': d.fillColor ? d.fillColorOpacity : 0
                    })
                    .transition()
                    .duration(ANIMATION_TIME * para)
                    .ease(EASE)
                    .attrTween('d', function(d){
                        var initSeg = self.component._getInitPathSegment(d.pathSegment);
                        var interpolate  = d3.interpolateArray(initSeg, d.pathSegment);

                        this._pathSegment_ = d.pathSegment;

                        return function(t){
                            return self.component._getRadarSeriesFillPath(interpolate(t), d.connectNulls);
                        };
                    });

                this.addSeriesEventHandler(fillPath);
            }

        },

        _createPolygonTypeSeries:function(enterS){

            var self = this;

            var markerClass = this._getMarkerClass();

            var supportAnimation = this.component.isSupportAnimation();
            var para = supportAnimation ? 1 : 0;

            enterS.each(function(d){

                var gElement = d3.select(this);

                self._createPolygonStroke(gElement, d);

                self._createPolygonFill(gElement, d);

                gElement
                    .selectAll('g.' + markerClass)
                    .data(d.points)
                    .call(self._createSvgMarker.bind(self))
                    .attr('transform', function(){
                        return BaseUtils.makeTranslate([0,0]) + 'scale(0.01)'
                    })
                    .transition()
                    .duration(ANIMATION_TIME * para)
                    .ease(EASE)
                    .attr('transform', function(d){
                        return BaseUtils.makeTranslate(d.pos) + 'scale(1)';
                    })

            });
        },

        _createColumn:function(updateS){

            var newColumn = updateS.enter();

            newColumn
                .append('path')
                .attr('class', function(d){
                    return COLUMN + ' ' + d.className;
                })
                .style('fill', function (d) {
                    return d.color;
                })
                .style('fill-opacity', function(d){
                    return d.fillColorOpacity;
                })
                .style('stroke', function(d){
                    return d.borderColor;
                })
                .style('stroke-width', function(d){
                    return d.borderWidth;
                })
                .call(this.addShapeEventHandler.bind(this));
        },

        _drawLabel:function(delay){

            var radarData = this.component.getVisibleChartData();

            var allPoints = [];
            radarData.forEach(function(data){
                allPoints = allPoints.concat(data.points);
            });

            var center = this.component.getRadarCenter();

            if(!this._labelG){
                this._labelG = this._bodyG.append('g');
            }

            this._drawSvgDataLabels(this._labelG, allPoints, center[0], center[1], delay);
        },

        _getRadarClipID:function(){
            return 'radarClip' + this.component.vanchart.getIDPrefix();
        },

        mouseOver:function(event){
            if(event && event.target){
                var d = event.target.datum();
                if(d.columnType){
                    event.target
                        .style('stroke', d.mouseOverColor)
                        .style('fill', d.mouseOverColor)
                        .style('stroke-width', d.borderWidth)
                        .style('stroke-opacity', 0.35)
                        .interrupt()
                        .transition()
                        .duration(100)
                        .ease('ease-out-in')
                        .style('stroke-width', 6);
                }else{
                    this._makeMarkerChosenState(event.target, d);
                }
            }
        },

        mouseOut:function(event){
            if(event && event.target){
                var d = event.target.datum();

                if(d.columnType){
                    event.target.interrupt().transition()
                        .style('fill', d.color)
                        .style('stroke', d.borderColor)
                        .style('stroke-opacity', 1)
                        .style('stroke-width', d.borderWidth);
                }else{
                    this._cancelMarkerChosenState(event.target, d);
                }

            }
        },

        mouseDown:function(event){
            if(event && event.target){
                var d = event.target.datum();
                if(d.columnType){
                    event.target.style('fill', d.clickColor);
                }else{
                    this._makeMarkerClickedState(event.target, d);
                }
            }
        },

        mouseUp:function(event){
            if(event && event.target){
                var d = event.target.datum();
                
                if(d.columnType){
                    event.target.style('fill', d.mouseOverColor);
                }else{
                    this._cancelMarkerClickedState(event.target, d);
                }
            }
        }
    });

    require('./RenderLibrary').register(Constants.RADAR_SVG, RadarSvgRender);
});
/**
 * Created by Mitisky on 16/3/14.
 */
define('render/BubbleSvgRender',['require','./BaseRender','../utils/BaseUtils','../Constants','./RenderLibrary'],function(require){
    var BaseRender = require('./BaseRender');
    var BaseUtils = require('../utils/BaseUtils');
    var Constants = require('../Constants');

    var BUBBLE_INIT_TIME = 500;
    var BUBBLE_UPDATE_TIME = 500;
    var BUBBLE_EXIT_TIME = 300;
    var BUBBLE_CHOSEN_TIME = 200;
    var BUBBLES_SHOW_TIME = 800;

    var CHOSEN_STROKE_WIDTH = 6;

    var BUBBLE_SERIES_GROUP = 'bubble-series-group';
    var BUBBLE_SHADOW_ID = 'bubble-shadow-id';
    var FORCE_BUBBLE_GROUP = 'force-bubble-group';

    var BubbleSvgRender = BaseRender.extend({

        render:function(){
            this.component.isLargeMode() ? this._canvasRender() : this._svgRender();
        },

        _svgRender:function() {
            this.component.isUpdateWithForce() ? this._renderForceBubbles() : this._renderNormalBubbles();
        },

        _createForceBubbleDivLabel:function(visiblePoints){

            var self = this;

            var plotBounds = self.component.getPlotBounds();

            var validPoints = [];

            visiblePoints.forEach(function(point){
                if(point.labelPos && point.dataLabels.useHtml){
                    point.labelPos = {
                        x:-point.labelDim.width/2 + point.x,
                        y:-point.labelDim.height/2 + point.y
                    };
                    validPoints.push(point)
                }

            });

            self._renderDivLabels(visiblePoints, plotBounds.x, plotBounds.y);
        },

        _renderForceBubbles:function(){

            //准备node数据
            var bubbleData = this.component.getVisibleChartData();
            var nodes = [];
            var maxRadius = 0, padding = 2, clusterPadding = 2;

            bubbleData.forEach(function(sery){
                sery.points.forEach(function(point){
                    if(point.visible){
                        nodes.push(point);
                        point.px = undefined;
                        point.py = undefined;
                        maxRadius = Math.max(maxRadius, point.radius);
                    }
                })
            });

            var svgRoot = this.component.getVanchartRender().getRenderRoot();
            var clipID = this.component.vanchart.getBodyClipID();
            var plotBounds = this.component.getPlotBounds();
            var self = this;

            if(!this._bodyG) {
                this._bodyG = svgRoot.append('g');
                this._createDefs();
            }

            this._bodyG
                .attr('transform', 'translate('+plotBounds.x+','+plotBounds.y+')')
                .attr('clip-path', "url(#" + clipID +")");

            var bubbleS = this._bodyG
                .selectAll('g.' + FORCE_BUBBLE_GROUP)
                .data(nodes, function(d){return d.className;});

            bubbleS.each(function(d){

                var circle = d3.transform(d3.select(this)
                    .attr('transform')).translate;

                d.x = circle[0];
                d.y = circle[1];
            });

            if(this.force){
                this.force.stop();
            }

            var force = d3.layout.force()
                .nodes(nodes)
                .size([plotBounds.width, plotBounds.height])
                .gravity(.05)
                .charge(0)
                .on("tick", tick)
                .on('start', function(){
                    self.labelDivManager.clearAllLabels();
                })
                .on('end', function(){
                    self._createForceBubbleDivLabel(nodes);
                })
                .start();

            this.force = force;

            var exitBubbles = bubbleS.exit();
            exitBubbles.each(function(){

                d3.select(this)
                    .transition()
                    .duration(BUBBLE_EXIT_TIME)
                    .ease('back-in')
                    .each(function(){

                        d3.transition(d3.select(this).select('circle'))
                            .attrTween("r", function(d) {
                                var i = d3.interpolate(d.radius, 0);
                                return function(t) { return i(t); };
                            });

                    })
                    .remove();

            });

            bubbleS
                .call(this.force.drag)
                .each(function(d){

                    var g = d3.select(this);

                    g.select('circle')
                        .transition()
                        .duration(750)
                        .attrTween("r", function(d) {
                            var currentR = d3.select(this).attr('r');
                            var i = d3.interpolate(currentR, d.radius);
                            return function(t) { return d.radius = i(t); };
                        })
                        .each('end', function(d){
                            self._createForceLabel(d, d3.select(this.parentNode));
                        });

                    g.select('text').remove();
                });

            this.addShapeEventHandler(bubbleS.select('circle'));

            this._createNewForceBubble(bubbleS, true);

            function tick(e) {

                bubbleS
                    .each(cluster(10 * e.alpha * e.alpha))
                    .each(collide(.5));

                bubbleS.each(function(){
                    var g = d3.select(this);
                    var scale = BaseUtils.pick(d3.transform(g.attr("transform")).scale, 1);
                    g
                        .attr('transform', function(d){
                            return 'translate(' + d.x + ',' + d.y + ')' + 'scale(' + scale + ')';
                        })
                });
            }

            // Move d to be adjacent to the cluster node.
            function cluster(alpha) {
                return function(d) {
                    var cluster = d.series.cluster;
                    if (!cluster || cluster === d) return;
                    var x = d.x - cluster.x,
                        y = d.y - cluster.y,
                        l = Math.sqrt(x * x + y * y),
                        r = d.radius + cluster.radius;
                    if (l != r) {
                        l = (l - r) / l * alpha;
                        d.x -= x *= l;
                        d.y -= y *= l;
                        cluster.x += x;
                        cluster.y += y;
                    }
                };
            }

            // Resolves collisions between d and all other circles.
            function collide(alpha) {
                var quadtree = d3.geom.quadtree(nodes);
                return function(d) {
                    var r = d.radius + maxRadius + Math.max(padding, clusterPadding),
                        nx1 = d.x - r,
                        nx2 = d.x + r,
                        ny1 = d.y - r,
                        ny2 = d.y + r;
                    quadtree.visit(function(quad, x1, y1, x2, y2) {
                        if (quad.point && (quad.point !== d)) {
                            var x = d.x - quad.point.x,
                                y = d.y - quad.point.y,
                                l = Math.sqrt(x * x + y * y),
                                r = d.radius + quad.point.radius + (d.series.cluster === quad.point.series.cluster ? padding : clusterPadding);
                            if (l < r) {
                                l = (l - r) / l * alpha;
                                d.x -= x *= l;
                                d.y -= y *= l;
                                quad.point.x += x;
                                quad.point.y += y;
                            }
                        }
                        return x1 > nx2 || x2 < nx1 || y1 > ny2 || y2 < ny1;
                    });
                };
            }
        },

        _createNewForceBubble:function(bubbleS, animation){

            var self = this;

            var plotBounds = this.component.getPlotBounds();
            var cX = plotBounds.width/2;
            var cY = plotBounds.height/2;

            var newForceGroup = bubbleS.enter().append('g').attr('class', function(d){
                return FORCE_BUBBLE_GROUP + ' ' + d.className;
            });

            newForceGroup
                .attr('transform', function(d){
                    var x = BaseUtils.isEmpty(d.x) ? cX : d.x;
                    var y = BaseUtils.isEmpty(d.y) ? cY : d.y;
                    return 'translate(' + x + ',' + y + ')'
                })
                .call(this.force.drag)
                .append('circle')
                .style('fill', function(d){
                    return d.color;
                })
                .style('fill-opacity', function(d){
                    return d.fillColorOpacity
                })
                .each(function(d){
                    self._addFilter(d, d3.select(this), 0);
                });

            this.addShapeEventHandler(newForceGroup.select('circle'));

            newForceGroup
                .select('circle')
                .transition().duration(animation ? 750 : 0)
                .delay(function(d, i) { return i * 5; })
                .attrTween("r", function(d) {
                    var i = d3.interpolate(0, d.radius);
                    return function(t) { return d.radius = i(t); };
                })
                .each('end', function(d){
                    self._createForceLabel(d, d3.select(this.parentNode));
                });
        },

        _createForceLabel:function(d, gElement){

            if(d.labelPos && d.labelDim && !d.dataLabels.useHtml){

                var labelContent = d.labelContent;

                var centerX = d.labelPos.x + d.labelDim.width/2;

                var startY = d.labelPos.y;

                var text = gElement.append('text').style('opacity', 0);

                for(var i = 0, count = labelContent.length; i < count; i++){
                    var label = labelContent[i];

                    var labelDim = label.dim;
                    var labelText = label.text;
                    var labelStyle = label.style;

                    text
                        .append('tspan')
                        .attr('x', centerX)
                        .attr('y', startY + labelDim.height/2)
                        .attr('dy', '.32em')
                        .attr("text-anchor", "middle")
                        .text(labelText)
                        .call(BaseUtils.setTextStyle, labelStyle);
                    startY += (labelDim.height + this.component.getLabelGap());
                }

                text.transition('linear')
                    .duration(400)
                    .style('opacity', 1)

            }
        },

        _renderNormalBubbles:function(){
            var svgRoot = this.component.getVanchartRender().getRenderRoot();
            var supportAnimation = this.component.isSupportAnimation();

            if(!this._bodyG) {
                this._bodyG = svgRoot.append('g');
                this._createDefs();
                this._updateChartBodyTranslate([this._bodyG]);
            } else {
                this._updateChartBodyTranslate([this._bodyG], supportAnimation, BUBBLE_UPDATE_TIME);
            }

            var bubbleData = this.component.getVisibleChartData();

            var bubbleSeriesS = this._bodyG
                .selectAll('g.' + BUBBLE_SERIES_GROUP)
                .data(bubbleData, function(d){return d.className});

            this._animationTimeOut = {};

            this._dropSeries(bubbleSeriesS.exit(), supportAnimation);

            this._updateSeries(bubbleSeriesS, supportAnimation);

            this._createSeries(bubbleSeriesS, supportAnimation);
        },

        scaleRender:function(){
            if(this.component.isUpdateWithForce()){
                var bubbleData = this.component.getVisibleChartData();
                var nodes = [];
                bubbleData.forEach(function(sery){
                    sery.points.forEach(function(point){
                        if(point.visible){
                            nodes.push(point);
                        }
                    })
                });

                var self = this;

                var bubbleS = this._bodyG
                    .selectAll('g.' + FORCE_BUBBLE_GROUP)
                    .data(nodes, function(d){return d.className;});

                bubbleS
                    .transition()
                    .duration(BUBBLE_UPDATE_TIME)
                    .ease('back-out')
                    .attr('transform', function(d){
                        return 'translate('+ d.x + ',' + d.y +')';
                    })
                    .each('start', function(){
                        self.labelDivManager.clearAllLabels();
                    })
                    .each('end', function(){
                        self._createForceBubbleDivLabel(nodes);
                    });


                bubbleS.each(function(d){

                    var g = d3.select(this);

                    g.select('circle').attr('r', d.radius);

                    if(d.labelPos && g.select('text').empty()){
                        self._createForceLabel(d, g);
                    }

                });
            }else{
                this.render();
            }
        },

        filterRender: function () {
            if(this.component.isLargeMode()){
                this._canvasRender();
            }else if(this.component.isUpdateWithForce()){

                var bubbleData = this.component.getVisibleChartData();
                var nodes = [];
                bubbleData.forEach(function(sery){
                    sery.points.forEach(function(point){
                        if(point.visible){
                            nodes.push(point);
                        }
                    })
                });

                this.labelDivManager.clearAllLabels();
                this._createForceBubbleDivLabel(nodes);

                var bubbleS = this._bodyG
                    .selectAll('g.' + FORCE_BUBBLE_GROUP)
                    .data(nodes, function(d){return d.className;});

                bubbleS.each(function(){
                    var g = d3.select(this);

                    var translate = d3.transform(g.attr('transform')).translate;

                    g.attr('transform', BaseUtils.makeTranslate(translate) + 'scale(1)');
                });


                bubbleS.exit().each(function(){

                    var g = d3.select(this);

                    var translate = d3.transform(g.attr('transform')).translate;

                    g.attr('transform', BaseUtils.makeTranslate(translate) + 'scale(0)');
                });

            }else{
                var self = this;
                this._bodyG.selectAll('text')
                    .filter(function(d){return d.visible})
                    .style('opacity', 1);

                this._bodyG.selectAll('text')
                    .filter(function(d){return !d.visible})
                    .style('opacity', 0);

                this._bodyG.selectAll('path')
                    .filter(function(d){return d.visible})
                    .attr('transform', function (d) {
                        return 'translate('+d.posX+','+ d.posY+')';
                    })
                    .attr('d', function(d){
                        return d3.svg.arc().outerRadius(d.radius)({startAngle:0, endAngle:2 * Math.PI})})
                    .each(function (p) {
                        self.labelDivManager.setLabelOpacity(p.className, 1);
                    });

                this._bodyG.selectAll('path')
                    .filter(function(d){return !d.visible})
                    .attr('transform', function (d) {
                        return 'translate('+d.posX+','+ d.posY+')';
                    })
                    .attr('d', d3.svg.arc().outerRadius(0)({startAngle:0, endAngle:2 * Math.PI}))
                    .each(function (p) {
                        self.labelDivManager.setLabelOpacity(p.className, 0);
                    })
            }

        },

        _createDefs:function(){

            var defs = this._bodyG.append('defs');

            this._createDropShadowFilter(defs, this._getFilterID(), 0, 0, 0.2, 2);
        },

        _getFilterID:function(){

            return this.component.vanchart.getIDPrefix() + BUBBLE_SHADOW_ID;;

        },

        _addFilter:function(d, bubble, delay){
            var self = this;
            if(d.shadow) {
                delay = delay || 0;
                delay += 200;
                setTimeout(function () {
                    if (bubble) {
                        bubble.style("filter", 'url(#' + self._getFilterID() + ')')
                    }
                }, delay)
            }
        },

        //系列消失动画
        _dropSeries:function(exitSeries, supportAnimation){
            var self = this;
            exitSeries.each(function(d){
                d3.select(this)
                    .selectAll('path')
                    .transition()
                    .duration(supportAnimation ? BUBBLE_EXIT_TIME : 0)
                    .ease('back-in')
                    .attr('d', d3.svg.arc().outerRadius(0)({startAngle:0, endAngle:2 * Math.PI}))
                    .remove();

                d3.select(this)
                    .selectAll('text')
                    .remove();

                d.points.forEach(function (p) {
                    self.labelDivManager.clearLabels(p.className);
                })
            });
        },

        _updateSeries:function(bubbleSeries, supportAnimation){

            var isChangeData = this.component.vanchart.isChangeDataState();

            var self = this;
            if(isChangeData){
                this._dropSeries(bubbleSeries, supportAnimation);

                clearTimeout(self._animationTimeOut['changeData']);
                self._animationTimeOut['changeData'] = setTimeout(function () {
                    bubbleSeries.each(function(d){
                        var bubbles = d3.select(this)
                            .selectAll('path')
                            .data(d.points, function(d){return d.className;});

                        self._createBubbles(bubbles, supportAnimation);
                        
                        var labels = d3.select(this)
                            .selectAll('text')
                            .data(d.points)
                            .enter()
                            .append('text')
                            .style('opacity', function(d){
                                return d.visible ? 1 : 0;
                            })
                            .each(function (d) {
                                self._createSingleDataLabel(d, d3.select(this));
                            });

                        labels.style('pointer-events', 'none');
                    })
                }, supportAnimation ? BUBBLE_EXIT_TIME + 100 : 0)
            } else {
                bubbleSeries.each(function(d){

                    var bubbles = d3.select(this)
                        .selectAll('path')
                        .data(d.points, function(d){return d.className;});

                    var parentG = d3.select(this);

                    var delayTime = supportAnimation ? (bubbles.empty() ? BUBBLE_EXIT_TIME : BUBBLE_UPDATE_TIME) + 100 : 0;
                    if(bubbles.empty()){
                        self._createBubbles(bubbles, supportAnimation);
                    } else {
                        d3.select(this)
                            .selectAll('text')
                            .remove();

                        d.points.forEach(function (p) {
                            self.labelDivManager.clearLabels(p.className);
                        });

                        self._updateBubbles(bubbles, supportAnimation);
                    }

                    clearTimeout(self._animationTimeOut[d.className]);
                    self._animationTimeOut[d.className] = setTimeout(function () {
                        var labels = parentG
                            .selectAll('text')
                            .data(d.points)
                            .enter()
                            .append('text')
                            .style('opacity', function(d){
                                return d.visible ? 1 : 0;
                            })
                            .each(function (d) {
                                self._createSingleDataLabel(d, d3.select(this));
                            });
                        labels.style('pointer-events', 'none');
                    }, delayTime)

                });
            }
        },

        //系列重现动画
        _createBubbles:function(bubbles, supportAnimation) {
            var bubbleG = bubbles.enter().append('path');
            var self = this;
            bubbleG.each(function(d){

                var bubble = d3.select(this);

                bubble
                    .attr('class', d.className)
                    .attr('transform', 'translate('+d.posX+','+ d.posY+')')
                    .attr('d', d3.svg.arc().outerRadius(0)({startAngle:0, endAngle:2 * Math.PI}))
                    .style('fill', d.color)
                    .style('fill-opacity', d.fillColorOpacity)
                    .transition()
                    .ease('back-out')
                    .duration(supportAnimation ? BUBBLE_EXIT_TIME : 0)
                    .attr('d', d3.svg.arc().outerRadius(d.radius)({startAngle:0, endAngle:2 * Math.PI}));

                self._addFilter(d, bubble, supportAnimation ? BUBBLE_EXIT_TIME : 0);
            });

            self.addShapeEventHandler(bubbles);
        },

        //系列消失或重现时，其他系列位置、大小动画.
        _updateBubbles:function(bubbles, supportAnimation) {
            this.addShapeEventHandler(bubbles);

            bubbles
                .filter(function(d){return d.visible})
                .each(function(d){

                    d3.select(this)
                        .transition()
                        .duration(supportAnimation ? BUBBLE_UPDATE_TIME : 0)
                        .ease('back-out')
                        .attr('d', function(d){
                            return d3.svg.arc().outerRadius(d.radius)({startAngle:0, endAngle:2 * Math.PI});
                        })
                        .attr('transform', 'translate('+ d.posX+','+ d.posY+')');
                });
        },

        //初始化
        _createSeries:function(bubbleSeries, supportAnimation) {
            var newSeriesG = bubbleSeries.enter().append('g').attr('class', BUBBLE_SERIES_GROUP);

            var self = this;
            newSeriesG.each(function(d){

                var bubbles = d3.select(this)
                    .selectAll('path')
                    .data(d.points, function(d){return d.className;});

                var bubbleG = bubbles.enter().append('path');

                bubbleG
                    .filter(function(d){return d.visible})
                    .each(function(d){

                        var bubble = d3.select(this);

                        bubble
                            .attr('class', d.className)
                            .attr('transform', 'translate('+d.posX+','+ d.posY+')')
                            .attr('d', d3.svg.arc().outerRadius(0)({startAngle:0, endAngle:2 * Math.PI}))
                            .style('fill', d.color)
                            .style('fill-opacity', d.fillColorOpacity)
                            .transition()
                            .delay(supportAnimation ? d.delayTime : 0)
                            .ease('bounce')
                            .duration(supportAnimation ? BUBBLE_INIT_TIME : 0)
                            .attr('d', d3.svg.arc().outerRadius(d.radius)({startAngle:0, endAngle:2 * Math.PI}));

                        self._addFilter(d, bubble, supportAnimation ? (BUBBLE_INIT_TIME + d.delayTime) : 0);
                    });

                self.addShapeEventHandler(bubbles);

                var labels = d3.select(this)
                    .selectAll('text')
                    .data(d.points);

                clearTimeout(self._animationTimeOut[d.className + 'init']);
                self._animationTimeOut[d.className + 'init'] = setTimeout(function () {
                    labels
                        .enter()
                        .append('text')
                        .filter(function(d){return d.visible})
                        .each(function (d) {
                            self._createSingleDataLabel(d, d3.select(this))
                        });

                    labels.style('pointer-events', 'none');

                }, supportAnimation ? BUBBLE_INIT_TIME + BUBBLES_SHOW_TIME : 0)

            });
        },

        mouseOver:function(event){
            if(this.component.isLargeMode()){
                return;
            }

            if(event && event.target){
                var d = event.target.datum();
                event.target
                    .style({
                        'stroke':d.mouseOverColor,
                        'stroke-width':0,
                        'stroke-opacity':0.35,
                        'fill':d.mouseOverColor
                    })
                    .interrupt(Constants.SELECT_ANIMATION)
                    .transition(Constants.SELECT_ANIMATION)
                    .duration(BUBBLE_CHOSEN_TIME)
                    .ease('back-out')
                    .style('stroke-width', CHOSEN_STROKE_WIDTH)
            }
        },

        mouseOut:function(event){

            if(this.component.isLargeMode()){
                return;
            }

            if(event && event.target){
                var d = event.target.datum();

                event.target
                    .style('fill', d.color)
                    .style('fill-opacity', d.fillColorOpacity)
                    .interrupt(Constants.SELECT_ANIMATION)
                    .transition(Constants.SELECT_ANIMATION);

                event.target
                    .style('stroke-width', 0);
            }
        },

        mouseDown:function(event){

            if(this.component.isLargeMode()){
                return;
            }

            if(event && event.target){
                var d = event.target.datum();
                event.target.style('fill', d.clickColor);
            }
        },

        mouseUp:function(event){
            if(event && event.target){
                var d = event.target.datum();
                event.target.style('fill', d.mouseOverColor);
            }
        }
    });

    require('./RenderLibrary').register(Constants.BUBBLE_SVG, BubbleSvgRender);

    return BubbleSvgRender;
});
/**
 * Created by Mitisky on 16/3/24.
 */
define('render/ScatterSvgRender',['require','./BaseRender','../utils/BaseUtils','../utils/ColorUtils','../Constants','./RenderLibrary'],function (require) {
    var BaseRender = require('./BaseRender');
    var BaseUtils = require('../utils/BaseUtils');
    var ColorUtils = require('../utils/ColorUtils');
    var Constants = require('../Constants');

    var SCATTER_SHOW_TIME = 800;
    var SCATTER_INIT_TIME = 300;
    var SCATTER_UPDATE_TIME = 500;

    var SCATTER_SERIES_GROUP = 'scatter-series-group';
    var SCATTER_SERIES_LINE_CLASS = 'scatter-series-line-class';

    var ScatterSvgRender = BaseRender.extend({
        render:function(){
            this.component.isLargeMode() ? this._canvasRender() : this._svgRender();
        },

        _svgRender:function(){

            var svgRoot = this.component.getVanchartRender().getRenderRoot();
            var supportAnimation = this.component.isSupportAnimation();

            if(!this._bodyG) {
                this._bodyG = svgRoot.append('g');
                this._updateChartBodyTranslate([this._bodyG]);
            } else {
                this._updateChartBodyTranslate([this._bodyG], supportAnimation, SCATTER_UPDATE_TIME);
            }

            var scatterData = this.component.getVisibleChartData();

            var scatterSeriesS = this._bodyG
                .selectAll('g.' + SCATTER_SERIES_GROUP)
                .data(scatterData, function(d){return d.className});

            this._animationTimeOut = {};

            this._dropSeries(scatterSeriesS.exit(), supportAnimation);

            this._updateSeries(scatterSeriesS, supportAnimation);

            this._createSeries(scatterSeriesS, supportAnimation);
        },

        filterRender: function () {
            if(this.component.isLargeMode()){
                this._canvasRender();
            }else{
                var self = this;
                this._bodyG.selectAll('g.' + SCATTER_SERIES_GROUP)
                    .each(function () {
                        d3.select(this)
                            .selectAll('g')
                            .filter(function(d){return d.visible})
                            .attr('transform', function(d){
                                return 'translate('+ d.posX +','+ d.posY +') scale(1)';
                            })
                            .each(function (p) {
                                self.labelDivManager.setLabelOpacity(p.className, 1);
                            });

                        d3.select(this)
                            .selectAll('g')
                            .filter(function(d){return !d.visible})
                            .attr('transform', function(d){
                                return 'translate('+ d.posX +','+ d.posY +') scale(0)';
                            })
                            .each(function (p) {
                                self.labelDivManager.setLabelOpacity(p.className, 0);
                            });
                    });
            }
        },

        //系列消失动画
        _dropSeries:function(exitSeries, supportAnimation){
            var self = this;

            exitSeries.each(function(d){
                d3.select(this)
                    .selectAll('g')
                    .transition()
                    .duration(supportAnimation ? SCATTER_INIT_TIME : 0)
                    .ease('back-in')
                    .attr('transform', function(d){
                        return 'translate('+ d.posX +','+ d.posY +') scale(0)';
                    })
                    .remove();

                d.points.forEach(function (p) {
                    self.labelDivManager.clearLabels(p.className);
                });

                d3.select(this)
                    .selectAll('path.' + SCATTER_SERIES_LINE_CLASS)
                    .remove();
            });
        },

        _updateSeries:function(scatterSeriesS, supportAnimation){

            var isChangeData = this.component.vanchart.isChangeDataState();

            var self = this;
            scatterSeriesS.each(function(d){
                var parentG = d3.select(this);

                var points = parentG
                    .selectAll('g')
                    .data(d.points, function(d){return d.className;});

                if(isChangeData){
                    //自动刷新动画
                    parentG.selectAll('path.' + SCATTER_SERIES_LINE_CLASS).remove();

                    points
                        .transition()
                        .duration(supportAnimation ? SCATTER_INIT_TIME : 0)
                        .ease('back-in')
                        .attr('transform', function(d){
                            return 'translate('+ d.posX +','+ d.posY +') scale(0)';
                        })
                        .remove();

                    clearTimeout(self._animationTimeOut[d.className]);
                    self._animationTimeOut[d.className] = setTimeout(function () {
                        self._createSeriesLine(parentG, d, supportAnimation ? SCATTER_INIT_TIME : 0);

                        parentG
                            .selectAll('g')
                            .data(d.points, function(d){return d.className;})
                            .call(self._createSvgMarker.bind(self))
                            .filter(function(d){return d.visible})
                            .attr('transform', function(d){
                                return 'translate('+ d.posX +','+ d.posY +') scale(0.01)';
                            })
                            .transition()
                            .duration(supportAnimation ? SCATTER_INIT_TIME : 0)
                            .ease('back-out')
                            .attr('transform', function(d){
                                return 'translate('+ d.posX +','+ d.posY +') scale(1)';
                            })
                            .each('end', function () {
                                var labelG = d3.select(this)
                                    .append('text')
                                    .attr('transform', function(d){
                                        return 'translate('+ (-d.posX) +','+ (-d.posY) +') scale(1)';
                                    });

                                labelG
                                    .each(function (p) {
                                        self._createSingleDataLabel(p, labelG);
                                    })
                            });
                    }, supportAnimation ? SCATTER_INIT_TIME : 0);
                }else{
                    if(points.empty()){
                        //点击图例系列重现
                        self._createSeriesLine(parentG, d, supportAnimation ? SCATTER_INIT_TIME : 0);

                        points
                            .call(self._createSvgMarker.bind(self))
                            .filter(function(d){return d.visible})
                            .attr('transform', function(d){
                                return 'translate('+ d.posX +','+ d.posY +') scale(0.01)';
                            })
                            .transition()
                            .duration(supportAnimation ? SCATTER_INIT_TIME : 0)
                            .ease('back-out')
                            .attr('transform', function(d){
                                return 'translate('+ d.posX +','+ d.posY +') scale(1)';
                            })
                            .each('end', function () {
                                var labelG = d3.select(this)
                                    .append('text')
                                    .attr('transform', function(d){
                                        return 'translate('+ (-d.posX) +','+ (-d.posY) +') scale(1)';
                                    });

                                labelG
                                    .each(function (p) {
                                        self._createSingleDataLabel(p, labelG);
                                    })
                            });
                    } else {
                        //点击图例其他系列移动
                        d.points.forEach(function (p) {
                            self.labelDivManager.clearLabels(p.className);
                        });

                        points
                            .filter(function(d){return d.visible})
                            .transition()
                            .duration(supportAnimation ? SCATTER_UPDATE_TIME : 0)
                            .ease('back-out')
                            .attr('transform', function(d){
                                return 'translate('+ d.posX +','+ d.posY +') scale(1)';
                            })
                            .each('end', function () {
                                d3.select(this)
                                    .append('text')
                                    .attr('transform', function(d){
                                        return 'translate('+ (-d.posX) +','+ (-d.posY) +') scale(1)';
                                    })
                                    .each(function (p) {
                                        self._createSingleDivDataLabel(p);
                                    })
                            });
                        parentG.select('path.' + SCATTER_SERIES_LINE_CLASS)
                            .transition()
                            .duration(supportAnimation ? SCATTER_UPDATE_TIME : 0)
                            .ease('back-out')
                            .attr('d',  d.lineSvg(d.points));
                    }
                }
            });
        },

        //初始化
        _createSeries:function(scatterSeriesS, supportAnimation) {
            var newSeriesG = scatterSeriesS.enter().append('g').attr('class', SCATTER_SERIES_GROUP);

            var self = this;
            newSeriesG
                .each(function (d) {
                    self._createSeriesLine(d3.select(this), d, supportAnimation ? SCATTER_SHOW_TIME : 0);
                });

            var markerS = newSeriesG.selectAll('g.' + SCATTER_SERIES_GROUP)
                .data(function(d){ return d.points; });

            this._createMarkers(markerS, supportAnimation)
        },

        _createMarkers:function(markerS, supportAnimation){
            var self = this;

            markerS
                .call(this._createSvgMarker.bind(this))
                .filter(function(d){return d.visible})
                .attr('transform', function(d){
                    return 'translate('+ d.posX +','+ d.posY +') scale(0.01)';
                })
                .transition()
                .delay(function(d){return supportAnimation ? d.delayTime : 0})
                .duration(supportAnimation ? SCATTER_INIT_TIME : 0)
                .ease('back-out')
                .attr('transform', function(d){
                    return 'translate('+ d.posX +','+ d.posY +') scale(1)';
                })
                .each('end', function () {
                    var labelG = d3.select(this)
                        .append('text')
                        .attr('transform', function(d){
                            return 'translate('+ (-d.posX) +','+ (-d.posY) +') scale(1)';
                        });

                    labelG
                        .each(function (p) {
                            self._createSingleDataLabel(p, labelG);
                        })
                });

        },

        _createSeriesLine: function (parentG, d, delayTime) {
            parentG
                .append('path')
                .attr('class', SCATTER_SERIES_LINE_CLASS)
                .attr('d',  d.lineSvg(d.points))
                .style('fill', 'none')
                .style('stroke', ColorUtils.colorToHex(d.color))
                .style('stroke-width', 0);

            parentG
                .select('path.' + SCATTER_SERIES_LINE_CLASS)
                .transition()
                .delay(delayTime)
                .style('stroke-width', d.lineWidth);
        },

        mouseOver:function(event){
            if(event && event.target){
                var d = event.target.datum();
                this._makeMarkerChosenState(event.target, d);
            }
        },

        mouseOut:function(event){
            if(event && event.target){
                var d = event.target.datum();
                this._cancelMarkerChosenState(event.target, d);
            }
        },

        mouseDown:function(event){
            if(event && event.target){
                var d = event.target.datum();
                this._makeMarkerClickedState(event.target, d);
            }
        },

        mouseUp:function(event){
            if(event && event.target){
                var d = event.target.datum();
                this._cancelMarkerClickedState(event.target, d);
            }
        }
    });

    require('./RenderLibrary').register(Constants.SCATTER_SVG, ScatterSvgRender);

    return ScatterSvgRender;
});

/**
 * Created by eason on 16/5/9.
 */
define('render/MapSvgRender',['require','../utils/BaseUtils','../Constants','./BaseRender','./RenderLibrary'],function(require){

    var BaseUtils = require('../utils/BaseUtils');
    var Constants = require('../Constants');
    var BaseRender = require('./BaseRender');

    var MapSvgRender = BaseRender.extend({
        render:function(){
            var map = this.component, geo = map.vanchart.getComponent(Constants.GEO_COMPONENT);
            var leaflet = map.vanchart._leaflet, featureMap = geo.getFeatureMap(map.vanchart.series);
            var tooltip = map.vanchart.getTooltip(), renderer = this;
            var eventHandler = function(feature, layer){
                layer.on({
                    click:function(){
                        map.drillDown(feature);
                    },

                    mouseover:function(){
                        d3.select(layer._path)
                            .style({
                                'stroke-width': 2,
                                'filter':'url(#' + renderer._getDropShadowID() + ')'
                            });

                    },

                    mouseout:function(){
                        d3.select(layer._path)
                            .style({'stroke-width': feature.borderWidth, 'filter':''});
                    },

                    mousemove:function(){
                        tooltip.showWithPoint(feature);
                    }
                });
            };

            //区块地图
            var areaOptions = {
                style:function(feature){
                    return {
                        fillColor:feature.fillColor,
                        fillOpacity:feature.fillColorOpacity,
                        color:feature.borderColor,
                        weight:feature.borderWidth,
                        opacity:feature.borderOpacity
                    }
                },
                onEachFeature:eventHandler
            };
            this._areaLayer = this._areaLayer || L.geoJson([], areaOptions).addTo(leaflet);
            this._updateAreaLayerGroup(this._areaLayer, featureMap.areaFeatures, function(d){return d.properties.id});

            this._areaLabelLayer = this._areaLabelLayer || L.layerGroup().addTo(leaflet);
            this._updatePointLayerGroup(this._areaLabelLayer, L.text, featureMap.areaText, null, function(d){return d.properties.id});

            //气泡地图
            var keyFunction = function(d){return d.className};
            var bubbleOptions = {
                style:function(data){
                    return {
                        radius:data.radius,
                        fillColor:data.color,
                        fillOpacity:data.fillColorOpacity,
                        weight:0
                    }
                },
                onEachLayer:eventHandler
            };
            this._bubbleLayer = this._bubbleLayer || L.layerGroup().addTo(leaflet);
            this._updatePointLayerGroup(this._bubbleLayer, L.circleMarker, featureMap.bubbleFeatures, bubbleOptions, keyFunction);

            this._bubbleLabelLayer = this._bubbleLabelLayer || L.layerGroup().addTo(leaflet);
            this._updatePointLayerGroup(this._bubbleLabelLayer, L.text, featureMap.bubbleText, null, keyFunction);

            //散点地图
            var scatterOptions = {
                style:function(feature){
                    return {
                        fillColor:'blue'
                    }
                },

                onEachLayer:eventHandler
            };
            this._scatterLayer = this._scatterLayer || L.layerGroup().addTo(leaflet);
            this._updatePointLayerGroup(this._scatterLayer, L.scatterMarker, featureMap.scatterFeatures, scatterOptions, keyFunction);

            this._scatterLabelLayer = this._scatterLabelLayer || L.layerGroup().addTo(leaflet);
            this._updatePointLayerGroup(this._scatterLabelLayer, L.text, featureMap.scatterText, null, keyFunction);

            //图片类型的标记点
            var imageOptions = {
                style:function(feature){
                    return {icon:L.icon(feature.icon)}
                },

                onEachLayer:eventHandler
            };

            this._imageLayer = this._imageLayer || L.layerGroup().addTo(leaflet);
            this._updatePointLayerGroup(this._imageLayer, L.marker, featureMap.imageFeatures, imageOptions, keyFunction);

            this._imageLabelLayer = this._imageLabelLayer || L.layerGroup().addTo(leaflet);
            this._updatePointLayerGroup(this._imageLabelLayer, L.text, featureMap.imageText, null, keyFunction);

            this._createDropShadow(leaflet);
        },

        _updatePointLayerGroup:function(layerGroup, layerFunc, features, options, keyFunction){

            var layers = layerGroup.getLayers();
            var selection = this._rebindLayers(layers, features, keyFunction);

            for(var i = selection.enter.length - 1; i >= 0; i--){
                var point = selection.enter[i];
                var layer = layerFunc(this.getLatLng(point), options && options.style.call(null, point), point);
                options && options.onEachLayer.call(null, point, layer);
                layerGroup.addLayer(layer);
            }
            selection.exit.forEach(function(layer){layerGroup.removeLayer(layer);});
        },

        _updateAreaLayerGroup:function(layerGroup, features, keyFunction){

            var layers = layerGroup.getLayers();
            var selection = this._rebindLayers(layers, features, keyFunction);

            layerGroup.addData(selection.enter);
            selection.exit.forEach(function(layer){layerGroup.removeLayer(layer);});
            layers.forEach(function(layer){layerGroup.resetStyle(layer);});
        },

        getLatLng:function(point){
            var lnglat = point.lnglat;
            var geo = this.component.vanchart.getComponent(Constants.GEO_COMPONENT);
            if(!lnglat){
                lnglat = geo.getFeature(point.name).properties.center;
            }
            return [lnglat[1], lnglat[0]];
        },

        //参考d3的selection的实现
        _rebindLayers:function(layers, dataArray, keyFunction){
            var i, n = layers.length, m = dataArray.length, enterFeatures = [], exitLayers = [];
            var nodeByKeyValue = {}, keyValues = new Array(n), keyValue, layer, data;
            for (i = -1; ++i < n; ) {
                layer = layers[i];
                keyValue = keyFunction(layer._data);
                nodeByKeyValue[keyValue] = layer;
                keyValues[i] = keyValue;
            }
            for (i = -1; ++i < m; ) {
                data = dataArray[i];
                keyValue = keyFunction(data);
                layer = nodeByKeyValue[keyValue];
                if (!layer) {
                    enterFeatures.push(data);
                }else if(layer !== true){
                    layer._data = data;
                    layer.feature = data;//兼容
                }
                nodeByKeyValue[keyValue] = true;
            }

            for (i = -1; ++i < n; ) {
                if (nodeByKeyValue[keyValues[i]] !== true) {
                    exitLayers[i] = layers[i];
                }
            }

            return {
                enter:enterFeatures,
                exit:exitLayers
            }
        },

        _createDropShadow:function(leaflet){
            if(!this._defs && leaflet){
                this._defs = d3.select(leaflet._renderer._container).append('defs');
                this._createDropShadowFilter(this._defs, this._getDropShadowID(), 0, 1, 0.5, 2);
            }
        },

        _getDropShadowID:function(){
            return this.component.vanchart.getIDPrefix() + Constants.MAP_CHART;
        }
    });
    
    require('./RenderLibrary').register(Constants.MAP_SVG, MapSvgRender);
});
/**
 * Created by eason on 16/5/17.
 */
define('render/DrillToolsSvgRender',['require','./BaseRender','../utils/BaseUtils','../Constants','./RenderLibrary'],function(require){

    var BaseRender = require('./BaseRender');
    var BaseUtils = require('../utils/BaseUtils');
    var Constants = require('../Constants');

    var DrillToolsSvgRender = BaseRender.extend({
        render:function(){
            var cfg = this.component.componentOption;
            var b = this.component.bounds;
            var svgRoot = this.component.getVanchartRender().getRenderRoot();
            this._bodyG = this._bodyG || svgRoot.append('g');

            var shadowID = this.component.vanchart.getIDPrefix() + Constants.DRILL_TOOLS + "shadow";
            var clipID = this.component.vanchart.getIDPrefix() + Constants.DRILL_TOOLS + 'clip';
            if(!this._defs){
                this._defs = this._bodyG.append('defs');
                this._createDropShadowFilter(this._defs, shadowID, 0, 0, 0.15, 1);
                this._defs.append('clipPath').attr('id', clipID).append('rect').attr('width', b.width).attr('height', b.height);
            }

            this._bodyG.attr('transform', BaseUtils.makeTranslate(b)).attr('clip-path', "url(#" + clipID +")");

            var dTools = this.component;
            var map = dTools.vanchart.getChart(Constants.MAP_CHART);
            var iconS = this._bodyG.selectAll('g').data(this.component.getIconData(), function(d){return d.layerIndex});

            //update状态的标签注意改文字颜色
            iconS.select('text').style('fill', function(d){return dTools.textColor(d);});

            var exitData = [];
            var exit = iconS.exit().each(function(d){exitData.push(d)});
            dTools.calculateExitAnimation(exitData);
            exit.transition()
                .duration(function(d){return d.time;}).delay(function(d){return d.delay;})
                .ease('quad-in').attr('transform', function(d){return BaseUtils.makeTranslate([d.aniStart, 0])})
                .style('opacity', 0)
                .remove();

            iconS.enter().insert('g', ':first-child').each(function(d){
                var label = d.geo.geoName;
                var g = d3.select(this).style('cursor', 'pointer');
                g.append('path').attr('d', dTools.getBookMarkPath(d)).style('fill', cfg.backgroundColor).style("filter", 'url(#'+ shadowID +')');
                g.append('text').text(label).attr('x', dTools.leftPadding(d) + 'em').attr('y', (dTools.topPadding() + .85) + 'em')
                    .call(BaseUtils.setTextStyle, cfg.style).style('fill', cfg.currentColor);
                g.attr('transform', BaseUtils.makeTranslate([d.aniStart, 0]))
                    .transition().duration(500).ease('cubic-out')
                    .attr('transform', BaseUtils.makeTranslate([d.aniEnd, 0]));
                g
                    .on('click', function(d){map.drillUp(d);})
                    .on('mouseenter', function(d){
                        d3.select(this).select('text').style('fill', dTools.mouseOverColor(d));
                    })
                    .on('mouseleave', function(d){
                        d3.select(this).select('text').style('fill', dTools.textColor(d));
                    })
            })
        }
    });
    
    require('./RenderLibrary').register(Constants.DRILL_TOOLS_SVG, DrillToolsSvgRender);

    return DrillToolsSvgRender;
});
/**
 * Created by eason on 15/8/14.
 */

define('render/TitleSvgRender',['require','./BaseRender','../utils/BaseUtils','../Constants','../utils/BezierEasing','./RenderLibrary'],function(require){

    var BaseRender = require('./BaseRender');
    var BaseUtils = require('../utils/BaseUtils');
    var Constants = require('../Constants');
    var BezierEasing = require('../utils/BezierEasing');

    var TITLE_GRADUAL = 'title-gradual-background';

    var TitleSvgRender = BaseRender.extend({
        render:function(){

            if(this._titleG){
                return;
            }

            var cfg = this.component.componentOption;
            var bounds = this.component.bounds;
            var svgRoot = this.component.getVanchartRender().getRenderRoot();

            var IDPrefix = this.component.vanchart.getIDPrefix();
            var gradualID = TITLE_GRADUAL + IDPrefix;

            if(!this._titleG){
                this._backgroundG = svgRoot.append('g')
                    .attr('transform', 'translate(' + bounds.x + ',' + bounds.y + ')');

                this._titleG = svgRoot.append('g')
                    .attr('transform', 'translate(' + bounds.x + ',' + bounds.y + ')');
            }

            //背景
            if(cfg.backgroundColor){

                this._createGradualDefs(this._titleG, cfg.backgroundColor, gradualID);

                this._backgroundG
                    .append('rect')
                    .attr('x', 0)
                    .attr('y', 0)
                    .attr('width', bounds.width)
                    .attr('height', bounds.height)
                    .attr('rx', cfg.borderRadius)
                    .attr('ry', cfg.borderRadius)
                    .style('fill', function(){
                        return typeof cfg.backgroundColor == 'string' ?
                            cfg.backgroundColor : "url(#" + gradualID + ")";
                    });
            }

            var textDim = this.component.textDim;
            var padding = this.component.getPadding();
            var textBounds = {
                x: bounds.x + padding,
                y: bounds.y + padding,
                width: textDim.width,
                height: textDim.height
            };

            if (!this.component.isFloat && cfg.align === 'center') {
                textBounds.x = bounds.x + bounds.width / 2 - textDim.width / 2;
            }

            this.textBounds = textBounds;

            this._drawTitle(cfg, textBounds);
        },

        translateX:function(width){

            this.labelDivManager.translateLabelsHorizontal(width);

            var gap = this.usedWidth - this.textEndX;

            if(gap > Math.abs(width)){
                return;
            }

            var translate = d3.transform(this._titleG.attr('transform')).translate;

            var newX = translate[0] + width;

            this._titleG.transition().ease(BezierEasing.css.swing).duration(300)
                .attr('transform', 'translate(' + newX + ',' + translate[1] + ')');

        },

        changeTextRightSpace: function (changes) {

            if (this.component.isFloat) {
                return;
            }

            switch (this.component.componentOption.align) {
                case 'center':
                    var bounds = this.component.bounds;
                    var initTextDim = this.component.textDim;
                    var initTextX = bounds.x + bounds.width / 2 - initTextDim.width / 2;
                    var textBounds = this.textBounds;
                    var padding = this.component.getPadding();
                    var barWidth = this.component.vanchart.getToolbarWidth();
                    var initBarWidth = this.component.initBarWidth;

                    var gap = bounds.width / 2 - initTextDim.width / 2 - initBarWidth - padding;

                    var changesToInit = barWidth - initBarWidth;

                    var x = textBounds.x;
                    var width = textBounds.width;

                    if (gap <= 0) {
                        x = bounds.x;
                        width = bounds.width - barWidth;
                    } else if (gap < changesToInit) {
                        x = initTextX - (changesToInit - gap);
                    } else {
                        x = initTextX;
                        width = initTextDim.width;
                    }

                    this.labelDivManager.changeLabelDim({
                        left: x - textBounds.x,
                        width: width - textBounds.width
                    });

                    this.textBounds.x = x;
                    this.textBounds.width = width;

                    break;
                default:
                    // adjust width
                    this.labelDivManager.changeLabelDim({
                        width: -changes
                    });
            }
        }
    });

    TitleSvgRender.addInitHook(function(){
        //文本实际结束的位置
        this.textEndX = 0;
        this.usedWidth = 0;
        this.textBounds = {};
    });

    require('./RenderLibrary').register(Constants.TITLE_SVG, TitleSvgRender);
    return TitleSvgRender;
});
/**
 * Created by eason on 15/9/25.
 */

define('render/BaseAxisSvgRender',['require','./BaseRender','../utils/BaseUtils','../utils/BezierEasing','../Constants'],function(require){

    var BaseRender = require('./BaseRender');
    var BaseUtils = require('../utils/BaseUtils');
    var BezierEasing = require('../utils/BezierEasing');
    var Constants = require('../Constants');


    var TIME = 400;
    var EASE = BezierEasing.css.swing;

    var MONITOR_EASE = 'linear';
    var MONITOR_TIME = 500;

    var TICK_TEXT = 'axis-tick-text';
    var TICK_LINE = 'axis-tick-line';
    var MINOR_TICK_LINE = 'axis-minor-tick-line';
    var GRID_LINE = 'axis-grid-line';
    var PLOT_BANDS = 'plot-bands';
    var PLOT_LINES = 'plot-lines';
    var AXIS_LINE = 'axis-line';
    var HIGHLIGHT_BAND = 'highlight-band';

    var BaseAxisSvgRender = BaseRender.extend({

        render:function(){

            var svgRoot = this.component.getVanchartRender().getRenderRoot().select('g.' + Constants.AXIS_GROUP);

            this.labelDivManager.clearAllLabels();

            if(this._axisG){
                if(this.component.option.plotOptions.large){
                    this._axisG.call(this._drawAxis.bind(this));
                }else{
                    this._axisG.transition().ease(EASE).duration(TIME).call(this._drawAxis.bind(this));
                }

                clearTimeout(this._animation_);
                var self = this;
                this._animation_ = setTimeout(function(){
                    self._axisG.call(self._drawAxis.bind(self));
                }, TIME + 100)

            }else{
                this._axisG =  svgRoot.append('g');
                this._axisG.call(this._drawAxis.bind(this));
            }

            this._axisTitleG = this._axisTitleG || svgRoot.append('g');

            var titleBounds = this.component.getAxisTitleBounds();

            this._axisTitleG.attr('transform', 'translate(' + titleBounds.x + ',' + titleBounds.y + ')');

            this._drawAxisTitle(titleBounds);
        },

        drawHighlightBand: function (pos) {

            var axis = this.component;
            if (!axis._getBandByPosition) {
                return;
            }

            var drawBand = axis._getBandByPosition(pos);
            var highlightType = axis.getHighlightType();

            this.removeHighlightBand();

            switch (highlightType) {
                case 'band':
                    this._axisG
                        .append('rect')
                        .attr('class', HIGHLIGHT_BAND)
                        .attr('x', drawBand.x)
                        .attr('y', drawBand.y)
                        .attr('width', drawBand.width)
                        .attr('height', drawBand.height)
                        .style('fill', 'rgba(98,179,240,0.2)');

                    break;
                case 'line':
                default:
                    this._axisG
                        .append('line')
                        .attr('class', HIGHLIGHT_BAND)
                        .attr('x1', drawBand.x)
                        .attr('y1', drawBand.y)
                        .attr('x2', drawBand.x)
                        .attr('y2', drawBand.y + drawBand.height)
                        .attr('stroke', 'rgb(140,140,140)')
                        .attr('stroke-width', '1');
            }

        },

        removeHighlightBand: function () {
            this._axisG.select('.' + HIGHLIGHT_BAND).remove();
        },
        
        _drawPlotBands:function(g){

            var plotBands = this.component._preCalculatePlotBands();
            var plotBounds = this.component.getPlotBounds();

            g.each(function(){

                var bands = d3.select(this)
                    .selectAll('.' + PLOT_BANDS).data(plotBands);

                bands.exit().remove();

                bands.enter().append('rect').attr('class', PLOT_BANDS);

                bands
                    .attr('transform', BaseUtils.makeTranslate(plotBounds))
                    .style('fill', function(d){return d.color});

                d3.transition(bands)
                    .attr('x', function(d){return d.x})
                    .attr('y', function(d){return d.y})
                    .attr('width', function(d){return d.width})
                    .attr('height', function(d){return d.height});
            });
        },

        _drawPlotLines:function(g){

            var plotLines = this.component._preCalculatePlotLines();
            var plotBounds = this.component.getPlotBounds();

            g.each(function(){

                var lines = d3.select(this)
                    .selectAll('.' + PLOT_LINES).data(plotLines);

                lines.exit().remove();

                var lineEnter = lines.enter().append('g').attr('class', PLOT_LINES);
                lineEnter.append('line');
                lineEnter.append('text');

                d3.transition(lines).attr('transform', BaseUtils.makeTranslate(plotBounds));

                d3.transition(lines.select('line'))
                    .attr('x1', function(d){return d.startPos.x})
                    .attr('y1', function(d){return d.startPos.y})
                    .attr('x2', function(d){return d.endPos.x})
                    .attr('y2', function(d){return d.endPos.y})
                    .style('stroke', function(d){
                        return d.color;
                    })
                    .style('stroke-width', function(d){
                        return d.width;
                    })
                    .style('stroke-dasharray', function(d){
                        return d.dataArray;
                    });

                d3.transition(lines.select('text'))
                    .text(function(d){
                        return d.text;
                    })
                    .attr('x', function(d){
                        return d.textX;
                    })
                    .attr('y', function(d){
                        return d.textY;
                    })
                    .attr('dy', '0.85em')
                    .each(function(d){
                        d3.select(this)
                            .call(BaseUtils.setTextStyle, d.style);
                    });
            });
        },

        _drawGridLine:function(g){
            var cfg = this.component.componentOption;
            var plotBounds = this.component.getPlotBounds();
            var gridLineWidth = cfg.gridLineWidth;
            var ticks = this.component.getTickData();
            var scale = this.component.scale;
            var lastScale = this.component.lastScale || scale;

            var x1 = 'x1', y1 = 'y1', x2 = 'x2', y2 = 'y2';
            var lineSize = plotBounds.height;
            var endPos = plotBounds.width;

            if(!this.component.isHorizontal()){
                x1 = 'y1'; y1 = 'x1'; x2 = 'y2'; y2 = 'x2';
                lineSize = plotBounds.width;
                endPos = 0;
            }

            var gridLineColor = cfg.gridLineColor;
            var det = BaseUtils.lineSubPixelOpt(0, gridLineWidth);

            g.each(function(){

                d3.select(this).selectAll('.' + GRID_LINE).data([0]).enter().append('g').attr('class', GRID_LINE);

                var gridLines = d3.select(this).select('g.' + GRID_LINE)
                                        .selectAll('line').data(ticks, function(d){return d.tickValue});

                if(gridLineWidth){

                    d3.transition(gridLines.exit())
                        .style("opacity", 0)
                        .attr(x1, function(d){
                            return scale(d.tickValue);
                        })
                        .attr(y1, 0)
                        .attr(x2, function(d){
                            return scale(d.tickValue);
                        })
                        .attr(y2, lineSize)
                        .remove();

                    var enter = gridLines.enter();

                    enter.append('line')
                        .attr('class', GRID_LINE)
                        .attr('transform', BaseUtils.makeTranslate(plotBounds))
                        .attr(x1, function(d){
                            return lastScale(d.tickValue) + det}
                        )
                        .attr(y1, 0)
                        .attr(x2, function(d){return lastScale(d.tickValue) + det})
                        .attr(y2, lineSize)
                        .style({
                            'stroke':gridLineColor,
                            'stroke-width':gridLineWidth,
                            'opacity':0
                        });

                    d3.transition(gridLines)
                        .attr('transform', BaseUtils.makeTranslate(plotBounds))
                        .attr(x1, function(d){return d.tickPos + det})
                        .attr(y1, 0)
                        .attr(x2, function(d){return d.tickPos + det})
                        .attr(y2, lineSize)
                        .style('opacity', 1);
                }else{
                    gridLines.remove();
                }

            });
        },

        _drawTickLine:function(g){

            var cfg = this.component.componentOption;

            var ticks = this.component.getMainTickData();
            var tickLength = cfg.enableTick ? cfg.tickLength : 0;
            var tickWidth = cfg.tickWidth;
            var tickColor = cfg.tickColor;
            var axisOrigin = this.component._getAxisOriginPoint();
            var orient = this.component.getPosition();

            var x1 = 'x1', y1 = 'y1', x2 = 'x2', y2 = 'y2';
            if(!this.component.isHorizontal()){
                x1 = 'y1'; y1 = 'x1'; x2 = 'y2'; y2 = 'x2';
            }

            var sign = (orient == Constants.TOP || orient == Constants.LEFT) ? -1 : 1;
            var det = BaseUtils.lineSubPixelOpt(0, tickWidth);

            g.each(function(){

                var tickLines = d3.select(this).selectAll('.' + TICK_LINE).data(ticks);

                if(tickLength && tickWidth){

                    tickLines.enter()
                        .append('line').attr('class', TICK_LINE)
                        .attr('transform', BaseUtils.makeTranslate(axisOrigin))
                        .style({
                            'stroke':tickColor,
                            'stroke-width':tickWidth
                        });

                    tickLines.exit().remove();

                    d3.transition(tickLines)
                        .attr('transform', BaseUtils.makeTranslate(axisOrigin))
                        .attr(x1, function(d){
                            return d.tickPos + det;
                        })
                        .attr(y1, 0)
                        .attr(x2, function(d){
                            return d.tickPos + det;
                        })
                        .attr(y2, sign * tickLength);
                }else{
                    tickLines.remove();
                }
            });

        },

        _drawTickLabel:function(g){

            var cfg = this.component.componentOption;
            var plotBounds = this.component.getPlotBounds();

            var scale = this.component.scale;
            var lastScale = this.component.lastScale || scale;

            var ticks = this.component.getTickData();
            var tickLength = cfg.enableTick ? cfg.tickLength : 0;
            var labelRotation = cfg.labelRotation || 0;
            var axisOrigin = this.component._getAxisOriginPoint();
            var useHtml = cfg.useHtml && !cfg.labelRotation;
            var labelStyle = cfg.labelStyle;
            var labelHeight = BaseUtils.getTextHeight(labelStyle);
            var tickPadding = cfg.tickPadding + tickLength || 0;

            var orient = this.component.getPosition();
            var sign = (orient == Constants.TOP || orient == Constants.LEFT) ? -1 : 1;

            var isHorizontal = this.component.isHorizontal();

            var x = 'x', y = 'y';
            if(!isHorizontal){
                x = 'y'; y = 'x';
            }

            var self = this;

            g.each(function(){

                var tickLabels = d3.select(this)
                    .selectAll('.' + TICK_TEXT)
                    .data(ticks, function(d){return d.tickValue});

                if(cfg.showLabel && !useHtml){

                    tickLabels.enter()
                        .append('text')
                        .attr('class', TICK_TEXT)
                        .attr('transform', function(d){
                            return self._getLabelTransform(lastScale, d, sign, tickPadding, axisOrigin, labelRotation);
                        })
                        .attr(x, function(d){return lastScale(d.tickValue);})
                        .style('text-anchor', 'middle')
                        .style('opacity', 0)
                        .call(BaseUtils.setTextStyle, labelStyle);

                    d3.transition(tickLabels.exit())
                        .attr(x, function(d){
                            return scale(d.tickValue);
                        })
                        .style('opacity', 0)
                        .remove();


                    d3.transition(tickLabels)
                        .attr('transform', function(d){
                            return self._getLabelTransform(scale, d, sign, tickPadding, axisOrigin, labelRotation);
                        })
                        .text(function(d){return d.tickContent;})
                        .attr(x, function(d){return d.tickLabelPos;})
                        .attr(y, function(d){
                            if(isHorizontal){
                                var tmp = orient == Constants.TOP ? (tickPadding + d.tickDim.height/2 - labelHeight/2) : (tickPadding + d.tickDim.height/2 + labelHeight/2);
                                return sign * tmp;
                            }else{
                                return sign * (tickPadding + d.tickDim.width/2)
                            }
                        })
                        .attr('dy', isHorizontal ? 0 : '.32em')
                        .style('opacity', 1);

                }else{
                    tickLabels.remove();
                }
            });
        },

        _getLabelTransform:function(scale, d, sign, tickPadding, axisOrigin, labelRotation){

            var det = scale.rangeBand ? -scale.rangeBand()/2 : 0;
            var tickLabelPos = Math.round(scale(d.tickValue)) - det;

            var rx, ry;
            if(this.component.isHorizontal()){
                rx = tickLabelPos;
                ry = sign * (tickPadding + d.tickDim.height/2);
            }else{
                rx = sign * (tickPadding + d.tickDim.width/2);
                ry = tickLabelPos;
            }
            return BaseUtils.makeTranslate(axisOrigin) + 'rotate(' + labelRotation + ' ' + rx + ',' + ry + ')';
        },

        _drawAxisLine:function(g){
            var cfg = this.component.componentOption;
            var plotBounds = this.component.getPlotBounds();
            var axisOrigin = this.component._getAxisOriginPoint();
            var lineWidth = cfg.lineWidth;
            var lineColor = cfg.lineColor;

            var x1 = 'x1', y1 = 'y1', x2 = 'x2', y2 = 'y2';
            var size = plotBounds.width;

            if(!this.component.isHorizontal()){
                x1 = 'y1'; y1 = 'x1'; x2 = 'y2'; y2 = 'x2';
                size = plotBounds.height;
            }

            var det = BaseUtils.lineSubPixelOpt(0, lineWidth);

            g.each(function(){

                var path = d3.select(this).selectAll("line." + AXIS_LINE).data([ 0 ]);

                if(lineWidth){

                    path.exit().remove();

                    path.enter().append('line').attr('class', AXIS_LINE);

                    d3.transition(path)
                        .attr('transform', BaseUtils.makeTranslate(axisOrigin))
                        .attr(x1, 0)
                        .attr(y1, det)
                        .attr(x2, size)
                        .attr(y2, det)
                        .style({
                            'stroke':lineColor,
                            'stroke-width':lineWidth
                        });
                }else{
                    path.remove();
                }

            });

        },

        _drawMinorTickLine:function(g){

            var cfg = this.component.componentOption;
            var minorTickLength = cfg.enableMinorTick ? cfg.minorTickLength : 0;
            var minorTickWidth = cfg.minorTickWidth;
            var minorTickColor = cfg.minorTickColor;
            var minorTickData = this.component.getMinorTickData();

            var axisOrigin = this.component._getAxisOriginPoint();
            var orient = this.component.getPosition();

            var x1 = 'x1', y1 = 'y1', x2 = 'x2', y2 = 'y2';
            if(!this.component.isHorizontal()){
                x1 = 'y1'; y1 = 'x1'; x2 = 'y2'; y2 = 'x2';
            }

            var sign = (orient == Constants.TOP || orient == Constants.LEFT) ? -1 : 1;
            var det = BaseUtils.lineSubPixelOpt(0, minorTickWidth);

            var isCategory = this.component.type == Constants.CATEGORY_AXIS_COMPONENT;
            var scale = this.component.scale;

            g.each(function(){

                var minorTicks = d3.select(this)
                    .selectAll('.' + MINOR_TICK_LINE)
                    .data(minorTickData);

                if(minorTickLength && minorTickWidth){

                    minorTicks.enter()
                        .append('line').attr('class', MINOR_TICK_LINE)
                        .attr('transform', BaseUtils.makeTranslate(axisOrigin))
                        .style({
                            'stroke':minorTickColor,
                            'stroke-width':minorTickWidth
                        });

                    minorTicks.exit().remove();

                    d3.transition(minorTicks)
                        .attr('transform', BaseUtils.makeTranslate(axisOrigin))
                        .attr(x1, function(d){
                            return (isCategory ? d : scale(d)) + det;
                        })
                        .attr(y1, 0)
                        .attr(x2, function(d){
                            return (isCategory ? d : scale(d)) + det;
                        })
                        .attr(y2, sign * minorTickLength);
                }else{
                    minorTicks.remove();
                }
            });
        },

        _drawDivLabels:function(){

            var labelDivManager = this.labelDivManager;
            var cfg = this.component.componentOption;

            if(!cfg.useHtml || cfg.labelRotation){
                return;
            }

            var origin = this.component._getAxisOriginPoint();

            var transX = origin.x;
            var transY = origin.y;

            var orient = this.component.getPosition();
            var isHorizontal = this.component.isHorizontal();
            var scale = this.component.getTickScale();
            var ticks = this.component.getTickData();

            var tickLength = cfg.enableTick ? cfg.tickLength : 0;
            var tickSpacing = (scale.rangeBand ? 0 : tickLength) + cfg.tickPadding;

            var labelStyle = cfg.labelStyle;
            var labelHeight = BaseUtils.getTextHeight(labelStyle);

            var x,y;
            if(cfg.useHtml && !cfg.labelRotation){

                if(isHorizontal){

                    y = orient == Constants.TOP ? -(tickSpacing + labelHeight) : tickSpacing;

                    ticks.forEach(function(tick){

                        x = tick.tickLabelPos - tick.tickDim.width/2;

                        labelDivManager.addLabel(tick.tickContent, {x:x + transX, y:y + transY}, labelStyle);

                    });

                }else{

                    ticks.forEach(function(tick){

                        x = orient == Constants.LEFT ? -(tickSpacing + tick.tickDim.width) : tickSpacing;
                        y = tick.tickLabelPos - labelHeight/2;

                        labelDivManager.addLabel(tick.tickContent, {x:x + transX, y:y + transY}, labelStyle);
                    });
                }
            }

        },

        /**
         * 坐标轴的刻度线，同区域背景什么的要分开画
         * @param selection
         * @private
         */
        _drawAxis:function(g) {

            this._drawPlotBands(g);

            this._drawGridLine(g);

            this._drawAxisLine(g);

            this._drawArrow(g);

            this._drawTickLine(g);

            this._drawTickLabel(g);

            this._drawDivLabels();

            this._drawMinorTickLine(g);

            this._drawPlotLines(g);
        },

        _drawArrow:function(g){

            if(!this.component.showArrow()){
                return;
            }

            var plotBounds = this.component.getPlotBounds();
            var cfg = this.component.componentOption;
            var lineWidth = cfg.lineWidth;
            var lineColor = cfg.lineColor;
            var pathDet = BaseUtils.lineSubPixelOpt(0, lineWidth);
            var axisOrigin = this.component._getAxisOriginPoint();

            this._axisG.select('g.arrow').remove();

            var arrowG = this._axisG.append('g')
                .attr('class', 'arrow')
                .attr('transform', BaseUtils.makeTranslate(axisOrigin));
            arrowG.append('line');
            arrowG.append('path');

            if(this.component.isHorizontal()){

                arrowG
                    .select('line')
                    .attr('x1', plotBounds.width)
                    .attr('y1', pathDet)
                    .attr('x2', plotBounds.width + 6)
                    .attr('y2', pathDet)
                    .style({
                        'stroke':lineColor,
                        'stroke-width':lineWidth
                    });

                arrowG
                    .select('path')
                    .attr("d", "M2,2 L10,6 L2,10 L6,6 L2,2")
                    .attr('transform', 'translate(' + plotBounds.width + ',' + '-6' + ')')
                    .style('fill', lineColor);

            }else{

                arrowG
                    .select('line')
                    .attr('x1', pathDet)
                    .attr('y1', -6)
                    .attr('x2', pathDet)
                    .attr('y2', 0)
                    .style({
                        'stroke':lineColor,
                        'stroke-width':lineWidth
                    });

                arrowG
                    .select('path')
                    .attr("d", "M2,-2 L6,-10 L10,-2 L6,-6 L2,-2")
                    .attr('transform', 'translate(-6,0)')
                    .style('fill', lineColor);

            }
        },

        _drawAxisTitle:function(titleBounds){
            this.component.isHorizontal() ? this._drawHorizontalTitle(titleBounds)
                : this._drawVerticalTitle(titleBounds);
        },

        _drawHorizontalTitle:function(titleBounds){
            var cfg = this.component.componentOption;

            if(cfg.title){

                var title = cfg.title;

                if(title.useHtml){
                    this._drawHorizontalAxisTitleWithHtml(title, titleBounds);
                }else{
                    var rotation = title.rotation || 0;

                    var textDim = BaseUtils.getTextDimension(title.text, title.style, title.useHtml);

                    var x, textAnchor, rx;
                    var align = title.align || 'left';
                    switch(align){
                        case 'left':
                            x = 0;
                            rx = x + textDim.width/2;
                            textAnchor = 'start';
                            break;
                        case 'center':
                            x = titleBounds.width/2;
                            rx = x;
                            textAnchor = 'middle';
                            break;
                        case 'right':
                            x = titleBounds.width;
                            rx = x - textDim.width/2;
                            textAnchor = 'end';
                            break;
                    }

                    var gap = this.component.getTitleLabelGap();
                    var ry = titleBounds.height/2;
                    var y = textDim.height * 0.85 + (this.component.getPosition() == Constants.BOTTOM ? gap : -gap);

                    this._axisTitleG.select('text').remove();

                    this._axisTitleG
                        .append('text')
                        .attr('x', x)
                        .attr('y', y)
                        .text(title.text)
                        .style('text-anchor', textAnchor)
                        .attr('transform', 'rotate(' + rotation + ' ' + rx + ',' + ry + ')')
                        .call(BaseUtils.setTextStyle, title.style);
                }
            }
        },

        _drawVerticalTitle:function(titleBounds){

            var cfg = this.component.componentOption;

            if(cfg.title) {
                var title = cfg.title;
                if(title.useHtml){
                    this._drawVerticalAxisTitleWithHtml(title, titleBounds);
                }else{
                    var rotation = title.rotation || 0;

                    var textDim = BaseUtils.getTextDimension(title.text, title.style, title.useHtml);
                    var rotatedDim = BaseUtils.getTextDimensionWithRotation(title.text, title.style, title.useHtml, rotation);

                    var x = titleBounds.width / 2;
                    var rx = x;

                    var align = title.align || 'top';
                    var y, ry;
                    switch(align){
                        case 'top':
                            y = textDim.height + rotatedDim.height/2;
                            break;
                        case 'center':
                            y = textDim.height + (titleBounds.height - textDim.height)/2;
                            break;
                        case 'bottom':
                            y = titleBounds.height - rotatedDim.height/2;
                            break;
                    }

                    ry = y;

                    this._axisTitleG.select('text').remove();

                    this._axisTitleG
                        .append('text')
                        .attr('x', x)
                        .attr('y', y)
                        .text(title.text)
                        .style('text-anchor', 'middle')
                        .attr('transform', 'rotate(' + rotation + ' ' + rx + ',' + ry + ')')
                        .call(BaseUtils.setTextStyle, title.style);
                }
            }
        },

        remove:function(){
            this.removeDivLabels();
            this._axisG.remove();
            this._axisTitleG.remove();
        }
    });

    return BaseAxisSvgRender;
});
/**
 * Created by eason on 15/9/25.
 */

define('render/CategoryAxisSvgRender',['require','./BaseAxisSvgRender','../Constants','./RenderLibrary'],function(require){

    var BaseAxisRender = require('./BaseAxisSvgRender');
    
    var Constants = require('../Constants');

    var CategoryAxisSvgRender = BaseAxisRender.extend({});

    require('./RenderLibrary').register(Constants.CATEGORY_AXIS_SVG, CategoryAxisSvgRender);
});
/**
 * Created by eason on 15/9/25.
 */

define('render/ValueAxisSvgRender',['require','./BaseAxisSvgRender','../Constants','./RenderLibrary'],function(require){

    var BaseAxisRender = require('./BaseAxisSvgRender');
    var Constants = require('../Constants');

    var ValueAxisSvgRender = BaseAxisRender.extend({});
    
    require('./RenderLibrary').register(Constants.VALUE_AXIS_SVG, ValueAxisSvgRender);
});
/**
 * Created by Jeffrey on 16/4/22.
 */

define('render/RadiusAxisSvgRender',['require','./BaseRender','../utils/BaseUtils','../utils/BezierEasing','../Constants','./RenderLibrary'],function(require){

    var BaseRender = require('./BaseRender');
    var BaseUtils = require('../utils/BaseUtils');
    var BezierEasing = require('../utils/BezierEasing');
    var Constants = require('../Constants');


    var TIME = 400;
    var EASE = BezierEasing.css.swing;

    var MONITOR_EASE = 'linear';
    var MONITOR_TIME = 500;
    var ANIMATION_TIME = 500;

    var TICK_TEXT = 'axis-tick-text';
    var TICK_LINE = 'axis-tick-line';
    var MINOR_TICK_LINE = 'axis-minor-tick-line';
    var RADIUS_AXIS_GRID_LINE = 'radius-axis-grid-line';
    var PLOT_BANDS = 'plot-bands';
    var PLOT_LINES = 'plot-lines';
    var AXIS_LINE = 'axis-line';
    var CATEGORY_LINE = 'category-axis-line';
    var VALUE_LINE = 'value-axis-line';
    var VALUE_TICK_GAP = 2;
    var VALUE_TEXT = 'value-axis-tick-text';


    var RadiusAxisSvgRender = BaseRender.extend({
        render:function(){

            var svgRoot = this.component.getVanchartRender().getRenderRoot().select('g.' + Constants.AXIS_GROUP);

            var clipID = 'polarClip' + this.component.vanchart.getIDPrefix();

            if (this._axisG) {
                this._axisG.transition().ease('linear').duration(TIME).call(this._drawAxis.bind(this));
            } else{
                this._axisG = svgRoot.append('g')
                    .attr('clip-path', function(){
                        return "url(#"  + clipID +")";
                    });
                this._axisG
                    .append('defs')
                    .append('clipPath')
                    .attr('id', clipID);

                this._axisG.call(this._drawAxis.bind(this));
            }

            var radiusAxis = this.component;
            var clipPath = this._axisG.select('#' + clipID);
            clipPath.select('path').remove();
            clipPath.append('path').attr('d', function () {
                return radiusAxis._getRadiusGridPath(radiusAxis.scale.domain()[1]);
            });

            this._axisG.attr('transform', BaseUtils.makeTranslate(this.component.polar.center));

        },

        _drawAxis: function (g) {

            // in angleAxis grid lines
            // this._drawAxisLine(g);

            this._drawGridLine(g);

            this._drawPlotBands(g);

            this._drawPlotLines(g);

            this._drawTickLabel(g);
        },

        _drawAxisLine: function (g) {
            var cfg = this.component.componentOption;
            var lineWidth = cfg.lineWidth;
            var lineColor = cfg.lineColor;

            var axisLineData = this.component.getPolarInitPoint();

            g.each(function(){

                var axisLine = d3.select(this)
                    .selectAll('line.' + VALUE_LINE)
                    .data([axisLineData]);

                if(lineWidth){
                    axisLine.exit().remove();
                    axisLine.enter().append('line').attr('class', VALUE_LINE);

                    d3.transition(axisLine)
                        .attr('x2', function(d){
                            return d[0];
                        })
                        .attr('y2', function(d){
                            return d[1];
                        })
                        .style({
                            'stroke':lineColor,
                            'stroke-width':lineWidth
                        });
                }else{
                    axisLine.remove();
                }

            });

        },

        _drawGridLine: function (g) {

            var radiusAxis = this.component;
            var lastScale = radiusAxis.lastScale || radiusAxis.valueScale;
            var cfg = radiusAxis.componentOption;
            var ticks = radiusAxis.getTickData();
            var gridLineColor = cfg.gridLineColor;
            var gridLineWidth = cfg.gridLineWidth;

            g.each(function(){

                // prepare ticks data
                var gridLines = d3.select(this)
                    .selectAll('path.' + RADIUS_AXIS_GRID_LINE)
                    .data(ticks, function(d){return d.tickValue;});

                if (!gridLineWidth) {

                    gridLines.remove();

                } else {
                    // enter
                    gridLines.enter()
                        .append('path')
                        .attr('class', RADIUS_AXIS_GRID_LINE)
                        .attr('d', function(d) {
                            this._currentPos_ = radiusAxis._getRadiusGridData(d.tickValue, false, lastScale);
                            return radiusAxis._getRadiusGridPathByData(this._currentPos_);
                        })
                        .style({
                            fill:'none',
                            'stroke':gridLineColor,
                            'stroke-width':gridLineWidth,
                            'opacity': 1
                        });

                    // transition
                    var transition = d3.transition(gridLines)
                        .style('opacity', 1);

                    // add attrTween fun
                    if (!transition.attrTween) {
                        transition
                            .attr('d', function(d) {
                                this._currentPos_ = radiusAxis._getRadiusGridData(d.tickValue);
                                return radiusAxis._getRadiusGridPathByData(this._currentPos_);
                            });
                    } else {
                        transition
                            .attrTween('d', function(d) {
                                var prePos = this._currentPos_;
                                this._currentPos_ = radiusAxis._getRadiusGridData(d.tickValue);
                                var interpolate = d3.interpolate(prePos, this._currentPos_);

                                return function (t) {
                                    return radiusAxis._getRadiusGridPathByData(interpolate(t));
                                };
                            })
                    }

                    // exit
                    var gridExit = d3.transition(gridLines.exit())
                        .style('opacity', 0)
                        .remove();

                    if (gridExit.attrTween) {
                        gridExit
                            .attrTween('d', function(d) {
                                var prePos = this._currentPos_;
                                this._currentPos_ = radiusAxis._getRadiusGridData(d.tickValue);
                                var interpolate = d3.interpolate(prePos, this._currentPos_);

                                return function(t) {
                                    return radiusAxis._getRadiusGridPathByData(interpolate(t));
                                };
                            })
                    }
                }
            });

        },

        _drawPlotBands: function (g) {

            var plotBands = this.component.getRadiusPlotBands();

            g.each(function(){

                var bands = d3.select(this)
                    .selectAll('path.' + PLOT_BANDS).data(plotBands);

                bands.exit().remove();

                bands.enter().append('path').attr('class', PLOT_BANDS);

                d3.transition(bands)
                    .attr('d', function(d){
                        return d.path;
                    })
                    .style('fill', function(d){
                        return d.color;
                    })

            });

        },

        _drawPlotLines:function(g){

            var plotLines = this.component.getPlotLines();
            var self = this;

            g.each(function(){

                var lines = d3.select(this)
                    .selectAll('.' + PLOT_LINES).data(plotLines);

                lines.exit().remove();

                var lineEnter = lines.enter().append('g').attr('class', PLOT_LINES);
                lineEnter.append('path');
                lineEnter.append('text');

                d3.transition(lines.select('path'))
                    .attr('d', function(d){
                        return  self.component._getRadiusGridPath(d.value);
                    })
                    .style('fill', 'none')
                    .style('stroke', function(d){
                        return d.color;
                    })
                    .style('stroke-width', function(d){
                        return d.width;
                    })
                    .style('stroke-dasharray', function(d){
                        return d.dataArray;
                    });

                d3.transition(lines.select('text'))
                    .text(function(d){
                        return d.text;
                    })
                    .attr('y', function(d){
                        return d.baseY;
                    })
                    .attr('text-anchor', function(d){
                        return d.textAnchor;
                    })
                    .each(function(d){
                        d3.select(this)
                            .call(BaseUtils.setTextStyle, d.style);
                    });
            });

        },

        _drawTickLabel:function(g){

            var radiusAxis = this.component;
            var scale = radiusAxis.scale;
            var lastScale = radiusAxis.lastScale || radiusAxis.scale;
            var cfg = radiusAxis.componentOption;
            var ticks = radiusAxis.getTickData();

            //最大值标签不显示
            ticks.length = Math.max(ticks.length - 1, 0);

            var labelStyle = cfg.labelStyle;
            var labelRotation = cfg.labelRotation;
            var useHtml = cfg.useHtml;

            if(useHtml && !labelRotation){

                var center = radiusAxis.polar.center;

                for(var i = 0, len = ticks.length; i < len; i++){

                    var tick = ticks[i];

                    var x = -tick.tickDim.width - VALUE_TICK_GAP + center[0];
                    var y = -scale(tick.tickValue)-tick.tickDim.height + center[1];

                    this.labelDivManager.addLabel(tick.tickContent, {x:x, y:y}, labelStyle);
                }

            }else{

                g.each(function(){

                    var valueText = d3.select(this)
                        .selectAll('text.' + VALUE_TEXT)
                        .data(ticks, function(d){return d.tickValue;});

                    if(cfg.showLabel){
                        valueText.exit().remove();
                        valueText.enter().append('text').attr('class', VALUE_TEXT)
                            .attr('x', -VALUE_TICK_GAP)
                            .attr('y', function(d){
                                return -lastScale(d.tickValue);
                            })
                            .attr('transform', function(d){
                                return 'rotate(' + labelRotation + ' 0 0)';
                            });

                        valueText.call(BaseUtils.setTextStyle, labelStyle);

                        d3.transition(valueText)
                            .text(function(d){return d.tickContent;})
                            .attr('y', function(d){
                                return -scale(d.tickValue);
                            })
                            .style('text-anchor', 'end')
                    }else{
                        valueText.remove();
                    }

                });
            }
        },

        remove:function(){
            this.removeDivLabels();
            this._axisG.remove();
        }

    });
    
    require('./RenderLibrary').register(Constants.RADIUS_AXIS_SVG, RadiusAxisSvgRender);

});
/**
 * Created by Jeffrey on 16/4/22.
 */

define('render/AngleAxisSvgRender',['require','./BaseRender','../utils/BaseUtils','../utils/BezierEasing','../Constants','./RenderLibrary'],function(require){

    var BaseRender = require('./BaseRender');
    var BaseUtils = require('../utils/BaseUtils');
    var BezierEasing = require('../utils/BezierEasing');
    var Constants = require('../Constants');

    var TIME = 400;

    var ANGLE_AXIS_LINE = 'angle-axis-line';
    var ANGLE_AXIS_GRID_LINE = 'angle-axis-grid-line';
    var CATEGORY_TEXT = 'category-axis-tick-text';
    var HIGHLIGHT_BAND = 'highlight-band';

    var AngleAxisSvgRender = BaseRender.extend({

        render:function(){

            var svgRoot = this.component.getVanchartRender().getRenderRoot().select('g.' + Constants.AXIS_GROUP);

            if (this._axisG) {
                this._axisG.transition().ease('linear').duration(TIME).call(this._drawAxis.bind(this));
            } else{
                this._axisG = svgRoot.append('g');
                this._axisG.call(this._drawAxis.bind(this));
            }

            this._axisG.attr('transform', BaseUtils.makeTranslate(this.component.polar.center));
        },

        _drawAxis: function (g) {

            this._drawAxisLine(g);

            this._drawGridLine(g);

            this._drawTickLabel(g);
        },

        drawHighlightBand: function (pos) {

            var axis = this.component;
            if (!axis._getBandByPosition) {
                return;
            }

            var drawBand = axis._getBandByPosition(pos);
            var highlightType = axis.getHighlightType();

            this.removeHighlightBand();

            switch (highlightType) {
                case 'band':
                    this._axisG
                        .append('path')
                        .attr('class', HIGHLIGHT_BAND)
                        .attr('d', drawBand.d)
                        .style('fill', 'rgba(98,179,240,0.2)');

                    break;
                case 'line':
                default:
                    
                    this._axisG
                        .append('line')
                        .attr('class', HIGHLIGHT_BAND)
                        .attr('x2', drawBand.x)
                        .attr('y2', drawBand.y)
                        .attr('stroke', 'rgb(140,140,140)')
                        .attr('stroke-width', '1');
            }

        },

        removeHighlightBand: function () {
            this._axisG.select('.' + HIGHLIGHT_BAND).remove();
        },

        _drawAxisLine:function(g){
            var radiusAxis = this.component.polar.radiusAxis;

            var angleAxis = this.component;
            var lineWidth = angleAxis.componentOption.lineWidth;
            var lineColor = angleAxis.componentOption.lineColor;
            var maxValue = radiusAxis.scale.domain()[1];

            g.each(function(){

                var angleAxisLine = d3.select(this)
                    .selectAll('path.' + ANGLE_AXIS_LINE)
                    .data([0]);

                if(lineWidth){

                    angleAxisLine.enter().append('path').attr('class', ANGLE_AXIS_LINE);

                    d3.transition(angleAxisLine)
                        .attr('d', function(){
                            return radiusAxis._getRadiusGridPath(maxValue);
                        })
                        .style({
                            fill:'none',
                            'stroke':lineColor,
                            'stroke-width':lineWidth
                        });

                }else{
                    angleAxisLine.remove();
                }

            });

        },

        _drawGridLine:function(g){

            // for multiple radiusAxes feature (later)
            // angleAxis should not have grid line
            var cfg = this.component.polar.radiusAxis.componentOption;
            var lineWidth = cfg.lineWidth;
            var lineColor = cfg.lineColor;

            var axisLineData = this.component.getAngleGridLineData();

            g.each(function(){

                var axisLine = d3.select(this)
                    .selectAll('line.' + ANGLE_AXIS_GRID_LINE)
                    .data(axisLineData);

                if(lineWidth){
                    axisLine.exit().remove();
                    axisLine.enter()
                        .append('line')
                        .attr('class', ANGLE_AXIS_GRID_LINE);

                    d3.transition(axisLine)
                        .attr('x2', function(d){
                            return d[0];
                        })
                        .attr('y2', function(d){
                            return d[1];
                        })
                        .style({
                            'stroke':lineColor,
                            'stroke-width':lineWidth
                        });
                }else{
                    axisLine.remove();
                }

            });

        },

        _drawTickLabel:function(g){
            var angleAxis = this.component;
            var cfg = angleAxis.componentOption;

            var labelStyle = cfg.labelStyle;
            var labelRotation = cfg.labelRotation || 0;
            var useHtml = cfg.useHtml;

            var ticks = angleAxis.tickData;
            var lineHeight = BaseUtils.getTextHeight(labelStyle);

            if(useHtml && !labelRotation){

                var center = angleAxis.polar.center;

                for(var i = 0, len = ticks.length; i < len; i++){

                    var tick = ticks[i];

                    var x = tick.tickPos.x + center[0];
                    var y = tick.tickPos.y + center[1];

                    this.labelDivManager.addLabel(tick.tickContent, {x:x, y:y}, labelStyle);
                }

            }else{
                g.each(function(){
                    d3.select(this).selectAll('text.' + CATEGORY_TEXT).remove();

                    var cateText = d3.select(this).selectAll('text.' + CATEGORY_TEXT).data(ticks);

                    if(cfg.showLabel){

                        cateText.enter().append('text')
                            .attr('class', CATEGORY_TEXT)
                            .call(BaseUtils.setTextStyle, labelStyle);

                        cateText.each(function(d){

                            var tickContent = d.tickContent;

                            if(BaseUtils.isArray(tickContent)){

                                var dx = d.tickPos.x < 0 ? d.tickDim.width : 0;
                                var textAnchor = d.tickPos.x < 0 ? 'end' : 'start';

                                for(var i = 0, len = tickContent.length; i < len; i++){

                                    if(i == 0){

                                        d3.select(this)
                                            .append('tspan')
                                            .text(tickContent[i])
                                            .attr('x', dx + d.tickPos.x)
                                            .attr('y', 0.85 * lineHeight + d.tickPos.y)
                                            .attr('text-anchor', textAnchor);

                                    }else{

                                        d3.select(this)
                                            .append('tspan')
                                            .text(tickContent[i])
                                            .attr('x', dx + d.tickPos.x)
                                            .attr('y', 0.85 * lineHeight + i * (1.3 * lineHeight) + d.tickPos.y)
                                            .attr('text-anchor', textAnchor);

                                    }
                                }

                                if(labelRotation){

                                    var rx = d.tickPos.x + d.tickDim.width/2;
                                    var ry = d.tickPos.y + d.tickDim.height/2;

                                    d3.select(this)
                                        .attr('transform', 'rotate(' + labelRotation + ' ' + rx + ',' + ry + ')');
                                }

                            }else{

                                var rx = d.tickPos.x + d.tickDim.width/2;

                                var ry = d.tickPos.y + d.tickDim.height/2;

                                var normalDim = BaseUtils.getTextDimension(tickContent, labelStyle, useHtml);

                                d3.select(this)
                                    .text(tickContent)
                                    .attr('x', rx - normalDim.width/2)
                                    .attr('y', ry - normalDim.height/2)
                                    .attr('text-anchor', 'start')
                                    .attr('dy', '.85em')
                                    .attr('transform', 'rotate(' + labelRotation + ' ' + rx + ',' + ry + ')');

                            }

                        });
                    }
                });
            }
        },

        remove:function(){
            this.removeDivLabels();
            this._axisG.remove();
        }
    });

    require('./RenderLibrary').register(Constants.ANGLE_AXIS_SVG, AngleAxisSvgRender);
});
/**
 * Created by eason on 15/11/2.
 */
define('render/DateAxisSvgRender',['require','./BaseAxisSvgRender','../Constants','./RenderLibrary'],function(require){

    var BaseAxisRender = require('./BaseAxisSvgRender');
    var Constants = require('../Constants');

    var DateAxisSvgRender = BaseAxisRender.extend({});

    require('./RenderLibrary').register(Constants.DATE_AXIS_SVG, DateAxisSvgRender);
});
/**
 * Created by eason on 15/8/14.
 */
define('render/LegendSvgRender',['require','./BaseRender','../utils/BaseUtils','../utils/BezierEasing','../Constants','./LegendIconFactory','./RenderLibrary'],function(require){

    var BaseRender = require('./BaseRender');
    var BaseUtils = require('../utils/BaseUtils');
    var BezierEasing = require('../utils/BezierEasing');
    var Constants = require('../Constants');
    var LegendIconFactory = require('./LegendIconFactory');

    var LEGEND_ITEM = 'legend-item';
    var LEGEND_MARKER = 'legend-marker';
    var LEGEND_LABEL = 'legend-label';

    var LEGEND_GRADUAL = 'legend-gradual-background';
    var LEGEND_PAGES = 'legend-pages';

    var ENABLED_COLOR = 'rgb(67,67,72)';
    var DISABLED_COLOR = 'rgb(204,204,204)';

    var LegendSvgRender = BaseRender.extend({
        render:function(){

            var svgRoot = this.component.getVanchartRender().getRenderRoot();
            var bounds = this.component.bounds;

            this._legendG = this._legendG ||  svgRoot.append('g');

            this._legendG.attr('transform', 'translate('+ bounds.x +','+ bounds.y +')');

            this._updateBackground();

            this.component.isHorizontal() ? this._updateHorizontal() : this._updateVertical();
        },

        _updateBackground:function(){

            var option = this.component.componentOption;
            var bounds = this.component.bounds;
            var IDPrefix = this.component.vanchart.getIDPrefix();
            var gradualID = LEGEND_GRADUAL + IDPrefix;

            this._renderSvgBackground(this._legendG, option, bounds, gradualID);
        },

        _renderVerticalWithPages:function(verticalG){

            var width = this.component.bounds.width;
            var height = this.component.bounds.height;

            height -= this.component.getButtonHeight();

            var clipID = this.component.vanchart.getIDPrefix() + LEGEND_PAGES;

            var defs = verticalG.selectAll('defs').data([0]);
            defs.enter().append('defs');
            var clip = defs.selectAll('#' + clipID).data([0]);
            clip.enter().append('clipPath').attr('id', clipID).append('rect');
            clip.select('rect').attr('width', width).attr('height', height);

            var clippedG = verticalG.selectAll('g.clip').data([0]);
            clippedG.enter().append('g').attr('class', 'clip');
            clippedG = verticalG.select('g.clip').attr('clip-path', "url(#" + clipID +")");

            var pageG = clippedG.selectAll('g.pageG').data([0]);
            pageG.enter().append('g').attr('class', 'pageG');
            pageG = clippedG.select('g.pageG');

            this._renderVerticalWithoutPages(pageG);

            var buttonWidth = 40;

            var buttonG = verticalG.selectAll('g.button').data([0]);
            buttonG.enter().append('g').attr('class', 'button');
            buttonG = verticalG.select('g.button').attr('transform', 'translate(' + 0 + ',' + height + ')');

            var leftButtonTopX = (width - buttonWidth) / 2;
            var rightButtonTopX = (width + buttonWidth) / 2;

            var translateDet = height - this.component.getPadding();

            var totalHeight = this.component.getPreHeight();

            this.pageIndex = BaseUtils.pick(this.pageIndex, 0);
            var pageCount = Math.ceil((totalHeight - height) / translateDet) + 1;

            var labelX = width/2;

            var text = buttonG.selectAll('text').data([0]);
            text.enter().append('text');

            text
                .attr('x', labelX)
                .attr('y', 0)
                .attr('dy', '.71em')
                .attr("text-anchor", "middle")
                .text((this.pageIndex + 1) + '/' + pageCount)
                .style('font-Family', 'Verdana')
                .style('font-Size', '14px');

            var self = this;
            var leftButton = buttonG.selectAll('path.left').data([0]);

            leftButton.enter()
                .append('path').attr('class', 'left')
                .attr('d', this._prePageButtonPath(leftButtonTopX))
                .style('cursor', 'pointer')
                .style('fill', DISABLED_COLOR)
                .on('click', function(){

                    if(self.pageIndex <= 0){
                        return;
                    }

                    var translate = d3.transform(pageG.attr('transform')).translate;

                    var translateX = translate[0];
                    var translateY = self.pageIndex == 1 ? 0 : (translate[1] + translateDet);

                    pageG
                        .transition()
                        .duration(500)
                        .ease(BezierEasing.css.swing)
                        .attr('transform', 'translate(' + translateX + ',' + translateY + ')');

                    self.pageIndex--;
                    var showIndex = self.pageIndex + 1;
                    text.text(showIndex + "/" + pageCount);

                    rightButton.style('fill', self.pageIndex == pageCount - 1 ? DISABLED_COLOR : ENABLED_COLOR);
                    d3.select(this).style('fill', self.pageIndex <= 0 ? DISABLED_COLOR : ENABLED_COLOR);
                });


            var rightButton = buttonG.selectAll('path.right').data([0]);
            rightButton.enter()
                .append('path')
                .attr('class', 'right')
                .attr('d', this._nextPageButtonPath(rightButtonTopX))
                .style('cursor', 'pointer')
                .style('fill', ENABLED_COLOR)
                .on('click', function(){

                    if(self.pageIndex == pageCount - 1){
                        return;
                    }

                    var translate = d3.transform(pageG.attr('transform')).translate;

                    var translateX = translate[0];
                    var translateY = translate[1] - translateDet;

                    pageG
                        .transition()
                        .duration(800)
                        .ease(BezierEasing.css.swing)
                        .attr('transform', 'translate(' + translateX + ',' + translateY + ')');

                    self.pageIndex++;
                    var showIndex = self.pageIndex + 1;
                    text.text(showIndex + "/" + pageCount);

                    d3.select(this).style('fill', self.pageIndex == pageCount - 1 ? DISABLED_COLOR : ENABLED_COLOR);
                    leftButton.style('fill', self.pageIndex <= 0 ? DISABLED_COLOR : ENABLED_COLOR)
                });
        },

        _prePageButtonPath:function(topX){
            var edge = 12;
            var topY = 0;

            var leftBottomX = topX - edge / 2;
            var leftBottomY = (edge / 2) * Math.sqrt(3);

            var rightBottomX = topX + edge / 2;
            var rightBottomY = leftBottomY;

            return 'M' + topX + ',' + topY + 'L' + leftBottomX + ',' + leftBottomY + 'L' + rightBottomX + ',' + rightBottomY + 'Z';
        },

        _nextPageButtonPath:function(topX){
            var edge = 12;
            var topY = 0;

            var topLeftX = topX - edge/2;
            var topLeftY = topY;

            var topRightX = topX + edge/2;
            var topRightY = topY;

            var bottomX = topX;
            var bottomY = (edge / 2) * Math.sqrt(3);

            return 'M' + topLeftX + ',' + topLeftY + 'L' + topRightX + ',' + topRightY + 'L' + bottomX + ',' + bottomY + 'Z';
        },

        _renderVerticalWithoutPages:function(gElement){
            var items = this.component.getLegendItems();
            var self = this;
            var legend = this.component;
            var cfg = this.component.componentOption;

            var PADDING = this.component.getPadding() + this.component.verticalAlign;
            var GAP = this.component.getGap();

            var updateS = gElement.selectAll('g.' + LEGEND_ITEM).data(items);

            updateS.exit().remove();

            updateS
                .enter()
                .append('g')
                .attr('class', LEGEND_ITEM)
                .each(function(){

                    var rowSelection = d3.select(this);

                    rowSelection.append('path').attr('class', LEGEND_MARKER);

                    rowSelection.append('text').attr('class', LEGEND_LABEL);

                    rowSelection.call(self._bindMouseEvent.bind(self));
                });

            gElement
                .selectAll('g.' + LEGEND_ITEM)
                .each(function(d, i){

                    var rowSelection = d3.select(this);

                    var iconSize = LegendIconFactory.getLegendIconSize(d.legendIconType);
                    var labelDim = BaseUtils.getTextDimension(d.itemName, cfg.style, true);
                    var detY = Math.max(iconSize.height, labelDim.height)/2;

                    var preHeight = legend.getPreHeight(i);

                    var markerG = rowSelection
                        .select('path.' + LEGEND_MARKER);

                    markerG
                        .attr('transform', 'translate(' + PADDING + ',' + (preHeight + detY - iconSize.height/2) + ')')
                        .attr('d', function(){
                            return LegendIconFactory.getLegendIconPath(d.legendIconType);
                        })
                        .style('fill', function(d){
                            return d.visible ? d.color : d.hiddenColor
                        });

                    if(d.series.type == Constants.BUBBLE_CHART){
                        markerG
                            .style('fill-opacity', 0.7)
                            .style('stroke', function(d){
                                return d.visible ? d.color : d.hiddenColor
                            })
                            .style('stroke-width',1);
                    }

                    rowSelection
                        .select('text.' + LEGEND_LABEL)
                        .text(function(d){return d.itemName})
                        .attr('x', PADDING + iconSize.width + GAP)
                        .attr('y', preHeight + detY)
                        .attr("dy", ".35em")
                        .call(BaseUtils.setTextStyle, cfg.style)
                        .style('fill', function(d){
                            return d.visible ? cfg.style.color : d.hiddenColor;
                        });

                })
        },

        _updateVertical:function(){

            var verticalG = this._legendG.selectAll('g.vertical').data([0]);
            verticalG.enter().append('g').attr('class', 'vertical');
            verticalG = this._legendG.select('g.vertical');

            var lastState = BaseUtils.pick(this.hasEnoughSpace, this.component.hasEnoughVerticalSpace());

            var currentState = this.component.hasEnoughVerticalSpace();

            if(currentState != lastState){
                verticalG.remove();
                verticalG = this._legendG.append('g').attr('class', 'vertical');
                this.hasEnoughSpace = currentState;
            }

            this.component.hasEnoughVerticalSpace() ? this._renderVerticalWithoutPages(verticalG) : this._renderVerticalWithPages(verticalG);
        },

        _updateHorizontal:function(){

            var PADDING = this.component.getPadding();
            var HORIZONTAL_GAP = this.component.getHorizontalGap();
            var GAP = this.component.getGap();

            var lineItems = this.component.getHorizontalLineItems();
            var lineHeight = this.component.getLineHeight();
            var lineStartX = [];
            var lineStartY = [];

            var cfg = this.component.componentOption;
            var boundsWidth = this.component.bounds.width;
            var y = PADDING;
            for(var lineIndex = 0, len = lineItems.length; lineIndex < len; lineIndex++){

                var items = lineItems[lineIndex];

                var itemsWidth = this.component.getHorizontalItemsWidth(items);

                var x = Math.round((boundsWidth - itemsWidth) / 2);
                var startX = [x];

                for(var i = 1; i < items.length; i++){
                    var preItem = items[i - 1];
                    var iconSize = LegendIconFactory.getLegendIconSize(preItem.legendIconType);
                    var labelDim = BaseUtils.getTextDimension(preItem.itemName, cfg.style, true);
                    x += iconSize.width + GAP + labelDim.width + HORIZONTAL_GAP;
                    startX.push(x);
                }

                lineStartX.push(startX);
                lineStartY.push(y);

                y += lineHeight[lineIndex] + PADDING
            }

            function indexInLine(d, j){
                var preCount = 0;
                for(var i = 0; i < d.lineIndex; i++){
                    preCount += lineItems[i].length;
                }
                return j - preCount;
            }

            var self = this;
            var items = this.component.getLegendItems();

            var itemS = this._legendG.selectAll('g.' + LEGEND_ITEM).data(items);
            itemS.exit().remove();

            var newItems = itemS.enter();
            newItems
                .append('g')
                .attr('class', LEGEND_ITEM)
                .each(function(){
                    var newItem = d3.select(this);
                    newItem.append('path').attr('class', LEGEND_MARKER);
                    newItem.append('text').attr('class', LEGEND_LABEL);
                    newItem.call(self._bindMouseEvent.bind(self));
                });

            itemS.each(function(d, i){

                var rowSelection = d3.select(this);

                var iconSize = LegendIconFactory.getLegendIconSize(d.legendIconType);
                var labelDim = BaseUtils.getTextDimension(d.itemName, cfg.style, true);

                var detY = Math.max(iconSize.height, labelDim.height)/2;

                i = indexInLine(d, i);
                var x = lineStartX[d.lineIndex][i];
                var y = lineStartY[d.lineIndex];

                var textColor = d.visible ? cfg.style.color : d.hiddenColor;
                var markerColor = d.visible ? d.color : d.hiddenColor;

                var markerG = rowSelection.select('path');

                markerG
                    .attr('transform', 'translate(' + x + ',' + (y + detY - iconSize.height/2) + ')')
                    .attr('d', function(){
                        return LegendIconFactory.getLegendIconPath(d.legendIconType);
                    })
                    .style('fill', markerColor);

                if(d.series.type == Constants.BUBBLE_CHART){
                    markerG
                        .style('fill-opacity', 0.3)
                        .style('stroke', markerColor)
                        .style('stroke-width',1);
                }

                rowSelection.select('text')
                    .text(function(d){return d.itemName})
                    .attr('x', x + iconSize.width + GAP)
                    .attr('y', y + detY)
                    .attr("dy", ".35em")
                    .call(BaseUtils.setTextStyle, cfg.style)
                    .style('fill', textColor);


            });
        },

        _bindMouseEvent:function(rowSelection){

            var vanchart = this.component.vanchart;
            var cfg = this.component.componentOption;

            rowSelection
                .style('cursor', 'pointer')
                .on('mouseenter', function(d){
                    d3.select(this).select('.' + LEGEND_LABEL).style('fill', d.hoverColor);
                })
                .on('mouseleave', function(d){
                    var textColor = d.visible ? cfg.style.color : d.hiddenColor;
                    d3.select(this).select('.' + LEGEND_LABEL).style('fill', textColor);
                })
                .on('click', function(d){
                    var series = d.series;
                    var name = d.itemName;

                    vanchart.series.map(function(sery){

                        if(sery.type == Constants.PIE_CHART){

                            sery.points.map(function(point){
                                if(point.seriesName == name){
                                    point.visible = !point.visible;
                                }
                            });

                            sery.updateVisiblePoints();

                        } else {
                            if (sery.name === name) {
                                sery.visible = !sery.visible;
                            }
                        }
                    });

                    vanchart.currentOption.byClassName = true;
                    vanchart.refreshComponentsAndSeries();
                });
        },

        remove:function(){
            this._legendG && this._legendG.remove();
        }
    });

    require('./RenderLibrary').register(Constants.LEGEND_SVG, LegendSvgRender);
    return LegendSvgRender;
});
/**
 * Created by eason on 15/8/24.
 */


define('render/ToolbarSvgRender',['require','./BaseRender','../utils/BaseUtils','../Constants','./RenderLibrary'],function(require){

    var BaseRender = require('./BaseRender');
    var BaseUtils = require('../utils/BaseUtils');
    var Constants = require('../Constants');

    var ToolbarSvgRender = BaseRender.extend({
        render:function(){
            var cfg = this.component.componentOption;

            if(!cfg.enabled || this._bodyG){
                return;
            }

            var svgRoot = this.component.getVanchartRender().getRenderRoot();

            var pos = this.component.getToolbarPos();

            if(!this._bodyG){
                this._bodyG = svgRoot.append('g')
                    .attr('transform', 'translate('+ pos.x +','+ pos.y +')');
            }

            if(this.component.menuIcon){
                this.component.menuIcon.render(this._bodyG);
            }

            this.component.refreshIcon.render(this._bodyG);

            var toolbarIcons = this.component.getToolbarIcons();

            for(var i = 0, len = toolbarIcons.length; i < len; i++){
                toolbarIcons[i].render(this._bodyG);
            }
        },

        hide:function(){

            var toolbarIcons = this.component.getToolbarIcons();

            var iconSize = toolbarIcons.length;

            var delay = [];

            for(var i = 0; i < iconSize; i++){
                delay.push(100 + 80 * i);
            }

            for(var i = 0; i < iconSize; i++){
                var moveIndex = iconSize - i;
                toolbarIcons[i].hideIcon(moveIndex, delay[i]);
            }

            var refreshIcon = this.component.getRefreshIcon();

            var left = 4 * (iconSize + 1) ;
            var right = 4 * (iconSize + 1) + 33 * iconSize;

            if(refreshIcon.visible){
                refreshIcon.refreshMove(left, right);
            }

        },

        show:function(){
            var delay = [0];

            var toolbarIcons = this.component.getToolbarIcons();

            var iconSize = toolbarIcons.length;

            for(var i = 0; i < iconSize - 1; i++){
                delay.push(100 + 80 * i);
            }

            for(var i = 0; i < iconSize; i++){
                var moveIndex = iconSize - i;
                toolbarIcons[i].showIcon(moveIndex, delay[i]);
            }

            var refreshIcon = this.component.getRefreshIcon();

            var left = 4 * (iconSize + 1) + 33 * iconSize;
            var right = 4 * (iconSize + 1);

            if(refreshIcon.visible){
                refreshIcon.refreshMove(left, right);
            }

        },

        toFront: function () {
            this._bodyG && BaseUtils.toFrontOfAll(this._bodyG.node());
        }
    });

    require('./RenderLibrary').register(Constants.TOOLBAR_SVG, ToolbarSvgRender);
    
    return ToolbarSvgRender;
});
/**
 * Created by eason on 15/10/12.
 */

define('render/DataSheetSvgRender',['require','./BaseRender','../utils/BaseUtils','../Constants','./LegendIconFactory','./RenderLibrary'],function(require){

    var BaseRender = require('./BaseRender');
    var BaseUtils = require('../utils/BaseUtils');
    var Constants = require('../Constants');
    var LegendIconFactory = require('./LegendIconFactory');

    var DataSheetSvgRender = BaseRender.extend({

        render:function(){

            var svgRoot = this.component.getVanchartRender().getRenderRoot();

            if(this._tableG){
                this._tableG.remove();
            }

            var axis = this.component.vanchart.xAxis();
            var categories = axis.getCategories();
            var unitLength = this.component.getPlotBounds().width / categories.length;

            var seriesWidth = this.component.getMaxSeriesWidth();
            var categoryHeight = this.component.getCategoryHeight();

            var transX = this.component.bounds.x;
            var transY = this.component.bounds.y;

            this._tableG = svgRoot
                .append('g')
                .attr('transform', 'translate(' + transX + ',' + transY + ')');

            this._drawLines(seriesWidth, categoryHeight, unitLength);

            this._drawCategory(seriesWidth, categoryHeight, unitLength);

            this._drawSeries(seriesWidth, categoryHeight);

            this._drawValues(seriesWidth, categoryHeight, unitLength);
        },

        _drawLines:function(seriesWidth, categoryHeight, unitLength){

            var lineG = this._tableG.append('g');
            var cfg = this.component.componentOption;

            var endX = this.component.bounds.width;
            var endY = this.component.bounds.height;

            lineG.append('path')
                .attr('d', 'M' + seriesWidth + ',0' + 'L' + endX + ',0' + 'L' + endX + ' ' + endY + 'L0' + ',' + endY + 'L0' + ',' + categoryHeight)
                .style({
                    fill:'none',
                    stroke:cfg.borderColor,
                    'stroke-width':cfg.borderWidth
                });

            var cateCount = this.component.categoryNames.length;

            var startX = seriesWidth;

            for(var i = 0; i < cateCount; i++){
                lineG.append('line')
                    .attr('x1', startX)
                    .attr('y1', 0)
                    .attr('x2', startX)
                    .attr('y2', endY);

                startX += unitLength;
            }

            var seriesCount = this.component.seriesNames.length;
            var height = categoryHeight;

            for(var i = 0; i < seriesCount; i++){

                lineG.append('line')
                    .attr('x1', 0)
                    .attr('y1', height)
                    .attr('x2', endX)
                    .attr('y2', height);

                height += this.component.getSeriesHeight(i);
            }

            lineG.selectAll('line')
                .style({
                    fill:'none',
                    stroke:cfg.borderColor,
                    'stroke-width':cfg.borderWidth
                });

        },

        _drawValues:function(seriesWidth, categoryHeight, unitLength){

            var valueG = this._tableG.append('g');

            var values = this.component.values;

            var valueStyle = this.component._valueStyle();
            var valueLineHeight = BaseUtils.getTextHeight(valueStyle);
            var textPadding = this.component.getTextPadding();
            var startX = seriesWidth;
            var startY = categoryHeight;

            for(var lineIndex = 0; lineIndex < values.length; lineIndex++){
                var singleLine = values[lineIndex];

                var valueHeight = this.component.getSeriesHeight(lineIndex);

                for(var valueIndex = 0; valueIndex < singleLine.length; valueIndex++){

                    var singleName = singleLine[valueIndex];

                    if (!singleName) {
                        continue;
                    }

                    var firstY = startY + this._getStartY(singleName, valueStyle, valueHeight) + valueLineHeight * 0.85;

                    for(var i = 0; i < singleName.length; i++){

                        valueG
                            .append('text')
                            .text(singleName[i])
                            .attr('x', startX + unitLength/2 + unitLength * valueIndex)
                            .attr('y', firstY + (valueLineHeight + textPadding) * i)

                    }
                }

                startY += valueHeight;
            }

            valueG.selectAll('text')
                .style({
                    'text-anchor':'middle'
                })
                .call(BaseUtils.setTextStyle, valueStyle);

        },

        _drawCategory:function(seriesWidth, categoryHeight, unitLength){

            var categoryG = this._tableG.append('g');

            var categoryNames = this.component.categoryNames;

            var startX = seriesWidth;

            var categoryStyle = this.component._categoryStyle();

            var categoryLineHeight = BaseUtils.getTextHeight(categoryStyle);
            var textPadding = this.component.getTextPadding();

            for(var index = 0, cCount = categoryNames.length; index < cCount; index++){

                var singleName = categoryNames[index];

                var startY = this._getStartY(singleName, categoryStyle, categoryHeight) + categoryLineHeight * 0.85;

                for(var i = 0; i < singleName.length; i++){

                    categoryG
                        .append('text')
                        .text(singleName[i])
                        .attr('x', startX + unitLength/2 + unitLength * index)
                        .attr('y', startY + (categoryLineHeight + textPadding) * i)

                }

            }

            categoryG.selectAll('text')
                .style({
                    'text-anchor':'middle'
                })
                .call(BaseUtils.setTextStyle, categoryStyle);

        },

        _drawSeries:function(seriesWidth, categoryHeight){

            var seriesG = this._tableG.append('g');

            var seriesNames = this.component.seriesNames;

            var startX = 16 + (seriesWidth - 16) / 2;
            var startY = categoryHeight;

            var seriesStyle = this.component._seriesStyle();
            var seriesLineHeight = BaseUtils.getTextHeight(seriesStyle);
            var textPadding = this.component.getTextPadding();

            for(var index = 0, sCount = seriesNames.length; index < sCount; index++){

                var singleName = seriesNames[index];
                var seriesHeight = this.component.getSeriesHeight(index);

                var firstY = startY + this._getStartY(singleName, seriesStyle, seriesHeight) + seriesLineHeight * 0.85;

                for(var i = 0; i < singleName.length; i++){

                    seriesG
                        .append('text')
                        .text(singleName[i])
                        .attr('x', startX)
                        .attr('y', firstY + (seriesLineHeight + textPadding) * i)

                }

                //画前面的色块
                var iconType = this.component.getLegendIconTypeWithSeriesIndex(index);
                var iconHeight = LegendIconFactory.getLegendIconSize(iconType).height;
                seriesG
                    .append('path')
                    .attr('d', LegendIconFactory.getLegendIconPath(iconType))
                    .attr('transform', 'translate(2,' + ((seriesHeight - iconHeight)/2 + startY) + ')')
                    .style('fill', this.component._getDefaultSeriesColor(singleName[0]));

                startY += seriesHeight;
            }

            seriesG.selectAll('text')
                .style({
                    'text-anchor':'middle'
                })
                .call(BaseUtils.setTextStyle, seriesStyle);

        },

        _getStartY:function(textArray, style, boxHeight){

            var textPadding = this.component.getTextPadding();

            var textCount = textArray.length;

            var textHeight = BaseUtils.getTextHeight(style) * textCount + (textCount - 1) * textPadding;

            return (boxHeight - textHeight) / 2;
        },

        remove:function(){
            this._tableG && this._tableG.remove();
        }

    });
    
    require('./RenderLibrary').register(Constants.DATA_SHEET_SVG, DataSheetSvgRender);

});
/**
 * Created by Mitisky on 16/3/21.
 */
define('render/RangeLegendSvgRender',['require','./BaseRender','../utils/BaseUtils','../Constants','./RenderLibrary'],function(require){
    var BaseRender = require('./BaseRender');
    var BaseUtils = require('../utils/BaseUtils');
    var Constants = require('../Constants');

    var PADDING = 10;

    var WIDTH = 15;
    var HEIGHT = 100;
    var BAR_WIDTH = 15;
    var BAR_HEIGHT = 10;
    var BAR_TEXT_GAP = 5;
    var ITEM_WIDTH = 25;
    var ITEM_GAP = 2;

    var CLIP_ID = 'linear-color-clip-path-id';
    var MIN_BAR_CLASS_NAME = 'min-bar-class-name';
    var MAX_BAR_CLASS_NAME = 'max-bar-class-name';

    var RANGE_ITEM = 'range-item';

    var RangeLegendSvgRender = BaseRender.extend({
        render:function() {

            var svgRoot = this.component.getVanchartRender().getRenderRoot();
            var bounds = this.component.bounds;

            this.isHorizontal = this.component.isHorizontal();

            if(!this._legendG){
                this._legendG = svgRoot.append('g');
                this.minPos = 0;
                this.maxPos = HEIGHT;
            }

            if(!this.component.vanchart.isZoomRefreshState()){
                this.minPos = 0;
                this.maxPos = HEIGHT;
            }

            this._legendG.attr('transform', 'translate('+ this._getIntPos(bounds.x) +','+ this._getIntPos(bounds.y) +')');

            this._updateBackground();

            this.component.isIntervalLegend ? this._renderInterval() : this._renderGradient();
        },

        _updateBackground: function () {
            var option = this.component.componentOption;
            var bounds = this.component.bounds;
            var IDPrefix = this.component.vanchart.getIDPrefix();
            var gradualID = 'range-legend-background' + IDPrefix;

            this._renderSvgBackground(this._legendG, option, bounds, gradualID);
        },

        _renderGradient:function() {
            var linearGradient = this._createDefs();
            var startPos = ((this.isHorizontal ? this.component.bounds.width : this.component.bounds.height)- HEIGHT)/2;
            startPos = this._getIntPos(startPos);

            var barBackgroundG = this._legendG.selectAll('rect.' + 'gradient-bar-background').data([0]);
            barBackgroundG.enter().append('rect').attr('class', 'gradient-bar-background');
            barBackgroundG
                .attr('rx', 2)
                .attr('ry', 2)
                .attr('x', this.isHorizontal ? startPos : PADDING)
                .attr('y', this.isHorizontal ? PADDING : startPos)
                .attr('width',this.isHorizontal ? HEIGHT : WIDTH)
                .attr('height',this.isHorizontal ? WIDTH : HEIGHT)
                .style('fill', '#eaeaea');

            var IDPrefix = this.component.vanchart.getIDPrefix();
            var barGradientG = this._legendG.selectAll('rect.' + 'gradient-bar').data([0]);
            barGradientG.enter().append('rect').attr('class', 'gradient-bar');
            barGradientG
                .attr('clip-path', "url(#" + CLIP_ID + IDPrefix +")")
                .attr('rx', 2)
                .attr('ry', 2)
                .attr('x', this.isHorizontal ? startPos : PADDING)
                .attr('y', this.isHorizontal ? PADDING : startPos)
                .attr('width',this.isHorizontal ? HEIGHT : WIDTH)
                .attr('height',this.isHorizontal ? WIDTH : HEIGHT)
                .style('fill','url(#' + linearGradient.attr('id') + ')');

            var self = this;
            var minDrag = d3.behavior.drag()
                .on("dragstart", function() {
                    // silence other listeners
                    d3.event.sourceEvent.stopPropagation();
                })
                .on('drag', function () {
                    var change = 0;
                    if(self.isHorizontal){
                        var temp = self.minPos;
                        self.minPos += Math.round(d3.event.dx);
                        self.minPos = Math.max(self.minPos, 0);
                        self.minPos = Math.min(self.minPos, self.maxPos);
                        change = self.minPos - temp;
                    } else {
                        var temp = self.maxPos;
                        self.maxPos += Math.round(d3.event.dy);
                        self.maxPos = Math.min(self.maxPos, HEIGHT);
                        self.maxPos = Math.max(self.maxPos, self.minPos);
                        change = self.maxPos - temp;
                    }
                    if(Math.abs(change) >= 1) {
                        self._updateMinBar(startPos);
                        self.component.refreshPoints(self.minPos, self.maxPos);
                    }
                });

            var maxDrag = d3.behavior.drag()
                .on("dragstart", function() {
                    // silence other listeners
                    d3.event.sourceEvent.stopPropagation();
                })
                .on('drag', function () {
                    var change = 0;
                    if(self.isHorizontal){
                        var temp = self.maxPos;
                        self.maxPos += Math.round(d3.event.dx);
                        self.maxPos = Math.min(self.maxPos, HEIGHT);
                        self.maxPos = Math.max(self.maxPos, self.minPos);
                        change = self.maxPos - temp;
                    } else {
                        var temp = self.minPos;
                        self.minPos += Math.round(d3.event.dy);
                        self.minPos = Math.max(self.minPos, 0);
                        self.minPos = Math.min(self.minPos, self.maxPos);
                        change = self.minPos - temp;
                    }
                    if(Math.abs(change) >= 1) {
                        self._updateMaxBar(startPos);
                        self.component.refreshPoints(self.minPos, self.maxPos);
                    }
                });

            var minBarG = this._legendG.selectAll('path.' + MIN_BAR_CLASS_NAME).data([0]);
            minBarG.enter().append('path').attr('class', MIN_BAR_CLASS_NAME);
            minBarG
                .attr('d', this.isHorizontal ? this.component.getLeftBarPath() : this.component.getTopBarPath())
                .call(minDrag);

            var maxBarG = this._legendG.selectAll('path.' + MAX_BAR_CLASS_NAME).data([0]);
            maxBarG.enter().append('path').attr('class', MAX_BAR_CLASS_NAME);
            maxBarG
                .attr('d', this.isHorizontal ? this.component.getRightBarPath() : this.component.getBottomBarPath())
                .call(maxDrag);

            var labelStyle = this.component.componentOption.style;
            if(!this._labelUseHtml()){
                var minLabelG = this._legendG.selectAll('text.' +  MIN_BAR_CLASS_NAME).data([0]);
                minLabelG.enter().append('text').attr('class', MIN_BAR_CLASS_NAME);
                minLabelG
                    .attr('dy', '.32em')
                    .call(BaseUtils.setTextStyle, labelStyle);

                var maxLabelG = this._legendG.selectAll('text.' + MAX_BAR_CLASS_NAME).data([0]);
                maxLabelG.enter().append('text').attr('class', MAX_BAR_CLASS_NAME);
                maxLabelG
                    .attr('dy', '.32em')
                    .call(BaseUtils.setTextStyle, labelStyle);
            }

            this._updateMinBar(startPos);
            this._updateMaxBar(startPos);
        },

        _createDefs:function() {
            if(!this._legendG.selectAll('defs').empty()){
                return this._legendG.selectAll('defs').select('linearGradient');
            }
            var defs = this._legendG.append('defs');

            var IDPrefix = this.component.vanchart.getIDPrefix();

            defs.append('clipPath').attr('id', CLIP_ID + IDPrefix).append('rect');

            var linearGradient = defs.append('linearGradient')
                .attr('id','gradient-range-legend' + IDPrefix)
                .attr('x1','0%')
                .attr('y1',this.isHorizontal ? '0%' : '100%')
                .attr('x2',this.isHorizontal ? '100%' : '0%')
                .attr('y2','0%');

            var valueAndColorArray = this.component.getValueAndColors();

            valueAndColorArray.forEach(function(valueAndColor){
                var value = valueAndColor[0];
                var color = valueAndColor[1];
                linearGradient.append('stop')
                    .attr('offset', value)
                    .style('stop-color', color);
            });

            return linearGradient;
        },

        _updateMinBar:function(startPos) {
            this.isHorizontal ? this._updateHorizontalMinBar(startPos)
                : this._updateVerticalMinBar(startPos);
        },

        _updateVerticalMinBar: function(startPos) {
            var x = PADDING + WIDTH;
            var y = startPos + this.maxPos;

            this._legendG.select('path.' + MIN_BAR_CLASS_NAME)
                .attr('transform', 'translate('+ x  +','+ y +')')
                .style('fill', this.component.colorScale((HEIGHT - this.maxPos)/HEIGHT));

            var label = this.component.getGradientLabelContent(this.maxPos);
            var labelStyle = this.component.componentOption.style;
            var labelDim = BaseUtils.getTextDimension(label, labelStyle, true);

            if(this._labelUseHtml()){
                var labelY = this._getIntPos(startPos + this.maxPos + BAR_HEIGHT / 2 - labelDim.height/2);
                var labelBounds = this._getAbsoluteBounds(labelDim, PADDING + WIDTH + BAR_WIDTH + BAR_TEXT_GAP, labelY);
                this.labelDivManager.clearLabels(MIN_BAR_CLASS_NAME);
                this.labelDivManager.addLabelWidthBounds(label, labelBounds, labelStyle, MIN_BAR_CLASS_NAME);
            } else {
                this._legendG.select('text.' + MIN_BAR_CLASS_NAME)
                    .attr('text-anchor', 'middle')
                    .attr('x', this._getIntPos(PADDING + WIDTH + BAR_WIDTH + BAR_TEXT_GAP + labelDim.width / 2))
                    .attr('y', this._getIntPos(startPos + this.maxPos + BAR_HEIGHT / 2))
                    .text(label);
            }

            this._updateVerticalLinearColorClipPath(startPos);
        },

        _getAbsoluteBounds: function (labelDim, relativeX, relativeY) {
            return {
                x:this.component.bounds.x + relativeX,
                y:this.component.bounds.y + relativeY,
                width:labelDim.width,
                height:labelDim.height
            };
        },

        _getIntPos: function (pos) {
            return Math.round(pos);
        },

        _labelUseHtml: function () {
            return this.component.componentOption.useHtml;
        },

        _updateHorizontalMinBar: function(startPos) {
            var x = startPos - BAR_HEIGHT + this.minPos;
            var y = PADDING + WIDTH;

            this._legendG.select('path.' + MIN_BAR_CLASS_NAME)
                .attr('transform', 'translate('+ x  +','+ y +')')
                .style('fill', this.component.colorScale(this.minPos/HEIGHT));

            var label = this.component.getGradientLabelContent(this.minPos);
            var labelStyle = this.component.componentOption.style;
            var labelDim = BaseUtils.getTextDimension(label, labelStyle, true);

            if(this._labelUseHtml()){
                var labelBounds = this._getAbsoluteBounds(labelDim, this._getIntPos(startPos + this.minPos - labelDim.width), PADDING + WIDTH + BAR_WIDTH + BAR_TEXT_GAP);
                this.labelDivManager.clearLabels(MIN_BAR_CLASS_NAME);
                this.labelDivManager.addLabelWidthBounds(label, labelBounds, labelStyle, MIN_BAR_CLASS_NAME);
            } else {
                this._legendG.select('text.' + MIN_BAR_CLASS_NAME)
                    .attr('text-anchor', 'left')
                    .attr('y', this._getIntPos(PADDING + WIDTH + BAR_WIDTH + BAR_TEXT_GAP + labelDim.height/2))
                    .attr('x', this._getIntPos(startPos + this.minPos - labelDim.width))
                    .text(label);
            }

            this._updateHorizontalLinearColorClipPath(startPos);
        },

        _updateMaxBar: function (startPos) {
            this.isHorizontal ? this._updateHorizontalMaxBar(startPos)
                : this._updateVerticalMaxBar(startPos);
        },

        _updateVerticalMaxBar: function(startPos) {
            var x = PADDING + WIDTH;
            var y = startPos - BAR_HEIGHT + this.minPos;

            this._legendG.select('path.' + MAX_BAR_CLASS_NAME)
                .attr('transform', 'translate('+ x  +','+ y +')')
                .style('fill', this.component.colorScale((HEIGHT - this.minPos)/HEIGHT));

            var label = this.component.getGradientLabelContent(this.minPos);
            var labelStyle = this.component.componentOption.style;
            var labelDim = BaseUtils.getTextDimension(label, labelStyle, true);

            if(this._labelUseHtml()){
                var labelY = this._getIntPos(startPos + this.minPos - BAR_HEIGHT/2 - labelDim.height/2);
                var labelBounds = this._getAbsoluteBounds(labelDim, PADDING + WIDTH + BAR_WIDTH + BAR_TEXT_GAP, labelY);
                this.labelDivManager.clearLabels(MAX_BAR_CLASS_NAME);
                this.labelDivManager.addLabelWidthBounds(label, labelBounds, labelStyle, MAX_BAR_CLASS_NAME);
            } else {
                this._legendG.select('text.' + MAX_BAR_CLASS_NAME)
                    .attr('text-anchor', 'middle')
                    .attr('x', this._getIntPos(PADDING + WIDTH + BAR_WIDTH + BAR_TEXT_GAP + labelDim.width/2))
                    .attr('y', this._getIntPos(startPos + this.minPos - BAR_HEIGHT/2))
                    .text(label);
            }

            this._updateVerticalLinearColorClipPath(startPos);
        },

        _updateHorizontalMaxBar: function(startPos) {
            var x = startPos + this.maxPos;
            var y = PADDING + WIDTH;

            this._legendG.select('path.' + MAX_BAR_CLASS_NAME)
                .attr('transform', 'translate('+ x  +','+ y +')')
                .style('fill', this.component.colorScale(this.maxPos/HEIGHT));

            var label = this.component.getGradientLabelContent(this.maxPos);
            var labelStyle = this.component.componentOption.style;
            var labelDim = BaseUtils.getTextDimension(label, labelStyle, true);

            if(this._labelUseHtml()){
                var labelBounds = this._getAbsoluteBounds(labelDim, this._getIntPos(startPos + this.maxPos), PADDING + WIDTH + BAR_WIDTH + BAR_TEXT_GAP);
                this.labelDivManager.clearLabels(MAX_BAR_CLASS_NAME);
                this.labelDivManager.addLabelWidthBounds(label, labelBounds, labelStyle, MAX_BAR_CLASS_NAME);
            } else {
                this._legendG.select('text.' + MAX_BAR_CLASS_NAME)
                    .attr('text-anchor', 'left')
                    .attr('y', this._getIntPos(PADDING + WIDTH + BAR_WIDTH + BAR_TEXT_GAP + labelDim.height/2))
                    .attr('x', this._getIntPos(startPos + this.maxPos))
                    .text(label);
            }

            this._updateHorizontalLinearColorClipPath(startPos);
        },

        _updateVerticalLinearColorClipPath: function (startPos) {
            var IDPrefix = this.component.vanchart.getIDPrefix();

            this._legendG.select('defs')
                .select('clipPath#' + CLIP_ID + IDPrefix)
                .select('rect')
                .attr('x', PADDING)
                .attr('y', startPos + this.minPos)
                .attr('width', WIDTH)
                .attr('height', this.maxPos - this.minPos);
        },

        _updateHorizontalLinearColorClipPath: function (startPos) {
            var IDPrefix = this.component.vanchart.getIDPrefix();

            this._legendG.select('defs')
                .select('clipPath#' + CLIP_ID + IDPrefix)
                .select('rect')
                .attr('x', startPos + this.minPos)
                .attr('y', PADDING)
                .attr('width', this.maxPos - this.minPos)
                .attr('height', WIDTH);
        },

        _renderInterval:function() {
            if(this.component.items.length <= 0){
                return;
            }

            var itemS = this._legendG.selectAll('g.' + RANGE_ITEM)
                .data(this.component.items);

            var self = this;

            itemS.enter().append('g').attr('class', RANGE_ITEM)
                . each(function () {
                    var newItem = d3.select(this);
                    newItem.append('rect').attr('class', RANGE_ITEM);
                    if(!self._labelUseHtml()){
                        newItem.append('text').attr('class', RANGE_ITEM);
                    }
                    newItem.call(self._bindMouseEvent.bind(self));
                });

            this.isHorizontal ? this._updateHorizontalIntervalItems(itemS)
                : this._updateVerticalIntervalItems(itemS);
        },

        _updateVerticalIntervalItems: function (itemS) {
            var cfg = this.component.componentOption;
            var labelStyle = cfg.style;

            var x = PADDING;
            var labelX = PADDING + WIDTH + BAR_TEXT_GAP;
            var startY = (this.component.bounds.height - this.component.items.length * ITEM_WIDTH - (this.component.items.length - 1) * ITEM_GAP)/2;
            startY = this._getIntPos(startY);

            var self = this;
            itemS.each(function(d){
                var item = d3.select(this);

                var labelDim = BaseUtils.getTextDimension(d.label, labelStyle);

                item.select('rect')
                    .attr('rx', 2)
                    .attr('ry', 2)
                    .attr('x', x)
                    .attr('y', startY)
                    .attr('width', WIDTH)
                    .attr('height', ITEM_WIDTH)
                    .style('fill', d.visible ? d.color : d.hiddenColor);

                if(self._labelUseHtml()) {
                    var labelBounds = self._getAbsoluteBounds(labelDim, self._getIntPos(labelX),  self._getIntPos(startY + ITEM_WIDTH / 2 - labelDim.height/2));
                    self.labelDivManager.addLabelWidthBounds(d.label, labelBounds, labelStyle);
                } else {
                    item.select('text')
                        .text(function (d) {
                            return d.label
                        })
                        .attr('x', self._getIntPos(labelX + labelDim.width / 2))
                        .attr('y', self._getIntPos(startY + ITEM_WIDTH / 2))
                        .attr('dy', '.32em')
                        .attr('text-anchor', 'middle')
                        .call(BaseUtils.setTextStyle, labelStyle)
                        .style('fill', d.visible ? labelStyle.color : d.hiddenColor);
                }

                startY += (ITEM_WIDTH + ITEM_GAP);
            });
        },

        _updateHorizontalIntervalItems: function (itemS) {
            var cfg = this.component.componentOption;
            var labelStyle = cfg.style;
            var startX = (this.component.bounds.width - this.component.items.length * ITEM_WIDTH - (this.component.items.length - 1) * ITEM_GAP)/2;
            startX = this._getIntPos(startX);

            var self = this;
            itemS.each(function(d, i){
                var item = d3.select(this);

                var labelDim = BaseUtils.getTextDimension(d.label, labelStyle);
                var topLabelY = PADDING;
                var iconY = topLabelY + labelDim.height + BAR_TEXT_GAP;
                var bottomY = iconY + WIDTH + BAR_TEXT_GAP;

                item.select('rect')
                    .attr('rx', 2)
                    .attr('ry', 2)
                    .attr('x', startX)
                    .attr('y', iconY)
                    .attr('width', ITEM_WIDTH)
                    .attr('height', WIDTH)
                    .style('fill', d.visible ? d.color : d.hiddenColor);

                if(self._labelUseHtml()) {
                    var labelY = self._getIntPos(i % 2 == 0 ? topLabelY : bottomY);
                    var labelBounds = self._getAbsoluteBounds(labelDim, self._getIntPos(startX), labelY);
                    self.labelDivManager.addLabelWidthBounds(d.label, labelBounds, labelStyle);
                } else {
                    item.select('text')
                        .text(function (d) {
                            return d.label
                        })
                        .attr('x', self._getIntPos(startX + ITEM_WIDTH / 2))
                        .attr('y', self._getIntPos(i % 2 == 0 ? topLabelY + labelDim.height / 2 : bottomY + labelDim.height / 2))
                        .attr('dy', '.32em')
                        .attr('text-anchor', 'middle')
                        .call(BaseUtils.setTextStyle, labelStyle)
                        .style('fill', d.visible ? labelStyle.color : d.hiddenColor);
                }

                startX += (ITEM_WIDTH + ITEM_GAP);
            });
        },

        _bindMouseEvent:function(rowSelection){
            var vanChart = this.component.vanchart;
            var cfg = this.component.componentOption;
            var labelColor = cfg.style.color;

            rowSelection
                .style('cursor', 'pointer')
                .on('mouseenter', function(d){
                    d3.select(this).select('text.' + RANGE_ITEM).style('fill', d.hoverColor);
                })
                .on('mouseleave', function(d){
                    var textColor = d.visible ? labelColor : d.hiddenColor;
                    d3.select(this).select('text.' + RANGE_ITEM).style('fill', textColor);
                })
                .on('click', function(d){
                    d.visible = !d.visible;
                    var iconColor = d.visible ? d.color : d.hiddenColor;
                    var textColor = d.visible ? labelColor : d.hiddenColor;
                    d3.select(this).select('rect.' + RANGE_ITEM).style('fill', iconColor);
                    d3.select(this).select('text.' + RANGE_ITEM).style('fill', textColor);

                    d.points.forEach(function (point) {
                        point.visible = d.visible;
                    });

                    vanChart.renderOnlyCharts();
                });
        }
    });
    
    require('./RenderLibrary').register(Constants.RANGE_LEGEND_SVG, RangeLegendSvgRender);

    return RangeLegendSvgRender;
});

/**
 * Created by eason on 15/8/12.
 */
define('render/VanChartSvgRender',['require','../Constants','./BaseRender','../utils/BaseUtils','./RenderLibrary'],function(require){

    var Constants = require('../Constants');

    var BaseRender = require('./BaseRender');
    var BaseUtils = require('../utils/BaseUtils');

    var CHART_GRADUAL = 'chart-gradual-background';
    var PLOT_GRADUAL = 'plot-gradual-background';
    var TREND_LINE = 'trend-line';

    var VanChartSvgRender = BaseRender.extend({
        render:function(){
            var dom = this.component.getParentDom();
            var width = this.component.chartWidth();
            var height = this.component.chartHeight();
            
            if(!this.svgRoot){
                this.svgRoot = d3.select(dom).append('svg')
                    .attr('width', width).attr('height', height);
                var clipID = this.component.getBodyClipID();
                this.svgRoot.append('defs').append('clipPath').attr('id', clipID);
            }

            this._updateBodyClip();

            var charts = this.component.getChartRenders();

            var fixed = this.component.getFixedComponentRenders();
            var float = this.component.getFloatComponentRenders();

            this._renderBackground();

            this.svgRoot.selectAll('g.' + Constants.AXIS_GROUP).data([0]).enter()
                .append('g').attr('class', Constants.AXIS_GROUP);

            fixed.forEach(function(render){
                render.render();
            });

            charts.forEach(function(render){
                render.render();
            });

            float.forEach(function(render){
                render.render();
            });

            this.component.getComponent(Constants.TOOLBAR_COMPONENT) &&
            this.component.getComponent(Constants.TOOLBAR_COMPONENT).render.toFront();

            this._renderTrendLine();
        },

        _updateBodyClip:function(){

            var clipBounds = this.component.getPlotClipBounds();

            var clipPath = this.svgRoot.select('#' + this.component.getBodyClipID());

            clipPath.select('rect').remove();

            clipPath
                .append('rect')
                .attr('x', clipBounds.x)
                .attr('y', clipBounds.y)
                .attr('width', clipBounds.width)
                .attr('height', clipBounds.height);
        },

        //图表区和绘图区的背景
        _renderBackground:function(){

            var IDPrefix = this.component.getIDPrefix();

            var chartBounds = BaseUtils.makeBounds(0,0,this.component.chartWidth() - 5, this.component.chartHeight() - 5);
            var chartBackground = this.component.getChartBackgroundOption();

            var plotBounds = this.component.getPlotBounds();
            var plotBackground = this.component.getPlotBackgroundOption();

            if(!this._backgroundG){
                this._backgroundG = this.svgRoot.append('g');
            }

            this._backgroundG.selectAll('.background').remove();
            this._backgroundG.selectAll('defs').remove();

            this._createGradualDefs(this._backgroundG, chartBackground.color, CHART_GRADUAL + IDPrefix);
            this._createGradualDefs(this._backgroundG, plotBackground.color, PLOT_GRADUAL + IDPrefix);

            this._renderBackgroundWithBounds(chartBackground, chartBounds, CHART_GRADUAL + IDPrefix);
            this._renderBackgroundWithBounds(plotBackground, plotBounds, PLOT_GRADUAL + IDPrefix);
        },

        _renderBackgroundWithBounds:function(option, bounds, ID){

            if(ID.indexOf(CHART_GRADUAL) != -1) {
                var bw = option.borderWidth;
                bounds = BaseUtils.rectSubPixelOpt(bounds.x + bw/2, bounds.y + bw/2, bounds.width - bw, bounds.height - bw, option.borderWidth);
            } else {
                bounds = BaseUtils.rectSubPixelOpt(bounds.x, bounds.y, bounds.width, bounds.height, option.borderWidth);
            }
            var dom = this.component.getParentDom();
            //阴影
            if(option.chartShadow){
                d3.select(dom).style('box-shadow', '1px 1px 2px rgba(0,0,0,0.1)')
            }else if(option.plotShadow){
                var width = [5, 3, 1];
                var opacity = [0.05, 0.1, 0.15];

                var shadowBounds = BaseUtils.rectSubPixelOpt(bounds.x, bounds.y, bounds.width, bounds.height, 1);

                for(var i = 0; i < 3; i++){
                    this._backgroundG
                        .append('rect')
                        .attr('class', 'background')
                        .attr('x', shadowBounds.x)
                        .attr('y', shadowBounds.y)
                        .attr('width', shadowBounds.width)
                        .attr('height', shadowBounds.height)
                        .attr('transform', 'translate(1, 1)')
                        .attr('rx', option.borderRadius)
                        .attr('ry', option.borderRadius)
                        .style('fill', 'none')
                        .style('stroke', 'black')
                        .style('stroke-width', width[i])
                        .style('stroke-opacity', opacity[i]);
                }

                this._backgroundG
                    .append('rect')
                    .attr('class', 'background')
                    .attr('x', shadowBounds.x)
                    .attr('y', shadowBounds.y)
                    .attr('width', shadowBounds.width)
                    .attr('height', shadowBounds.height)
                    .attr('rx', option.borderRadius)
                    .attr('ry', option.borderRadius)
                    .style('fill', 'white');
            }

            this._backgroundG
                .append('rect')
                .attr('class', 'background')
                .attr('x', bounds.x)
                .attr('y', bounds.y)
                .attr('width', bounds.width)
                .attr('height', bounds.height)
                .attr('rx', option.borderRadius)
                .attr('ry', option.borderRadius)
                .style('fill', function(){
                    if(option.color){
                        return typeof option.color == 'string' ? option.color : "url(#" + ID + ")";
                    }
                    return 'none';
                })
                .style('stroke', option.borderColor)
                .style('stroke-width', option.borderWidth);

            if(option.image){
                this._backgroundG
                    .append('image')
                    .attr('class', 'background')
                    .attr('preserveAspectRatio', 'none')
                    .attr('x', bounds.x)
                    .attr('y', bounds.y)
                    .attr('width', bounds.width)
                    .attr('height', bounds.height)
                    .attr('xlink:href', option.image);
            }

        },

        _renderTrendLine:function(){

            var trendLines = this.component.getTrendLineOption();
            var plotBounds = this.component.getPlotBounds();
            var clipID = this.component.getBodyClipID();

            if(!this._trendG){
                this._trendG = this.svgRoot
                    .append('g')
                    .attr('clip-path', "url(#" + clipID +")");
            }

            this._trendG
                .attr('transform', 'translate('+ plotBounds.x + ','+ plotBounds.y+')');

            var selection = this._trendG.selectAll('line').data(trendLines);

            selection.enter().append('line');
            selection.exit().remove();

            selection
                .attr('x1', function(d){return d.x1})
                .attr('y1', function(d){return d.y1})
                .attr('x2', function(d){return d.x2})
                .attr('y2', function(d){return d.y2})
                .style('stroke', function(d){
                    return d.trendLine.color;
                })
                .style('stroke-width', function(d){
                    return d.trendLine.width;
                })
                .style('stroke-dasharray', function(d){
                    return Constants.DASH_TYPE[d.trendLine.dashStyle];
                });
        },

        getRenderRoot:function(){
            return this.svgRoot;
        },

        remove:function(){
            this.svgRoot.remove();
            var charts = this.component.getChartRenders();
            var components = this.component.getComponentRenders();

            charts.forEach(function(render){
                render.removeDivLabels();
            });

            components.forEach(function(render){
                render.removeDivLabels();
            });
        }
    });

    require('./RenderLibrary').register(Constants.VANCHART_SVG, VanChartSvgRender);

    return VanChartSvgRender;
});
/**
 * Created by eason on 16/2/5.
 */

define('ModernBrowserRequire',['require','./chart/Pie','./chart/Bar','./chart/Line','./chart/Area','./chart/Gauge','./chart/Radar','./chart/Bubble','./chart/Scatter','./chart/Map','./render/PieSvgRender','./render/BarSvgRender','./render/LineSvgRender','./render/AreaSvgRender','./render/GaugeSvgRender','./render/RadarSvgRender','./render/BubbleSvgRender','./render/ScatterSvgRender','./render/MapSvgRender','./render/DrillToolsSvgRender','./render/TitleSvgRender','./render/CategoryAxisSvgRender','./render/ValueAxisSvgRender','./render/RadiusAxisSvgRender','./render/AngleAxisSvgRender','./render/DateAxisSvgRender','./render/LegendSvgRender','./render/ToolbarSvgRender','./render/DataSheetSvgRender','./render/RangeLegendSvgRender','./VanCharts','./render/VanChartSvgRender'],function(require){

    require('./chart/Pie');
    require('./chart/Bar');
    require('./chart/Line');
    require('./chart/Area');
    require('./chart/Gauge');
    require('./chart/Radar');
    require('./chart/Bubble');
    require('./chart/Scatter');
    require('./chart/Map');

    require('./render/PieSvgRender');
    require('./render/BarSvgRender');
    require('./render/LineSvgRender');
    require('./render/AreaSvgRender');
    require('./render/GaugeSvgRender');
    require('./render/RadarSvgRender');
    require('./render/BubbleSvgRender');
    require('./render/ScatterSvgRender');
    require('./render/MapSvgRender');

    require('./render/DrillToolsSvgRender');
    require('./render/TitleSvgRender');
    require('./render/CategoryAxisSvgRender');
    require('./render/ValueAxisSvgRender');
    require('./render/RadiusAxisSvgRender');
    require('./render/AngleAxisSvgRender')
    require('./render/DateAxisSvgRender');
    require('./render/LegendSvgRender');
    require('./render/ToolbarSvgRender');
    require('./render/DataSheetSvgRender');
    require('./render/RangeLegendSvgRender');

    require('./VanCharts');
    require('./render/VanChartSvgRender');

});
/**
 * Created by eason on 15/12/31.
 */
define('render/RadarVmlRender',['require','./BaseRender','../utils/BaseUtils','../utils/ColorUtils','../Constants','./RenderLibrary'],function(require){

    var BaseRender = require('./BaseRender');
    var BaseUtils = require('../utils/BaseUtils');
    var ColorUtils = require('../utils/ColorUtils');
    var Constants = require('../Constants');

    var VALUE_TICK_GAP = 2;

    var RadarVmlRender = BaseRender.extend({
        render:function(){

            this._removeAll();

            var paper = this.component.getVanchartRender().getRenderRoot();

            var radarCenter = this.component.getRadarCenter();

            this._bodySet = paper.set();

            this._axisSet = paper.set();

            this._lineSet = {};

            this.markerMap = {};

            this._drawRadarAxis(paper, radarCenter);

            this._drawRadarSeries(paper, radarCenter);

            this._drawDataLabels(paper, radarCenter);
        },

        _drawDataLabels:function(paper, radarCenter){
            var radarData = this.component.getVisibleChartData();

            var labelSet = paper.set();

            this._axisSet.push(labelSet);

            for(var i = 0, count = radarData.length; i < count; i++){

                var points = radarData[i].points;

                this._drawVmlDataLabels(paper, labelSet, points, radarCenter[0], radarCenter[1]);
            }
        },

        _drawRadarSeries:function(paper, radarCenter){
            var radarData = this.component.getVisibleChartData();

            for(var i = 0, count = radarData.length; i < count; i++){
                var seryData = radarData[i];
                var points = seryData.points;

                var seriesSet = paper.set();
                this._lineSet[seryData.seriesName] = seriesSet;
                this._bodySet.push(seriesSet);

                if(this.component.isColumnType()){
                    for(var pIndex = 0, pCount = points.length; pIndex < pCount; pIndex++){
                        var d = points[pIndex];

                        var rect = paper.path(this.component._getRadarColumnPath(d.y0, d.y, d.radian))
                            .attr({
                                fill: d.color,
                                'fill-opacity': d.fillColorOpacity,
                                stroke: d.borderColor,
                                'stroke-width': d.borderWidth
                            })
                            .transform(BaseUtils.makeTranslate(radarCenter))
                            .datum(d);

                        this.markerMap[d.className] = rect;

                        this.addShapeEventHandler(rect);

                        seriesSet.push(rect);
                    }

                }else{

                    var line = paper.path(this.component._getRadarSeriesStrokePath(seryData.pathSegment, seryData.connectNulls))
                        .attr({
                            fill: 'none',
                            stroke:seryData.lineColor,
                            'stroke-width':seryData.lineWidth
                        })
                        .transform(BaseUtils.makeTranslate(radarCenter))
                        .datum(seryData);

                    this.addSeriesEventHandler(line);

                    seriesSet.push(line);

                    var fill = paper.path(this.component._getRadarSeriesFillPath(seryData.pathSegment, seryData.connectNulls))
                        .attr({
                            fill: seryData.fillColor,
                            'fill-opacity': seryData.fillColor ? seryData.fillColorOpacity : 0,
                            stroke:'none'
                        })
                        .transform(BaseUtils.makeTranslate(radarCenter))
                        .datum(seryData);

                    this.addSeriesEventHandler(fill);

                    seriesSet.push(fill);

                    for(var pIndex = 0, pCount = points.length; pIndex < pCount; pIndex++){
                        var point = points[pIndex];
                        var pos = point.pos;

                        var marker = this._createVmlMarker(paper, point, [radarCenter[0] + pos[0], radarCenter[1] + pos[1]])

                        this.markerMap[point.className] = marker;

                        seriesSet.push( marker.marker );
                    }
                }
            }
        },

        _drawRadarAxis:function(paper, radarCenter){

            // this._drawPlotBands(paper, radarCenter);
            //
            // this._drawPlotLines(paper, radarCenter);
            //
            // this._drawGridLine(paper, radarCenter);
            //
            // this._drawAxisLine(paper, radarCenter);
            //
            // this._drawTickLabel(paper, radarCenter);
        },

        _drawPlotBands:function(paper, radarCenter){
            var plotBands = this.component.getRadarPlotBands();
            var axisSet = this._axisSet;
            plotBands.forEach(function(band){
                axisSet.push(
                    paper.path(band.path)
                        .attr({
                            'fill': band.color,
                            'stroke': 'none'
                        })
                        .transform(BaseUtils.makeTranslate(radarCenter))
                )
            });
        },

        _drawPlotLines:function(paper, radarCenter){
            var plotLines = this.component.getRadarPlotLines();
            var self = this;

            plotLines.forEach(function(d){

                self._axisSet.push(

                    paper.path(self.component._getGridPath(d.value))
                        .attr({
                            fill:'none',
                            stroke: d.color,
                            'stroke-width': d.width,
                            'stroke-dasharray': d.dataArray
                        })
                        .transform(BaseUtils.makeTranslate(radarCenter))

                );

                if(d.text){
                    var textStyle = BaseUtils.cssNormalization(d.style);
                    paper.text(0, d.baseY, d.text)
                        .attr(textStyle)
                        .attr('text-anchor', d.textAnchor)
                        .transform(BaseUtils.makeTranslate(radarCenter));
                }

            });
        },

        _drawGridLine:function(paper, radarCenter){
            var valueAxis = this.component.getValueAxis();
            var cfg = valueAxis.componentOption;
            var ticks = valueAxis.getTickData();
            var gridLineColor = cfg.gridLineColor;
            var gridLineWidth = cfg.gridLineWidth;

            var self = this;

            ticks.forEach(function(d){

                self._axisSet.push(

                    paper.path(self.component._getGridPath(d.tickValue))
                        .attr({
                            'fill':'none',
                            'stroke':gridLineColor,
                            'stroke-width':gridLineWidth
                        })
                        .transform(BaseUtils.makeTranslate(radarCenter))
                );

            });
        },

        _drawAxisLine:function(paper, radarCenter) {

            var valueAxis = this.component.getValueAxis();
            var cfg = valueAxis.componentOption;
            var lineWidth = cfg.lineWidth;
            var lineColor = cfg.lineColor;
            var self = this;

            var axisLineData = this.component.getAxisLineData();

            axisLineData.forEach(function (d) {

                self._axisSet.push(
                    paper.path(self._getLinePath([0, 0], d))
                        .attr({
                            'fill': 'none',
                            'stroke': lineColor,
                            'stroke-width': lineWidth
                        })
                        .transform(BaseUtils.makeTranslate(radarCenter))
                );

            });

            var baseAxis = this.component.getBaseAxis();
            var categoryLineWidth = baseAxis.componentOption.lineWidth;
            var categoryLineColor = baseAxis.componentOption.lineColor;
            var maxValue = valueAxis.scale.domain()[1];

            this._axisSet.push(

                paper.path(this.component._getGridPath(maxValue))
                    .attr({
                        'fill':'none',
                        'stroke':categoryLineColor,
                        'stroke-width':categoryLineWidth
                    })
                    .transform(BaseUtils.makeTranslate(radarCenter))

            );
        },

        _drawTickLabel:function(paper, radarCenter){

            this._drawValueTickLabel(paper, radarCenter);

            this._drawCategoryTickLabel(paper, radarCenter);
        },

        _drawValueTickLabel:function(paper, radarCenter){

            var valueAxis = this.component.getValueAxis();
            var cfg = valueAxis.componentOption;
            var ticks = BaseUtils.clone(valueAxis.getTickData());

            //最大值标签不显示
            ticks.length = Math.max(ticks.length - 1, 0);

            var labelStyle = cfg.labelStyle;
            var labelRotation = cfg.labelRotation || 0;
            var useHtml = cfg.useHtml;
            var valueScale = this.component.valueScale;

            if(useHtml && !labelRotation){

                for(var i = 0, len = ticks.length; i < len; i++){

                    var tick = ticks[i];

                    var x = -tick.tickDim.width - VALUE_TICK_GAP + radarCenter[0];
                    var y = -valueScale(tick.tickValue)-tick.tickDim.height + radarCenter[1];

                    this.labelDivManager.addLabel(tick.tickContent, {x:x, y:y}, labelStyle);
                }

            }else{

                for(var i = 0, count = ticks.length; i < count; i++){

                    var tick = ticks[i];

                    var normalDim = BaseUtils.getTextDimension(tick.tickContent, labelStyle, useHtml);

                    var x = radarCenter[0] - VALUE_TICK_GAP - normalDim.width/2;
                    var y = radarCenter[1] - valueScale(tick.tickValue) - normalDim.height/2;

                    this._axisSet.push(
                        paper.text(x, y, tick.tickContent)
                            .attr(BaseUtils.cssNormalization(labelStyle))
                            .transform('r' + labelRotation)
                    )
                }
            }

        },

        _drawCategoryTickLabel:function(paper, radarCenter){

            var baseAxis = this.component.getBaseAxis();
            var cfg = baseAxis.componentOption;

            var labelStyle = cfg.labelStyle;
            var labelRotation = cfg.labelRotation || 0;
            var useHtml = cfg.useHtml;

            var ticks = this.component.categoryLabel;
            var lineHeight = BaseUtils.getTextHeight(labelStyle);

            if(useHtml && !labelRotation){

                for(var i = 0, len = ticks.length; i < len; i++){

                    var tick = ticks[i];

                    var x = tick.tickPos.x + radarCenter[0];
                    var y = tick.tickPos.y + radarCenter[1];

                    this.labelDivManager.addLabel(tick.tickContent, {x:x, y:y}, labelStyle);
                }

            }else{

                for(var i = 0, count = ticks.length; i < count; i++){

                    var tick = ticks[i];
                    var tickContent = tick.tickContent;

                    if(BaseUtils.isArray(tickContent)){

                        var startX = radarCenter[0] + tick.tickPos.x;
                        var startY = radarCenter[1] + tick.tickPos.y + lineHeight/2;

                        var dx = tick.tickPos.x < 0 ? tick.tickDim.width : 0;
                        var textAnchor = tick.tickPos.x < 0 ? 'end' : 'start';
                        var x = dx + startX;

                        for(var j = 0, len = tickContent.length; j < len; j++){

                            var y = startY + j * (1.3 * lineHeight);
                            var t_content = tickContent[j];

                            this._axisSet.push(
                                paper.text(x, y, t_content)
                                    .attr(BaseUtils.cssNormalization(labelStyle))
                                    .attr('text-anchor', textAnchor)
                                    .transform('t' + labelRotation)
                            );
                        }

                    }else{

                        var rx = radarCenter[0] + tick.tickPos.x + tick.tickDim.width/2;

                        var ry = radarCenter[1] + tick.tickPos.y + tick.tickDim.height/2;

                        this._axisSet.push(
                            paper.text(rx, ry, tickContent)
                                .attr(BaseUtils.cssNormalization(labelStyle))
                                .transform('r' + labelRotation)
                        );
                    }
                }
            }

        },

        getElementByData:function(d){
            return this.markerMap[d.className];
        },

        mouseOver:function(event){
            if(event && event.target){
                var d = event.target.datum();
                if(d.columnType){
                    event.target.attr({
                        'stroke':ColorUtils.mixColorWithAlpha(d.mouseOverColor, 0.35),
                        'fill':  d.mouseOverColor ? d.mouseOverColor : d.color,
                        'stroke-width':6
                    });
                }else{
                    this._makeVmlMarkerChosenState(d);
                }
            }
        },

        mouseOut:function(event){
            if(event && event.target){
                var d = event.target.datum();
                if(d.columnType){
                    event.target
                        .attr({
                            'stroke':d.borderColor,
                            'fill':  d.color,
                            'stroke-width': d.borderWidth
                        });
                }else{
                    this._cancelVmlMarkerChosenState(d);
                }
            }
        },

        _getTypes:function(){
            return {
                'mouseover':this._mouseOver,
                'mouseout':this._mouseOut
            }
        },
        
        _removeAll:function(){

            if(this._bodySet){

                if(this.component.getVisibleChartData().length){
                    this._bodySet.remove();
                    this._axisSet.remove();
                }else{
                    this._bodySet.remove();
                }

                this.labelDivManager.clearAllLabels();
            }
        }
    });

    require('./RenderLibrary').register(Constants.RADAR_VML, RadarVmlRender);
});
/**
 * Created by eason on 15/12/2.
 */
define('render/GaugeVmlRender',['require','../utils/BaseUtils','../Constants','./BaseRender','../utils/ColorUtils','./RenderLibrary'],function(require){

    var BaseUtils = require('../utils/BaseUtils');
    var Constants = require('../Constants');
    var BaseRender = require('./BaseRender');
    var ColorUtils = require('../utils/ColorUtils');

    var THERMOMETER_R = 5;

    var GaugeVmlRender = BaseRender.extend({
        render:function(){

            this._removeAll();

            var paper = this.component.getVanchartRender().getRenderRoot();
            var plotBounds = this.component.getPlotBounds();
            var plotX = plotBounds.x;
            var plotY = plotBounds.y;

            this._bodySet = paper.set();

            var gaugeData = this.component.getVisibleChartData();

            for(var i = 0, len = gaugeData.length; i < len; i++){
                var gaugeSet = paper.set();
                var d = gaugeData[i];
                var style = d.style;

                switch (style){
                    case Constants.GAUGE_POINTER:
                        this._createPointer(paper, gaugeSet, d);
                        break;

                    case Constants.GAUGE_POINTER_SEMI:
                        this._createPointerSemi(paper, gaugeSet, d);
                        break;

                    case Constants.GAUGE_SLOT:
                        this._createSlot(paper, gaugeSet, d);
                        break;

                    case Constants.GAUGE_THERMOMETER:
                        this._createThermometer(paper, gaugeSet, d);
                        break;

                    case Constants.GAUGE_RING:
                        this._createRing(paper, gaugeSet, d);
                        break;
                }

                gaugeSet.transform('t' + (d.centerX + plotX) + ',' + (d.centerY + plotY));

                this._bodySet.push(gaugeSet);
            }

            this.component.vanchart.hoverSeries = gaugeData[0];
        },

        _createPointer:function(paper, gaugeSet, d){
            var arc = d3.svg.arc().startAngle(0).endAngle(2 * Math.PI)
                .innerRadius(0).outerRadius(d.radius);

            var domain = d.gaugeAxis.scale.domain();
            var scale = d3.scale.linear().domain(domain)
                .range([BaseUtils.toRadian(-150), BaseUtils.toRadian(150)]);

            //底盘
            gaugeSet.push(
                paper.path(arc()).attr({
                    fill:d.paneBackgroundColor,
                    'fill-opacity':ColorUtils.getColorOpacity(d.paneBackgroundColor),
                    stroke:'none'
                })
            );

            //枢纽背景
            arc.outerRadius(0.16 * d.radius);
            gaugeSet.push(
                paper.path(arc()).attr({
                    fill:d.hingeBackgroundColor,
                    'fill-opacity':ColorUtils.getColorOpacity(d.hingeBackgroundColor),
                    stroke:'none'
                })
            );

            this._drawGaugeLabels(paper, gaugeSet, d);

            this._drawPointerTicks(paper, gaugeSet, d, scale);
            //
            this._drawPointerArrow(paper, gaugeSet, d, scale);

            //枢纽
            arc.outerRadius(0.07 * d.radius);
            gaugeSet.push(
                paper.path(arc()).attr({
                    fill: d.hinge,
                    'fill-opacity':ColorUtils.getColorOpacity(d.hinge),
                    stroke:'none'
                })
            );
        },

        _createPointerSemi:function(paper, gaugeSet, d){

            var circle = d3.svg.arc().startAngle(0).endAngle(2 * Math.PI).innerRadius(0);

            var arc = d3.svg.arc().startAngle(BaseUtils.toRadian(-98))
                .endAngle(BaseUtils.toRadian(98))
                .innerRadius(0).outerRadius(d.radius).toCenter(false);

            var domain = d.gaugeAxis.scale.domain();
            var scale = d3.scale.linear().domain(domain)
                .range([BaseUtils.toRadian(-90), BaseUtils.toRadian(90)]);

            //底盘
            gaugeSet.push(
                paper.path(arc()).attr({
                    fill:d.paneBackgroundColor,
                    'fill-opacity':ColorUtils.getColorOpacity(d.paneBackgroundColor),
                    stroke:'none'
                })
            );

            //枢纽背景
            circle.outerRadius(0.11 * d.radius);
            gaugeSet.push(
                paper.path(circle()).attr({
                    fill:d.hingeBackgroundColor,
                    'fill-opacity':ColorUtils.getColorOpacity(d.hingeBackgroundColor),
                    stroke:'none'
                })
            );

            this._drawGaugeLabels(paper, gaugeSet, d);

            this._drawPointerTicks(paper, gaugeSet, d, scale);
            //
            this._drawPointerArrow(paper, gaugeSet, d, scale);

            //枢纽
            circle.outerRadius(0.055 * d.radius);
            gaugeSet.push(
                paper.path(circle()).attr({
                    fill: d.hinge,
                    'fill-opacity':ColorUtils.getColorOpacity(d.hinge),
                    stroke:'none'
                })
            );
        },

        _drawGaugeLabels:function(paper, gaugeSet, d){

            if(d.seriesLabelContent){
                this._drawLabel(paper, gaugeSet, d.seriesLabelContent, d.seriesLabelPos, d.seriesLabelStyle,
                    d.seriesLabelDim, d, d.seriesLabel.useHtml);
            }

            if(d.percentageLabelContent){
                this._drawLabel(paper, gaugeSet, d.percentageLabelContent, d.percentageLabelPos, d.percentageLabelStyle,
                    d.percentageLabelDim, d, d.percentageLabel.useHtml);
            }

            if(d.valueLabelContent){

                //指针类型的仪表盘值标签后面有背景
                if(d.valueLabelBackground){

                    var opt = d.valueLabelBackground;

                    gaugeSet.push(
                        paper.rect(opt.x, opt.y, opt.width, opt.height)
                            .attr({
                                fill:d.valueLabel.backgroundColor,
                                'fill-opacity':ColorUtils.getColorOpacity(d.valueLabel.backgroundColor),
                                stroke:'none'
                            })
                    );

                }

                for(var i = 0, len = d.valueLabelContent.length; i < len; i++){
                    var valueLabel = d.valueLabelContent[i];
                    this._drawLabel(paper, gaugeSet, valueLabel.labelContent, valueLabel.labelPos, valueLabel.labelStyle,
                        valueLabel.labelDim, d, d.valueLabel.useHtml);
                }

            }
        },

        _drawLabel:function(paper, gaugeSet, labelContent, labelPos, labelStyle, labelDim, gauge, useHtml){

            //ie678有自体大小不一致的问题,暂时统一用div
            var plotBounds = this.component.getPlotBounds();
            var centerX = gauge.centerX;
            var centerY = gauge.centerY;

            labelPos = {
                x:labelPos.x + centerX + plotBounds.x,
                y:labelPos.y + centerY + plotBounds.y
            };

            this.labelDivManager.addLabel(labelContent, labelPos, labelStyle);
        },

        _drawPointerArrow:function(paper, gaugeSet, d, scale){
            var self = this;

            d.points.forEach(function(point) {

                var endRadian = scale(point.valueInDomain);

                var p0 = self._getArcPoint(0.9 * d.radius, endRadian);

                var p1 = self._getArcPoint(0.02 * d.radius, endRadian + Math.PI / 2);

                var p2 = self._getArcPoint(0.02 * d.radius, endRadian - Math.PI / 2);

                var pointer = paper.path('M' + self._dealWithFloat(p0[0]) + ',' + self._dealWithFloat(p0[1])
                    + 'L' + self._dealWithFloat(p1[0]) + ',' + self._dealWithFloat(p1[1])
                    + 'L' + self._dealWithFloat(p2[0]) + ',' + self._dealWithFloat(p2[1]) + 'Z');

                pointer
                    .attr({
                        fill: d.needle,
                        'fill-opacity':ColorUtils.getColorOpacity(d.needle),
                        stroke:'none'
                    })
                    .datum(point);

                self.addShapeEventHandler(pointer);

                gaugeSet.push(pointer);
            });

        },

        _drawPointerTicks:function(paper, gaugeSet, d, scale){

            var tickData = d.gaugeAxis.getTickData();

            var axisOption = d.gaugeAxis.componentOption;
            var labelStyle = axisOption.labelStyle;
            var useHtml = axisOption.useHtml;

            var minorTickData = d.gaugeAxis.getMinorTickData();

            var self = this;

            var tickR = (1 - 0.05) * d.radius;

            var bands = d.bands;
            var plotBounds = this.component.getPlotBounds();
            var transX = plotBounds.x + d.centerX;
            var transY = plotBounds.y + d.centerY;
            tickData.forEach(function(tick){

                var radian = scale(tick.tickValue);
                var start = self._getArcPoint(tickR, radian);
                var end = self._getArcPoint(tickR - 0.1 * d.radius, radian);

                var color = self.component._getColorFromBands(tick.tickValue, bands);

                gaugeSet.push(
                    paper.path(self._getLinePath(start, end)).attr({
                        stroke:color
                    })
                );

                var labelR = (1 - 0.05 - 0.1 - 0.01) * d.radius;
                var tickDim = tick.tickDim;

                var angle = Math.atan(tickDim.width / tickDim.height);
                var joinPoint = self._getArcPoint(labelR, radian);
                var x = joinPoint[0];
                var y = joinPoint[1];

                var labelCenterX, labelCenterY;
                if(Math.abs(radian) < angle){

                    var gap = tickDim.height/2;
                    labelCenterX = x + gap * x / y;
                    labelCenterY = y + gap;

                }else if(radian >= angle && radian <= (Math.PI - angle)){//右

                    var gap = tickDim.width/2;
                    labelCenterX = x - gap;
                    labelCenterY = y - gap * y / x;

                }else if(radian >= angle - Math.PI && radian <= -angle){//左

                    var gap = tickDim.width/2;
                    labelCenterX = x + gap;
                    labelCenterY = y + gap * y / x;

                }else{
                    //下
                    var gap = tickDim.height/2;
                    labelCenterX = x - gap * x / y;
                    labelCenterY = y - gap;
                }

                if(useHtml){
                    var labelPos = {
                        x:transX + labelCenterX - tick.tickDim.width/2,
                        y:transY + labelCenterY - tick.tickDim.height/2
                    };
                    self.labelDivManager.addLabel(tick.tickContent, labelPos, labelStyle);
                }else{
                    gaugeSet.push(
                        paper.text(labelCenterX, labelCenterY, tick.tickContent)
                            .attr(BaseUtils.cssNormalization(labelStyle))
                    );
                }

            });

            minorTickData.forEach(function(value){

                var radian = scale(value);
                var start = self._getArcPoint(tickR, radian);
                var end = self._getArcPoint(tickR - 0.05 * d.radius, radian);

                var color = self.component._getColorFromBands(value, bands);

                gaugeSet.push(
                    paper.path(self._getLinePath(start, end)).attr({
                        stroke:color
                    })
                );

            });
        },

        _getArcPoint:function(r, radian){
            return [r * Math.sin(radian), -r * Math.cos(radian)]
        },

        _createSlot:function(paper, gaugeSet, d){

            var arc = d3.svg.arc().startAngle(BaseUtils.toRadian(-135))
                .endAngle(BaseUtils.toRadian(135))
                .innerRadius(0).outerRadius(d.radius)
                .toCenter(false).closePath(false);

            var circle = d3.svg.arc().startAngle(BaseUtils.toRadian(-135))
                .endAngle(BaseUtils.toRadian(135))
                .innerRadius(0).outerRadius(d.radius)
                .toCenter(false).closePath(false);

            gaugeSet.push(
                paper.path(circle()).attr({
                    'fill':'none',
                    'stroke': d.slotBackgroundColor,
                    'stroke-linecap':'round',
                    'stroke-width': d.radius * 0.16
                })
            );

            var domain = d.gaugeAxis.scale.domain();
            var startRadian = BaseUtils.toRadian(-135);
            var scale = d3.scale.linear().domain(domain).range([startRadian, BaseUtils.toRadian(135)]);
            var point = d.points[0];
            if(!point){
                return;
            }

            var valueInDomain = point.valueInDomain;
            var endRadian = scale(valueInDomain);
            var endStroke = point.color;
            var cP = this._getArcPoint(d.radius, endRadian);

            if(Math.abs(endRadian - startRadian) < 1e-6){
                gaugeSet.push(
                    paper.circle(cP[0], cP[1], 0.08 * d.radius)
                        .attr({
                            fill: endStroke,
                            stroke: 'none'
                        })
                );
            }else{

                var outerStroke = paper.path(arc.endAngle(endRadian)())
                    .attr({
                        'fill':'none',
                        'stroke': endStroke,
                        'stroke-linecap':'round',
                        'stroke-width': d.radius * 0.16
                    }).datum(d);
                this.addSeriesEventHandler(outerStroke);
                gaugeSet.push(outerStroke);
            }

            gaugeSet.push(
                paper.circle(cP[0], cP[1], 0.048 * d.radius)
                    .attr({
                        fill: d.needle,
                        'fill-opacity':ColorUtils.getColorOpacity(d.needle),
                        stroke: 'none'
                    })
            );

            this._drawGaugeLabels(paper, gaugeSet, d);
        },

        _createThermometer:function(paper, gaugeSet, d){
            d.thermometerLayout == Constants.HORIZONTAL_LAYOUT
                ? this._createHorizontalThermometer(paper, gaugeSet, d) : this._createVerticalThermometer(paper, gaugeSet, d);

        },

        _createHorizontalThermometer:function(paper, gaugeSet, d){

            var domain = d.gaugeAxis.scale.domain();
            var point = d.points[0];
            if(!point){
                return;
            }

            var valueInDomain = point.valueInDomain;
            var color = point.color;

            var radius = d.radius;
            var scale = d3.scale.linear()
                .domain(domain).range([-radius, radius]);

            gaugeSet.push(
                paper.path(this._getLinePath([-radius,0], [radius,0]))
                    .attr({
                        'fill':'none',
                        'stroke': d.slotBackgroundColor,
                        'stroke-width':THERMOMETER_R * 2,
                        'stroke-linecap':'round'
                    })
            );

            var outerStroke = paper.path(this._getLinePath([-radius,0], [scale(valueInDomain),0]))
                .attr({
                    'fill':'none',
                    'stroke': color,
                    'stroke-width':THERMOMETER_R * 2,
                    'stroke-linecap':'round'
                }).datum(d);

            this.addSeriesEventHandler(outerStroke);
            gaugeSet.push(outerStroke);

            gaugeSet.push(
                paper.circle(scale(valueInDomain), 0, THERMOMETER_R * 0.9)
                    .attr({
                        'fill': d.needle,
                        'fill-opacity':ColorUtils.getColorOpacity(d.needle),
                        'stroke-width': THERMOMETER_R * 0.6,
                        'stroke':ColorUtils.mixColorWithHSB(color, 0, 0.1, -0.1)
                    })

            );

            this._drawGaugeLabels(paper, gaugeSet, d);

            this._drawHorizontalThermometerTicks(paper, gaugeSet, d, scale);
        },

        _drawHorizontalThermometerTicks:function(paper, gaugeSet, d, scale){
            var tickData = d.gaugeAxis.getTickData();

            var axisOption = d.gaugeAxis.componentOption;
            var labelStyle = axisOption.labelStyle;
            var useHtml = axisOption.useHtml;

            var minorTickData = d.gaugeAxis.getMinorTickData();

            var plotBounds = this.component.getPlotBounds();
            var transX = plotBounds.x + d.centerX;
            var transY = plotBounds.y + d.centerY;
            var self = this;

            tickData.forEach(function(tick){

                var x = scale(tick.tickValue);

                gaugeSet.push(
                    paper.path(self._getLinePath([x,-9],[x,-15]))
                        .attr({
                            stroke:axisOption.tickColor,
                            'stroke-width':1
                        })
                );

                if(useHtml){

                    var labelPos = {
                        x:transX + x - tick.tickDim.width/2,
                        y:transY -19 - tick.tickDim.height
                    };

                    self.labelDivManager.addLabel(tick.tickContent, labelPos, labelStyle);

                }else{
                    gaugeSet.push(
                        paper.text(x, -19 - tick.tickDim.height/2, tick.tickContent)
                            .attr(BaseUtils.cssNormalization(labelStyle))

                    );
                }



            });

            minorTickData.forEach(function(value){

                var x = scale(value);

                gaugeSet.push(
                    paper.path(self._getLinePath([x,-9],[x,-13]))
                        .attr({
                            stroke:axisOption.minorTickColor,
                            'stroke-width':1
                        })
                );

            });

        },

        _createVerticalThermometer:function(paper, gaugeSet, d){

            var domain = d.gaugeAxis.scale.domain();
            var point = d.points[0];
            if(!point){
                return;
            }

            var color = point.color;
            var valueInDomain = point.valueInDomain;
            var radius = d.radius;
            var scale = d3.scale.linear()
                .domain(domain).range([radius, -radius]);

            gaugeSet.push(
                paper.path(this._getLinePath([0,radius], [0,-radius]))
                    .attr({
                        'fill':'none',
                        'stroke': d.slotBackgroundColor,
                        'stroke-width':THERMOMETER_R * 2,
                        'stroke-linecap':'round'
                    })
            );

            var outerStroke = paper.path(this._getLinePath([0,radius], [0, scale(valueInDomain)]))
                .attr({
                    'fill':'none',
                    'stroke': color,
                    'stroke-width':THERMOMETER_R * 2,
                    'stroke-linecap':'round'
                }).datum(d);
            this.addSeriesEventHandler(outerStroke);
            gaugeSet.push(outerStroke);

            gaugeSet.push(
                paper.circle(0, scale(valueInDomain), THERMOMETER_R * 0.9)
                    .attr({
                        'fill': d.needle,
                        'fill-opacity':ColorUtils.getColorOpacity(d.needle),
                        'stroke-width': THERMOMETER_R * 0.6,
                        'stroke':ColorUtils.mixColorWithHSB(color, 0, 0.1, -0.1)
                    })

            );

            this._drawGaugeLabels(paper, gaugeSet, d);

            this._drawVerticalThermometerTicks(paper, gaugeSet, d, scale);
        },

        _drawVerticalThermometerTicks:function(paper, gaugeSet, d, scale){

            var tickData = d.gaugeAxis.getTickData();

            var axisOption = d.gaugeAxis.componentOption;
            var labelStyle = axisOption.labelStyle;
            var useHtml = axisOption.useHtml;

            var minorTickData = d.gaugeAxis.getMinorTickData();

            var plotBounds = this.component.getPlotBounds();
            var transX = plotBounds.x + d.centerX;
            var transY = plotBounds.y + d.centerY;
            var self = this;

            tickData.forEach(function(tick){

                var y = scale(tick.tickValue);

                gaugeSet.push(
                    paper.path(self._getLinePath([9,y],[15,y]))
                        .attr({
                            stroke:axisOption.tickColor,
                            'stroke-width':1
                        })
                );

                if(useHtml){

                    var labelPos = {
                        x:transX + 19,
                        y:transY + y - tick.tickDim.height/2
                    };

                    self.labelDivManager.addLabel(tick.tickContent, labelPos, labelStyle);

                }else{
                    gaugeSet.push(
                        paper.text(19, y, tick.tickContent)
                            .attr(BaseUtils.cssNormalization(labelStyle))
                            .attr('text-anchor', 'start')

                    );
                }

            });

            minorTickData.forEach(function(value){

                var y = scale(value);

                gaugeSet.push(
                    paper.path(self._getLinePath([9,y],[13,y]))
                        .attr({
                            stroke:axisOption.minorTickColor,
                            'stroke-width':1
                        })
                );

            });
        },

        _createRing:function(paper, gaugeSet, d){
            var circle = d3.svg.arc()
                .startAngle(0).endAngle(2 * Math.PI)
                .innerRadius(0).outerRadius(d.radius);

            var arc = d3.svg.arc().startAngle(0)
                .innerRadius(0).outerRadius(d.radius);

            var point = d.points[0];
            if(!point){
                return;
            }

            var arcPercentage = Math.max(point.percentage, 0);
            var endRadian = 2 * Math.PI * arcPercentage * (d.clockwise ? 1 : -1);
            var endFill = point.color;
            var innerR = d.radius * 0.8;
            var outerStrokeR = innerR + 2;

            gaugeSet.push(
                paper.path(circle())
                    .attr({
                        fill:d.paneBackgroundColor,
                        'fill-opacity':ColorUtils.getColorOpacity(d.paneBackgroundColor),
                        stroke:'none'
                    })
            );


            var outerRing = paper.path(arc.endAngle(endRadian)())
                .attr({
                    fill:endFill,
                    'fill-opacity':ColorUtils.getColorOpacity(endFill),
                    stroke:'none'
                })
                .datum(d);
            this.addSeriesEventHandler(outerRing);
            gaugeSet.push(outerRing);

            gaugeSet.push(
                paper.path(circle.outerRadius(innerR)())
                    .attr({
                        fill:d.innerPaneBackgroundColor,
                        'fill-opacity':ColorUtils.getColorOpacity(d.innerPaneBackgroundColor),
                        stroke:'none'
                    })
            );

            gaugeSet.push(
                paper.path(circle.outerRadius(outerStrokeR)())
                    .attr({
                        'fill': 'none',
                        'stroke':'#000000',
                        'stroke-opacity':0.05,
                        'stroke-width':4
                    })
            );

            this._drawGaugeLabels(paper, gaugeSet, d);
        },

        _removeAll:function(){
            if(this._bodySet){
                this._bodySet.remove();
            }
            this.labelDivManager.clearAllLabels();
        },

        _getTypes:function(){
            return {
                'mouseover':this._mouseOver,
                'mouseout':this._mouseOut
            };
        }
    });

    require('./RenderLibrary').register(Constants.GAUGE_VML, GaugeVmlRender);
});
/**
 * Created by eason on 15/11/6.
 */
define('render/LineVmlRender',['require','./BaseRender','../utils/BaseUtils','../Constants','./RenderLibrary'],function(require){

    var BaseRender = require('./BaseRender');
    var BaseUtils = require('../utils/BaseUtils');
    var Constants = require('../Constants');


    var LineVmlRender = BaseRender.extend({
        render:function(){

            this._removeAll();

            var paper = this.component.getVanchartRender().getRenderRoot();
            var plotBounds = this.component.getPlotBounds();
            var transX = plotBounds.x;
            var transY = plotBounds.y;

            this._bodySet = paper.set();

            this._lineSet = paper.set();
            this._markerSet = paper.set();
            this._labelSet = paper.set();

            this._bodySet.push(this._lineSet);
            this._bodySet.push(this._markerSet);
            this._bodySet.push(this._labelSet);

            this.markerMap = {};

            var lines = this.component.getVisibleChartData();
            var self = this;
            lines.forEach(function(line){

                var dataBands = line.dataBands;

                var needsClipRect = dataBands.length > 1;

                //先画堆积的面积图,不用移动到最上层
                dataBands.forEach(function(band){
                    var lineData = band.lineData;

                    if(self.component.componentType == Constants.AREA_CHART && lineData.isStack){
                        var area = paper.path(lineData.areaSvg(lineData.points))
                            .attr({
                                'fill':band.fillColor,
                                'fill-opacity':band.fillColorOpacity,
                                'stroke':'none'
                            })
                            .datum(lineData);

                        self.addSeriesEventHandler(area);

                        if(needsClipRect){
                            area.attr('clip-rect', self._getClipRect(band));
                        }

                        self._lineSet.push(area);
                    }
                });
            });

            lines.forEach(function(line){

                var dataBands = line.dataBands;

                var needsClipRect = dataBands.length > 1;

                dataBands.forEach(function(band){

                    var lineData = band.lineData;

                    if(self.component.componentType == Constants.AREA_CHART && !lineData.isStack){

                        var area = paper.path(lineData.areaSvg(lineData.points))
                            .attr({
                                'fill':band.fillColor,
                                'fill-opacity':band.fillColorOpacity,
                                'stroke':'none'
                            })
                            .datum(lineData);

                        self.addSeriesEventHandler(area);

                        if(needsClipRect){
                            area.attr('clip-rect', self._getClipRect(band));
                        }

                        self._lineSet.push(area);

                    }

                    var singleLine = paper
                        .path(lineData.lineSvg(lineData.points))
                        .attr({
                            'fill':'none',
                            'stroke':band.color,
                            'stroke-width':lineData.lineWidth
                        })
                        .datum(lineData);

                    self.addSeriesEventHandler(singleLine);

                    if(needsClipRect){
                        singleLine.attr('clip-rect', self._getClipRect(band));
                    }

                    self._lineSet.push(singleLine);
                });

            });

            lines.forEach(function(line){
                line.points.forEach(function(point){

                    var x = point.x + transX;
                    var y = point.y + transY;

                    var marker = self._createVmlMarker(paper, point, [x,y]);

                    self.markerMap[point.className] = marker;

                    if(marker.marker){
                        self._markerSet.push(marker.marker);
                    }

                    if(marker.strokeMarker){
                        self._markerSet.push(marker.strokeMarker);
                    }
                });
            });

            this._drawDataLabels(paper);

            this._lineSet.transform('t' + plotBounds.x + ',' + plotBounds.y);
        },

        _getClipRect:function(band){

            var plotBounds = this.component.getPlotBounds();

            return (band.x + plotBounds.x) + ',' + (band.y + plotBounds.y) + ',' + band.width + ',' + band.height;
        },

        getElementByData:function(d){

            if(this.markerMap && this.markerMap[d.className]){
                return this.markerMap[d.className];
            }

        },

        mouseOver:function(event){
            if(event && event.target){
                var d = event.target.datum();
                this._makeVmlMarkerChosenState(d);
            }
        },

        mouseOut:function(event){
            if(event && event.target){
                var d = event.target.datum();
                this._cancelVmlMarkerChosenState(d);
            }
        },

        _drawDataLabels:function(paper){

            var lines = this.component.getVisibleChartData();
            var plotBounds = this.component.getPlotBounds();
            var labelSet = this._labelSet;
            var self = this;

            lines.forEach(function(line){

                var points = line.points;

                self._drawVmlDataLabels(paper, labelSet, points, plotBounds.x, plotBounds.y);
            });
        },

        _getTypes:function(){
            return {
                'mouseover':this._mouseOver,
                'mouseout':this._mouseOut,
                'cover':this.mouseOver,
                'leave':this.mouseOut
            }
        },

        _removeAll:function(){
            if(this._bodySet){
                this._bodySet.remove();
            }
            this.labelDivManager.clearAllLabels();
        }
    });
    
    require('./RenderLibrary').register(Constants.LINE_VML, LineVmlRender);

    return LineVmlRender;

});
/**
 * Created by eason on 15/11/6.
 */

define('render/AreaVmlRender',['require','../Constants','./LineVmlRender','./RenderLibrary'],function(require){

    var Constants = require('../Constants');
    var LineVmlRender = require('./LineVmlRender');

    var AreaVmlRender = LineVmlRender.extend({});

    require('./RenderLibrary').register(Constants.AREA_VML, AreaVmlRender);
});
/**
 * Created by eason on 15/9/24.
 */
define('render/BarVmlRender',['require','./BaseRender','../utils/BaseUtils','../utils/ColorUtils','../Constants','./RenderLibrary'],function(require){

    var BaseRender = require('./BaseRender');
    var BaseUtils = require('../utils/BaseUtils');
    var ColorUtils = require('../utils/ColorUtils');
    var Constants = require('../Constants');

    var BarVmlRender = BaseRender.extend({

        render:function(){

            this._removeAll();

            var paper = this.component.getVanchartRender().getRenderRoot();
            var plotBounds = this.component.getPlotBounds();

            this._bodySet = paper.set();
            var barSet = paper.set();
            this._bodySet.push(barSet);

            this.shapeMap = {};

            var clipRect = this._getPlotClipRect();

            var series = this.component.getVisibleChartData();

            for(var i = 0, count = series.length; i < count; i++){
                var points = series[i].points;

                for(var j = 0, len = points.length; j < len; j++){
                    barSet.push(
                        this._createBar(points[j], paper, clipRect)
                    )
                }
            }

            barSet.transform('t' + plotBounds.x + ',' + plotBounds.y);

            this._drawDataLabels(paper);
        },

        _createBar:function(d, paper, clipRect){

            var rect = paper.rect(d.x, d.y, d.width, d.height)
                .attr({
                    rx: d.borderRadius,
                    ry: d.borderRadius,
                    fill:d.color,
                    'fill-opacity':ColorUtils.getColorOpacity(d.color),
                    stroke:d.borderColor,
                    'stroke-width':d.borderWidth
                })
                .datum(d);
            
            this.addShapeEventHandler(rect);

            this.shapeMap[d.className] = rect;

            return rect;
        },

        _getPlotClipRect:function(){

            var clipBounds = this.component.vanchart.getPlotClipBounds();
            var plotBounds = this.component.getPlotBounds();

            var x = plotBounds.x + clipBounds.x;
            var y = plotBounds.y + clipBounds.y;
            var width = clipBounds.width;
            var height = clipBounds.height;

            return x + ',' + y + ',' + width + ',' + height;
        },

        _drawDataLabels:function(paper){

            var series = this.component.getVisibleChartData();
            var plotBounds = this.component.getPlotBounds();


            for(var i = 0, len = series.length; i < len; i++){
                var labelSet = paper.set();
                this._bodySet.push(labelSet);

                var points = series[i].points;

                this._drawVmlDataLabels(paper, labelSet, points, plotBounds.x, plotBounds.y);
            }
        },

        _removeAll:function(){
            if(this._bodySet){
                this._bodySet.remove();
            }
            this.labelDivManager.clearAllLabels();
        },

        getElementByData:function(d){
            return this.shapeMap[d.className];
        },

        mouseOver:function(event){
            if(event && event.target){
                var d = event.target.datum();
                event.target.attr({
                        'stroke': d.mouseOverColor,
                        'stroke-opacity':0.35,
                        'fill':d.mouseOverColor ? d.mouseOverColor : d.color,
                        'stroke-width':6
                    });
            }
        },

        mouseOut:function(event){
            if(event && event.target){
                var d = event.target.datum();
                event.target
                    .attr({
                        'fill':d.color,
                        'fill-opacity':ColorUtils.getColorOpacity(d.color),
                        'stroke':d.borderColor,
                        'stroke-opacity':1,
                        'stroke-width':d.borderWidth
                    });
            }
        },

        mouseDown:function(event){
            if(event && event.target){
                var d = event.target.datum();
                event.target.attr('fill', d.clickColor);
            }
        },

        mouseUp:function(event){
            if(event && event.target){
                var d = event.target.datum();
                event.target.attr('fill', d.mouseOverColor);
            }
        }

    });

    require('./RenderLibrary').register(Constants.BAR_VML, BarVmlRender);
});
/**
 * Created by eason on 15/8/13.
 */
define('render/PieVmlRender',['require','./BaseRender','../utils/BaseUtils','../utils/ColorUtils','../Constants','./RenderLibrary'],function(require){

    var BaseRender = require('./BaseRender');
    var BaseUtils = require('../utils/BaseUtils');
    var ColorUtils = require('../utils/ColorUtils');
    var Constants = require('../Constants');

    var HOVER_PERCENT = 1.1;

    var PieVmlRender = BaseRender.extend({
        render:function(){

            this._removeAll();

            var paper = this.component.getVanchartRender().getRenderRoot();
            var plotBounds = this.component.getPlotBounds();

            this._bodySet = paper.set();
            this.dataMap = {};

            paper.customAttributes.segment = function(innerRadius, outerRadius, startAngle, endAngle, color){
                var arc = d3.svg.arc().innerRadius(innerRadius).outerRadius(outerRadius);
                var attrs = {
                    path: arc({startAngle:startAngle, endAngle:endAngle})
                };

                if(color){
                    attrs.fill = color;
                    attrs['fill-opacity'] = ColorUtils.getColorOpacity(color);
                }

                return attrs;
            };

            var arcMap = this.component.getVisibleChartData();

            for(var i = 0, len = arcMap.length; i < len; i++){
                var config = arcMap[i];

                var pathSet = paper.set();
                this._bodySet.push(pathSet);

                var translateX = plotBounds.x + config.centerX;
                var translateY = plotBounds.y + config.centerY;

                var innerRadius = config.innerRadius;
                var points = config.visiblePoints;

                for(var j = 0, count = points.length; j < count; j++){
                    var point = points[j];
                    var slice = paper.path()
                        .attr({
                            segment:[innerRadius, point.radius, point.startAngle, point.endAngle],
                            fill:point.color,
                            'fill-opacity':ColorUtils.getColorOpacity(point.color),
                            stroke:point.borderColor,
                            'stroke-width':point.borderWidth
                        })
                        .datum(point);

                    this.dataMap[point.className] = slice;

                    this.addShapeEventHandler(slice);

                    pathSet.push(slice);
                }

                pathSet.transform('t' + translateX + ',' + translateY);
            }
            //标签
            this._renderDataLabels(paper);
        },

        _renderDataLabels:function(paper){
            var arcMap = this.component.getVisibleChartData();

            for(var i = 0, len = arcMap.length; i < len; i++){

                var config = arcMap[i];

                var labelSet = paper.set();
                this._bodySet.push(labelSet);

                var plotBounds = this.component.getPlotBounds();
                var transX = plotBounds.x + config.centerX;
                var transY = plotBounds.y + config.centerY;

                var points = config.visiblePoints;

                this._drawVmlDataLabels(paper, labelSet, points, transX, transY);
            }
        },

        _removeAll:function(){
            if(this._bodySet){
                this._bodySet.remove();
            }
            this.labelDivManager.clearAllLabels();
        },

        mouseOver:function(event){
            if(event && event.target){
                var d = event.target.datum();
                var startAngle = d.startAngle;
                var endAngle = d.endAngle;
                var innerRadius = d.innerRadius;
                var radius = d.radius;
                var color = d.mouseOverColor ? d.mouseOverColor : d.color;
                event.target.attr({segment: [innerRadius, radius * HOVER_PERCENT, startAngle, endAngle, color]});
            }
        },

        mouseOut:function(event){
            if(event && event.target){
                var d = event.target.datum();

                var startAngle = d.startAngle;
                var endAngle = d.endAngle;
                var innerRadius = d.innerRadius;
                var radius = d.radius;

                event.target.attr({segment: [innerRadius, radius, startAngle, endAngle, d.color]});
            }
        },

        _getTypes:function(){
            return {
                'mouseover':this._mouseOver,
                'mouseout':this._mouseOut
            }
        },

        onDragStart:function(){

        },

        onDrag:function(){

        },

        onDragEnd:function(){
            
        }

    });

    require('./RenderLibrary').register(Constants.PIE_VML, PieVmlRender);

    return PieVmlRender;
});
/**
 * Created by Mitisky on 16/3/14.
 */
define('render/BubbleVmlRender',['require','./BaseRender','../utils/BaseUtils','../Constants','./RenderLibrary'],function(require){
    var BaseRender = require('./BaseRender');
    var BaseUtils = require('../utils/BaseUtils');
    var Constants = require('../Constants');

    var BubbleVmlRender = BaseRender.extend({

        render:function(){
            this._removeAll();

            var paper = this.component.getVanchartRender().getRenderRoot();

            this._bodySet = paper.set();

            this.shapeMap = {};
            this._createBubbles(paper);
        },

        filterRender: function () {
            this.render();
        },

        _createBubbles:function(paper){
            var plotBounds = this.component.getPlotBounds();
            var seriesS = this.component.getVisibleChartData();

            var bubbleSet = paper.set();

            var transX = plotBounds.x;
            var transY = plotBounds.y;

            for(var i = 0, count = seriesS.length; i < count; i++){
                var sery = seriesS[i];

                this._createSeriesLine(paper, sery, transX, transY);

                var points = sery.points;
                for(var j = 0, len = points.length; j < len; j++){
                    var point = points[j];
                    if(point.visible) {
                        bubbleSet.push(
                            this._createPoint(point, paper, transX, transY)
                        );
                    }
                }

                var labelSet = paper.set();
                this._bodySet.push(labelSet);
                this._drawVmlDataLabels(paper, labelSet, points, transX, transY);
            }

            this._bodySet.push(bubbleSet);
        },

        _createSeriesLine: function (paper, sery, transX, transY) {
        },

        _createPoint:function(point, paper, transX, transY){
            var plotBounds = this.component.getPlotBounds();

            var clipY = plotBounds.y + 5;

            var bubble = paper.path(d3.svg.arc().outerRadius(point.radius)({startAngle:0, endAngle:2 * Math.PI}))
                .attr({
                    'fill':point.color,
                    'fill-opacity':point.fillColorOpacity,
                    'stroke-width':0
                })
                .datum(point)
                .transform('t' + (point.posX + transX) + ',' + (point.posY + transY));
            
            this.addShapeEventHandler(bubble);

            this.shapeMap[point.className] = bubble;

            return bubble;
        },

        _removeAll:function(){
            if(this._bodySet){
                this._bodySet.remove();
            }
            this.labelDivManager.clearAllLabels();
        },

        mouseOver:function(event){
            if(this.component.isLargeMode()){
                return;
            }
            if(event && event.target){
                var d = event.target.datum();
                event.target.attr({
                        'stroke': d.mouseOverColor,
                        'stroke-opacity':0.35,
                        'stroke-width':6,
                        'fill':d.mouseOverColor,
                        'fill-opacity': 0.65
                    });
            }
        },

        mouseOut:function(event){
            if(this.component.isLargeMode()){
                return;
            }

            if(event && event.target){
                var d = event.target.datum();
                event.target
                    .attr({
                        'fill':d.color,
                        'fill-opacity':d.fillColorOpacity,
                        'stroke-width':0
                    });
            }
        },

        mouseDown:function(event){

            if(this.component.isLargeMode()){
                return;
            }

            if(event && event.target){
                var d = event.target.datum();
                event.target.attr('fill', d.clickColor);
            }
        },

        mouseUp:function(event){
            if(event && event.target){
                var d = event.target.datum();
                event.target.attr('fill', d.mouseOverColor);
            }
        }
    });

    require('./RenderLibrary').register(Constants.BUBBLE_VML, BubbleVmlRender);

    return BubbleVmlRender;
});

/**
 * Created by Mitisky on 16/3/24.
 */
define('render/ScatterVmlRender',['require','./BubbleVmlRender','../utils/BaseUtils','../Constants','./RenderLibrary'],function(require){
    var BubbleVmlRender = require('./BubbleVmlRender');
    var BaseUtils = require('../utils/BaseUtils');
    var Constants = require('../Constants');

    var ScatterVmlRender = BubbleVmlRender.extend({
        _createSeriesLine: function (paper, sery, transX, transY) {
            var plotBounds = this.component.getPlotBounds();

            var singleLine = paper
                .path(sery.lineSvg(sery.points))
                .transform('t' + transX + ',' + transY)
                .attr({
                    'fill':'none',
                    'stroke':sery.color,
                    'stroke-width':sery.lineWidth
                })
                .datum(sery);

            this._bodySet.push(singleLine);
        },

        _createPoint:function(point, paper, transX, transY){

            var x = point.posX + transX;
            var y = point.posY + transY;

            var marker = this._createVmlMarker(paper, point, [x,y]);

            this.shapeMap[point.className] = marker;

            return marker.marker;
        },

        getElementByData:function(d){
            if(this.shapeMap && this.shapeMap[d.className]){
                return this.shapeMap[d.className];
            }
        },

        mouseOver:function(event){
            if(event && event.target){
                var d = event.target.datum();
                this._makeVmlMarkerChosenState(d);
            }
        },

        mouseOut:function(event){
            if(event && event.target){
                var d = event.target.datum();
                this._cancelVmlMarkerChosenState(d);
            }
        },

        _getTypes:function(){
            return {
                'mouseover':this._mouseOver,
                'mouseout':this._mouseOut
            }
        }
    });
    
    require('./RenderLibrary').register(Constants.SCATTER_VML, ScatterVmlRender);

    return ScatterVmlRender;
});

/**
 * Created by eason on 16/5/9.
 */
define('render/MapVmlRender',['require','../utils/BaseUtils','../Constants','./BaseRender','./RenderLibrary'],function(require){

    var BaseUtils = require('../utils/BaseUtils');
    var Constants = require('../Constants');
    var BaseRender = require('./BaseRender');

    var MapVmlRender = BaseRender.extend({

    });

    require('./RenderLibrary').register(Constants.MAP_VML, MapVmlRender);
});
/**
 * Created by eason on 16/5/17.
 */
define('render/DrillToolsVmlRender',['require','./BaseRender','../Constants','./RenderLibrary'],function(require){

    var BaseRender = require('./BaseRender');
    var Constants = require('../Constants');

    var DrillToolsVmlRender = BaseRender.extend({

    });

    require('./RenderLibrary').register(Constants.DRILL_TOOLS_VML, DrillToolsVmlRender);

    return DrillToolsVmlRender;
});
/**
 * Created by eason on 15/10/12.
 */

define('render/DataSheetVmlRender',['require','./BaseRender','../utils/BaseUtils','../Constants','./LegendIconFactory','./RenderLibrary'],function(require){

    var BaseRender = require('./BaseRender');
    var BaseUtils = require('../utils/BaseUtils');
    var Constants = require('../Constants');
    var LegendIconFactory = require('./LegendIconFactory');

    var DataSheetVmlRender = BaseRender.extend({

        render:function(){

            if(this.componentSet){
                return;
            }

            var paper = this.component.getVanchartRender().getRenderRoot();

            var axis = this.component.vanchart.xAxis();
            var categories = axis.getCategories();
            var unitLength = this.component.getPlotBounds().width / categories.length;

            var seriesWidth = this.component.getMaxSeriesWidth();
            var categoryHeight = this.component.getCategoryHeight();

            var transX = this.component.bounds.x;
            var transY = this.component.bounds.y;


            this.componentSet = paper.set();
            this.iconSet = paper.set();

            this._drawLines(paper, seriesWidth, categoryHeight, unitLength);

            this._drawCategory(paper, seriesWidth, categoryHeight, unitLength);

            this._drawSeries(paper, seriesWidth, categoryHeight, transX, transY);

            this._drawValues(paper, seriesWidth, categoryHeight, unitLength);

            this.componentSet.transform('t' + transX + ',' + transY);
        },

        _drawLines:function(paper, seriesWidth, categoryHeight, unitLength){

            var lineG = paper.set();
            this.componentSet.push(lineG);

            var cfg = this.component.componentOption;

            var endX = this.component.bounds.width;
            var endY = this.component.bounds.height;
            var style = {
                fill:'none',
                stroke:cfg.borderColor,
                'stroke-width':cfg.borderWidth
            };

            lineG.push(paper.path('M' + seriesWidth + ',0' + 'L' + endX + ',0' + 'L' + endX + ' ' + endY + 'L0' + ',' + endY + 'L0' + ',' + categoryHeight));

            var cateCount = this.component.categoryNames.length;

            var startX = seriesWidth;

            for(var i = 0; i < cateCount; i++){
                lineG.push(paper.path(this._getLinePath([startX,0], [startX, endY])));
                startX += unitLength;
            }

            var seriesCount = this.component.seriesNames.length;
            var height = categoryHeight;

            for(var i = 0; i < seriesCount; i++){
                lineG.push(paper.path(this._getLinePath([0,height], [endX, height])));

                height += this.component.getSeriesHeight(i);
            }

            lineG.attr(style);
        },

        _drawValues:function(paper, seriesWidth, categoryHeight, unitLength){

            var valueG = paper.set();
            this.componentSet.push(valueG);

            var values = this.component.values;

            var valueStyle = this.component._valueStyle();
            var valueLineHeight = BaseUtils.getTextHeight(valueStyle);
            var textPadding = this.component.getTextPadding();
            var startX = seriesWidth;
            var startY = categoryHeight;

            for(var lineIndex = 0; lineIndex < values.length; lineIndex++){
                var singleLine = values[lineIndex];

                var valueHeight = this.component.getSeriesHeight(lineIndex);

                for(var valueIndex = 0; valueIndex < singleLine.length; valueIndex++){

                    var singleName = singleLine[valueIndex];

                    if (!singleName) {
                        continue;
                    }

                    var firstY = startY + this._getStartY(singleName, valueStyle, valueHeight) + valueLineHeight * 0.5;

                    for(var i = 0; i < singleName.length; i++){


                        valueG.push(

                            paper.text(startX + unitLength/2 + unitLength * valueIndex,
                                firstY + (valueLineHeight + textPadding) * i,
                                singleName[i])

                        );
                    }
                }

                startY += valueHeight;
            }

            valueStyle = BaseUtils.cssNormalization(valueStyle);
            valueStyle['text-anchor'] = 'middle';

            valueG.attr(valueStyle);
        },

        _drawCategory:function(paper, seriesWidth, categoryHeight, unitLength){

            var categoryG = paper.set();
            this.componentSet.push(categoryG);

            var categoryNames = this.component.categoryNames;

            var startX = seriesWidth;

            var categoryStyle = this.component._categoryStyle();

            var categoryLineHeight = BaseUtils.getTextHeight(categoryStyle);
            var textPadding = this.component.getTextPadding();

            for(var index = 0, cCount = categoryNames.length; index < cCount; index++){

                var singleName = categoryNames[index];

                var startY = this._getStartY(singleName, categoryStyle, categoryHeight) + categoryLineHeight * 0.5;

                for(var i = 0; i < singleName.length; i++){

                    categoryG.push(
                        paper.text(startX + unitLength/2 + unitLength * index, startY + (categoryLineHeight + textPadding) * i, singleName[i])
                    );

                }

            }

            categoryStyle = BaseUtils.cssNormalization(categoryStyle);
            categoryStyle['text-anchor'] = 'middle';

            categoryG.attr(categoryStyle);
        },

        _drawSeries:function(paper, seriesWidth, categoryHeight, transX, transY){

            var seriesG = paper.set();
            var itemG = paper.set();
            this.componentSet.push(seriesG);
            this.componentSet.push(itemG);

            var seriesNames = this.component.seriesNames;

            var startX = 16 + (seriesWidth - 16) / 2;
            var startY = categoryHeight;

            var seriesStyle = this.component._seriesStyle();
            var seriesLineHeight = BaseUtils.getTextHeight(seriesStyle);
            var textPadding = this.component.getTextPadding();

            for(var index = 0, sCount = seriesNames.length; index < sCount; index++){

                var singleName = seriesNames[index];
                var seriesHeight = this.component.getSeriesHeight(index);

                var firstY = startY + this._getStartY(singleName, seriesStyle, seriesHeight) + seriesLineHeight * 0.5;

                for(var i = 0; i < singleName.length; i++){

                    seriesG.push(
                        paper.text(startX, firstY + (seriesLineHeight + textPadding) * i, singleName[i])
                    );

                }

                var iconType = this.component.getLegendIconTypeWithSeriesIndex(index);
                var iconHeight = LegendIconFactory.getLegendIconSize(iconType).height;

                var tmpX = 2 + transX;
                var tmpY = (seriesHeight - iconHeight)/2 + startY + transY;

                this.iconSet.push(
                    paper.path(LegendIconFactory.getLegendIconPath(iconType))
                        .attr({
                            'fill' : this.component._getDefaultSeriesColor(singleName[0]),
                            'stroke' : 'none'
                        })
                        .transform('t' + tmpX +',' + tmpY )

                );

                startY += seriesHeight;
            }


            seriesStyle = BaseUtils.cssNormalization(seriesStyle);
            seriesStyle['text-anchor'] = 'middle';
            seriesG.attr(seriesStyle);
        },

        _getStartY:function(textArray, style, boxHeight){

            var textPadding = this.component.getTextPadding();

            var textCount = textArray.length;

            var textHeight = BaseUtils.getTextHeight(style) * textCount + (textCount - 1) * textPadding;

            return (boxHeight - textHeight) / 2;
        },

        remove:function(){
            this.componentSet && this.componentSet.remove();
            this.iconSet && this.iconSet.remove();
        }

    });

    require('./RenderLibrary').register(Constants.DATA_SHEET_VML, DataSheetVmlRender);
});
/**
 * Created by eason on 15/8/24.
 */

define('render/ToolbarVmlRender',['require','./BaseRender','../Constants','./RenderLibrary'],function(require){

    var BaseRender = require('./BaseRender');
    var Constants = require('../Constants');

    var ToolbarVmlRender = BaseRender.extend({
        render:function(){
            var cfg = this.component.componentOption;

            if(!cfg.enabled){
                return;
            }

            //todo 下次再改吧
            if(this.component.refreshIcon.iconRender.itemSet){

                this.toFront();

            }else{

                var paper = this.component.getVanchartRender().getRenderRoot();

                if(this.component.menuIcon){
                    this.component.menuIcon.render(paper);
                }

                this.component.refreshIcon.render(paper);

                var toolbarIcons = this.component.getToolbarIcons();

                for(var i = 0, len = toolbarIcons.length; i < len; i++){
                    toolbarIcons[i].render(paper);
                }
            }
        },

        hide:function(){
            var toolbarIcons = this.component.getToolbarIcons();
            var iconSize = toolbarIcons.length;

            for(var i = 0; i < iconSize; i++){
                toolbarIcons[i].hideIcon();
            }

            var refreshIcon = this.component.getRefreshIcon();

            var left = 4 * (iconSize + 1) ;
            var right = 4 * (iconSize + 1) + 33 * iconSize;

            if(refreshIcon.visible){
                refreshIcon.refreshMove(left, right);
            }
        },

        show:function(){
            var toolbarIcons = this.component.getToolbarIcons();
            var iconSize = toolbarIcons.length;

            for(var i = 0; i < iconSize; i++){
                toolbarIcons[i].showIcon();
            }

            var refreshIcon = this.component.getRefreshIcon();

            var left = 4 * (iconSize + 1) + 33 * iconSize;
            var right = 4 * (iconSize + 1);

            if(refreshIcon.visible){
                refreshIcon.refreshMove(left, right);
            }
        },

        toFront:function(iconRender){
            if(iconRender){
                iconRender.itemSet.toFront();
            } else {
                if(this.component.menuIcon){
                    this.toFront(this.component.menuIcon.iconRender)
                }

                this.toFront(this.component.refreshIcon.iconRender);

                var toolbarIcons = this.component.getToolbarIcons();

                for(var i = 0, len = toolbarIcons.length; i < len; i++){
                    this.toFront(toolbarIcons[i].iconRender);
                }
            }
        }
    });

    require('./RenderLibrary').register(Constants.TOOLBAR_VML, ToolbarVmlRender);
    return ToolbarVmlRender;
});
/**
 * Created by eason on 15/8/14.
 */

define('render/LegendVmlRender',['require','./BaseRender','../utils/BaseUtils','../Constants','./LegendIconFactory','./RenderLibrary'],function(require){

    var BaseRender = require('./BaseRender');
    var BaseUtils = require('../utils/BaseUtils');
    var Constants = require('../Constants');
    var LegendIconFactory = require('./LegendIconFactory');

    var ENABLED_COLOR = 'rgb(67,67,72)';
    var DISABLED_COLOR = 'rgb(204,204,204)';

    var LegendVmlRender = BaseRender.extend({
        render:function(){

            if(!this.component.componentOption.initState){
                this.refreshRestore();
                this.component.componentOption.initState = true;
            }else{
                this.background.forEach(function(element){
                    BaseUtils.toFront(element.node);
                });

                this.pageButton.forEach(function(element){
                    BaseUtils.toFront(element.node);
                });

                this.rectSet.forEach(function(element){
                    BaseUtils.toFront(element.node);
                });

                this.markerSet.forEach(function(element){
                    BaseUtils.toFront(element.node);
                });

                this.labelSet.forEach(function(element){
                    BaseUtils.toFront(element.node);
                });
            }

        },

        _render:function(){

            var option = this.component.componentOption;
            var bounds = this.component.bounds;
            var paper = this.component.getVanchartRender().getRenderRoot();

            this._renderVmlBackground(this.background, paper, option, bounds);

            this.component.isHorizontal() ? this._renderHorizontal(paper) : this._renderVertical(paper);
        },

        _renderWithPages:function(paper){

            var pages = this.component.getVerticalPages();

            this._renderWithoutPages(paper, pages[0], 0);

            var x = this.component.bounds.x;
            var y = this.component.bounds.y;

            var width = this.component.bounds.width;
            var height = this.component.bounds.height;
            height -= this.component.getButtonHeight();

            var buttonWidth = 40;
            var leftButtonTopX = x + (width - buttonWidth) / 2;
            var rightButtonTopX = x + (width + buttonWidth) / 2;
            var topY = y + height + this.component.getPadding();
            var labelX = x + width/2;

            var pageCount = pages.length;


            var label = paper.text(labelX, topY, '1/' + pageCount)
                .attr({
                    "textAnchor":"middle",
                    'font-family': 'Verdana',
                    'font-size': '14'
                });

            var pageIndex = 0;

            var self = this;

            var leftButton = paper.path(this._prePageButtonPath(leftButtonTopX, topY))
                .attr({
                    cursor:'pointer',
                    fill:DISABLED_COLOR,
                    stroke:'none'
                })
                .click(function(){
                    if(pageIndex <= 0){
                        return;
                    }

                    pageIndex--;
                    var showIndex = pageIndex + 1;
                    label.attr('text', showIndex + "/" + pageCount);

                    self._clearAllLegendItems();
                    self._renderWithoutPages(paper, pages[pageIndex], self._preItemCount(pageIndex));

                    rightButton.attr('fill', pageIndex == pageCount - 1 ? DISABLED_COLOR : ENABLED_COLOR)
                    leftButton.attr('fill', pageIndex <= 0 ? DISABLED_COLOR : ENABLED_COLOR);

                });

            var rightButton = paper.path(this._nextPageButtonPath(rightButtonTopX, topY))
                .attr({
                    cursor:'pointer',
                    fill:ENABLED_COLOR,
                    stroke:'none'
                })
                .click(function(){
                    if(pageIndex == pageCount - 1){
                        return;
                    }

                    pageIndex++;
                    var showIndex = pageIndex + 1;
                    label.attr('text', showIndex + "/" + pageCount);

                    self._clearAllLegendItems();
                    self._renderWithoutPages(paper, pages[pageIndex], self._preItemCount(pageIndex));

                    rightButton.attr('fill', pageIndex == pageCount - 1 ? DISABLED_COLOR : ENABLED_COLOR);
                    leftButton.attr('fill', pageIndex <= 0 ? DISABLED_COLOR : ENABLED_COLOR)
                })

            this.pageButton.push(label);
            this.pageButton.push(leftButton);
            this.pageButton.push(rightButton);
        },

        _preItemCount:function(pageIndex){

            var pages = this.component.getVerticalPages();

            var count = 0;
            for(var i = 0; i < pageIndex; i++){
                count += pages[i].length;
            }

            return count;
        },

        _prePageButtonPath:function(topX, topY){
            var edge = 12;

            var leftBottomX = topX - edge / 2;
            var leftBottomY = (edge / 2) * Math.sqrt(3) + topY;

            var rightBottomX = topX + edge / 2;
            var rightBottomY = leftBottomY;

            return 'M' + topX + ',' + topY + 'L' + leftBottomX + ',' + leftBottomY + 'L' + rightBottomX + ',' + rightBottomY + 'Z';
        },

        _nextPageButtonPath:function(topX, topY){
            var edge = 12;

            var topLeftX = topX - edge/2;
            var topLeftY = topY;

            var topRightX = topX + edge/2;
            var topRightY = topY;

            var bottomX = topX;
            var bottomY = (edge / 2) * Math.sqrt(3) + topY;

            return 'M' + topLeftX + ',' + topLeftY + 'L' + topRightX + ',' + topRightY + 'L' + bottomX + ',' + bottomY + 'Z';
        },

        _renderWithoutPages:function(paper, items, startIndex){

            items = items || this.component.getLegendItems();
            startIndex = startIndex || 0;

            var cfg = this.component.componentOption;

            var PADDING = this.component.getPadding() + this.component.verticalAlign;
            var GAP = this.component.getGap();

            var x = this.component.bounds.x;
            var y = this.component.bounds.y;
            var boundsWidth = this.component.bounds.width;

            var textStyle = BaseUtils.cssNormalization(cfg.style);

            for(var i = 0, len = items.length; i < len; i++){
                var d = items[i];

                var iconSize = LegendIconFactory.getLegendIconSize(d.legendIconType);
                var labelDim = BaseUtils.getTextDimension(d.itemName, cfg.style, true);
                var detY = Math.max(iconSize.height, labelDim.height)/2;

                var dataIndex = startIndex + i;
                var preHeight = this.component.getPreHeight(startIndex, dataIndex);
                var itemHeight = this.component.getVerticalItemHeight(dataIndex);

                var iconX = x + PADDING;
                var iconY = y + preHeight;

                var rect = paper.rect(x, iconY + detY - iconSize.height/2, boundsWidth, itemHeight)
                    .attr({
                        fill:'white',
                        'fill-opacity':0,
                        stroke:'none'
                    });

                var markerColor = d.visible ? d.color : d.hiddenColor;

                var textColor = d.visible ? cfg.style.color : d.hiddenColor;

                var marker = paper.path(LegendIconFactory.getLegendIconPath(d.legendIconType))
                    .attr('fill', markerColor)
                    .attr('stroke-width', 0)
                    .transform('t' + iconX + ',' + (iconY + detY - iconSize.height/2));

                var label = paper.text(iconX + iconSize.width + GAP, iconY + detY, d.itemName)
                    .attr('text-anchor', 'start')
                    .attr(textStyle)
                    .attr('fill', textColor);


                this._bindDataAndMarkerEvent(rect, d, i);
                this._bindDataAndMarkerEvent(marker, d, i);
                this._bindDataAndLabelEvent(label, d, i);

                this.rectSet.push(rect);
                this.markerSet.push(marker);
                this.labelSet.push(label);
            }
        },

        _clearAllLegendItems:function(){

            this.markerSet.forEach(function(element){
                element.remove();
            });

            this.labelSet.forEach(function(element){
                element.remove();
            });

            this.rectSet.forEach(function(element){
                element.remove();
            });

            this.markerSet = [];
            this.labelSet = [];
            this.rectSet = [];
        },

        _renderVertical:function(paper){
            this.component.hasEnoughVerticalSpace() ? this._renderWithoutPages(paper) : this._renderWithPages(paper);
        },

        _renderHorizontal:function(paper){

            var PADDING = this.component.getPadding();
            var HORIZONTAL_GAP = this.component.getHorizontalGap();
            var GAP = this.component.getGap();

            var lineItems = this.component.getHorizontalLineItems();

            var cfg = this.component.componentOption;
            var textStyle = BaseUtils.cssNormalization(cfg.style);

            var lineHeight = this.component.getLineHeight();

            var boundsWidth = this.component.bounds.width;

            var boundsX = this.component.bounds.x;
            var boundsY = this.component.bounds.y;

            var y = boundsY + PADDING;

            var itemIndex = 0;

            for(var lineIndex = 0, len = lineItems.length; lineIndex < len; lineIndex++){

                var items = lineItems[lineIndex];

                var itemsWidth = this.component.getHorizontalItemsWidth(items);

                var x = boundsX + (boundsWidth - itemsWidth) / 2;

                var startX = [x];

                for(var i = 1, count = items.length; i < count; i++){
                    var preItem = items[i - 1];
                    var iconSize = LegendIconFactory.getLegendIconSize(preItem.legendIconType);
                    var labelDim = BaseUtils.getTextDimension(preItem.itemName, cfg.style, true);
                    x += iconSize.width + GAP + labelDim.width + HORIZONTAL_GAP;
                    startX.push(x);
                }

                for(var i = 0, count = items.length; i < count; i++){

                    var d = items[i];
                    var iconSize = LegendIconFactory.getLegendIconSize(d.legendIconType);
                    var labelDim = BaseUtils.getTextDimension(d.itemName, cfg.style, true);
                    var detY = Math.max(iconSize.height, labelDim.height)/2;

                    var itemWidth = this.component.getHorizontalItemWidth(i);
                    var itemHeight = lineHeight[lineIndex] + PADDING;

                    var rect = paper.rect(startX[i], (y + detY - iconSize.height/2), itemWidth, itemHeight)
                        .attr({
                            fill:'white',
                            'fill-opacity':0,
                            stroke:'none'
                        });

                    var markerColor = d.visible ? d.color : d.hiddenColor;

                    var textColor = d.visible ? cfg.style.color : d.hiddenColor;

                    var marker = paper.path(LegendIconFactory.getLegendIconPath(d.legendIconType))
                        .attr('fill', markerColor)
                        .attr('stroke-width', 0)
                        .transform('t' + startX[i] + ',' + (y + detY - iconSize.height/2));

                    var label = paper.text(startX[i] + iconSize.width + GAP, (y + detY), d.itemName)
                        .attr('text-anchor', 'start')
                        .attr(textStyle)
                        .attr('fill', textColor);;

                    this._bindDataAndMarkerEvent(rect, d, itemIndex);
                    this._bindDataAndMarkerEvent(marker, d, itemIndex);
                    this._bindDataAndLabelEvent(label, d, itemIndex);

                    itemIndex++;

                    this.rectSet.push(rect);
                    this.markerSet.push(marker);
                    this.labelSet.push(label);

                }

                y += lineHeight[lineIndex] + PADDING;
            }
        },

        _clickHandler:function(d, index){

            var vanchart = this.component.vanchart;
            var cfg = this.component.componentOption;

            var series = d.series;
            var name = d.itemName;

            vanchart.series.map(function(sery){

                if(sery.type == Constants.PIE_CHART){

                    sery.points.map(function(point){
                        if(point.seriesName == name){
                            point.visible = !point.visible;
                        }
                    });

                    sery.updateVisiblePoints();

                } else {
                    if (sery.name === name) {
                        sery.visible = !sery.visible;
                    }
                }
            });

            vanchart.currentOption.byClassName = true;
            vanchart.refreshComponentsAndSeries();

            d.visible = !d.visible;

            var markerColor = d.visible ? d.color : d.hiddenColor;
            this.markerSet[index].attr('fill', markerColor);

            var textColor = d.visible ? cfg.style.color : d.hiddenColor;
            this.labelSet[index].attr('fill', textColor);
        },

        _bindDataAndMarkerEvent:function(element, data, index){

            element.data('data', data);
            element.attr('cursor', 'pointer');

            var self = this;
            element.click(function(){
                self._clickHandler(data, index);
            });

        },

        _bindDataAndLabelEvent:function(element, data, index){
            var cfg = this.component.componentOption;

            element.data('data', data);
            element.attr('cursor', 'pointer');

            element.mousemove(function(){
                this.attr('fill', data.hoverColor);
            });

            element.mouseout(function(){
                var textColor = data.visible ? cfg.style.color : data.hiddenColor;
                this.attr('fill', textColor);
            });

            var self = this;
            element.click(function(){
                self._clickHandler(data, index);
            });

        },

        refreshRestore:function(){
            this.remove();
            this.background = [];
            this.pageButton = [];

            this._render();
        },

        remove:function(){
            this._clearAllLegendItems();

            this.background.forEach(function(element){
                element.remove();
            });

            this.pageButton.forEach(function(element){
                element.remove();
            });
        }
    });

    LegendVmlRender.addInitHook(function(){
        this.markerSet = [];
        this.labelSet = [];
        this.rectSet = [];
        this.pageButton = [];
        this.background = [];
    });

    require('./RenderLibrary').register(Constants.LEGEND_VML, LegendVmlRender);

    return LegendVmlRender;
});
/**
 * Created by Yuqian on 16/5/10.
 */

define('render/AngleAxisVmlRender',['require','./BaseRender','../utils/BaseUtils','../utils/BezierEasing','../Constants','../utils/ColorUtils','./RenderLibrary'],function(require){

    var BaseRender = require('./BaseRender');
    var BaseUtils = require('../utils/BaseUtils');
    var BezierEasing = require('../utils/BezierEasing');
    var Constants = require('../Constants');
    var ColorUtils = require('../utils/ColorUtils');

    var AngleAxisVmlRender = BaseRender.extend({
        render: function () {

            this._removeAll();

            var paper = this.component.polar.getVanchartRender().getRenderRoot();

            var center = this.component.polar.center;

            this._axisSet = paper.set();

            this.markerMap = {};

            this._drawAxisLine(paper, center);

            this._drawGridLine(paper, center);

            this._drawTickLabel(paper, center);

        },

        _removeAll:function(){

            if(this._axisSet){
                this._axisSet.remove();
            }

            this.labelDivManager.clearAllLabels();
        },

        _drawAxisLine:function(paper, center){
            var radiusAxis = this.component.polar.radiusAxis;

            var angleAxis = this.component;
            var lineWidth = angleAxis.componentOption.lineWidth;
            var lineColor = angleAxis.componentOption.lineColor;
            var maxValue = radiusAxis.scale.domain()[1];

            this._axisSet.push(
                paper.path(radiusAxis._getRadiusGridPath(maxValue))
                    .attr({
                        'fill':'none',
                        'stroke':lineColor,
                        'stroke-width':lineWidth
                    })
                    .transform(BaseUtils.makeTranslate(center))
            );

        },

        _drawGridLine:function(paper, center){

            var cfg = this.component.polar.radiusAxis.componentOption;
            var lineWidth = cfg.lineWidth;
            var lineColor = cfg.lineColor;

            var axisLineData = this.component.getAngleGridLineData();

            var self = this;
            axisLineData.forEach(function (d) {

                self._axisSet.push(
                    paper.path(self._getLinePath([0, 0], d))
                        .attr({
                            'fill': 'none',
                            'stroke': lineColor,
                            'stroke-width': lineWidth
                        })
                        .transform(BaseUtils.makeTranslate(center))
                );

            });

        },

        _drawTickLabel:function(paper, radarCenter){
            var angleAxis = this.component;
            var cfg = angleAxis.componentOption;

            var labelStyle = cfg.labelStyle;
            var labelRotation = cfg.labelRotation || 0;
            var useHtml = cfg.useHtml;

            var ticks = angleAxis.tickData;
            var lineHeight = BaseUtils.getTextHeight(labelStyle);

            if(useHtml && !labelRotation){

                var center = angleAxis.polar.center;

                for(var i = 0, len = ticks.length; i < len; i++){

                    var tick = ticks[i];

                    var x = tick.tickPos.x + center[0];
                    var y = tick.tickPos.y + center[1];

                    this.labelDivManager.addLabel(tick.tickContent, {x:x, y:y}, labelStyle);
                }

            }else{

                if (cfg.showLabel) {
                    for (var i = 0, count = ticks.length; i < count; i++) {

                        var tick = ticks[i];
                        var tickContent = tick.tickContent;

                        if (BaseUtils.isArray(tickContent)) {

                            var startX = radarCenter[0] + tick.tickPos.x;
                            var startY = radarCenter[1] + tick.tickPos.y + lineHeight / 2;

                            var dx = tick.tickPos.x < 0 ? tick.tickDim.width : 0;
                            var textAnchor = tick.tickPos.x < 0 ? 'end' : 'start';
                            var x = dx + startX;

                            for (var j = 0, len = tickContent.length; j < len; j++) {

                                var y = startY + j * (1.3 * lineHeight);
                                var t_content = tickContent[j];

                                this._axisSet.push(
                                    paper.text(x, y, t_content)
                                        .attr(BaseUtils.cssNormalization(labelStyle))
                                        .attr('text-anchor', textAnchor)
                                        .transform('t' + labelRotation)
                                );
                            }

                        } else {

                            var rx = radarCenter[0] + tick.tickPos.x + tick.tickDim.width / 2;

                            var ry = radarCenter[1] + tick.tickPos.y + tick.tickDim.height / 2;

                            this._axisSet.push(
                                paper.text(rx, ry, tickContent)
                                    .attr(BaseUtils.cssNormalization(labelStyle))
                                    .transform('r' + labelRotation)
                            );
                        }
                    }
                }
            }
        },

        removeHighlightBand:function(){

            var paper = this.component.getVanchartRender().getRenderRoot();
            var band = paper.getById(this.highlightBandID);
            band && band.remove();

        },

        drawHighlightBand:function(pos){
            var axis = this.component;
            if (!axis._getBandByPosition) {
                return;
            }

            var paper = this.component.getVanchartRender().getRenderRoot();

            var center = this.component.polar.center;

            var drawBand = axis._getBandByPosition(pos);
            var highlightType = axis.getHighlightType();

            this.removeHighlightBand();

            switch (highlightType) {
                case 'band':
                    var highlightBand =
                        paper.path(drawBand.d)
                            .attr({
                                'stroke':'none',
                                'fill': 'rgb(98,179,240)',
                                'fill-opacity': 0.2
                            })
                            .transform(BaseUtils.makeTranslate(center));

                    this.highlightBandID = highlightBand.id;

                    this._axisSet.push(highlightBand);

                    break;
                case 'line':
                default:
                    var highlightBand =
                        paper.path(this._getLinePath([0, 0], [drawBand.x, drawBand.y]))
                            .attr({
                                'stroke': 'rgb(140,140,140)',
                                'stroke-width': 1
                            })
                            .transform(BaseUtils.makeTranslate(center));

                    this.highlightBandID = highlightBand.id;

                    this._axisSet.push(highlightBand);
            }
        },

        remove:function(){
            this._removeAll();
        }
    });

    require('./RenderLibrary').register(Constants.ANGLE_AXIS_VML, AngleAxisVmlRender);
});
/**
 * Created by Yuqian on 16/5/10.
 */

define('render/RadiusAxisVmlRender',['require','./BaseRender','../utils/BaseUtils','../utils/BezierEasing','../Constants','../utils/ColorUtils','./RenderLibrary'],function(require){

    var BaseRender = require('./BaseRender');
    var BaseUtils = require('../utils/BaseUtils');
    var BezierEasing = require('../utils/BezierEasing');
    var Constants = require('../Constants');
    var ColorUtils = require('../utils/ColorUtils');

    var VALUE_TICK_GAP = 2;

    var RadiusAxisVmlRender = BaseRender.extend({
        render: function () {

            this._removeAll();

            var paper = this.component.polar.getVanchartRender().getRenderRoot();

            var center = this.component.polar.center;

            this._axisSet = paper.set();

            this.markerMap = {};

            // this._drawAxisLine(paper, center);

            this._drawGridLine(paper, center);

            this._drawPlotBands(paper, center);

            this._drawPlotLines(paper, center);

            this._drawTickLabel(paper, center);

        },

        _removeAll:function(){

            if(this._axisSet){
                this._axisSet.remove();
            }

            this.labelDivManager.clearAllLabels();
        },

        _drawAxisLine: function (paper, center) {
            var cfg = this.component.componentOption;
            var lineWidth = cfg.lineWidth;
            var lineColor = cfg.lineColor;

            var axisLineData = this.component.getPolarInitPoint();
            this._axisSet.push(
                paper.path(this._getLinePath([0, 0], axisLineData))
                    .attr({
                        'fill': 'none',
                        'stroke': lineColor,
                        'stroke-width': lineWidth
                    })
                    .transform(BaseUtils.makeTranslate(center))
            );

        },

        _drawGridLine: function (paper, center) {

            var radiusAxis = this.component;
            var cfg = radiusAxis.componentOption;
            var ticks = radiusAxis.getTickData();
            var gridLineColor = cfg.gridLineColor;
            var gridLineWidth = cfg.gridLineWidth;

            var self = this;

            ticks.forEach(function(d){

                self._axisSet.push(

                    paper.path(self.component._getRadiusGridPath(d.tickValue))
                        .attr({
                            'fill':'none',
                            'stroke':gridLineColor,
                            'stroke-width':gridLineWidth
                        })
                        .transform(BaseUtils.makeTranslate(center))
                );

            });

        },

        _drawPlotBands: function (paper, center) {

            var plotBands = this.component.getRadiusPlotBands();

            var self = this;
            plotBands.forEach(function(band){
                self._axisSet.push(
                    paper.path(band.path)
                        .attr({
                            'fill': band.color,
                            'stroke': 'none'
                        })
                        .transform(BaseUtils.makeTranslate(center))
                )
            });

        },

        _drawPlotLines:function(paper, center){

            var plotLines = this.component.getPlotLines();
            var self = this;

            plotLines.forEach(function(d){

                self._axisSet.push(

                    paper.path(self.component._getRadiusGridPath(d.value))
                        .attr({
                            fill:'none',
                            stroke: d.color,
                            'stroke-width': d.width,
                            'stroke-dasharray': d.dataArray
                        })
                        .transform(BaseUtils.makeTranslate(center))

                );

                if(d.text){
                    var textStyle = BaseUtils.cssNormalization(d.style);
                    paper.text(0, d.baseY, d.text)
                        .attr(textStyle)
                        .attr('text-anchor', d.textAnchor)
                        .transform(BaseUtils.makeTranslate(center));
                }

            });

        },

        _drawTickLabel:function(paper, center){

            var radiusAxis = this.component;
            var scale = radiusAxis.scale;
            var lastScale = radiusAxis.lastScale || radiusAxis.scale;
            var cfg = radiusAxis.componentOption;
            var ticks = radiusAxis.getTickData();

            //最大值标签不显示
            ticks.length = Math.max(ticks.length - 1, 0);

            var labelStyle = cfg.labelStyle;
            var labelRotation = cfg.labelRotation || 0;
            var useHtml = cfg.useHtml;

            if(useHtml && !labelRotation){

                for(var i = 0, len = ticks.length; i < len; i++){

                    var tick = ticks[i];

                    var x = -tick.tickDim.width - VALUE_TICK_GAP + center[0];
                    var y = -scale(tick.tickValue)-tick.tickDim.height + center[1];

                    this.labelDivManager.addLabel(tick.tickContent, {x:x, y:y}, labelStyle);
                }

            }else{

                for(var i = 0, count = ticks.length; i < count; i++){

                    var tick = ticks[i];

                    var normalDim = BaseUtils.getTextDimension(tick.tickContent, labelStyle, useHtml);

                    var x = center[0] - VALUE_TICK_GAP - normalDim.width/2;
                    var y = center[1] - scale(tick.tickValue) - normalDim.height/2;

                    this._axisSet.push(
                        paper.text(x, y, tick.tickContent)
                            .attr(BaseUtils.cssNormalization(labelStyle))
                            .transform('r' + labelRotation)
                    )
                }
            }
        },
        
        remove:function(){
            this._removeAll();
        }
    });
    
    require('./RenderLibrary').register(Constants.RADIUS_AXIS_VML, RadiusAxisVmlRender);
});
/**
 * Created by eason on 15/9/25.
 */

define('render/BaseAxisVmlRender',['require','./BaseRender','../utils/BaseUtils','../utils/BezierEasing','../Constants','../utils/ColorUtils'],function(require){

    var BaseRender = require('./BaseRender');
    var BaseUtils = require('../utils/BaseUtils');
    var BezierEasing = require('../utils/BezierEasing');
    var Constants = require('../Constants');
    var ColorUtils = require('../utils/ColorUtils');

    var BaseAxisVmlRender = BaseRender.extend({
        render:function(){
            
            this.highlightBandID = null;

            this._removeAll();

            var paper = this.component.getVanchartRender().getRenderRoot();

            this._bodySet = paper.set();

            var cfg = this.component.componentOption;

            this._drawAxisLine(paper, cfg);

            this._drawArrow(paper, cfg);

            this._drawAxisTicks(paper, cfg);

            this._drawMinorTickLine(paper, cfg);

            this._drawGridLines(paper, cfg);

            this._drawAxisLabels(paper, cfg);

            this._drawPlotBands(paper);

            this._drawAxisTitle(paper);

            this._drawPlotLines(paper, cfg);
        },

        _removeAll:function(){

            if(this._bodySet){
                this._bodySet.remove();
            }

            this.labelDivManager.clearAllLabels();
        },

        _drawAxisLine:function(paper, cfg){

            var axisOrigon = this.component._getAxisOriginPoint();

            var lineWidth = cfg.lineWidth;
            var lineColor = cfg.lineColor;

            var width = this.component.bounds.width;
            var height = this.component.bounds.height;

            var line;
            if(this.component.isHorizontal()){
                line = paper.path(this._getLinePath([0,0], [width, 0]));
            }else{
                line = paper.path('M0,0' + 'L'+'0,' + height);
            }

            line.attr({
                    'stroke':lineColor,
                    'stroke-width':lineWidth
                })
                .transform(BaseUtils.makeTranslate(axisOrigon));

            this._bodySet.push(line);
        },

        _drawArrow:function(paper, cfg){

            if(!this.component.showArrow()){
                return;
            }

            var plotBounds = this.component.getPlotBounds();
            var cfg = this.component.componentOption;
            var lineWidth = cfg.lineWidth;
            var lineColor = cfg.lineColor;
            var pathDet = BaseUtils.lineSubPixelOpt(0, lineWidth);
            var axisOrigin = this.component._getAxisOriginPoint();

            var line, arrow;
            var dx, dy;

            if(this.component.isHorizontal()){

                line = paper.path(this._getLinePath([plotBounds.width, 0],[plotBounds.width + 6, 0]));
                arrow = paper.path("M2,2 L10,6 L2,10 L6,6 L2,2");
                dx = plotBounds.width;
                dy = -6;

            }else{

                line = paper.path(this._getLinePath([0, -6],[0, 0]));
                arrow = paper.path("M2,-2 L6,-10 L10,-2 L6,-6 L2,-2");
                dx = -6;
                dy = 0;
            }

            line
                .attr({
                    'fill':'none',
                    'stroke':lineColor,
                    'stroke-width':lineWidth
                })
                .transform(BaseUtils.makeTranslate(axisOrigin));

            arrow
                .attr({
                    'fill':lineColor,
                    'stroke':'none'
                })
                .transform(BaseUtils.makeTranslate([axisOrigin.x + dx, axisOrigin.y + dy]));

            this._bodySet.push(line);
            this._bodySet.push(arrow);

        },

        _drawMinorTickLine:function(paper, cfg){

            var minorTickLength = cfg.enableMinorTick ? cfg.minorTickLength : 0;
            var minorTickWidth = cfg.minorTickWidth;
            var minorTickColor = cfg.minorTickColor;
            var minorTickData = this.component.getMinorTickData();

            var axisOrigin = this.component._getAxisOriginPoint();

            var isCategory = this.component.type == Constants.CATEGORY_AXIS_COMPONENT;
            var scale = this.component.scale;

            var self = this;

            if(minorTickLength){

                minorTickData.forEach(function(d){

                    self._bodySet.push(
                        paper.path(self._getTickPath(isCategory ? d : scale(d), minorTickLength))
                            .attr({
                                'stroke':minorTickColor,
                                'stroke-width':minorTickWidth
                            })
                            .transform(BaseUtils.makeTranslate(axisOrigin))
                    );

                });
            }

        },

        _drawAxisTicks:function(paper, cfg){
            var ticks = this.component.getMainTickData();
            var self = this;
            var axisOrigin = this.component._getAxisOriginPoint();

            //主要刻度线
            if(cfg.enableTick){
                var tickColor = cfg.tickColor;
                var tickWidth = cfg.tickWidth;
                var tickLength = cfg.tickLength;

                ticks.forEach(function(tick){

                    self._bodySet.push(
                        paper.path(self._getTickPath(tick.tickPos, tickLength))
                            .attr({
                                'stroke':tickColor,
                                'stroke-width':tickWidth
                            })
                            .transform(BaseUtils.makeTranslate(axisOrigin))
                    );

                });
            }

        },

        _getTickPath:function(tickPos, tickLength){

            var position = this.component.getPosition();

            switch (position){
                case Constants.TOP:
                    return this._getLinePath([tickPos, 0], [tickPos, -tickLength ]);

                case Constants.BOTTOM:
                    return this._getLinePath([tickPos, 0], [tickPos, tickLength ]);

                case Constants.LEFT:
                    return this._getLinePath([0, tickPos], [-tickLength, tickPos]);

                case Constants.RIGHT:
                    return this._getLinePath([0, tickPos], [tickLength, tickPos]);

            };
        },

        _getGridLinePath:function(tickPos, useLength){

            if(this.component.isHorizontal()){

                return this._getLinePath([tickPos, 0], [tickPos, useLength]);

            }else{

                return this._getLinePath([0, tickPos], [useLength, tickPos]);

            }

        },

        _drawGridLines:function(paper, cfg){

            var gridLineColor = cfg.gridLineColor;
            var gridLineWidth = cfg.gridLineWidth;

            var plotBounds = this.component.getPlotBounds();

            var useLength = this.component.isHorizontal() ? plotBounds.height : plotBounds.width;

            var ticks = this.component.getTickData();

            var self = this;

            ticks.forEach(function(tick){

                self._bodySet.push(
                    paper.path(self._getGridLinePath(tick.tickPos, useLength))
                        .attr({
                            'stroke':gridLineColor,
                            'stroke-width':gridLineWidth
                        })
                        .transform(BaseUtils.makeTranslate(plotBounds))
                );

            });

        },

        _drawAxisLabels:function(paper){

            this.labelDivManager.clearAllLabels();

            var labelDivManager = this.labelDivManager;
            var cfg = this.component.componentOption;

            var origin = this.component._getAxisOriginPoint();

            var transX = origin.x;
            var transY = origin.y;

            var orient = this.component.getPosition();
            var isHorizontal = this.component.isHorizontal();
            var scale = this.component.getTickScale();
            var ticks = this.component.getTickData();

            var tickSpacing = (scale.rangeBand ? 0 : cfg.tickLength) + cfg.tickPadding;

            var labelStyle = cfg.labelStyle;
            var labelHeight = BaseUtils.getTextHeight(labelStyle);

            if (scale.rangeBand) {
                var scale0 = scale.copy();
                var dx = scale0.rangeBand();

                scale = function(d) {
                    return scale0(d) + dx/2;
                };
            }


            var self = this;
            var sign = orient === "top" || orient === "right" ? -1 : 1;

            ticks.forEach(function(tick){

                var x,y;

                var labelDim = BaseUtils.getTextDimension(tick.tickContent, labelStyle, false);
                if(isHorizontal){
                    y = orient == Constants.TOP ? -(tickSpacing + labelHeight) : tickSpacing;
                    x = scale(tick.tickValue) - labelDim.width/2;
                }else{
                    x = orient == Constants.LEFT ? -(tickSpacing + labelDim.width) : tickSpacing;
                    y = scale(tick.tickValue) - labelHeight/2;
                }

                if(cfg.useHtml){
                    labelDivManager.addLabel(tick.tickContent, {x:x + transX, y:y + transY}, labelStyle);
                }else{

                    var labelRotation = cfg.labelRotation || 0;
                    var rx = transX + x + labelDim.width/2;
                    var ry = transY + y + labelHeight/2;

                    if(Math.abs(labelRotation)){

                        var detY = Math.abs(labelDim.height - tick.tickDim.height);

                        var detX = Math.abs(labelDim.width - tick.tickDim.width);

                        if(orient === Constants.TOP || orient === Constants.BOTTOM){
                            ry += sign * detY/2;
                        }else{
                            rx += sign * detX/2;
                        }

                    }

                    var tickLabel = paper
                        .text(rx, ry, tick.tickContent)
                        .attr(BaseUtils.cssNormalization(labelStyle))
                        .transform('r' + labelRotation);

                    self._bodySet.push(tickLabel);
                }

            });

        },

        _drawAxisTitle:function(paper){
            this.component.isHorizontal() ? this._drawHorizontalTitle(paper)
                : this._drawVerticalTitle(paper);
        },

        _drawHorizontalTitle:function(paper){

            var position = this.component.getPosition();

            var titleBounds = this.component.getAxisTitleBounds();
            var transX = titleBounds.x;
            var transY = titleBounds.y + (position == Constants.TOP ? titleBounds.height : 0);

            var cfg = this.component.componentOption;

            if(cfg.title){
                var title = cfg.title;
                if(title.useHtml){
                    this._drawHorizontalAxisTitleWithHtml(title, titleBounds);
                }else{
                    var textStyle = BaseUtils.cssNormalization(title.style);
                    var rotation = title.rotation || 0;

                    var textDim = BaseUtils.getTextDimension(title.text, title.style, title.useHtml);
                    var textBounds = BaseUtils.getTextDimensionWithRotation(title.text, title.style, title.useHtml, rotation);

                    var sign = position == Constants.BOTTOM ? 1 : -1;

                    var rx = transX;
                    var ry = transY + sign * textDim.height / 2;

                    var align = title.align || 'left';
                    switch(align){
                        case 'left':
                            rx += textDim.width/2;
                            break;
                        case 'center':
                            rx += titleBounds.width/2;
                            break;
                        case 'right':
                            rx += (titleBounds.width - textDim.width/2);
                            break;
                    }

                    var detY = Math.abs(textBounds.height - textDim.height)/2;

                    this._bodySet.push(
                        paper
                            .text(rx, ry + sign * detY, title.text)
                            .attr(textStyle)
                            .transform('r' + rotation)
                    );
                }
            }

        },

        _drawVerticalTitle:function(paper){

            var position = this.component.getPosition();

            var titleBounds = this.component.getAxisTitleBounds();
            var transX = titleBounds.x + (position == Constants.LEFT ? titleBounds.width : 0);
            var transY = titleBounds.y;
            var cfg = this.component.componentOption;

            var sign = position == Constants.LEFT ? 1 : -1;

            if(cfg.title){
                var title = cfg.title;
                if(title.useHtml){
                    this._drawVerticalAxisTitleWithHtml(title, titleBounds);
                }else{
                    var textStyle = BaseUtils.cssNormalization(title.style);
                    var rotation = title.rotation || 0;

                    var textDim = BaseUtils.getTextDimension(title.text, title.style, title.useHtml);
                    var textBounds = BaseUtils.getTextDimensionWithRotation(title.text, title.style, title.useHtml, rotation);

                    var rx = transX - textDim.width/2 * sign;
                    var ry = transY;

                    var align = title.align || 'top';
                    switch(align){
                        case 'top':
                            ry += textDim.width/2;
                            break;
                        case 'center':
                            ry += titleBounds.height/2;
                            break;
                        case 'bottom':
                            ry += (titleBounds.height - textDim.width/2);
                            break;
                    }

                    var detX = Math.abs(textBounds.width - textDim.width)/2;

                    this._bodySet.push(
                        paper
                            .text(rx + detX * sign, ry, title.text)
                            .attr(textStyle)
                            .transform('r' + rotation)
                    );
                }
            }
        },

        _drawPlotLines:function(paper){
            var plotLines = this.component._preCalculatePlotLines();

            var plotBounds = this.component.getPlotBounds();

            var self = this;

            plotLines.forEach(function(line){
                self._bodySet.push(
                    paper.path(self._getLinePath([line.startPos.x, line.startPos.y], [line.endPos.x, line.endPos.y]))
                        .attr({
                            'stroke': line.color,
                            'stroke-width': line.width,
                            'stroke-dasharray': line.dataArray
                        })
                        .transform(BaseUtils.makeTranslate(plotBounds))
                );

                var text = line.text;
                var style = BaseUtils.cssNormalization(line.style);

                if(text){
                    self._bodySet.push(
                        paper.text(line.textX + line.textDim.width/2, line.textY + line.textDim.height/2, text)
                            .attr(style)
                            .transform(BaseUtils.makeTranslate(plotBounds))
                    );

                }

            })
        },

        _drawPlotBands:function(paper){

            var plotBands = this.component._preCalculatePlotBands();
            var plotBounds = this.component.getPlotBounds();

            var self = this;
            plotBands.forEach(function(bands){
                self._bodySet.push(
                    paper.rect(bands.x, bands.y, bands.width, bands.height)
                        .attr({
                            'stroke':'none',
                            fill:bands.color,
                            'fill-opacity':ColorUtils.getColorOpacity(bands.color)
                        })
                        .transform(BaseUtils.makeTranslate(plotBounds))
                );
            })
        },

        removeHighlightBand:function(){

            var paper = this.component.getVanchartRender().getRenderRoot();
            var band = paper.getById(this.highlightBandID);
            band && band.remove();

        },
        
        drawHighlightBand:function(pos){
            var axis = this.component;
            if (!axis._getBandByPosition) {
                return;
            }

            var paper = this.component.getVanchartRender().getRenderRoot();

            var drawBand = axis._getBandByPosition(pos);
            var highlightType = axis.getHighlightType();

            this.removeHighlightBand();

            switch (highlightType) {
                case 'band':
                    var highlightBand =
                        paper.rect(drawBand.x, drawBand.y, drawBand.width, drawBand.height)
                        .attr({
                            'stroke':'none',
                            'fill': 'rgb(98,179,240)',
                            'fill-opacity': 0.2
                        });

                    this.highlightBandID = highlightBand.id;

                    this._bodySet.push(highlightBand);

                    break;
                case 'line':
                default:
                    var highlightBand =
                        paper.path(this._getLinePath([drawBand.x, drawBand.y], [drawBand.x, drawBand.y + drawBand.height]))
                            .attr({
                                'stroke': 'rgb(140,140,140)',
                                'stroke-width': 1
                            });

                    this.highlightBandID = highlightBand.id;

                    this._bodySet.push(highlightBand);
            }
        },

        remove:function(){
            this._removeAll();
        }
    });

    return BaseAxisVmlRender;
});
/**
 * Created by eason on 15/11/2.
 */

define('render/DateAxisVmlRender',['require','./BaseAxisVmlRender','../Constants','./RenderLibrary'],function(require){

    var BaseAxisRender = require('./BaseAxisVmlRender');
    var Constants = require('../Constants');
    var DateAxisVmlRender = BaseAxisRender.extend({});
    require('./RenderLibrary').register(Constants.DATE_AXIS_VML, DateAxisVmlRender);
});
/**
 * Created by eason on 15/9/25.
 */
define('render/ValueAxisVmlRender',['require','./BaseAxisVmlRender','../Constants','./RenderLibrary'],function(require){

    var BaseAxisRender = require('./BaseAxisVmlRender');
    var Constants = require('../Constants');

    var ValueAxisVmlRender = BaseAxisRender.extend({});

    require('./RenderLibrary').register(Constants.VALUE_AXIS_VML, ValueAxisVmlRender);
});
/**
 * Created by eason on 15/9/25.
 */

define('render/CategoryAxisVmlRender',['require','./BaseAxisVmlRender','../Constants','./RenderLibrary'],function(require){

    var BaseAxisRender = require('./BaseAxisVmlRender');
    
    var Constants = require('../Constants');

    var CategoryAxisVmlRender = BaseAxisRender.extend({});

    require('./RenderLibrary').register(Constants.CATEGORY_AXIS_VML, CategoryAxisVmlRender);
});
/**
 * Created by eason on 15/8/14.
 */
define('render/TitleVmlRender',['require','./BaseRender','../utils/BaseUtils','../Constants','./RenderLibrary'],function(require){

    var BaseRender = require('./BaseRender');
    var BaseUtils = require('../utils/BaseUtils');
    var Constants = require('../Constants');

    var TitleVmlRender = BaseRender.extend({
        render:function(){

            if(this.componentSet){
                if(this.background){
                    this.background.toFront();
                }

                this.componentSet.toFront();
                return;
            }

            var cfg = this.component.componentOption;
            var bounds = this.component.bounds;

            var toolbarWidth = this.component.vanchart.getToolbarWidth();
            toolbarWidth = this.component.isFloat ? 0 : toolbarWidth;

            var paper = this.component.getVanchartRender().getRenderRoot();
            //背景
            if(cfg.backgroundColor){
                this.background = paper.rect(bounds.x, bounds.y, bounds.width, bounds.height)
                    .attr({
                        rx:cfg.borderRadius,
                        ry:cfg.borderRadius,
                        fill:this._getRaphaelFill(cfg.backgroundColor),
                        'stroke-width':0
                    })
                    .attr('fill-opacity', this._getFillOpacity(cfg.backgroundColor));
            }

            this.componentSet = paper.set();

            var textDim = this.component.textDim;
            var padding = this.component.getPadding();
            var textBounds = {
                x: bounds.x + padding,
                y: bounds.y + padding,
                width: textDim.width,
                height: textDim.height
            };

            if (!this.component.isFloat && cfg.align === 'center') {
                textBounds.x = bounds.x + bounds.width / 2 - textDim.width / 2;
            }

            this.textBounds = textBounds;

            this._drawTitle(cfg, textBounds);

        },

        changeTextRightSpace: function (changes) {

            if (this.component.isFloat) {
                return;
            }

            switch (this.component.componentOption.align) {
                case 'center':
                    var bounds = this.component.bounds;
                    var initTextDim = this.component.textDim;
                    var initTextX = bounds.x + bounds.width / 2 - initTextDim.width / 2;
                    var textBounds = this.textBounds;
                    var padding = this.component.getPadding();
                    var barWidth = this.component.vanchart.getToolbarWidth();
                    var initBarWidth = this.component.initBarWidth;

                    var gap = bounds.width / 2 - initTextDim.width / 2 - initBarWidth - padding;

                    var changesToInit = barWidth - initBarWidth;

                    var x = textBounds.x;
                    var width = textBounds.width;

                    if (gap <= 0) {
                        x = bounds.x;
                        width = bounds.width - barWidth;
                    } else if (gap < changesToInit) {
                        x = initTextX - (changesToInit - gap);
                    } else {
                        x = initTextX;
                        width = initTextDim.width;
                    }

                    this.labelDivManager.changeLabelDim({
                        left: x - textBounds.x,
                        width: width - textBounds.width
                    });

                    this.textBounds.x = x;
                    this.textBounds.width = width;

                    break;
                default:
                    // adjust width
                    this.labelDivManager.changeLabelDim({
                        width: -changes
                    });
            }

        },

        translateX:function(width){

            this.labelDivManager.translateLabelsHorizontal(width);

            var gap = this.usedWidth - this.textEndX;

            if(gap > Math.abs(width)){
                return;
            }

            this.componentSet.forEach(function(component){
                var matrix = component.matrix;

                matrix.translate(width, 0);
                component.transform(matrix.toTransformString());
            });
        },

        _removeAll:function(){

            if(this.componentSet){
                this.componentSet.remove();
            }

            this.labelDivManager.clearAllLabels();
        }
    });

    // function (title){
    //     BaseRender.call(this, title);
    //     this.component = title;
    //
    //     //文本实际结束的位置
    //     this.textEndX = 0;
    //     this.usedWidth = 0;
    //     this.textBounds = {};
    // }

    require('./RenderLibrary').register(Constants.TITLE_VML, TitleVmlRender);
    return TitleVmlRender;
});
/**
 * Created by Mitisky on 16/3/24.
 */
define('render/RangeLegendVmlRender',['require','./BaseRender','../utils/BaseUtils','../Constants','./RenderLibrary'],function (require) {
    var BaseRender = require('./BaseRender');
    var BaseUtils = require('../utils/BaseUtils');
    var Constants = require('../Constants');

    var PADDING = 10;

    var WIDTH = 15;
    var HEIGHT = 100;
    var BAR_WIDTH = 15;
    var BAR_HEIGHT = 10;
    var BAR_TEXT_GAP = 5;
    var ITEM_WIDTH = 25;
    var ITEM_GAP = 2;

    var MIN_BAR_CLASS_NAME = 'min-bar-class-name';
    var MAX_BAR_CLASS_NAME = 'max-bar-class-name';

    var RangeLegendVmlRender = BaseRender.extend({
        render: function () {
            this._removeAll();

            var option = this.component.componentOption;
            var bounds = this.component.bounds;
            this.isHorizontal = this.component.isHorizontal();
            var paper = this.component.getVanchartRender().getRenderRoot();

            this.background = [];
            this._bodySet = paper.set();

            this._renderVmlBackground(this.background, paper, option, bounds);

            this.component.isIntervalLegend ? this._renderInterval(paper, bounds)
                : this._renderGradient(paper, bounds);
        },

        _removeAll:function(){
            if(this.background) {
                this.background.forEach(function (element) {
                    element.remove();
                });
            }

            if(this._bodySet){
                this._bodySet.remove();
            }
        },

        _renderGradient: function (paper, bounds) {
            this.minPos = 0;
            this.maxPos = HEIGHT;
            var labelStyle = this.component.componentOption.style;
            var startPos = this.isHorizontal ? bounds.x : bounds.y;
            startPos += ((this.isHorizontal ? bounds.width : bounds.height)- HEIGHT)/2;

            this._bodySet.push(
                paper.rect(this.isHorizontal ? startPos : bounds.x + PADDING,
                    this.isHorizontal ? bounds.y + PADDING : startPos,
                    this.isHorizontal ? HEIGHT : WIDTH,
                    this.isHorizontal ? WIDTH : HEIGHT)
                    .attr('class', 'legend-gradient-background')
                    .attr('rx', 2)
                    .attr('ry', 2)
                    .attr('fill', '#eaeaea')
                    .attr('stroke-width', 0)
            );

            var gradientBar = paper.rect(this.isHorizontal ? startPos : bounds.x + PADDING,
                this.isHorizontal ? bounds.y + PADDING : startPos,
                this.isHorizontal ? HEIGHT : WIDTH,
                this.isHorizontal ? WIDTH : HEIGHT)
                .attr('class', 'legend-gradient-bar')
                .attr('rx', 2)
                .attr('ry', 2)
                .attr('fill', this._getGradientFillColor())
                .attr('stroke-width', 0)
                .attr('clip-rect', this._getGradientClipRect(startPos));

            var minBar = paper.path(this.isHorizontal ? this.component.getLeftBarPath() : this.component.getTopBarPath())
                .attr('class', MIN_BAR_CLASS_NAME)
                .attr('fill', this.component.colorScale(this.minPos/HEIGHT))
                .transform('t' + this._getMinBarPosX(this.isHorizontal, bounds, this.minPos, this.maxPos, startPos) +
                    ',' + this._getMinBarPosY(this.isHorizontal, bounds, this.minPos, this.maxPos, startPos))
                .attr('cursor', 'pointer')
                .attr('stroke-width', 0);

            var label = this.component.getGradientLabelContent(this.isHorizontal ? this.minPos : this.maxPos);
            var labelDim = BaseUtils.getTextDimension(label, labelStyle, true);
            var minBarLabel = paper.text(this._getMinLabelCenterX(this.isHorizontal, labelDim, bounds, startPos),
                this._getMinLabelCenterY(this.isHorizontal, labelDim, bounds, startPos)
                , label)
                .attr(BaseUtils.cssNormalization(labelStyle));

            var self = this;
            minBar.mousedown(function (event) {
                self._mindraging = true;
                self._mosX = event.screenX;
                self._mosY = event.screenY;
            });
            minBar.mouseup(function (event) {
                self._mindraging = false;
            });
            minBar.mouseout(function(event) {
                self._mindraging = false;
            });
            minBar.mousemove(function (event) {
                if(self._mindraging){
                    var change = 0;
                    if(self.isHorizontal){
                        var temp = self.minPos;
                        self.minPos += Math.round(event.screenX - self._mosX);
                        self.minPos = Math.max(0, self.minPos);
                        self.minPos = Math.min(self.minPos, self.maxPos);
                        change = self.minPos - temp;
                    } else {
                        var temp = self.maxPos;
                        self.maxPos += Math.round(event.screenY - self._mosY);
                        self.maxPos = Math.min(HEIGHT, self.maxPos);
                        self.maxPos = Math.max(self.maxPos, self.minPos);
                        change = self.maxPos - temp;
                    }

                    self._mosX = event.screenX;
                    self._mosY = event.screenY;

                    if(Math.abs(change) >= 1) {
                        minBar
                            .attr('fill', self.component.colorScale((self.isHorizontal ? self.minPos : HEIGHT - self.maxPos) / HEIGHT))
                            .transform('t' + self._getMinBarPosX(self.isHorizontal, bounds, self.minPos, self.maxPos, startPos) +
                                ',' + self._getMinBarPosY(self.isHorizontal, bounds, self.minPos, self.maxPos, startPos));
                        var label = self.component.getGradientLabelContent(self.isHorizontal ? self.minPos : self.maxPos);
                        var labelDim = BaseUtils.getTextDimension(label, labelStyle, true);
                        minBarLabel
                            .attr('text', label)
                            .attr('x', self._getMinLabelCenterX(self.isHorizontal, labelDim, bounds, startPos))
                            .attr('y', self._getMinLabelCenterY(self.isHorizontal, labelDim, bounds, startPos));
                        gradientBar
                            .attr('clip-rect', self._getGradientClipRect(startPos));
                        self.component.refreshPoints(self.minPos, self.maxPos);
                    }
                }
            });

            var maxBar = paper.path(this.isHorizontal ? this.component.getRightBarPath() : this.component.getBottomBarPath())
                .attr('class', MAX_BAR_CLASS_NAME)
                .attr('fill', this.component.colorScale(this.maxPos/HEIGHT))
                .transform('t' + this._getMaxBarPosX(this.isHorizontal, bounds, this.minPos, this.maxPos, startPos) +
                    ',' + this._getMaxBarPosY(this.isHorizontal, bounds, this.minPos, this.maxPos, startPos))
                .attr('cursor', 'pointer')
                .attr('stroke-width', 0);

            var maxLabel = this.component.getGradientLabelContent(this.isHorizontal ? this.maxPos : this.minPos);
            var maxLabelDim = BaseUtils.getTextDimension(maxLabel, labelStyle, true);
            var maxBarLabel = paper.text(this._getMaxLabelCenterX(this.isHorizontal, maxLabelDim, bounds, startPos),
                this._getMaxLabelCenterY(this.isHorizontal, maxLabelDim, bounds, startPos)
                , maxLabel)
                .attr(BaseUtils.cssNormalization(labelStyle));

            maxBar.mousedown(function () {
                self._maxdraging = true;
                self._mosX = event.screenX;
                self._mosY = event.screenY;
            });
            maxBar.mouseup(function () {
                self._maxdraging = false;
            });
            maxBar.mouseout(function() {
                self._maxdraging = false;
            });

            maxBar.mousemove(function (event) {
                if(self._maxdraging){
                    var change = 0;
                    if(self.isHorizontal){
                        var temp = self.maxPos;
                        self.maxPos += Math.round(event.screenX - self._mosX);
                        self.maxPos = Math.min(HEIGHT, self.maxPos);
                        self.maxPos = Math.max(self.maxPos, self.minPos);
                        change = self.maxPos - temp;
                    } else {
                        var temp = self.minPos;
                        self.minPos += Math.round(event.screenY - self._mosY);
                        self.minPos = Math.max(0, self.minPos);
                        self.minPos = Math.min(self.minPos, self.maxPos);
                        change = self.minPos - temp;
                    }
                    self._mosX = event.screenX;
                    self._mosY = event.screenY;
                    if(Math.abs(change) >= 1) {
                        maxBar
                            .attr('fill', self.component.colorScale((self.isHorizontal ? self.maxPos : HEIGHT - self.minPos) / HEIGHT))
                            .transform('t' + self._getMaxBarPosX(self.isHorizontal, bounds, self.minPos, self.maxPos, startPos) +
                                ',' + self._getMaxBarPosY(self.isHorizontal, bounds, self.minPos, self.maxPos, startPos));
                        var maxLabel = self.component.getGradientLabelContent(self.isHorizontal ? self.maxPos : self.minPos);
                        var maxLabelDim = BaseUtils.getTextDimension(maxLabel, labelStyle, true);
                        maxBarLabel
                            .attr('text', maxLabel)
                            .attr('x', self._getMaxLabelCenterX(self.isHorizontal, maxLabelDim, bounds, startPos))
                            .attr('y', self._getMaxLabelCenterY(self.isHorizontal, maxLabelDim, bounds, startPos));
                        gradientBar
                            .attr('clip-rect', self._getGradientClipRect(startPos));
                        self.component.refreshPoints(self.minPos, self.maxPos);
                    }
                }
            });

            this._bodySet.push([gradientBar, minBar, minBarLabel, maxBar, maxBarLabel]);
        },

        _getMinBarPosX: function (isHorizontal, bounds, minPos, maxPos, startPos) {
            return isHorizontal ? startPos - BAR_HEIGHT + minPos : bounds.x + PADDING + WIDTH;
        },

        _getMinBarPosY: function (isHorizontal, bounds, minPos, maxPos, startPos) {
            return isHorizontal ? bounds.y + PADDING + WIDTH : startPos + maxPos;
        },

        _getMaxBarPosX: function (isHorizontal, bounds, minPos, maxPos, startPos) {
            return isHorizontal ? startPos + maxPos : bounds.x + PADDING + WIDTH;
        },

        _getMaxBarPosY: function (isHorizontal, bounds, minPos, maxPos, startPos) {
            return isHorizontal ? bounds.y + PADDING + WIDTH : startPos - BAR_HEIGHT + minPos;
        },

        _getMinLabelCenterX: function (isHorizontal, labelDim, bounds, startPos) {
            return isHorizontal ? startPos + this.minPos - BAR_HEIGHT/2 - labelDim.width/2
                : bounds.x + PADDING + WIDTH + BAR_WIDTH + BAR_TEXT_GAP + labelDim.width/2;
        },

        _getMinLabelCenterY: function (isHorizontal, labelDim, bounds, startPos) {
            return isHorizontal ? bounds.y + PADDING + WIDTH + BAR_WIDTH + BAR_TEXT_GAP + labelDim.height/2
                : startPos + this.maxPos + BAR_HEIGHT/2;
        },

        _getMaxLabelCenterX: function (isHorizontal, labelDim, bounds, startPos) {
            return isHorizontal ? startPos + this.maxPos + BAR_HEIGHT/2 + labelDim.width/2
                : bounds.x + PADDING + WIDTH + BAR_WIDTH + BAR_TEXT_GAP + labelDim.width/2;
        },

        _getMaxLabelCenterY: function (isHorizontal, labelDim, bounds, startPos) {
            return isHorizontal ? bounds.y + PADDING + WIDTH + BAR_WIDTH + BAR_TEXT_GAP + labelDim.height/2
                : startPos + this.minPos - BAR_HEIGHT/2;
        },

        _getGradientClipRect: function(startPos) {
            var bounds = this.component.bounds;
            var x = bounds.x + PADDING;
            var y = startPos + this.minPos;
            var width = WIDTH;
            var height = this.maxPos - this.minPos;
            if(this.isHorizontal){
                x = startPos + this.minPos;
                y = bounds.y + PADDING;
                width = this.maxPos - this.minPos;
                height = WIDTH;
            }
            return x + ',' + y + ',' + width + ',' + height;
        },

        _getGradientFillColor: function() {
            var fillColor = this.isHorizontal ? 0 : 90;

            var valueAndColorArray = this.component.getValueAndColors();

            valueAndColorArray.forEach(function(valueAndColor){
                var value = valueAndColor[0];
                var color = valueAndColor[1];
                fillColor += ('-' + color + ':' + value * 100);
            });

            return fillColor;
        },

        _renderInterval: function (paper, bounds) {
            var items =  this.component.items;
            var labelStyle = this.component.componentOption.style;

            this.isHorizontal ? this._renderHorizontalInterval(paper, bounds, items, labelStyle)
                : this._renderVerticalInterval(paper, bounds, items, labelStyle);
        },

        _renderHorizontalInterval: function (paper, bounds, itemS, labelStyle) {
            var len = this.component.items.length;
            var startX = bounds.x + (bounds.width - len * ITEM_WIDTH - (len - 1) * ITEM_GAP)/2;

            for(var i = 0; i < len; i++){
                var item = itemS[i];
                var labelContent = item.label;
                var labelDim = BaseUtils.getTextDimension(labelContent, labelStyle);
                var topLabelY = bounds.y + PADDING;
                var iconY = topLabelY + labelDim.height + BAR_TEXT_GAP;
                var bottomY = iconY + WIDTH + BAR_TEXT_GAP;

                var icon = paper.rect(startX, iconY, ITEM_WIDTH, WIDTH)
                    .attr({
                        fill:item.visible ? item.color : item.hiddenColor,
                        'fill-opacity':1,
                        stroke:'none'
                    });

                var label = paper.text(startX + ITEM_WIDTH/2, i%2 == 0 ? topLabelY + labelDim.height/2 : bottomY + labelDim.height/2, labelContent)
                    .attr('text-anchor', 'middle')
                    .attr(BaseUtils.cssNormalization(labelStyle));

                this._bindMouseEvent(item, icon, label, labelStyle);

                this._bodySet.push([icon, label]);

                startX += (ITEM_WIDTH + ITEM_GAP);
            }
        },

        _renderVerticalInterval: function (paper, bounds, itemS, labelStyle) {
            var iconX = bounds.x + PADDING;
            var labelX = bounds.x + PADDING + WIDTH + BAR_TEXT_GAP;
            var startY = bounds.y + (this.component.bounds.height - this.component.items.length * ITEM_WIDTH - (this.component.items.length - 1) * ITEM_GAP)/2;

            for(var i = 0, len = itemS.length; i < len; i++){
                var item = itemS[i];
                var labelContent = item.label;
                var labelDim = BaseUtils.getTextDimension(labelContent, labelStyle);

                var icon = paper.rect(iconX, startY, WIDTH, ITEM_WIDTH)
                    .attr({
                        fill:item.visible ? item.color : item.hiddenColor,
                        'fill-opacity':1,
                        stroke:'none'
                    });

                var label = paper.text(labelX + labelDim.width/2, startY +  ITEM_WIDTH/ 2, labelContent)
                    .attr('text-anchor', 'middle')
                    .attr(BaseUtils.cssNormalization(labelStyle));

                this._bindMouseEvent(item, icon, label, labelStyle);

                this._bodySet.push([icon, label]);

                startY += (ITEM_WIDTH + ITEM_GAP);
            }

        },

        _bindMouseEvent:function(item, icon, label, labelStyle) {
            icon.attr('cursor', 'pointer');
            label.attr('cursor', 'pointer');

            label.mousemove(function(){
                label.attr('fill', item.hoverColor);
            });

            label.mouseout(function(){
                var textColor = item.visible ? labelStyle.color : item.hiddenColor;
                label.attr('fill', textColor);
            });

            var self = this;
            icon.click(function(){
                self._clickHandler(item, icon, label, labelStyle.color);
            });

            label.click(function () {
                self._clickHandler(item, icon, label, labelStyle.color);
            })
        },

        _clickHandler: function (item, icon, label, labelColor) {
            item.visible = !item.visible;
            var iconColor = item.visible ? item.color : item.hiddenColor;
            var textColor = item.visible ? labelColor : item.hiddenColor;

            label.attr('fill', textColor);
            icon.attr('fill', iconColor);

            item.points.forEach(function (point) {
                point.visible = item.visible;
            });

            this.component.vanchart.renderOnlyCharts();
        }

    });
    
    require('./RenderLibrary').register(Constants.RANGE_LEGEND_VML, RangeLegendVmlRender);

    return RangeLegendVmlRender;
});
/**
 * Created by eason on 15/8/12.
 */
define('render/VanChartVmlRender',['require','./BaseRender','../utils/BaseUtils','../Constants','./RenderLibrary'],function(require){

    var BaseRender = require('./BaseRender');
    var BaseUtils = require('../utils/BaseUtils');
    var Constants = require('../Constants');

    var VanChartVmlRender = BaseRender.extend({
        render:function(){

            var dom = this.component.getParentDom();

            var width = this.component.chartWidth();
            var height = this.component.chartHeight();

            if(!this.paper){
                this.paper = Raphael(dom, width, height);
            }

            var charts = this.component.getChartRenders();

            var fixed = this.component.getFixedComponentRenders();
            var float = this.component.getFloatComponentRenders();

            this._renderBackground();

            fixed.forEach(function(render){
                render.render();
            });

            charts.forEach(function(render){
                render.render();
            });

            float.forEach(function(render){
                render.render();
            });

            this.component.getComponent(Constants.TOOLBAR_COMPONENT) &&
            this.component.getComponent(Constants.TOOLBAR_COMPONENT).render.toFront();

            this._renderTrendLine();
        },

        _renderBackground:function(){

            if(this.backgroundSet){
                this.backgroundSet.remove();
            }

            this.backgroundSet = this.paper.set();

            var chartBounds = BaseUtils.makeBounds(0,0,this.component.chartWidth() - 5, this.component.chartHeight() - 5);
            var chartBackground = this.component.getChartBackgroundOption();
            chartBounds = BaseUtils.rectSubPixelOpt(chartBounds.x, chartBounds.y, chartBounds.width - chartBackground.borderWidth, chartBounds.height - chartBackground.borderWidth, chartBackground.borderWidth);

            var plotBounds = this.component.getPlotBounds();
            var plotBackground = this.component.getPlotBackgroundOption();

            this._renderBackgroundWithBounds(chartBackground, chartBounds);
            this._renderBackgroundWithBounds(plotBackground, plotBounds);
        },

        _renderTrendLine:function(){

            if(this.trendLineSet){
                this.trendLineSet.remove();
            }

            this.trendLineSet = this.paper.set();

            var trendLines = this.component.getTrendLineOption();
            var plotBounds = this.component.getPlotBounds();

            var self = this;

            trendLines.forEach(function(d){

                self.trendLineSet.push(
                    self.paper
                        .path(self._getLinePath([d.x1, d.y1], [d.x2, d.y2]))
                        .attr({
                            'stroke':d.trendLine.color,
                            'stroke-width':d.trendLine.width,
                            'stroke-dasharray': d.trendLine.dashStyle == Constants.DASH_TYPE ? '-' : ''
                        })
                );

            });

            this.trendLineSet.transform('t' + plotBounds.x + ',' + plotBounds.y);
        },

        _renderBackgroundWithBounds:function(option, bounds){

            var dom = this.component.getParentDom();
            if(option.chartShadow){
                dom.style.boxShadow = '1px 1px 2px rgba(0,0,0,0.1)';
            }else if(option.plotShadow){
                var width = [5, 3, 1];
                var opacity = [0.05, 0.1, 0.15];
                var shadowBounds = BaseUtils.rectSubPixelOpt(bounds.x, bounds.y, bounds.width, bounds.height, 1);
                for(var i = 0; i < 3; i++){
                    var rect = this.paper.rect(shadowBounds.x, shadowBounds.y, shadowBounds.width, shadowBounds.height)
                        .attr({
                            fill: 'none',
                            stroke: 'rgb(0,0,0)',
                            'stroke-opacity':opacity[i],
                            'stroke-width': width[i],
                            'rx': option.borderRadius,
                            'ry': option.borderRadius
                        })
                        .transform('t1,1');

                    this.backgroundSet.push(rect);
                }

                var rect = this.paper.rect(shadowBounds.x, shadowBounds.y, shadowBounds.width, shadowBounds.height)
                    .attr({
                        fill: 'white',
                        stroke: 'none',
                        'rx': option.borderRadius,
                        'ry': option.borderRadius
                    });

                this.backgroundSet.push(rect);
            }

            var bw = option.borderWidth;
            bounds = BaseUtils.rectSubPixelOpt(bounds.x + bw/2, bounds.y + bw/2, bounds.width - bw, bounds.height - bw, option.borderWidth);

            var rect = this.paper.rect(bounds.x, bounds.y, bounds.width, bounds.height)
                .attr({
                    fill: this._getRaphaelFill(option.color),
                    stroke: option.borderColor,
                    'stroke-width': option.borderWidth,
                    'rx': option.borderRadius,
                    'ry': option.borderRadius
                })
                .attr('fill-opacity', this._getFillOpacity(option.color));

            this.backgroundSet.push(rect);

            if(option.image){
                var image = this.paper.image(option.image, bounds.x, bounds.y, bounds.width, bounds.height);
                this.backgroundSet.push(image);
            }
        },

        getRenderRoot:function(){
            return this.paper;
        },

        remove:function(){
            this.paper.remove();

            var charts = this.component.getChartRenders();
            var components = this.component.getComponentRenders();

            charts.forEach(function(render){
                render.removeDivLabels();
            });

            components.forEach(function(render){
                render.removeDivLabels();
            });
        }
    });
    
    require('./RenderLibrary').register(Constants.VANCHART_VML, VanChartVmlRender);

    return VanChartVmlRender;
});

/**
 * Created by eason on 16/2/5.
 */

define('IERequire',['require','./chart/Pie','./chart/Bar','./chart/Line','./chart/Area','./chart/Gauge','./chart/Radar','./chart/Bubble','./chart/Scatter','./chart/Map','./render/RadarVmlRender','./render/GaugeVmlRender','./render/AreaVmlRender','./render/LineVmlRender','./render/BarVmlRender','./render/PieVmlRender','./render/BubbleVmlRender','./render/ScatterVmlRender','./render/MapVmlRender','./render/DrillToolsVmlRender','./render/DataSheetVmlRender','./render/ToolbarVmlRender','./render/LegendVmlRender','./render/AngleAxisVmlRender','./render/RadiusAxisVmlRender','./render/DateAxisVmlRender','./render/ValueAxisVmlRender','./render/CategoryAxisVmlRender','./render/TitleVmlRender','./render/RangeLegendVmlRender','./VanCharts','./render/VanChartVmlRender'],function(require){

    require('./chart/Pie');
    require('./chart/Bar');
    require('./chart/Line');
    require('./chart/Area');
    require('./chart/Gauge');
    require('./chart/Radar');
    require('./chart/Bubble');
    require('./chart/Scatter');
    require('./chart/Map');

    require('./render/RadarVmlRender');
    require('./render/GaugeVmlRender');
    require('./render/AreaVmlRender');
    require('./render/LineVmlRender');
    require('./render/BarVmlRender');
    require('./render/PieVmlRender');
    require('./render/BubbleVmlRender');
    require('./render/ScatterVmlRender');
    require('./render/MapVmlRender');

    require('./render/DrillToolsVmlRender');
    require('./render/DataSheetVmlRender');
    require('./render/ToolbarVmlRender');
    require('./render/LegendVmlRender');
    require('./render/AngleAxisVmlRender');
    require('./render/RadiusAxisVmlRender');
    require('./render/DateAxisVmlRender');
    require('./render/ValueAxisVmlRender');
    require('./render/CategoryAxisVmlRender');
    require('./render/TitleVmlRender');
    require('./render/RangeLegendVmlRender');

    require('./VanCharts');
    require('./render/VanChartVmlRender');
});
/**
 * Created by eason on 15/12/25.
 */

//The modules for your project will be inlined above
//this snippet. Ask almond to synchronously require the
//module value for 'main' here and return it as the
//value to use for the public API for the built file.
var VanCharts = require('VanCharts');

require('chart/Pie');
require('chart/Bar');
require('chart/Line');
require('chart/Area');
require('chart/Gauge');
require('chart/Radar');
require('chart/Scatter');
require('chart/Bubble');
require('chart/Map');

require('render/VanChartSvgRender');
require('render/VanChartVmlRender');

require('render/TitleSvgRender');
require('render/CategoryAxisSvgRender');
require('render/ValueAxisSvgRender');
require('render/DateAxisSvgRender');
require('render/RadiusAxisSvgRender');
require('render/AngleAxisSvgRender');
require('render/LegendSvgRender');
require('render/ToolbarSvgRender');
require('render/DataSheetSvgRender');
require('render/RangeLegendSvgRender');
require('render/DrillToolsSvgRender');

require('render/PieSvgRender');
require('render/BarSvgRender');
require('render/LineSvgRender');
require('render/AreaSvgRender');
require('render/GaugeSvgRender');
require('render/RadarSvgRender');
require('render/ScatterSvgRender');
require('render/BubbleSvgRender');
require('render/MapSvgRender');

require('render/RadarVmlRender');
require('render/GaugeVmlRender');
require('render/AreaVmlRender');
require('render/LineVmlRender');
require('render/BarVmlRender');
require('render/PieVmlRender');
require('render/ScatterVmlRender');
require('render/BubbleVmlRender');
require('render/MapVmlRender');

require('render/DataSheetVmlRender');
require('render/ToolbarVmlRender');
require('render/LegendVmlRender');
require('render/DateAxisVmlRender');
require('render/ValueAxisVmlRender');
require('render/CategoryAxisVmlRender');
require('render/AngleAxisVmlRender');
require('render/RadiusAxisVmlRender');
require('render/TitleVmlRender');
require('render/RangeLegendVmlRender');
require('render/DrillToolsVmlRender');

return VanCharts;
}));
