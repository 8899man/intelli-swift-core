package com.fr.bi.cal.analyze.cal.sssecret;import com.finebi.cube.conf.table.BusinessTable;import com.fr.bi.cal.analyze.cal.result.NewRootNodeChild;import com.fr.bi.cal.analyze.cal.result.Node;import com.fr.bi.cal.analyze.exception.TerminateExecutorException;import com.fr.bi.field.target.calculator.cal.CalCalculator;import com.fr.bi.cal.analyze.session.BISession;import com.fr.bi.conf.report.widget.field.dimension.filter.ResultFilter;import com.fr.bi.stable.constant.BIBaseConstant;import com.fr.bi.stable.data.Table;import com.finebi.cube.api.ICubeDataLoader;import com.fr.bi.stable.gvi.GroupValueIndex;import com.fr.bi.stable.report.key.TargetGettingKey;import com.fr.bi.stable.report.result.DimensionCalculator;import com.fr.bi.stable.report.result.TargetCalculator;import java.util.Map;/** * Created by Hiram on 2015/1/5. */public class FilterSingleDimensionGroup extends SingleDimensionGroup {    private final Map<String, TargetCalculator> targetsMap;    private final ResultFilter resultFilter;    private SingleDimensionGroup singleDimensionGroup;    private NodeSummaryCalculator nodeSummaryCalculator = new NodeSummaryCalculator(getLoader());    /**     * Group计算的构造函数     *     * @param tableKey     * @param column       维度     * @param getter       获取实际过滤条件的对象     * @param loader     * @param resultFilter     * @param tkey     * @param targetsMap     */    FilterSingleDimensionGroup(BusinessTable tableKey, DimensionCalculator column, GroupValueIndex gvi, ICubeDataLoader loader, ResultFilter resultFilter, TargetGettingKey tkey, Map<String, TargetCalculator> targetsMap, BISession session, boolean useRealData) {        super(tableKey, null, null, column, null, -1, gvi, loader, useRealData, BIBaseConstant.PART_DATA_GROUP_LIMIT);        this.targetsMap = targetsMap;        this.resultFilter = resultFilter;    }    @Override    public boolean jumpCurrentOne(NewRootNodeChild para) throws TerminateExecutorException {        if (super.jumpCurrentOne(para)) {            return true;        }        return false;    }    private boolean ignoreNode(Node node) {        for (TargetCalculator calculator : targetsMap.values()) {            if (calculator instanceof CalCalculator) {                ((CalCalculator) calculator).calCalculateTarget(node);            } else {                Number nodeSummary = nodeSummaryCalculator.getNodeSummary(node, calculator);                node.setSummaryValue(calculator.createTargetGettingKey(), nodeSummary);            }        }        if (resultFilter != null) {            return !resultFilter.showNode(node, targetsMap, null);        }        return false;    }}