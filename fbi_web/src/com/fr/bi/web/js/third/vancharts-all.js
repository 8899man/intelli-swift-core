(function (root, factory) {
    if (typeof define === 'function' && define.amd) {
        //Allow using this built library as an AMD module
        //in another project. That other project will only
        //see this AMD call, not the internal modules in
        //the closure below.
        define([], factory);
    } else {
        //Browser globals case. Just assign the
        //result to a property on the global.
        root.VanCharts = factory();
    }
}(this, function () {
/**
 * @license almond 0.3.1 Copyright (c) 2011-2014, The Dojo Foundation All Rights Reserved.
 * Available via the MIT or new BSD license.
 * see: http://github.com/jrburke/almond for details
 */
//Going sloppy to avoid 'use strict' string cost, but strict practices should
//be followed.
/*jslint sloppy: true */
/*global setTimeout: false */

var requirejs, require, define;
(function (undef) {
    var main, req, makeMap, handlers,
        defined = {},
        waiting = {},
        config = {},
        defining = {},
        hasOwn = Object.prototype.hasOwnProperty,
        aps = [].slice,
        jsSuffixRegExp = /\.js$/;

    function hasProp(obj, prop) {
        return hasOwn.call(obj, prop);
    }

    /**
     * Given a relative module name, like ./something, normalize it to
     * a real name that can be mapped to a path.
     * @param {String} name the relative name
     * @param {String} baseName a real name that the name arg is relative
     * to.
     * @returns {String} normalized name
     */
    function normalize(name, baseName) {
        var nameParts, nameSegment, mapValue, foundMap, lastIndex,
            foundI, foundStarMap, starI, i, j, part,
            baseParts = baseName && baseName.split("/"),
            map = config.map,
            starMap = (map && map['*']) || {};

        //Adjust any relative paths.
        if (name && name.charAt(0) === ".") {
            //If have a base name, try to normalize against it,
            //otherwise, assume it is a top-level require that will
            //be relative to baseUrl in the end.
            if (baseName) {
                name = name.split('/');
                lastIndex = name.length - 1;

                // Node .js allowance:
                if (config.nodeIdCompat && jsSuffixRegExp.test(name[lastIndex])) {
                    name[lastIndex] = name[lastIndex].replace(jsSuffixRegExp, '');
                }

                //Lop off the last part of baseParts, so that . matches the
                //"directory" and not name of the baseName's module. For instance,
                //baseName of "one/two/three", maps to "one/two/three.js", but we
                //want the directory, "one/two" for this normalization.
                name = baseParts.slice(0, baseParts.length - 1).concat(name);

                //start trimDots
                for (i = 0; i < name.length; i += 1) {
                    part = name[i];
                    if (part === ".") {
                        name.splice(i, 1);
                        i -= 1;
                    } else if (part === "..") {
                        if (i === 1 && (name[2] === '..' || name[0] === '..')) {
                            //End of the line. Keep at least one non-dot
                            //path segment at the front so it can be mapped
                            //correctly to disk. Otherwise, there is likely
                            //no path mapping for a path starting with '..'.
                            //This can still fail, but catches the most reasonable
                            //uses of ..
                            break;
                        } else if (i > 0) {
                            name.splice(i - 1, 2);
                            i -= 2;
                        }
                    }
                }
                //end trimDots

                name = name.join("/");
            } else if (name.indexOf('./') === 0) {
                // No baseName, so this is ID is resolved relative
                // to baseUrl, pull off the leading dot.
                name = name.substring(2);
            }
        }

        //Apply map config if available.
        if ((baseParts || starMap) && map) {
            nameParts = name.split('/');

            for (i = nameParts.length; i > 0; i -= 1) {
                nameSegment = nameParts.slice(0, i).join("/");

                if (baseParts) {
                    //Find the longest baseName segment match in the config.
                    //So, do joins on the biggest to smallest lengths of baseParts.
                    for (j = baseParts.length; j > 0; j -= 1) {
                        mapValue = map[baseParts.slice(0, j).join('/')];

                        //baseName segment has  config, find if it has one for
                        //this name.
                        if (mapValue) {
                            mapValue = mapValue[nameSegment];
                            if (mapValue) {
                                //Match, update name to the new value.
                                foundMap = mapValue;
                                foundI = i;
                                break;
                            }
                        }
                    }
                }

                if (foundMap) {
                    break;
                }

                //Check for a star map match, but just hold on to it,
                //if there is a shorter segment match later in a matching
                //config, then favor over this star map.
                if (!foundStarMap && starMap && starMap[nameSegment]) {
                    foundStarMap = starMap[nameSegment];
                    starI = i;
                }
            }

            if (!foundMap && foundStarMap) {
                foundMap = foundStarMap;
                foundI = starI;
            }

            if (foundMap) {
                nameParts.splice(0, foundI, foundMap);
                name = nameParts.join('/');
            }
        }

        return name;
    }

    function makeRequire(relName, forceSync) {
        return function () {
            //A version of a require function that passes a moduleName
            //value for items that may need to
            //look up paths relative to the moduleName
            var args = aps.call(arguments, 0);

            //If first arg is not require('string'), and there is only
            //one arg, it is the array form without a callback. Insert
            //a null so that the following concat is correct.
            if (typeof args[0] !== 'string' && args.length === 1) {
                args.push(null);
            }
            return req.apply(undef, args.concat([relName, forceSync]));
        };
    }

    function makeNormalize(relName) {
        return function (name) {
            return normalize(name, relName);
        };
    }

    function makeLoad(depName) {
        return function (value) {
            defined[depName] = value;
        };
    }

    function callDep(name) {
        if (hasProp(waiting, name)) {
            var args = waiting[name];
            delete waiting[name];
            defining[name] = true;
            main.apply(undef, args);
        }

        if (!hasProp(defined, name) && !hasProp(defining, name)) {
            throw new Error('No ' + name);
        }
        return defined[name];
    }

    //Turns a plugin!resource to [plugin, resource]
    //with the plugin being undefined if the name
    //did not have a plugin prefix.
    function splitPrefix(name) {
        var prefix,
            index = name ? name.indexOf('!') : -1;
        if (index > -1) {
            prefix = name.substring(0, index);
            name = name.substring(index + 1, name.length);
        }
        return [prefix, name];
    }

    /**
     * Makes a name map, normalizing the name, and using a plugin
     * for normalization if necessary. Grabs a ref to plugin
     * too, as an optimization.
     */
    makeMap = function (name, relName) {
        var plugin,
            parts = splitPrefix(name),
            prefix = parts[0];

        name = parts[1];

        if (prefix) {
            prefix = normalize(prefix, relName);
            plugin = callDep(prefix);
        }

        //Normalize according
        if (prefix) {
            if (plugin && plugin.normalize) {
                name = plugin.normalize(name, makeNormalize(relName));
            } else {
                name = normalize(name, relName);
            }
        } else {
            name = normalize(name, relName);
            parts = splitPrefix(name);
            prefix = parts[0];
            name = parts[1];
            if (prefix) {
                plugin = callDep(prefix);
            }
        }

        //Using ridiculous property names for space reasons
        return {
            f: prefix ? prefix + '!' + name : name, //fullName
            n: name,
            pr: prefix,
            p: plugin
        };
    };

    function makeConfig(name) {
        return function () {
            return (config && config.config && config.config[name]) || {};
        };
    }

    handlers = {
        require: function (name) {
            return makeRequire(name);
        },
        exports: function (name) {
            var e = defined[name];
            if (typeof e !== 'undefined') {
                return e;
            } else {
                return (defined[name] = {});
            }
        },
        module: function (name) {
            return {
                id: name,
                uri: '',
                exports: defined[name],
                config: makeConfig(name)
            };
        }
    };

    main = function (name, deps, callback, relName) {
        var cjsModule, depName, ret, map, i,
            args = [],
            callbackType = typeof callback,
            usingExports;

        //Use name if no relName
        relName = relName || name;

        //Call the callback to define the module, if necessary.
        if (callbackType === 'undefined' || callbackType === 'function') {
            //Pull out the defined dependencies and pass the ordered
            //values to the callback.
            //Default to [require, exports, module] if no deps
            deps = !deps.length && callback.length ? ['require', 'exports', 'module'] : deps;
            for (i = 0; i < deps.length; i += 1) {
                map = makeMap(deps[i], relName);
                depName = map.f;

                //Fast path CommonJS standard dependencies.
                if (depName === "require") {
                    args[i] = handlers.require(name);
                } else if (depName === "exports") {
                    //CommonJS module spec 1.1
                    args[i] = handlers.exports(name);
                    usingExports = true;
                } else if (depName === "module") {
                    //CommonJS module spec 1.1
                    cjsModule = args[i] = handlers.module(name);
                } else if (hasProp(defined, depName) ||
                    hasProp(waiting, depName) ||
                    hasProp(defining, depName)) {
                    args[i] = callDep(depName);
                } else if (map.p) {
                    map.p.load(map.n, makeRequire(relName, true), makeLoad(depName), {});
                    args[i] = defined[depName];
                } else {
                    throw new Error(name + ' missing ' + depName);
                }
            }

            ret = callback ? callback.apply(defined[name], args) : undefined;

            if (name) {
                //If setting exports via "module" is in play,
                //favor that over return value and exports. After that,
                //favor a non-undefined return value over exports use.
                if (cjsModule && cjsModule.exports !== undef &&
                    cjsModule.exports !== defined[name]) {
                    defined[name] = cjsModule.exports;
                } else if (ret !== undef || !usingExports) {
                    //Use the return value from the function.
                    defined[name] = ret;
                }
            }
        } else if (name) {
            //May just be an object definition for the module. Only
            //worry about defining if have a module name.
            defined[name] = callback;
        }
    };

    requirejs = require = req = function (deps, callback, relName, forceSync, alt) {
        if (typeof deps === "string") {
            if (handlers[deps]) {
                //callback in this case is really relName
                return handlers[deps](callback);
            }
            //Just return the module wanted. In this scenario, the
            //deps arg is the module name, and second arg (if passed)
            //is just the relName.
            //Normalize module name, if it contains . or ..
            return callDep(makeMap(deps, callback).f);
        } else if (!deps.splice) {
            //deps is a config object, not an array.
            config = deps;
            if (config.deps) {
                req(config.deps, config.callback);
            }
            if (!callback) {
                return;
            }

            if (callback.splice) {
                //callback is an array, which means it is a dependency list.
                //Adjust args if there are dependencies
                deps = callback;
                callback = relName;
                relName = null;
            } else {
                deps = undef;
            }
        }

        //Support require(['a'])
        callback = callback || function () {};

        //If relName is a function, it is an errback handler,
        //so remove it.
        if (typeof relName === 'function') {
            relName = forceSync;
            forceSync = alt;
        }

        //Simulate async callback;
        if (forceSync) {
            main(undef, deps, callback, relName);
        } else {
            //Using a non-zero value because of concern for what old browsers
            //do, and latest browsers "upgrade" to 4 if lower value is used:
            //http://www.whatwg.org/specs/web-apps/current-work/multipage/timers.html#dom-windowtimers-settimeout:
            //If want a value immediately, use require('id') instead -- something
            //that works in almond on the global level, but not guaranteed and
            //unlikely to work in other AMD implementations.
            setTimeout(function () {
                main(undef, deps, callback, relName);
            }, 4);
        }

        return req;
    };

    /**
     * Just drops the config on the floor, but returns req in case
     * the config return value is used.
     */
    req.config = function (cfg) {
        return req(cfg);
    };

    /**
     * Expose module registry for debugging and tooling
     */
    requirejs._defined = defined;

    define = function (name, deps, callback) {
        if (typeof name !== 'string') {
            throw new Error('See almond README: incorrect module build, no module name');
        }

        //This module may not have dependencies
        if (!deps.splice) {
            //deps is not an array, so probably means
            //an object literal or factory function for
            //the value. Adjust args.
            callback = deps;
            deps = [];
        }

        if (!hasProp(defined, name) && !hasProp(waiting, name)) {
            waiting[name] = [name, deps, callback];
        }
    };

    define.amd = {
        jQuery: true
    };
}());
define("almond", function(){});

/**
 * Created by eason on 15/5/4.
 */
define('Constants',[],function(){
    return {

        INSTANCES_KEY:'vancharts_index_',

        SELECT_ANIMATION:'select',

        CHART_HIDE: 'vancharts-chart-hide',
        EXPORT_HIDE: 'vancharts-export-hide',

        //坐标系类型
        GEO:'geographic_co_sys',
        PLANE:'plane_co_sys',

        //图表类型
        BAR_CHART:'bar',//条形图
        COLUMN_CHART:'column',//柱形图
        LINE_CHART:'line',//折线图
        AREA_CHART:'area',//面积图
        PIE_CHART:'pie',//饼图
        MULTIPIE_CHART:'multiPie',//多层饼图
        SCATTER_CHART:'scatter',//散点图
        BUBBLE_CHART:'bubble',//气泡图
        GAUGE_CHART:'gauge',//仪表盘
        RADAR_CHART:'radar',//雷达图
        MAP_CHART:'map',//地图
        POINT_MAP:'pointMap',
        AREA_MAP:'areaMap',


        //组件类型
        GEO_COMPONENT:'geo',
        X_AXIS_COMPONENT:'xAxis',
        Y_AXIS_COMPONENT:'yAxis',
        POLAR_COMPONENT:'polar',
        RADIUS_AXIS_COMPONENT:'radiusAxis',
        ANGLE_AXIS_COMPONENT:'angleAxis',
        GAUGE_AXIS_COMPONENT:'gaugeAxis',
        VALUE_AXIS_COMPONENT:'value',
        CATEGORY_AXIS_COMPONENT:'category',
        DATE_AXIS_COMPONENT:'datetime',
        DATA_SHEET_COMPONENT:'dataSheet',
        LEGEND_COMPONENT:'legend',
        TITLE_COMPONENT:'title',
        AXIS_COMPONENT:'axis',
        TOOLTIP_COMPONENT:'tooltip',
        TOOLBAR_COMPONENT:'tools',
        ZOOM_COMPONENT:'zoom',
        RANGE_LEGEND_COMPONENT:'rangeLegend',
        DRILL_TOOLS:'dTools',

        VANCHART:'vanchart',

        //工具栏的icon类型
        MAX_ICON : 'vancharts-icon-max',
        MIN_ICON:'vancharts-icon-min',
        MENU_ICON : 'vancharts-icon-menu',
        REFRESH_ICON : 'vancharts-icon-refresh',
        DECREASE_ICON : 'vancharts-icon-decrease',
        INCREASE_ICON : 'vancharts-icon-increase',
        EXPORT_ICON : 'vancharts-icon-export',

        AXIS_GROUP:'vanchart-axis-group',

        //位置相关的常量
        BOTTOM:'bottom',
        TOP:'top',
        LEFT:'left',
        RIGHT:'right',
        RIGHT_TOP:'right-top',

        //动画的方向
        LEFT_TO_RIGHT:'left-to-right',
        RIGHT_TO_LEFT:'right-to-right',
        BOTTOM_TO_TOP:'bottom-to-top',
        TOP_TO_BOTTOM:'top-to-botttom',

        //标记点类型
        NULL_MARKER:'null_marker',
        CIRCLE:'circle',
        SQUARE:'square',
        DIAMOND:'diamond',
        TRIANGLE:'triangle',

        CIRCLE_HOLLOW:'circle_hollow',
        SQUARE_HOLLOW:'square_hollow',
        DIAMOND_HOLLOW:'diamond_hollow',
        TRIANGLE_HOLLOW:'triangle_hollow',

        //图例的另外三种类型
        NORMAL_ICON:'normal-legend-icon',//一般的图例
        PIE_ICON:'pie-legend-icon',
        DONUT_ICON:'donut-legend-icon',
        BUBBLE_ICON:'bubble-legend-icon',
        SCATTER_ICON:'scatter-legend-icon',

        //虚线的类型
        DASH_TYPE:{
            Solid:'0,0',
            Dash:'8,6'
        },

        //玫瑰图的不同形状
        SAME_ARC : 'sameArc',//所有扇形弧长相同
        DIFFERENT_ARC : 'differentArc',//所有扇形弧长不相等

        //图的排序的状态
        DISORDER:'disorder',
        DESCENDING:'descending',
        ASCENDING:'ascending',

        //图的状态
        STATE_INIT:'init-state',//初始状态
        STATE_RESTORE_REFRESH:'restore-refresh-state',//缩放后的刷新状态
        STATE_CHANGE_DATA_REFRESH:'change-data-refresh-state',//自动刷新（数据变换）状态
        STATE_ZOOM_REFRESH:'zoom-refresh-state',//缩放状态

        //标签的位置
        OUTSIDE : 'outside',
        INSIDE : 'inside',
        CENTER:'center',

        //各种渲染器的名字
        VANCHART_SVG:'vanchart-svg-render',
        VANCHART_VML:'vanchart-vml-render',

        PIE_SVG:'pie-svg-render',
        PIE_VML:'pie-vml-render',

        MULTIPIE_SVG:'multiPie-svg-render',
        MULTIPIE_VML:'multiPie-vml-render',

        BAR_SVG:'bar-svg-render',
        BAR_VML:'bar-vml-render',

        LINE_SVG:'line-svg-render',
        LINE_VML:'line-vml-render',

        AREA_SVG:'area-svg-render',
        AREA_VML:'area-vml-render',

        GAUGE_SVG:'gauge-svg-render',
        GAUGE_VML:'gauge-vml-render',

        RADAR_SVG:'radar-svg-render',
        RADAR_VML:'radar-vml-render',

        BUBBLE_SVG:'bubble-svg-render',
        BUBBLE_VML:'bubble-vml-render',

        SCATTER_SVG:'scatter-svg-render',
        SCATTER_VML:'scatter-vml-render',

        MAP_SVG:'map-svg-render',
        MAP_VML:'map-vml-render',

        TITLE_SVG:'title-svg-render',
        TITLE_VML:'title-vml-render',
        LEGEND_SVG:'legend-svg-render',
        LEGEND_VML:'legend-vml-render',
        RANGE_LEGEND_SVG:'range-legend-svg-render',
        RANGE_LEGEND_VML:'range-legend-vml-render',
        TOOLBAR_SVG:'toolbar-svg-render',
        TOOLBAR_VML:'toolbar-vml-render',
        DRILL_TOOLS_SVG:'dTools-svg-render',
        DRILL_TOOLS_VML:'dTools-vml-render',

        ZOOM_SVG:'zoom-svg-render',

        DATA_SHEET_SVG:'data-sheet-svg-render',
        DATA_SHEET_VML:'data-sheet-vml-render',

        AXIS_RENDER:'axis-render',
        RADIUS_AXIS_RENDER:'radius-axis-render',
        ANGLE_AXIS_RENDER:'angle-axis-render',
        CATEGORY_AXIS_SVG:'category-axis-svg-render',
        CATEGORY_AXIS_VML:'category-axis-vml-render',
        VALUE_AXIS_SVG:'value-axis-svg-render',
        VALUE_AXIS_VML:'value-axis-vml-render',
        DATE_AXIS_SVG:'date-axis-svg-render',
        DATE_AXIS_VML:'date-axis-vml-render',
        RADIUS_AXIS_SVG:'radius-axis-svg-render',
        RADIUS_AXIS_VML:'radius-axis-vml-render',
        ANGLE_AXIS_SVG:'angle-axis-svg-render',
        ANGLE_AXIS_VML:'angle-axis-vml-render',

        //样式的名字
        STYLE_GRADUAL:'gradual', //渐变

        //四种仪表盘的样式
        GAUGE_POINTER:'pointer',
        GAUGE_POINTER_SEMI:'pointer_semi',
        GAUGE_SLOT:'slot',
        GAUGE_THERMOMETER:'thermometer',
        GAUGE_RING:'ring',

        //仪表盘布局
        HORIZONTAL_LAYOUT:'horizontal',
        VERTICAL_LAYOUT:'vertical',

        //雷达图底边
        POLYGON_RADAR:'polygon',
        CIRCLE_RADAR:'circle',

        //size是通过气泡的半径还是面积表现出来
        SIZE_BY_AREA:'area',
        SIZE_BY_WIDTH:'width',

        GRADUAL_LIGHTER: 'lighter',
        GRADUAL_DARKER: 'darker',

        TOOLTIP_CATEGORY_STYLE: '<span style="font-size:16px;font-family:Verdana;color:white;">',
        TOOLTIP_SERIES_STYLE: '<span style="font-size:14px;font-family:Verdana;color:white">',
        TOOLTIP_VALUE_STYLE: '<span style="font-size:14px;font-family:Verdana;font-weight:bold;color:white">'
    }

});
/**
 * Created by eason on 15/6/30.
 * some of the following methods are borrowed from zrender
 */

//Copyright (c) 2013, Baidu Inc.
//    All rights reserved.
//
//    Redistribution and use of this software in source and binary forms, with or
//    without modification, are permitted provided that the following conditions
//are met:
//
//    Redistributions of source code must retain the above copyright notice, this
//list of conditions and the following disclaimer.
//
//    Redistributions in binary form must reproduce the above copyright notice,
//    this list of conditions and the following disclaimer in the documentation
//and/or other materials provided with the distribution.
//
//    Neither the name of Baidu Inc. nor the names of its contributors may be used
//to endorse or promote products derived from this software without specific
//prior written permission of Baidu Inc.
//
//    THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
//AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
//IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
//DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR
//ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
//(INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
//LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON
//ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
//(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
//SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.

define('utils/ColorUtils',[],function(){
    var _nameColors = {
        aliceblue : '#f0f8ff',
        antiquewhite : '#faebd7',
        aqua : '#0ff',
        aquamarine : '#7fffd4',
        azure : '#f0ffff',
        beige : '#f5f5dc',
        bisque : '#ffe4c4',
        black : '#000',
        blanchedalmond : '#ffebcd',
        blue : '#00f',
        blueviolet : '#8a2be2',
        brown : '#a52a2a',
        burlywood : '#deb887',
        cadetblue : '#5f9ea0',
        chartreuse : '#7fff00',
        chocolate : '#d2691e',
        coral : '#ff7f50',
        cornflowerblue : '#6495ed',
        cornsilk : '#fff8dc',
        crimson : '#dc143c',
        cyan : '#0ff',
        darkblue : '#00008b',
        darkcyan : '#008b8b',
        darkgoldenrod : '#b8860b',
        darkgray : '#a9a9a9',
        darkgrey : '#a9a9a9',
        darkgreen : '#006400',
        darkkhaki : '#bdb76b',
        darkmagenta : '#8b008b',
        darkolivegreen : '#556b2f',
        darkorange : '#ff8c00',
        darkorchid : '#9932cc',
        darkred : '#8b0000',
        darksalmon : '#e9967a',
        darkseagreen : '#8fbc8f',
        darkslateblue : '#483d8b',
        darkslategray : '#2f4f4f',
        darkslategrey : '#2f4f4f',
        darkturquoise : '#00ced1',
        darkviolet : '#9400d3',
        deeppink : '#ff1493',
        deepskyblue : '#00bfff',
        dimgray : '#696969',
        dimgrey : '#696969',
        dodgerblue : '#1e90ff',
        firebrick : '#b22222',
        floralwhite : '#fffaf0',
        forestgreen : '#228b22',
        fuchsia : '#f0f',
        gainsboro : '#dcdcdc',
        ghostwhite : '#f8f8ff',
        gold : '#ffd700',
        goldenrod : '#daa520',
        gray : '#808080',
        grey : '#808080',
        green : '#008000',
        greenyellow : '#adff2f',
        honeydew : '#f0fff0',
        hotpink : '#ff69b4',
        indianred : '#cd5c5c',
        indigo : '#4b0082',
        ivory : '#fffff0',
        khaki : '#f0e68c',
        lavender : '#e6e6fa',
        lavenderblush : '#fff0f5',
        lawngreen : '#7cfc00',
        lemonchiffon : '#fffacd',
        lightblue : '#add8e6',
        lightcoral : '#f08080',
        lightcyan : '#e0ffff',
        lightgoldenrodyellow : '#fafad2',
        lightgray : '#d3d3d3',
        lightgrey : '#d3d3d3',
        lightgreen : '#90ee90',
        lightpink : '#ffb6c1',
        lightsalmon : '#ffa07a',
        lightseagreen : '#20b2aa',
        lightskyblue : '#87cefa',
        lightslategray : '#789',
        lightslategrey : '#789',
        lightsteelblue : '#b0c4de',
        lightyellow : '#ffffe0',
        lime : '#0f0',
        limegreen : '#32cd32',
        linen : '#faf0e6',
        magenta : '#f0f',
        maroon : '#800000',
        mediumaquamarine : '#66cdaa',
        mediumblue : '#0000cd',
        mediumorchid : '#ba55d3',
        mediumpurple : '#9370d8',
        mediumseagreen : '#3cb371',
        mediumslateblue : '#7b68ee',
        mediumspringgreen : '#00fa9a',
        mediumturquoise : '#48d1cc',
        mediumvioletred : '#c71585',
        midnightblue : '#191970',
        mintcream : '#f5fffa',
        mistyrose : '#ffe4e1',
        moccasin : '#ffe4b5',
        navajowhite : '#ffdead',
        navy : '#000080',
        oldlace : '#fdf5e6',
        olive : '#808000',
        olivedrab : '#6b8e23',
        orange : '#ffa500',
        orangered : '#ff4500',
        orchid : '#da70d6',
        palegoldenrod : '#eee8aa',
        palegreen : '#98fb98',
        paleturquoise : '#afeeee',
        palevioletred : '#d87093',
        papayawhip : '#ffefd5',
        peachpuff : '#ffdab9',
        peru : '#cd853f',
        pink : '#ffc0cb',
        plum : '#dda0dd',
        powderblue : '#b0e0e6',
        purple : '#800080',
        red : '#f00',
        rosybrown : '#bc8f8f',
        royalblue : '#4169e1',
        saddlebrown : '#8b4513',
        salmon : '#fa8072',
        sandybrown : '#f4a460',
        seagreen : '#2e8b57',
        seashell : '#fff5ee',
        sienna : '#a0522d',
        silver : '#c0c0c0',
        skyblue : '#87ceeb',
        slateblue : '#6a5acd',
        slategray : '#708090',
        slategrey : '#708090',
        snow : '#fffafa',
        springgreen : '#00ff7f',
        steelblue : '#4682b4',
        tan : '#d2b48c',
        teal : '#008080',
        thistle : '#d8bfd8',
        tomato : '#ff6347',
        turquoise : '#40e0d0',
        violet : '#ee82ee',
        wheat : '#f5deb3',
        white : '#fff',
        whitesmoke : '#f5f5f5',
        yellow : '#ff0',
        yellowgreen : '#9acd32'
    };

    var colorRegExp = /^\s*((#[a-f\d]{6})|(#[a-f\d]{3})|rgba?\(\s*([\d\.]+%?\s*,\s*[\d\.]+%?\s*,\s*[\d\.]+%?(?:\s*,\s*[\d\.]+%?)?)\s*\)|hsba?\(\s*([\d\.]+(?:deg|\xb0|%)?\s*,\s*[\d\.]+%?\s*,\s*[\d\.]+%?(?:\s*,\s*[\d\.]+)?)%?\s*\)|hsla?\(\s*([\d\.]+(?:deg|\xb0|%)?\s*,\s*[\d\.]+%?\s*,\s*[\d\.]+%?(?:\s*,\s*[\d\.]+)?)%?\s*\))\s*$/i;

    function trim(color) {
        return String(color).replace(/\s+/g, '');
    }

    // 调整值区间
    function adjust(value, region) {
        if (value <= region[0]) {
            value = region[0];
        }
        else if (value >= region[1]) {
            value = region[1];
        }
        return value;
    }

    // 数组映射
    function map(array, fun) {
        if (typeof fun !== 'function') {
            throw new TypeError();
        }
        var len = array ? array.length : 0;
        for (var i = 0; i < len; i++) {
            array[i] = fun(array[i]);
        }
        return array;
    }

    /**
     * 把颜色转化成数组数据，用于计算
     * @param color 颜色
     */
    function getRGBAColorArray(color){
        if (_nameColors[color]) {
            color = _nameColors[color];
        }

        color = trim(color);

        if (/^#[\da-f]{3}$/i.test(color)) {
            color = parseInt(color.slice(1), 16);
            var r = (color & 0xf00) << 8;
            var g = (color & 0xf0) << 4;
            var b = color & 0xf;

            color = '#' + ((1 << 24) + (r << 4) + r + (g << 4) + g + (b << 4) + b).toString(16).slice(1);
        }

        var r = color.match(colorRegExp);

        var d;
        var a;
        var data = [];
        var rgb;

        if (r[2]) {
            // #rrggbb
            d = r[2].replace('#', '').split('');
            rgb = [ d[0] + d[1], d[2] + d[3], d[4] + d[5] ];
            data = map(rgb,
                function(c) {
                    return adjust(parseInt(c, 16), [ 0, 255 ]);
                }
            );
        } else if (r[4]) {
            // rgb rgba
            var rgba = (r[4]).split(',');
            a = rgba[3];
            rgb = rgba.slice(0, 3);
            data = map(
                rgb,
                function(c) {
                    c = Math.floor(
                        c.indexOf('%') > 0 ? parseInt(c, 0) * 2.55 : c
                    );
                    return adjust(c, [ 0, 255 ]);
                }
            );

            if (typeof a !== 'undefined') {
                data.push(adjust(parseFloat(a), [ 0, 1 ]));
            }
        }


        //统一rgba的格式
        if(data.length == 3){
            data.push(1);
        }

        return data;
    }

    function toColor(data, format){
        format = format || 'rgb';
        if (data && (data.length === 3 || data.length === 4)) {
            data = map(data,
                function(c) {
                    return c > 1 ? Math.ceil(c) : c;
                }
            );

            if (format.indexOf('hex') > -1) {
                return '#' + ((1 << 24) + (data[0] << 16) + (data[1] << 8) + (+data[2])).toString(16).slice(1);
            }
            else if (format.indexOf('hs') > -1) {
                var sx = map(data.slice(1, 3),
                    function(c) {
                        return c + '%';
                    }
                );
                data[1] = sx[0];
                data[2] = sx[1];
            }

            if (format.indexOf('a') > -1) {
                if (data.length === 3) {
                    data.push(1);
                }
                data[3] = adjust(data[3], [ 0, 1 ]);
                return format + '(' + data.slice(0, 4).join(',') + ')';
            }

            return format + '(' + data.slice(0, 3).join(',') + ')';
        }
    }

    function getHighLightColor(color){
        var rgba = getRGBAColorArray(color);
        var tmp = [];
        for(var i = 0; i < 3; i++){
            var x = rgba[i];
            if(x <= 128){
                tmp.push(adjust(x-(255-x)*(255-2*x)/(2*x), [0,255]));
            }else{
                tmp.push(adjust(x+x*(2*x-255)/(2*(255-x)), [0,255]));
            }
        }

        var result = [];
        for(i = 0; i < 3; i++){
            result.push(Math.round(0.65 * rgba[i] + 0.35 * tmp[i]));
        }
        result.push(rgba[3]);

        return toColor(result, 'rgba');
    }

    function getColorWithDivider(color, divider){
        var rgba = getRGBAColorArray(color);

        for(var i = 0; i < 3; i++){
            rgba[i] /= divider;
        }

        return toColor(rgba, 'rgba');
    }

    function getClickColor(color){

        var rgba = getRGBAColorArray(color);

        for(var i = 0; i < 3; i++){
            rgba[i] *= 0.95;
        }

        return toColor(rgba, 'rgba');
    }

    function mixColorWithAlpha(color, alpha){
        var rgba = getRGBAColorArray(color);
        rgba[3] = alpha;
        return toColor(rgba, 'rgba');
    }

    function mixColorWithHSB(color, detH, detS, detB){
        var rgba = getRGBAColorArray(color);

        var hsb = rgb2hsb(rgba[0], rgba[1], rgba[2]);

        hsb[0] += detH;
        hsb[1] += detS;
        hsb[2] += detB;

        var rgb = hsb2rgb(hsb[0], hsb[1], hsb[2]);

        return toColor(rgb, 'rgb');
    }

    function hsb2rgb(hue, saturation, brightness){

        saturation = Math.min(1, Math.max(0, saturation));

        brightness = Math.min(1, Math.max(0, brightness));

        var r = 0, g = 0, b = 0;
        if (saturation === 0) {
            r = g = b = brightness * 255.0 + 0.5;
        } else {
            var h = (hue - Math.floor(hue)) * 6.0;
            var f = h - Math.floor(h);
            var p = brightness * (1.0 - saturation);
            var q = brightness * (1.0 - saturation * f);
            var t = brightness * (1.0 - (saturation * (1.0 - f)));
            switch (Math.floor(h)) {
                case 0:
                    r = brightness * 255.0 + 0.5;
                    g = t * 255.0 + 0.5;
                    b = p * 255.0 + 0.5;
                    break;
                case 1:
                    r = q * 255.0 + 0.5;
                    g = brightness * 255.0 + 0.5;
                    b = p * 255.0 + 0.5;
                    break;
                case 2:
                    r = p * 255.0 + 0.5;
                    g = brightness * 255.0 + 0.5;
                    b = t * 255.0 + 0.5;
                    break;
                case 3:
                    r = p * 255.0 + 0.5;
                    g = q * 255.0 + 0.5;
                    b = brightness * 255.0 + 0.5;
                    break;
                case 4:
                    r = t * 255.0 + 0.5;
                    g = p * 255.0 + 0.5;
                    b = brightness * 255.0 + 0.5;
                    break;
                case 5:
                    r = brightness * 255.0 + 0.5;
                    g = p * 255.0 + 0.5;
                    b = q * 255.0 + 0.5;
                    break;
            }
        }
        var rgb = [];
        rgb.push(Math.floor(r));
        rgb.push(Math.floor(g));
        rgb.push(Math.floor(b));
        return rgb;
    }

    function createColorsWithHsb(color, count){

        color = color || 'blue';
        count = count || 1;

        var rgba = getRGBAColorArray(color);
        var hsb = rgb2hsb(rgba[0], rgba[1], rgba[2]);

        var result = [], h = hsb[0], s = hsb[1], b = hsb[2];

        for(var i = 0; i < count; i++){
            var tmpS = s * (1 - i / count);
            var tmpB = b + i * (1 - b) / count;
            result.push(toColor(hsb2rgb(h, tmpS, tmpB)));
        }

        return result;
    }

    function rgb2hsb(r, g, b){

        var hue, saturation, brightness;

        var hsbvals = [3];
        var cmax = (r > g) ? r : g;
        if (b > cmax) {
            cmax = b;
        }
        var cmin = (r < g) ? r : g;
        if (b < cmin) {
            cmin = b;
        }

        brightness = cmax / 255.0;
        if (cmax !== 0) {
            saturation = (cmax - cmin) / cmax;
        }else{
            saturation = 0;
        }


        if (saturation === 0) {
            hue = 0;
        }else{
            var redc = (cmax - r) / (cmax - cmin);
            var greenc = (cmax - g) / (cmax - cmin);
            var bluec = (cmax - b) / (cmax - cmin);
            if (r == cmax) {
                hue = bluec - greenc;
            }
            else if (g == cmax) {
                hue = 2.0 + redc - bluec;
            }
            else {
                hue = 4.0 + greenc - redc;
            }
            hue = hue / 6.0;
            if (hue < 0) {
                hue = hue + 1.0;
            }
        }

        hsbvals[0] = hue;
        hsbvals[1] = saturation;
        hsbvals[2] = brightness;
        return hsbvals;
    }

    function getColorOpacity(color){

        return (color && typeof color == 'string' && (color.indexOf('rgba') != -1)) ?
            getRGBAColorArray(color)[3] :
            1;
    }

    //没有a定义的话返回空
    function getColorOpacityWithoutDefault(color){

        return (color && typeof color == 'string' && (color.indexOf('rgba') != -1))
                                                    ? getColorOpacity(color) : undefined;

    }

    function colorToHex(color){
        return colorToHexAlpha(color).hex;
    }

    function colorToHexAlpha(color){
        var rgb = toColor(getRGBAColorArray(color), 'rgba');

        var rRgba = /rgba?\((\d{1,3}),(\d{1,3}),(\d{1,3})(,([.\d]+))?\)/,
            r, g, b, a,
            rsa = rgb.replace(/\s+/g, "").match(rRgba);

        r = (+rsa[1]).toString(16);
        r = r.length === 1 ? "0" + r : r;
        g = (+rsa[2]).toString(16);
        g = g.length === 1 ? "0" + g : g;
        b = (+rsa[3]).toString(16);
        b = b.length === 1 ? "0" + b : b;
        a = (+(rsa[5] ? rsa[5] : 1)) * 100;

        return {hex: "#" + r + g + b, alpha: Math.ceil(a)};
    }

    var ColorUtils = {
        toColor:toColor,
        hsb2rgb:hsb2rgb,
        rgb2hsb:rgb2hsb,
        createColorsWithHsb:createColorsWithHsb,
        getRGBAColorArray:getRGBAColorArray,
        mixColorWithHSB:mixColorWithHSB,
        getHighLightColor:getHighLightColor,
        getColorWithDivider:getColorWithDivider,
        mixColorWithAlpha:mixColorWithAlpha,
        getColorOpacity:getColorOpacity,
        getColorOpacityWithoutDefault:getColorOpacityWithoutDefault,
        colorToHex:colorToHex,
        colorToHexAlpha:colorToHexAlpha,
        getClickColor:getClickColor
    };

    window.ColorUtils = ColorUtils;
    
    return ColorUtils;
});
/**
 * Created by eason on 15/6/16.
 */

define('utils/QueryUtils',['require','./BaseUtils'],function(require){
    var BaseUtils = require('./BaseUtils');

    //从选项中读出指定属性
    function query(opt, optLocation){
        if(!opt || !optLocation){
            return;
        }

        optLocation = optLocation.split('.');
        for(var index = 0, length = optLocation.length; index < length; index++){
            opt = opt[optLocation[index]];

            //这里的opt可能为0,false等
            if(opt == undefined){
                return;
            }
        }

        return opt;
    }


    //从可能的属性列表里读optLocation的属性，前面的优先级高
    function queryList(optList, optLocation){
        if(!optList || !optList.length || !optLocation){
            return undefined;
        }

        for(var i = 0; i < optList.length; i++){
            var result = query(optList[i], optLocation);
            if(result != undefined){
                return result;
            }
        }
    }

    function merge(target, source, overwrite){
        for (var key in source) {
            if (source.hasOwnProperty(key)) {
                var targetProp = target[key];
                if (typeof targetProp == 'object') {

                    //target[key]不为对象时？
                    merge(target[key], source[key], overwrite);
                }else if(overwrite || !(key in target)){
                    target[key] = source[key];
                }
            }
        }
        return target;
    }


    //从list里合并需要的选项
    function mergeList(optList, optLocation){
        if(!optList || !optList.length || !optLocation){
            return undefined;
        }

        var result;
        for(var i = 0, length = optList.length; i < length; i++){
            var tmpOption = query(optList[i], optLocation);

            if(result == undefined){
                result = BaseUtils.clone(tmpOption);
            }else{
                merge(result, tmpOption);
            }
        }

        return result;
    }

    return {
        mergeList:mergeList,
        queryList:queryList,
        query:query,
        merge:merge
    };
});
/**
 * Created by eason on 16/5/26.
 *
 * try to use Behavior Delegation
 */

define('utils/Class',['require','./QueryUtils'],function(require){

    var QueryUtils = require('./QueryUtils');

    function Class(){};

    Class.extend = function(props){

        // @function extend(props: Object): Function
        // [Extends the current class](#class-inheritance) given the properties to be included.
        // Returns a Javascript function that is a class constructor (to be called with `new`).
        var NewClass = function () {

            // call the constructor
            if (this.initialize) {
                this.initialize.apply(this, arguments);
            }

            // call all constructor hooks
            this.callInitHooks();
        };

        var parentProto = NewClass.__super__ = this.prototype;

        var proto = Object.create(parentProto);
        proto.constructor = NewClass;

        NewClass.prototype = proto;

        // inherit parent's statics
        for (var i in this) {
            if (this.hasOwnProperty(i) && i !== 'prototype') {
                NewClass[i] = this[i];
            }
        }

        //todo 暂时不知道用不用得上,先留着
        // // mix static properties into the class
        // if (props.statics) {
        //     L.extend(NewClass, props.statics);
        //     delete props.statics;
        // }
        //
        // // mix includes into the prototype
        // if (props.includes) {
        //     L.Util.extend.apply(null, [proto].concat(props.includes));
        //     delete props.includes;
        // }
        //
        // // merge options
        // if (proto.options) {
        //     props.options = L.Util.extend(L.Util.create(proto.options), props.options);
        // }

        // mix given properties into the prototype
        QueryUtils.merge(proto, props, true);

        proto._initHooks = [];

        // add method for calling all hooks
        proto.callInitHooks = function () {

            if (this._initHooksCalled) { return; }

            if (parentProto.callInitHooks) {
                parentProto.callInitHooks.call(this);
            }

            this._initHooksCalled = true;

            for (var i = 0, len = proto._initHooks.length; i < len; i++) {
                proto._initHooks[i].call(this);
            }
        };

        return NewClass;
    };

    // @function addInitHook(fn: Function)
    // Adds a [constructor hook](#class-constructor-hooks) to the class.
    Class.addInitHook = function (fn) { // (Function) || (String, args...)
        var args = Array.prototype.slice.call(arguments, 1);

        var init = typeof fn === 'function' ? fn : function () {
            this[fn].apply(this, args);
        };

        this.prototype._initHooks = this.prototype._initHooks || [];
        this.prototype._initHooks.push(init);
        return this;
    };

    return Class;
});


/**
 * Created by eason on 15/5/18.
 * 各种注册了的组件
 */
define('ComponentLibrary',[],function(){
    var _registeredComponents = Object.create(null);

    /**
     * 根据名字获得组件的function
     * @param name 组件的名字
     */
    function get(name){
        return _registeredComponents[name];
    }

    /**
     * 注册某种组件类型
     * @param name 组件的名字
     * @param chart 组件的实现
     */
    function register(name, compnent){
        _registeredComponents[name] = compnent;
    }

    return {
        get:get,
        register:register
    }

});
/**
 * Created by eason on 15/5/4.
 * 注册了的图表的工厂,所有加载的图表模块都在这里注册
 */
define('ChartLibrary',[],function(){
    var _registeredCharts = {};

    /**
     * 根据名字获得某种图表类型的function
     * @param name 图表名字
     */
    function get(name){
        return _registeredCharts[name];
    }

    /**
     * 注册某种图表类型
     * @param name 图表的名字
     * @param chart 图表的实现
     */
    function register(name, chart){
        _registeredCharts[name] = chart;
    }

    return {
        get:get,
        register:register
    }
});
/**
 * Created by eason on 15/8/12.
 * 各种注册了的渲染器
 */

define('render/RenderLibrary',[],function(){
    var _registeredRender = Object.create(null);

    /**
     * 根据名字获得渲染器的function
     * @param name 渲染器的名字
     */
    function get(name){
        return _registeredRender[name];
    }

    function getRender(name, attrObj){
        var RenderFunction = get(name);
        if(RenderFunction){
            return new RenderFunction(attrObj);
        }
    }

    /**
     * 注册某种渲染器
     * @param name 渲染器的名字
     * @param chart 渲染器的实现
     */
    function register(name, compnent){
        _registeredRender[name] = compnent;
    }

    return {
        get:get,
        getRender:getRender,
        register:register
    }

});
/**
 * Created by eason on 15/8/13.
 */
define('render/RenderFactory',['require','./RenderLibrary','../Constants','../utils/BaseUtils'],function(require){

    var RenderLibrary = require('./RenderLibrary');

    var Constants = require('../Constants');

    var BaseUtils = require('../utils/BaseUtils');

    var SVG_MAP = {};

    SVG_MAP[Constants.VANCHART] = Constants.VANCHART_SVG;
    SVG_MAP[Constants.PIE_CHART] = Constants.PIE_SVG;
    SVG_MAP[Constants.MULTIPIE_CHART] = Constants.MULTIPIE_SVG;
    SVG_MAP[Constants.BAR_CHART] = Constants.BAR_SVG;
    SVG_MAP[Constants.COLUMN_CHART] = Constants.BAR_SVG;
    SVG_MAP[Constants.LINE_CHART] = Constants.LINE_SVG;
    SVG_MAP[Constants.AREA_CHART] = Constants.AREA_SVG;
    SVG_MAP[Constants.GAUGE_CHART] = Constants.GAUGE_SVG;
    SVG_MAP[Constants.RADAR_CHART] = Constants.RADAR_SVG;
    SVG_MAP[Constants.BUBBLE_CHART] = Constants.BUBBLE_SVG;
    SVG_MAP[Constants.SCATTER_CHART] = Constants.SCATTER_SVG;
    SVG_MAP[Constants.MAP_CHART] = Constants.MAP_SVG;


    SVG_MAP[Constants.TITLE_COMPONENT] = Constants.TITLE_SVG;
    SVG_MAP[Constants.DRILL_TOOLS] = Constants.DRILL_TOOLS_SVG;
    SVG_MAP[Constants.LEGEND_COMPONENT] = Constants.LEGEND_SVG;
    SVG_MAP[Constants.TOOLBAR_COMPONENT] = Constants.TOOLBAR_SVG;
    SVG_MAP[Constants.X_AXIS_COMPONENT] = Constants.AXIS_RENDER;
    SVG_MAP[Constants.Y_AXIS_COMPONENT] = Constants.AXIS_RENDER;
    SVG_MAP[Constants.RADIUS_AXIS_COMPONENT] = Constants.AXIS_RENDER;
    SVG_MAP[Constants.ANGLE_AXIS_COMPONENT] = Constants.AXIS_RENDER;
    SVG_MAP[Constants.RADIUS_AXIS_RENDER] = Constants.RADIUS_AXIS_SVG;
    SVG_MAP[Constants.ANGLE_AXIS_RENDER] = Constants.ANGLE_AXIS_SVG;
    SVG_MAP[Constants.CATEGORY_AXIS_COMPONENT] = Constants.CATEGORY_AXIS_SVG;
    SVG_MAP[Constants.VALUE_AXIS_COMPONENT] = Constants.VALUE_AXIS_SVG;
    SVG_MAP[Constants.DATE_AXIS_COMPONENT] = Constants.DATE_AXIS_SVG;
    SVG_MAP[Constants.ZOOM_COMPONENT] = Constants.ZOOM_SVG;
    SVG_MAP[Constants.DATA_SHEET_COMPONENT] = Constants.DATA_SHEET_SVG;
    SVG_MAP[Constants.RANGE_LEGEND_COMPONENT] = Constants.RANGE_LEGEND_SVG;

    var VML_MAP = {};
    VML_MAP[Constants.VANCHART] = Constants.VANCHART_VML;
    VML_MAP[Constants.PIE_CHART] = Constants.PIE_VML;
    VML_MAP[Constants.MULTIPIE_CHART] = Constants.MULTIPIE_VML;
    VML_MAP[Constants.BAR_CHART] = Constants.BAR_VML;
    VML_MAP[Constants.COLUMN_CHART] = Constants.BAR_VML;
    VML_MAP[Constants.LINE_CHART] = Constants.LINE_VML;
    VML_MAP[Constants.AREA_CHART] = Constants.AREA_VML;
    VML_MAP[Constants.GAUGE_CHART] = Constants.GAUGE_VML;
    VML_MAP[Constants.RADAR_CHART] = Constants.RADAR_VML;
    VML_MAP[Constants.BUBBLE_CHART] = Constants.BUBBLE_VML;
    VML_MAP[Constants.SCATTER_CHART] = Constants.SCATTER_VML;
    VML_MAP[Constants.MAP_CHART] = Constants.MAP_VML;

    VML_MAP[Constants.TITLE_COMPONENT] = Constants.TITLE_VML;
    VML_MAP[Constants.DRILL_TOOLS] = Constants.DRILL_TOOLS_VML;
    VML_MAP[Constants.LEGEND_COMPONENT] = Constants.LEGEND_VML;
    VML_MAP[Constants.TOOLBAR_COMPONENT] = Constants.TOOLBAR_VML;
    VML_MAP[Constants.X_AXIS_COMPONENT] = Constants.AXIS_RENDER;
    VML_MAP[Constants.Y_AXIS_COMPONENT] = Constants.AXIS_RENDER;
    VML_MAP[Constants.RADIUS_AXIS_COMPONENT] = Constants.AXIS_RENDER;
    VML_MAP[Constants.ANGLE_AXIS_COMPONENT] = Constants.AXIS_RENDER;
    VML_MAP[Constants.RADIUS_AXIS_RENDER] = Constants.RADIUS_AXIS_VML;
    VML_MAP[Constants.ANGLE_AXIS_RENDER] = Constants.ANGLE_AXIS_VML;
    VML_MAP[Constants.CATEGORY_AXIS_COMPONENT] = Constants.CATEGORY_AXIS_VML;
    VML_MAP[Constants.VALUE_AXIS_COMPONENT] = Constants.VALUE_AXIS_VML;
    VML_MAP[Constants.DATE_AXIS_COMPONENT] = Constants.DATE_AXIS_VML;
    VML_MAP[Constants.DATA_SHEET_COMPONENT] = Constants.DATA_SHEET_VML;
    VML_MAP[Constants.RANGE_LEGEND_COMPONENT] = Constants.RANGE_LEGEND_VML;

    function getRender(componentTpe, attrObj){

        var renderName = BaseUtils.isSupportSVG() ?
                                SVG_MAP[componentTpe] : VML_MAP[componentTpe];

        return RenderLibrary.getRender(renderName, attrObj);
    }

    return {
        getRender:getRender
    }

});
/**
 * Created by eason on 16/5/26.
 */

define('dom/Browser',['require'],function(require){

    var ua = navigator.userAgent.toLowerCase(),
        doc = document.documentElement,

        ie = 'ActiveXObject' in window,

        webkit    = ua.indexOf('webkit') !== -1,
        phantomjs = ua.indexOf('phantom') !== -1,
        android23 = ua.search('android [23]') !== -1,
        chrome    = ua.indexOf('chrome') !== -1,
        gecko     = ua.indexOf('gecko') !== -1  && !webkit && !window.opera && !ie,

        mobile = typeof orientation !== 'undefined' || ua.indexOf('mobile') !== -1,
        msPointer = !window.PointerEvent && window.MSPointerEvent,
        pointer = window.PointerEvent || msPointer,

        ie3d = ie && ('transition' in doc.style),
        webkit3d = ('WebKitCSSMatrix' in window) && ('m11' in new window.WebKitCSSMatrix()) && !android23,
        gecko3d = 'MozPerspective' in doc.style,
        opera12 = 'OTransition' in doc.style;

    var touch = !window.L_NO_TOUCH && (pointer || 'ontouchstart' in window ||
        (window.DocumentTouch && document instanceof window.DocumentTouch));

    return {
        ie: ie,

        // @property ielt9: Boolean
        // `true` for Internet Explorer versions less than 9.
        ielt9: ie && !document.addEventListener,

        // @property edge: Boolean
        // `true` for the Edge web browser.
        edge: 'msLaunchUri' in navigator && !('documentMode' in document),

        // @property webkit: Boolean
        // `true` for webkit-based browsers like Chrome and Safari (including mobile versions).
        webkit: webkit,

        // @property gecko: Boolean
        // `true` for gecko-based browsers like Firefox.
        gecko: gecko,

        // @property android: Boolean
        // `true` for any browser running on an Android platform.
        android: ua.indexOf('android') !== -1,

        // @property android23: Boolean
        // `true` for browsers running on Android 2 or Android 3.
        android23: android23,

        // @property chrome: Boolean
        // `true` for the Chrome browser.
        chrome: chrome,

        // @property safari: Boolean
        // `true` for the Safari browser.
        safari: !chrome && ua.indexOf('safari') !== -1,


        // @property ie3d: Boolean
        // `true` for all Internet Explorer versions supporting CSS transforms.
        ie3d: ie3d,

        // @property webkit3d: Boolean
        // `true` for webkit-based browsers supporting CSS transforms.
        webkit3d: webkit3d,

        // @property gecko3d: Boolean
        // `true` for gecko-based browsers supporting CSS transforms.
        gecko3d: gecko3d,

        // @property opera12: Boolean
        // `true` for the Opera browser supporting CSS transforms (version 12 or later).
        opera12: opera12,

        // @property any3d: Boolean
        // `true` for all browsers supporting CSS transforms.
        any3d: !window.L_DISABLE_3D && (ie3d || webkit3d || gecko3d) && !opera12 && !phantomjs,


        // @property mobile: Boolean
        // `true` for all browsers running in a mobile device.
        mobile: mobile,

        // @property mobileWebkit: Boolean
        // `true` for all webkit-based browsers in a mobile device.
        mobileWebkit: mobile && webkit,

        // @property mobileWebkit3d: Boolean
        // `true` for all webkit-based browsers in a mobile device supporting CSS transforms.
        mobileWebkit3d: mobile && webkit3d,

        // @property mobileOpera: Boolean
        // `true` for the Opera browser in a mobile device.
        mobileOpera: mobile && window.opera,

        // @property mobileGecko: Boolean
        // `true` for gecko-based browsers running in a mobile device.
        mobileGecko: mobile && gecko,


        // @property touch: Boolean
        // `true` for all browsers supporting [touch events](https://developer.mozilla.org/docs/Web/API/Touch_events).
        touch: !!touch,

        // @property msPointer: Boolean
        // `true` for browsers implementing the Microsoft touch events model (notably IE10).
        msPointer: !!msPointer,

        // @property pointer: Boolean
        // `true` for all browsers supporting [pointer events](https://msdn.microsoft.com/en-us/library/dn433244%28v=vs.85%29.aspx).
        pointer: !!pointer,


        // @property retina: Boolean
        // `true` for browsers on a high-resolution "retina" screen.
        retina: (window.devicePixelRatio || (window.screen.deviceXDPI / window.screen.logicalXDPI)) > 1
    };
    
});

/**
 * Created by eason on 16/5/26.
 * 尝试换一种dom事件的实现方式
 */

define('dom/DomEvent',['require','../utils/BaseUtils','./Browser'],function(require){

    var eventsKey = '_vanchart_events';

    var BaseUtils = require('../utils/BaseUtils');
    var Browser = require('./Browser');

    var DomEvent = {

        // @function on(el: HTMLElement, types: String, fn: Function, context?: Object): this
        // Adds a listener function (`fn`) to a particular DOM dom type of the
        // element `el`. You can optionally specify the context of the listener
        // (object the `this` keyword will point to). You can also pass several
        // space-separated types (e.g. `'click dblclick'`).

        // @alternative
        // @function on(el: HTMLElement, eventMap: Object, context?: Object): this
        // Adds a set of type/listener pairs, e.g. `{click: onClick, mousemove: onMouseMove}`
        on: function (obj, types, fn, context) {

            // types can be a map of types/handlers
            if (typeof types === 'object') {
                for (var type in types) {
                    // we don't process space-separated events here for performance;
                    // it's a hot path since Layer uses the on(obj) syntax
                    this._on(obj, type, types[type], fn);
                }
            } else {
                // types can be a string of space-separated words
                types = BaseUtils.splitWords(types);

                for (var i = 0, len = types.length; i < len; i++) {
                    this._on(obj, types[i], fn, context);
                }
            }

            return this;
        },

        // @function off(el: HTMLElement, types: String, fn: Function, context?: Object)
        // Removes a previously added listener function. If no function is specified,
        // it will remove all the listeners of that particular DOM dom from the element.
        // Note that if you passed a custom context to on, you must pass the same
        // context to `off` in order to remove the listener.

        // @alternative
        // @function off(el: HTMLElement, types: eventMap: Object, context?: Object): this
        off: function (obj, types, fn, context) {

            if (!types) {
                // clear all listeners if called without arguments
                delete this._events;

            } else if (typeof types === 'object') {
                for (var type in types) {
                    this._off(obj, type, types[type], fn);
                }

            } else {
                types = BaseUtils.splitWords(types);

                for (var i = 0, len = types.length; i < len; i++) {
                    this._off(obj, types[i], fn, context);
                }
            }

            return this;
        },

        _on: function (obj, type, fn, context) {
            var id = type + BaseUtils.stamp(fn) + (context ? '_' + BaseUtils.stamp(context) : '');

            if (obj[eventsKey] && obj[eventsKey][id]) { return this; }

            var handler = function (e) {
                return fn.call(context || obj, e || window.event);
            };

            var originalHandler = handler;

            // if (Browser.pointer && type.indexOf('touch') === 0) {
            //     this.addPointerListener(obj, type, handler, id);
            //
            // } else if (Browser.touch && (type === 'dblclick') && this.addDoubleTapListener) {
            //     this.addDoubleTapListener(obj, handler, id);
            //
            // }

            if ('addEventListener' in obj) {

                if (type === 'mousewheel') {
                    obj.addEventListener('onwheel' in obj ? 'wheel' : 'mousewheel', handler, false);

                } else if ((type === 'mouseenter') || (type === 'mouseleave')) {
                    handler = function (e) {
                        e = e || window.event;
                        if (DomEvent._isExternalTarget(obj, e)) {
                            originalHandler(e);
                        }
                    };
                    obj.addEventListener(type === 'mouseenter' ? 'mouseover' : 'mouseout', handler, false);

                } else {
                    if (type === 'click' && Browser.android) {
                        handler = function (e) {
                            return DomEvent._filterClick(e, originalHandler);
                        };
                    }
                    obj.addEventListener(type, handler, false);
                }

            } else if ('attachEvent' in obj) {
                obj.attachEvent('on' + type, handler);
            }

            obj[eventsKey] = obj[eventsKey] || {};
            obj[eventsKey][id] = handler;

            return this;
        },

        _off: function (obj, type, fn, context) {

            var id = type + BaseUtils.stamp(fn) + (context ? '_' + BaseUtils.stamp(context) : ''),
                handler = obj[eventsKey] && obj[eventsKey][id];

            if (!handler) { return this; }

            // if (Browser.pointer && type.indexOf('touch') === 0) {
            //     this.removePointerListener(obj, type, id);
            //
            // } else if (Browser.touch && (type === 'dblclick') && this.removeDoubleTapListener) {
            //     this.removeDoubleTapListener(obj, id);
            //
            // }

            if ('removeEventListener' in obj) {

                if (type === 'mousewheel') {
                    obj.removeEventListener('onwheel' in obj ? 'wheel' : 'mousewheel', handler, false);

                } else {
                    obj.removeEventListener(
                        type === 'mouseenter' ? 'mouseover' :
                            type === 'mouseleave' ? 'mouseout' : type, handler, false);
                }

            } else if ('detachEvent' in obj) {
                obj.detachEvent('on' + type, handler);
            }

            obj[eventsKey][id] = null;

            return this;
        },

        // @function stopPropagation(ev: DOMEvent): this
        // Stop the given dom from propagation to parent elements. Used inside the listener functions:
        // ```js
        // DomEvent.on(div, 'click', function (ev) {
        // 	DomEvent.stopPropagation(ev);
        // });
        // ```
        stopPropagation: function (e) {

            if (e.stopPropagation) {
                e.stopPropagation();
            } else if (e.originalEvent) {  // In case of Leaflet dom.
                e.originalEvent._stopped = true;
            } else {
                e.cancelBubble = true;
            }

            DomEvent._skipped(e);

            return this;
        },

        // @function disableScrollPropagation(el: HTMLElement): this
        // Adds `stopPropagation` to the element's `'mousewheel'` events (plus browser variants).
        disableScrollPropagation: function (el) {
            return DomEvent.on(el, 'mousewheel', DomEvent.stopPropagation);
        },

        // @function disableClickPropagation(el: HTMLElement): this
        // Adds `stopPropagation` to the element's `'click'`, `'doubleclick'`,
        // `'mousedown'` and `'touchstart'` events (plus browser variants).
        disableClickPropagation: function (el) {
            var stop = DomEvent.stopPropagation;

            DomEvent.on(el, Draggable.START.join(' '), stop);

            return DomEvent.on(el, {
                click: DomEvent._fakeStop,
                dblclick: stop
            });
        },

        // @function preventDefault(ev: DOMEvent): this
        // Prevents the default action of the DOM Event `ev` from happening (such as
        // following a link in the href of the a element, or doing a POST request
        // with page reload when a `<form>` is submitted).
        // Use it inside listener functions.
        preventDefault: function (e) {

            if (e.preventDefault) {
                e.preventDefault();
            } else {
                e.returnValue = false;
            }
            return this;
        },

        // @function stop(ev): this
        // Does `stopPropagation` and `preventDefault` at the same time.
        stop: function (e) {
            return DomEvent.preventDefault(e).stopPropagation(e);
        },

        // @function getWheelDelta(ev: DOMEvent): Number
        // Gets normalized wheel delta from a mousewheel DOM dom, in vertical
        // pixels scrolled (negative if scrolling down).
        // Events from pointing devices without precise scrolling are mapped to
        // a best guess of between 50-60 pixels.
        getWheelDelta: function (e) {
            return (e.deltaY && e.deltaMode === 0) ? -e.deltaY :        // Pixels
                (e.deltaY && e.deltaMode === 1) ? -e.deltaY * 18 :   // Lines
                    (e.deltaY && e.deltaMode === 2) ? -e.deltaY * 52 :   // Pages
                        (e.deltaX || e.deltaZ) ? 0 :	// Skip horizontal/depth wheel events
                            e.wheelDelta ? (e.wheelDeltaY || e.wheelDelta) / 2 : // Legacy IE pixels
                                (e.detail && Math.abs(e.detail) < 32765) ? -e.detail * 18 : // Legacy Moz lines
                                    e.detail ? e.detail / -32765 * 52 : // Legacy Moz pages
                                        0;
        },

        _skipEvents: {},

        _fakeStop: function (e) {
            // fakes stopPropagation by setting a special dom flag, checked/reset with DomEvent._skipped(e)
            DomEvent._skipEvents[e.type] = true;
        },

        _skipped: function (e) {
            var skipped = this._skipEvents[e.type];
            // reset when checking, as it's only used in map container and propagates outside of the map
            this._skipEvents[e.type] = false;
            return skipped;
        },

        // check if element really left/entered the dom target (for mouseenter/mouseleave)
        _isExternalTarget: function (el, e) {

            var related = e.relatedTarget;

            if (!related) { return true; }

            try {
                while (related && (related !== el)) {
                    related = related.parentNode;
                }
            } catch (err) {
                return false;
            }
            return (related !== el);
        },

        // this is a horrible workaround for a bug in Android where a single touch triggers two click events
        _filterClick: function (e, handler) {
            var timeStamp = (e.timeStamp || (e.originalEvent && e.originalEvent.timeStamp)),
                elapsed = DomEvent._lastClick && (timeStamp - DomEvent._lastClick);

            // are they closer together than 500ms yet more than 100ms?
            // Android typically triggers them ~300ms apart while multiple listeners
            // on the same dom should be triggered far faster;
            // or check if click is simulated on the element, and if it is, reject any non-simulated events

            if ((elapsed && elapsed > 100 && elapsed < 500) || (e.target._simulatedClick && !e._simulated)) {
                DomEvent.stop(e);
                return;
            }

            DomEvent._lastClick = timeStamp;

            handler(e);
        }
    };

    DomEvent.addListener = DomEvent.on;

    DomEvent.removeListener = DomEvent.off;

    return DomEvent;

});

/**
 * Created by eason on 16/5/26.
 */

define('dom/Evented',['require','../utils/QueryUtils','../utils/BaseUtils'],function(require){

    var QueryUtils = require('../utils/QueryUtils');
    var BaseUtils = require('../utils/BaseUtils');

    return {
        /* @method on(type: String, fn: Function, context?: Object): this
         * Adds a listener function (`fn`) to a particular event type of the object. You can optionally specify the context of the listener (object the this keyword will point to). You can also pass several space-separated types (e.g. `'click dblclick'`).
         *
         * @alternative
         * @method on(eventMap: Object): this
         * Adds a set of type/listener pairs, e.g. `{click: onClick, mousemove: onMouseMove}`
         */
        on: function (types, fn, context) {

            // types can be a map of types/handlers
            if (typeof types === 'object') {
                for (var type in types) {
                    // we don't process space-separated events here for performance;
                    // it's a hot path since Layer uses the on(obj) syntax
                    this._on(type, types[type], fn);
                }

            } else {
                // types can be a string of space-separated words
                types = BaseUtils.splitWords(types);

                for (var i = 0, len = types.length; i < len; i++) {
                    this._on(types[i], fn, context);
                }
            }

            return this;
        },

        /* @method off(type: String, fn?: Function, context?: Object): this
         * Removes a previously added listener function. If no function is specified, it will remove all the listeners of that particular event from the object. Note that if you passed a custom context to `on`, you must pass the same context to `off` in order to remove the listener.
         *
         * @alternative
         * @method off(eventMap: Object): this
         * Removes a set of type/listener pairs.
         *
         * @alternative
         * @method off: this
         * Removes all listeners to all events on the object.
         */
        off: function (types, fn, context) {

            if (!types) {
                // clear all listeners if called without arguments
                delete this._events;

            } else if (typeof types === 'object') {
                for (var type in types) {
                    this._off(type, types[type], fn);
                }

            } else {
                types = BaseUtils.splitWords(types);

                for (var i = 0, len = types.length; i < len; i++) {
                    this._off(types[i], fn, context);
                }
            }

            return this;
        },

        // attach listener (without syntactic sugar now)
        _on: function (type, fn, context) {

            var events = this._events = this._events || {},
                contextId = context && context !== this && BaseUtils.stamp(context);

            if (contextId) {
                // store listeners with custom context in a separate hash (if it has an id);
                // gives a major performance boost when firing and removing events (e.g. on map object)

                var indexKey = type + '_idx',
                    indexLenKey = type + '_len',
                    typeIndex = events[indexKey] = events[indexKey] || {},
                    id = BaseUtils.stamp(fn) + '_' + contextId;

                if (!typeIndex[id]) {
                    typeIndex[id] = {fn: fn, ctx: context};

                    // keep track of the number of keys in the index to quickly check if it's empty
                    events[indexLenKey] = (events[indexLenKey] || 0) + 1;
                }

            } else {
                // individual layers mostly use "this" for context and don't fire listeners too often
                // so simple array makes the memory footprint better while not degrading performance

                events[type] = events[type] || [];
                events[type].push({fn: fn});
            }
        },

        _off: function (type, fn, context) {
            var events = this._events,
                indexKey = type + '_idx',
                indexLenKey = type + '_len';

            if (!events) { return; }

            if (!fn) {
                // clear all listeners for a type if function isn't specified
                delete events[type];
                delete events[indexKey];
                delete events[indexLenKey];
                return;
            }

            var contextId = context && context !== this && BaseUtils.stamp(context),
                listeners, i, len, listener, id;

            if (contextId) {
                id = BaseUtils.stamp(fn) + '_' + contextId;
                listeners = events[indexKey];

                if (listeners && listeners[id]) {
                    listener = listeners[id];
                    delete listeners[id];
                    events[indexLenKey]--;
                }

            } else {
                listeners = events[type];

                if (listeners) {
                    for (i = 0, len = listeners.length; i < len; i++) {
                        if (listeners[i].fn === fn) {
                            listener = listeners[i];
                            listeners.splice(i, 1);
                            break;
                        }
                    }
                }
            }

            // set the removed listener to noop so that's not called if remove happens in fire
            if (listener) {
                listener.fn = BaseUtils.falseFn;
            }
        },

        // @method fire(type: String, data?: Object, propagate?: Boolean): this
        // Fires an event of the specified type. You can optionally provide an data
        // object — the first argument of the listener function will contain its
        // properties. The event might can optionally be propagated to event parents.
        fire: function (type, data, propagate) {
            if (!this.listens(type, propagate)) { return this; }

            var event = BaseUtils.extend({}, data, {type: type, target: this}),
                events = this._events;

            if (events) {
                var typeIndex = events[type + '_idx'],
                    i, len, listeners, id;

                if (events[type]) {
                    // make sure adding/removing listeners inside other listeners won't cause infinite loop
                    listeners = events[type].slice();

                    for (i = 0, len = listeners.length; i < len; i++) {
                        listeners[i].fn.call(this, event);
                    }
                }

                // fire event for the context-indexed listeners as well
                for (id in typeIndex) {
                    typeIndex[id].fn.call(typeIndex[id].ctx, event);
                }
            }

            if (propagate) {
                // propagate the event to parents (set with addEventParent)
                this._propagateEvent(event);
            }

            return this;
        },

        // @method listens(type: String): Boolean
        // Returns `true` if a particular event type has any listeners attached to it.
        listens: function (type, propagate) {
            var events = this._events;

            if (events && (events[type] || events[type + '_len'])) { return true; }

            if (propagate) {
                // also check parents for listeners if event propagates
                for (var id in this._eventParents) {
                    if (this._eventParents[id].listens(type, propagate)) { return true; }
                }
            }
            return false;
        },

        // @method once(…): this
        // Behaves as [`on(…)`](#evented-on), except the listener will only get fired once and then removed.
        // once: function (types, fn, context) {
        //
        //     if (typeof types === 'object') {
        //         for (var type in types) {
        //             this.once(type, types[type], fn);
        //         }
        //         return this;
        //     }
        //
        //     var handler = L.bind(function () {
        //         this
        //             .off(types, fn, context)
        //             .off(types, handler, context);
        //     }, this);
        //
        //     // add a listener that's executed once and removed after that
        //     return this
        //         .on(types, fn, context)
        //         .on(types, handler, context);
        // },

        // @method addEventParent(obj: Evented): this
        // Adds an event parent - an `Evented` that will receive propagated events
        addEventParent: function (obj) {
            this._eventParents = this._eventParents || {};
            this._eventParents[BaseUtils.stamp(obj)] = obj;
            return this;
        },

        // @method removeEventParent(obj: Evented): this
        // Removes an event parent, so it will stop receiving propagated events
        removeEventParent: function (obj) {
            if (this._eventParents) {
                delete this._eventParents[BaseUtils.stamp(obj)];
            }
            return this;
        },

        _propagateEvent: function (e) {
            for (var id in this._eventParents) {
                this._eventParents[id].fire(e.type, BaseUtils.extend({layer: e.target}, e), true);
            }
        }
    }
});
/**
 * Created by eason on 16/2/19.
 * 处理事件
 */

define('Handler',['require','./utils/BaseUtils','./Constants','./dom/DomEvent','./dom/Evented'],function(require){

    var MIN_DISTANCE = 5;

    var BaseUtils = require('./utils/BaseUtils');
    var Constants = require('./Constants');
    var DomEvent = require('./dom/DomEvent');
    var Evented = require('./dom/Evented');

    function Handler(vanchart, container){

        this.vanchart = vanchart;

        this._container = container;

        this._targets = {};

        !vanchart._leaflet && this._initEvents();
    }

    Handler.prototype = {

        _initEvents:function(){
            BaseUtils.extend(this, Evented);

            this.initTargets();

            if(BaseUtils.hasTouch()){
                this.on({
                    'touchstart':this._onContainerMouseMove,
                    'touchend':this._onContainerMouseUp
                }, this);

                DomEvent.on(this._container, 'touchstart touchend', this._handleDOMEvent, this);

            }else{
                this.on({
                    'mousemove':this._onContainerMouseMove,
                    'mousedown':this._onContainerMouseDown,
                    'mouseup':this._onContainerMouseUp,
                    'mouseout':this._onContainerMouseOut
                }, this);

                DomEvent.on(this._container, 'click dblclick mousedown mouseup ' +
                    'mouseout mouseover mousemove contextmenu keypress', this._handleDOMEvent, this);
            }
        },

        offEvents:function(){
            if(BaseUtils.hasTouch()){
                DomEvent.off(this._container, 'touchstart touchend', this._handleDOMEvent, this);
            }else{
                DomEvent.off(this._container, 'click dblclick mousedown mouseup ' +
                    'mouseout mouseover mousemove contextmenu keypress', this._handleDOMEvent, this);
            }
        },

        initTargets:function(){
            this._targets = {};
            this._targets[BaseUtils.stamp(this._container)] = this;
        },

        _handleDOMEvent: function (e) {
            if (DomEvent._skipped(e)) { return; }

            var type = e.type === 'keypress' && e.keyCode === 13 ? 'click' : e.type;

            this._fireDOMEvent(e, type);
        },

        _fireDOMEvent: function (e, type, targets) {

            if (e._stopped) { return; }
            
            // Find the layer the event is propagating from and its parents.
            targets = (targets || []).concat(this._findEventTargets(e, type));

            if (!targets.length) { return; }

            var target = targets[0];
            if (type === 'contextmenu' && target.listens(type, true)) {
                DomEvent.preventDefault(e);
            }

            var data = {
                originalEvent: e
            };

            if (e.type !== 'keypress') {
                data.containerPoint = BaseUtils.getMousePos(e, this._container);
            }

            for (var i = 0; i < targets.length; i++) {
                targets[i].fire(type, data, true);
                if (data.originalEvent._stopped) { return; }
            }
        },

        _findEventTargets: function (e, type) {
            var targets = [],
                target,
                isHover = type === 'mouseout' || type === 'mouseover' || type == 'touchstart' || type == 'touchend',
                src = e.target || e.srcElement,
                dragging = false;

            while (src) {
                target = this._targets[BaseUtils.stamp(src)];
                if (target && (type === 'click' || type === 'preclick') && !e._simulated) {
                    // Prevent firing click after you just dragged an object.
                    dragging = true;
                    break;
                }
                if (target && target.listens(type, true)) {
                    if (isHover && !DomEvent._isExternalTarget(src, e)) { break; }
                    targets.push(target);
                    if (isHover) {
                        break;
                    }
                }
                if (src === this._container) { break; }
                src = src.parentNode;
            }
            if (!targets.length && !dragging && !isHover && DomEvent._isExternalTarget(src, e)) {
                targets = [this];
            }
            return targets;
        },

        addInteractiveTarget:function(domWrapper, types, render){

            BaseUtils.extend(domWrapper, Evented);

            var domEl =  BaseUtils.isSupportSVG() ?  domWrapper.node() : domWrapper.node;

            var data = domWrapper.datum();

            this._targets[BaseUtils.stamp(domEl)] = domWrapper;
            
            this._targets[BaseUtils.stamp(data)] = domWrapper;

            domWrapper.on(types, render);
        },

        fireEventByData:function(data, type, event){
            var target = data ? this._targets[BaseUtils.stamp(data)] : null;

            target && target.fire(type, event)
        },

        _onContainerMouseOut:function(){
            var tooltip = this.vanchart.getTooltip();
            tooltip && tooltip.hide();
        },

        _onContainerMouseDown:function(event){

            var chart = this.vanchart;
            var hoverPoint = this.vanchart.hoverPoint;
            var mousePos = event.containerPoint;
            var plotBounds = chart.getPlotBounds();
            var tooltip = chart.getTooltip();

            chart.isMouseDown = true;
            chart.downPos = mousePos;

            tooltip.immediateHide();

            //饼图旋转
            if(hoverPoint){
                var seriesChart = hoverPoint.series.chart;
                this._draggingTarget = seriesChart.findDraggingTarget && seriesChart.findDraggingTarget(event);
            }

            //缩放
            if(this.selectRect){
                this.selectRect.remove();
                this.selectRect = null;
            }
            
            if(!this._draggingTarget && this._supportCoordinateZoom() && BaseUtils.containsPoint(plotBounds, mousePos)){
                this.selectRect = this.vanchart.render.getRenderRoot().append('rect');
            }
        },

        _onContainerMouseUp:function(event){

            var chart = this.vanchart;
            var components = chart.components;
            var upPos = event.containerPoint;

            if(this.selectRect){

                if(chart.downPos && upPos){
                    if(BaseUtils.distance(chart.downPos, upPos) > MIN_DISTANCE){
                        chart.dealAxisZoom(chart.downPos, upPos);

                        if(components[Constants.TOOLBAR_COMPONENT]){
                            var toolbar = components[Constants.TOOLBAR_COMPONENT];
                            toolbar.showRefreshIconWhenZoom();
                        }
                    }
                }

                this.selectRect.remove();
                this.selectRect = null;
            }

            if(chart.isMouseDown && this._draggingTarget){
                this._draggingTarget.dragEnd(event);
                this._draggingTarget = null;
            }

            if(chart.hoverPoint && this.validClick(upPos)){

                chart.hoverPoint.onClick(event.originalEvent)
            }

            chart.isMouseDown = false;
            chart.downPos = null;
        },

        _onContainerMouseMove:function(event){
            var chart = this.vanchart;
            var currentPos = event.containerPoint;
            var hoverPoint = this.vanchart.hoverPoint;

            var plotBounds = this.vanchart.getPlotBounds();
            var options = this.vanchart.getOptions();

            var sharedAxis = chart.getSharedAxis();

            if(this.selectRect){

                var zoomType = options.zoom.zoomType;

                var x = Math.min(currentPos[0], chart.downPos[0]);
                var y = Math.min(currentPos[1], chart.downPos[1]);
                var width = Math.abs(currentPos[0] - chart.downPos[0]);
                var height = Math.abs(currentPos[1] - chart.downPos[1]);

                var isXZoom = zoomType.indexOf('x') != -1;
                var isYZoom = zoomType.indexOf('y') != -1;

                if(isXZoom && !isYZoom){
                    y = plotBounds.y;
                    height = plotBounds.height;
                }else if(isYZoom && !isXZoom){
                    x = plotBounds.x;
                    width = plotBounds.width;
                }

                this.selectRect.attr('x', x).attr('y', y)
                    .attr('width', width).attr('height', height)
                    .style({'fill':'rgba(69,114,167,0.25)'});
            }

            var tooltip = this.vanchart.getTooltip();
            var isInPlot = BaseUtils.containsPoint(plotBounds,currentPos);
            if(isInPlot) {

                // 1. Charts that don't support shared tooltip get priority.
                if (hoverPoint && !hoverPoint.series.supportSharedTooltip) {

                    sharedAxis && sharedAxis.getRender().removeHighlightBand();
                    this._setCoveredKey(null, event);

                } else {

                // 2. May support shared tooltip

                    // 2.1 Listen to area.
                    //     if this category(not value/datetime) has shared points,
                    //     the axis dominates coordinate's area.
                    //     i.e. ignore other normal points tooltip at this category.
                    if (sharedAxis &&
                        sharedAxis.type === Constants.CATEGORY_AXIS_COMPONENT &&
                        this._getCoveredPointsByPos(currentPos).length !== 0) {

                        this._highlightShared(event);

                    } else if (hoverPoint) {
                    // 2.2 Listen to hover point.
                    //     no shared or shared value/datetime axis listens to hover point.

                        // line & area have 'closestPoint',
                        // otherwise events fire on the shape itself
                        var seriesChart = hoverPoint.series.chart;
                        var closestPoint = seriesChart.getClosestPoint(currentPos);

                        // 2.2.1 No shared, choose single one
                        if (closestPoint && !(closestPoint.tooltip && closestPoint.tooltip.shared)) {

                            sharedAxis && sharedAxis.getRender().removeHighlightBand();
                            this._setCoveredKey(null);

                            if (closestPoint != hoverPoint) {
                                this.fireEventByData(hoverPoint, 'mouseout', event)
                                this.fireEventByData(closestPoint, 'mouseover', event);

                            }

                        } else if (sharedAxis && [
                                Constants.VALUE_AXIS_COMPONENT,
                                Constants.DATE_AXIS_COMPONENT
                            ].indexOf(sharedAxis.type) !== -1) {
                        // 2.2.2 Highlight shared points according to hovered one.

                            // hoverPoint here may not be the real hovered one,
                            // for line/area, it points out the hovered series.
                            var tmpPoint = closestPoint || hoverPoint;
                            this._highlightShared(event, tmpPoint);
                        }
                    }
                }

                //canvas的时候通过位置判断
                var scatter = chart.getChart(Constants.SCATTER_CHART) || chart.getChart(Constants.BUBBLE_CHART);
                if(scatter && scatter.isLargeMode()){
                    chart.hoverPoint = scatter.getClosestPoint(currentPos);
                }
            }

            //没有数据点共享的时候显示当前选中的数据点
            if(!this.vanchart.coveredKey){
                tooltip.showWithPoint(chart.hoverPoint, event.originalEvent);
            }

            if ((!isInPlot && this.vanchart.coveredKey) || this._draggingTarget) {
                // reset
                tooltip.hide();
                hoverPoint && this.fireEventByData(hoverPoint, 'mouseout', event);
                sharedAxis && sharedAxis.getRender().removeHighlightBand();
                this._setCoveredKey(null);
            }

            //drag operation
            if(chart.isMouseDown && this._draggingTarget){
                this._draggingTarget.onDrag(event);
            }
        },

        _getCoveredPointsByPos: function (pos, axis) {
            axis = axis || this.vanchart.getSharedAxis();
            var index = axis.getIndexByPosition(pos);
            var key = (axis.type === Constants.CATEGORY_AXIS_COMPONENT) ? axis.scale.domain()[index] : index;
            return this._getCoveredPointsByKey(key);
        },

        _getCoveredPointsByKey: function (key, axis) {
            axis = axis || this.vanchart.getSharedAxis();
            return key && axis && axis.sharedPoints[key] || [];
        },

        _setCoveredKey: function (key, event) {
            if (key === null) {
                if (BaseUtils.isNull(this.vanchart.coveredKey)) {
                    return;
                }

                var prePoints = this._getCoveredPointsByKey(this.vanchart.coveredKey);
                prePoints.map(function (point) {
                    this.fireEventByData(point, 'leave', event);
                },this);

            } else if (typeof key === 'string' || !isNaN(key)) {

                if (this.vanchart.coveredKey === key){
                    return;
                }

                this._setCoveredKey(null, event);

                var points = this._getCoveredPointsByKey(key);
                points.map(function (point) {
                    this.fireEventByData(point, 'cover', event);
                }, this);

            } else {

                throw new TypeError(key);
            }

            this.vanchart.coveredKey = key;
        },

        _highlightShared: function (event, point) {
            var axis = this.vanchart.getSharedAxis();
            if (!axis) {
                return;
            }

            var dom = this.vanchart.getParentDom();
            var pos = BaseUtils.getMousePos(event, dom);
            var tooltip = this.vanchart.getTooltip();

            var key;

            if (point) {
                key = point.category;
            } else {
                var index = axis.getIndexByPosition(pos);
                key = (axis.type === Constants.CATEGORY_AXIS_COMPONENT) ? axis.scale.domain()[index] : index;
            }

            if (this._getCoveredPointsByKey(key).length !== 0) {

                axis.getRender().drawHighlightBand(pos);
                this._setCoveredKey(key, event);
                this.fireEventByData(this.vanchart.hoverSeries, 'forceMouseOut', event);
                
                // todo, shouldn't calculate dim&content every time
                tooltip.showWithSharedPoints(this._getCoveredPointsByKey(this.vanchart.coveredKey), event.originalEvent);

            } else {
                axis.getRender().removeHighlightBand();
                tooltip.hide();
            }

        },

        // todo ugly method to be removed
        _supportCoordinateZoom:function(){

            var option = this.vanchart.getOptions();

            var hoverPoint = this.vanchart.hoverPoint;

            if(hoverPoint && hoverPoint.series.chart.isUpdateWithForce()){
                return;
            }

            return BaseUtils.isSupportSVG() && option.zoom && option.zoom.zoomType;
        },

        validClick:function(currentPos){

            if(this.vanchart.downPos){
                return BaseUtils.distance(this.vanchart.downPos, currentPos) < MIN_DISTANCE;
            }

            return true;
        }

    };


    return Handler;
});
/**
 * Created by eason on 15/9/7.
 */

define('utils/Formatter',['require','./BaseUtils'],function(require){

    var BaseUtils = require('./BaseUtils');

    function format(cv, fmt){

        fmt = BaseUtils.getFormatterFunction(fmt);

        return fmt ? fmt.bind(cv)(cv) : cv;
    }

    return {
        format:format
    }

});
/**
 * Created by Yuqian on 16/5/19.
 */

define('theme/options',['require','../Constants'],function (require) {
    var Constants = require('../Constants');

    var options = {};

    options[Constants.PIE_CHART] = {
        plotOptions: {

        }
    };

    options[Constants.MULTIPIE_CHART] = {
        innerRadiusPct: 2/3,
        
        plotOptions: {
            borderWidth: 1,
            borderColor: 'rgb(255,255,255)',
            rotatable: true,
            gradual: 'lighter',
            center: [],
            innerRadius: 0,
            startAngle: 0,
            endAngle: 360,
            drilldown: true
        }
    };

    options[Constants.COLUMN_CHART] = {
        plotOptions: {
            categoryGap: '20%',
            gap: '20%'
        }

    };

    options[Constants.BAR_CHART] = {
        plotOptions: {

        }

    };

    options[Constants.LINE_CHART] = options[Constants.AREA_CHART] = {

        plotOptions:{
            large:false,

            marker:{
                symbol:'null_marker'
            },

            dataLabels:{
                "enabled": false,
                "align": "outside"
            }
        }
    };

    options[Constants.GAUGE_CHART] = {
        plotOptions: {

        }

    };

    options[Constants.RADAR_CHART] = {

        plotOptions:{
            columnType:false,
            marker:{
                symbol:'null_marker'
            },

            borderWidth:1,

            borderColor:'white',

            lineWidth:1,

            shape: 'circle'
        }

    };

    options[Constants.SCATTER_CHART] = {
        plotOptions: {
            fillColorOpacity:1,
            opacity:1
        }

    };

    options[Constants.BUBBLE_CHART] = {
        plotOptions: {
            fillColorOpacity:0.75,
            opacity:0.75
        }

    };

    options[Constants.AREA_MAP] = {
        plotOptions:{
            fillColor:'#cccccc',
            fillColorOpacity:0.75,
            borderColor:'#ffffff',
            borderWidth:1,
            borderOpacity:1
        }
    };

    options[Constants.POINT_MAP] = {
        plotOptions:{
            icon:{
                iconUrl:'../../doc/example/marker-icon.png',
                iconSize: [25, 41]
            }
        }
    };

    return options
});
/**
 * Created by eason on 16/2/19.
 * 数据点的抽象
 */
define('component/Point',['require','../utils/QueryUtils','../utils/BaseUtils','../utils/ColorUtils','../utils/Formatter','../Constants','../theme/options'],function(require){

    var QueryUtils = require('../utils/QueryUtils');
    var BaseUtils = require('../utils/BaseUtils');
    var ColorUtils = require('../utils/ColorUtils');
    var Formatter = require('../utils/Formatter');
    var Constants = require('../Constants');
    var Options = require('../theme/options');

    var CATEGORY = 'CATEGORY';
    var SERIES = 'SERIES';
    var VALUE = 'VALUE';
    var PERCENT = 'PERCENT';
    var NAME = 'NAME';

    var LABEL_GAP = 2;

    function Point(series, pointOption, index){
        if(series && pointOption){
            this.series = series;

            //排序以后的顺序根据初始状态的index确定
            this.index = index;

            this.pointOption = pointOption;

            this.updateClassName(index);

            this._init(pointOption);
        }
    }

    Point.prototype = {

        constructor:Point,

        isPoint:true,

        _init:function(pointOption){

            var series = this.series;
            var chart = this.series.chart;

            var queryList = [
                pointOption,
                series.seriesOption,
                series.chart.option.plotOptions[series.type],
                series.chart.option.plotOptions,
                Options[series.type].plotOptions
            ];

            var dataLabels = QueryUtils.queryList(queryList, 'dataLabels');
            var tooltip = QueryUtils.queryList(queryList, 'tooltip');

            var gaussValue = BaseUtils.pick(pointOption.y, pointOption.value, pointOption.size);
            var value = series.valueAxis ? series.valueAxis.getValueFromData(pointOption) : gaussValue;
            var isNull = value === '-' || value === undefined || value == null;

            //对数坐标轴是错误的数值
            if(series.valueAxis && series.valueAxis.componentOption.log){
                isNull = value <= 0;
            }

            value = isNull ? 0 : value;//用于计算

            var category = (series.baseAxis && !series.chart.isForceBubble()) ? series.baseAxis.getValueFromData(pointOption, this.index) : BaseUtils.pick( pointOption.x, pointOption.name, series.seriesOption.name);
            var seriesName = series.name;

            //饼图要反过来
            if (series.type === Constants.PIE_CHART || series.type === Constants.GAUGE_CHART) {
                seriesName = [category, category = seriesName][0];
                seriesName = BaseUtils.isNull(seriesName) ? 'SeriesX' + this.index : seriesName; 
            }

            if (series.type === Constants.GAUGE_CHART || this.index < 0) {
                // don't occupy default color index
                var color = '#000';
            } else if (series.type === Constants.MULTIPIE_CHART) {
                var color = chart.vanchart.getDefaultSeriesColor(pointOption.name);
            } else {
                var color = chart.vanchart.getDefaultSeriesColor(seriesName);
            }
            var _color = color;

            //范围图例覆盖系列色
            var rangeLegend = chart.vanchart.getComponent(Constants.RANGE_LEGEND_COMPONENT);
            if(isNull && series.type == Constants.AREA_MAP){
                color = QueryUtils.queryList(queryList, 'fillColor');
            }else if(rangeLegend){
                var size = BaseUtils.pick(QueryUtils.queryList(queryList, 'size'), 0);

                size = chart.isForceBubble() ? pointOption.y : size;

                size = (series.type == Constants.AREA_MAP || series.type == Constants.POINT_MAP) ? value : size;

                color = rangeLegend.getColorWithSize(size) || color;
            }

            color = QueryUtils.queryList(queryList, 'color') || color;
            color = series._getBandsColor(this) || color;

            var clickColor = ColorUtils.getClickColor(color);

            var mouseOverColor = QueryUtils.queryList(queryList, 'mouseOverColor') || ColorUtils.getHighLightColor(color);

            QueryUtils.merge(this, {

                // children: , // log: init in multiPie

                value:value,
                y:value,
                y0:series.valueAxis ? series.valueAxis.getStartPosValue() : 0,

                category: category,
                seriesName: seriesName,
                visible : BaseUtils.pick(pointOption.visible, true),

                //todo 写到这里的感觉是,有些属性应该根据坐标轴的不同来merge
                name:pointOption.name,
                lnglat:pointOption.lnglat,
                drill : QueryUtils.queryList(queryList, 'drilldown'),
                fillColorOpacity:QueryUtils.queryList(queryList, 'fillColorOpacity'),

                isNull:isNull,
                style:series.style,
                color:color,
                _color:_color,
                clickColor:clickColor,
                hyperlink:QueryUtils.queryList(queryList, 'hyperlink'),
                jsonHyperlink:QueryUtils.queryList(queryList, 'jsonHyperlink'),
                click:QueryUtils.queryList(queryList, 'click'),
                borderWidth:QueryUtils.queryList(queryList, 'borderWidth') || 0,
                borderColor:QueryUtils.queryList(queryList, 'borderColor') || 'white',
                borderRadius:QueryUtils.queryList(queryList, 'borderRadius') || 0,
                image:QueryUtils.queryList(queryList, 'image'),
                imageWidth:QueryUtils.queryList(queryList, 'imageWidth') || 0,
                imageHeight:QueryUtils.queryList(queryList, 'imageHeight') || 0,
                dataLabels:isNull ? null : dataLabels,
                tooltip:tooltip,
                mouseOverColor: mouseOverColor
            }, true);

            chart.mergeDataPointAttributes(this);
        },

        updateClassName:function(index){
            this.className = 'vancharts-dataPoint-series' + this.series.index + 'point' + index;
        },

        setPercentage:function(percentage){

            this.percentage = percentage;

            //算晚百分比才能算具体的标签的内容
            if(this.dataLabels && this.dataLabels.enabled){
                QueryUtils.merge(this, this._calculateLabelInfo(this.dataLabels), true);
            }
        },

        _calculateLabelInfo:function(labelInfo){

            var dataLabels = labelInfo || {};
            var formatter =  dataLabels.formatter;
            var useHtml = dataLabels.useHtml;

            if(!formatter){
                return {};
            }

            var content = [];

            if(typeof formatter == 'object'){

                var label = formatter.identifier;

                var items =[];
                if (label.indexOf(NAME) != -1) {
                    var nameString = Formatter.format(this.name, formatter.nameFormat);
                    items.push(nameString);
                }
                if (label.indexOf(CATEGORY) != -1) {
                    var categoryString = Formatter.format(this.category, formatter.categoryFormat);
                    items.push(categoryString);
                }
                if (label.indexOf(SERIES) != -1) {
                    var seriesString = Formatter.format(this.seriesName, formatter.seriesFormat);
                    items.push(seriesString);
                }
                
                if (items.length) {
                    var text = items.join(' ');
                    var style = this.getCategorySeriesStyle(dataLabels);
                    var dim = BaseUtils.getTextDimension(text, style, useHtml);
                    content.push({
                        text: text,
                        style: style,
                        dim: dim
                    });
                }


                if(label.indexOf(VALUE) != -1 || label.indexOf(PERCENT) != -1){
                    
                    var valueString = Formatter.format(this.value, formatter.valueFormat);

                    var percentString = Formatter.format(this.percentage, formatter.percentFormat);

                    var text = '';

                    if(label.indexOf(VALUE) != -1 && label.indexOf(PERCENT) != -1){
                        text = valueString + ' ' + percentString;
                    }else if(label.indexOf(VALUE) != -1){
                        text = valueString;
                    }else{
                        text = percentString;
                    }

                    var style = this.getValuePercentageStyle(dataLabels);
                    var dim = BaseUtils.getTextDimension(text, style, useHtml);
                    content.push({
                        text:text,
                        style:style,
                        dim:dim
                    });
                }

            }else{
                this.pushCustomLabelContent(formatter, dataLabels, useHtml, content);
            }

            var labelDim = this.calculateTextDim(content);

            return {
                labelContent:content,
                labelDim:labelDim
            };

        },

        pushCustomLabelContent:function(formatter, dataLabels, useHtml, content, defaultPosition){
            var text = BaseUtils.getFormatterFunction(formatter).call(this);
            var style = this.getValuePercentageStyle(dataLabels, defaultPosition);
            var dim = BaseUtils.getTextDimension(text, style, useHtml);

            if(dataLabels.useHtml){
                dim.width = isNaN(parseFloat(dataLabels.labelWidth)) ? dim.width : parseFloat(dataLabels.labelWidth);
                dim.height = isNaN(parseFloat(dataLabels.labelHeight)) ? dim.height : parseFloat(dataLabels.labelHeight);
            }

            content.push({
                text:text,
                style:style,
                dim:dim
            });
        },

        calculateTextDim:function(labelContent){

            var width = 0;
            var height = 0;

            if(labelContent && labelContent.length){

                for(var i = 0, count = labelContent.length; i < count; i++){
                    var dim = labelContent[i].dim;

                    width = Math.max(width, dim.width);

                    height += dim.height;
                }

                height += (count - 1) * LABEL_GAP;
            }

            return {
                width:width,
                height:height
            };
        },

        getCategorySeriesStyle:function(dataLabels, defaultPosition){

            if(dataLabels && dataLabels.style){
                return dataLabels.style;
            }

            var position = defaultPosition ||
                 (this.columnType ? Constants.INSIDE : (dataLabels.align || Constants.OUTSIDE));

            var shadowOpacity = position === Constants.OUTSIDE ? 0.1 : 0.15;

            return {
                color:position == Constants.OUTSIDE ? ColorUtils.colorToHex(this.color) : '#ffffff',
                fontSize:'12px',
                fontFamily:'Verdana',
                textShadow:'1px 1px 1px rgba(0,0,0,' + shadowOpacity + ')',
                fontWeight:'bold'
            }

        },

        getValuePercentageStyle:function(dataLabels, defaultPosition){

            if(dataLabels && dataLabels.style){
                return dataLabels.style;
            }

            var position = defaultPosition ||
                 (this.columnType ? Constants.INSIDE : (dataLabels.align || Constants.OUTSIDE));

            return {
                fontSize:'12px',
                fontFamily:'Verdana',
                textShadow:'1px 1px 1px rgba(0,0,0,0.15)',
                color: position == Constants.OUTSIDE ? ColorUtils.colorToHex(this.color) : '#ffffff'
            };
        },

        onClick:function(e){
            if(this.click){
                this.click.call(this, e);
            }else if(this.hyperlink){
                e = e.touches ?  (e.touches.length ? e.touches.item(0) : e.changedTouches[0]) : e;
                var hyperlink = this.hyperlink;
                if(hyperlink && window.FR){
                    FR.doHyperlink(e, (new Function("return " + hyperlink))(), true);
                }
            }
        }

    };

    return Point;
});

/**
 * Created by eason on 16/2/19.
 * 系列的抽象
 */
define('component/Series',['require','../utils/BaseUtils','../utils/QueryUtils','../Constants','./Point','../theme/options'],function(require){

    var BaseUtils = require('../utils/BaseUtils');
    var QueryUtils = require('../utils/QueryUtils');
    var Constants = require('../Constants');
    var Point = require('./Point');
    var Options = require('../theme/options');


    function Series(chart, seriesOption){

        this.chart = chart;

        this._init(seriesOption);
    }


    Series.prototype = {

        constructor:Series,

        isSeries:true,

        _init:function(seriesOption){

            var vanchart = this.chart.vanchart;

            var plotOptions = this.chart.option.plotOptions;

            this.type = seriesOption.type;
            this.index = vanchart.totalSeriesCount++;

            var queryList = [
                seriesOption,
                plotOptions[this.type],
                plotOptions,
                Options[this.type].plotOptions
            ];

            this.seriesOption = seriesOption;

            this.name = BaseUtils.pick(seriesOption.name, 'Series' + this.index);

            this.className = 'vancharts-series-' + this.index;

            // pie charts have colors inside 
            if ([
                    Constants.PIE_CHART,
                    Constants.GAUGE_CHART,
                    Constants.MULTIPIE_CHART
                ].indexOf(this.type) === -1) {
                this.color = QueryUtils.queryList(queryList, 'color') || this.chart._getDefaultSeriesColor(this.name);
            }

            this.visible = QueryUtils.queryList(queryList, 'visible');
            this.stack = QueryUtils.queryList(queryList, 'stack');
            this.stackByPercent = QueryUtils.queryList(queryList, 'stackByPercent');
            this.style = QueryUtils.queryList(queryList, 'style');
            this.trendLine = QueryUtils.queryList(queryList, 'trendLine');
            this.bands = QueryUtils.queryList(queryList, 'bands');
            this.image = QueryUtils.queryList(queryList, 'image');
            this.tooltip = QueryUtils.queryList(queryList, 'tooltip');
            this.fillColorOpacity = QueryUtils.queryList(queryList, 'fillColorOpacity');

            this.supportSharedTooltip = false;
            if ([
                    Constants.BAR_CHART,
                    Constants.COLUMN_CHART,
                    Constants.LINE_CHART,
                    Constants.AREA_CHART,
                    Constants.RADAR_CHART
                ].indexOf(this.type) !== -1 ) {
                this.supportSharedTooltip = true;
            }

            var marker = BaseUtils.clone(QueryUtils.queryList(queryList, 'marker'));
            
            this.marker = marker;

            switch (this.type) {
                case Constants.PIE_CHART:
                case Constants.MULTIPIE_CHART:
                    break;
                case Constants.GAUGE_CHART:
                    this.gaugeAxis = vanchart.gaugeAxis(QueryUtils.queryList(queryList, 'gaugeAxis'));
                    break;
                case Constants.RADAR_CHART:
                    
                    var isColumnType = QueryUtils.queryList(queryList, 'columnType');
                    if (isColumnType) {
                        this.stack = Constants.RADAR_CHART;
                    }

                    this.polar = vanchart.polar(QueryUtils.queryList(queryList, 'polar'));
                    this.polar.shape = QueryUtils.queryList(queryList, 'shape');

                    this.radiusAxis = this.polar.radiusAxis;
                    this.angleAxis = this.polar.angleAxis;

                    // compatible
                    if (this.radiusAxis && this.angleAxis) {
                        this.baseAxis = this.angleAxis;
                        this.baseAxis.isBaseAxis = true;
                        this.valueAxis = this.radiusAxis;
                    }
                    break;

                default:

                    this.xAxis = vanchart.xAxis(QueryUtils.queryList(queryList, 'xAxis'));
                    this.yAxis = vanchart.yAxis(QueryUtils.queryList(queryList, 'yAxis'));

                    if (this.xAxis && this.yAxis) {
                        this.baseAxis = this._getBaseAxis();
                        this.baseAxis.isBaseAxis = true;
                        this.valueAxis = this._getValueAxis();
                    }
            }

            this.chart.mergeSeriesAttributes(this);

            this.points = [];
            this.visiblePoints = [];//为了饼图还是加上吧

            var data = seriesOption.data;

            var self = this;
            this.points =
                data.map(function (datum, i) {
                        return new Point(self, datum, i);
                    });

            this.updateVisiblePoints();
        },

        updateVisiblePoints:function(){

            this.visiblePoints =
                this.points.filter(function (point) {
                    return point.visible;
                });

        },

        //排序以后,根据排序的效果,需要更新className
        updateClassName:function(){

            if(this.baseAxis && this.baseAxis.type == Constants.CATEGORY_AXIS_COMPONENT){

                var categories = this.baseAxis.categories;

                var newPoints = [];

                this.points.forEach(function(point){

                    var newPoint = QueryUtils.merge(new Point(), point);

                    newPoint.updateClassName(BaseUtils.indexInArray(categories, point.category));

                    newPoints.push(newPoint);
                });

                this.points = newPoints;

                if(this.originalPoints){
                    this.originalPoints = this.points;
                }
            }

        },

        getDataPointCount:function(){
            return this.seriesOption.data.length;
        },

        getSeryTotalValue:function(){

            var total = 0;

            this.points.forEach(function(point){
                total += point.value;
            });

            return total;
        },

        getLocation:function(){

            return this.baseAxis ? this.baseAxis.getPosition() : Constants.BOTTOM;

        },

        isValueAxisBased:function(){
            var c_name = Constants.CATEGORY_AXIS_COMPONENT;
            return (this.xAxis && this.xAxis.type != c_name) && (this.yAxis && this.yAxis.type != c_name);
        },

        _getBaseAxis:function(){
            var c_name = Constants.CATEGORY_AXIS_COMPONENT;
            if(this.xAxis.type == c_name){
                return this.xAxis;
            }else if(this.yAxis.type == c_name){
                return this.yAxis;
            }else{
                return this.type == Constants.BAR_CHART ? this.yAxis : this.xAxis;
            }
        },

        _getValueAxis:function(){
            var c_name = Constants.CATEGORY_AXIS_COMPONENT;
            if(this.xAxis.type == c_name){
                return this.yAxis;
            }else if(this.yAxis.type == c_name){
                return this.xAxis;
            }else{
                return this.type == Constants.BAR_CHART ? this.xAxis : this.yAxis;
            }
        },

        //根据bands的定义获取颜色
        _getBandsColor:function(point){

            var bands = this.bands;

            if(bands){
                bands = BaseUtils.isArray(bands) ? bands : [bands];

                for(var i = 0, count = bands.length; i < count; i++){

                    var band = bands[i];

                    if(band.axis){

                        var axis = band.axis == 'x' ? this.xAxis : this.yAxis;
                        var value = axis.getValueFromData(point.pointOption);
                        var from = band.from;
                        var to = band.to;

                        if(axis.type == Constants.CATEGORY_AXIS_COMPONENT){
                            value = axis.indexOfLabel(value);
                            from = from ? axis.indexOfLabel(from) : from;
                            to = to ? axis.indexOfLabel(from) : to;
                        }

                        var largerThanFrom = BaseUtils.hasDefined(from) ? value >= from : true;
                        var smallerThanTo = BaseUtils.hasDefined(to) ? value <= to : true;

                        if(largerThanFrom && smallerThanTo){
                            return band.color;
                        }

                    }else{

                        var from = Math.min(band.from, band.to);
                        var to = Math.max(band.from, band.to);

                        if(point.value >= from && point.value < to){
                            return band.color;
                        }

                    }
                }

                if(BaseUtils.hasDefined(point.valueInDomain)){

                    for(var i = 0, len = bands.length; i < len; i++){

                        var band = bands[i];

                        var from = Math.min(band.from, band.to);
                        var to = Math.max(band.from, band.to);

                        if(point.valueInDomain >= from && point.valueInDomain <= to){
                            return band.color;
                        }
                    }
                }
                
            }
        }
    };

    return Series;
});

/**
 * Created by eason on 16/6/15.
 * 从理论上来讲,一种图表应该只存在一种坐标系
 * 暂时可以有的应该有两种,地理坐标系,和平面坐标系
 * 平面坐标系的位置都是相对于画布的像素位置
 * 地理坐标系的位置都是经纬度位置
 */
define('component/CoordinateSystem',['require','../utils/Class','../Constants'],function(require){

    //暂时这个概念用来区分,后面想清楚了再往上叠加概念
    var Class = require('../utils/Class');
    var Constants = require('../Constants');

    var CoordinateSystem = Class.extend({

        initialize:function(type){
            this.type = type || Constants.PLANE;
        },

        //todo wow,切换坐标系,实现这个功能应该要考虑更多的事情
        setType:function(type){
            this.type = type;
        },

        accept:function(componentType){
            var isPlaneAxis = componentType.toLowerCase().indexOf('axis') != -1;
            return (isPlaneAxis && this.type != Constants.GEO) || !isPlaneAxis;
        }

    });

    return CoordinateSystem;
});


/**
 * Created by eason on 15/8/17.
 */

define('render/LegendIconFactory',['require','../Constants'],function(require){

    var Constants = require('../Constants');

    var LegendPath = {};
    var LegendSize = {};

    LegendPath[Constants.PIE_ICON] = 'M15.795,7.943L7.909,12.5L0.205,8.052C1.756,5.333,4.68,3.5,8.032,3.5C11.338,3.5,14.23,5.287,15.795,7.943z';
    LegendSize[Constants.PIE_ICON] = {
        width:16,
        height:16
    };

    LegendPath[Constants.DONUT_ICON] = 'M8.945,11.107c1.671,0,3.181,0.684,4.269,1.786l4.271-4.271c-4.686-4.686-12.284-4.686-16.971,0l4.216,4.216C5.815,11.768,7.302,11.107,8.945,11.107z';
    LegendSize[Constants.DONUT_ICON] = {
        width:18,
        height:18
    };

    LegendPath[Constants.NORMAL_ICON] = 'M0,0L12,0L12,12L0,12Z';
    LegendSize[Constants.NORMAL_ICON] = {
        width:12,
        height:12
    };

    LegendPath[Constants.BUBBLE_ICON] = "M6,11.5c-1.47,0-2.851-0.572-3.889-1.611C1.072,8.851,0.5,7.47,0.5,6s0.572-2.851,1.611-3.889C3.149,1.072,4.53,0.5,6,0.5s2.851,0.572,3.889,1.611C10.928,3.149,11.5,4.53,11.5,6s-0.572,2.851-1.611,3.889C8.851,10.928,7.47,11.5,6,11.5z";
    LegendSize[Constants.BUBBLE_ICON] = {
        width:11,
        height:11
    };

    LegendPath[Constants.NULL_MARKER] = 'M1,8L1,8c0-0.552,0.448-1,1-1h12c0.552,0,1,0.448,1,1v0c0,0.552-0.448,1-1,1H2C1.448,9,1,8.552,1,8z';
    LegendSize[Constants.NULL_MARKER] = {
        width:16,
        height:16
    };

    LegendPath[Constants.CIRCLE] = 'M11,8c0,1.657-1.343,3-3,3S5,9.657,5,8s1.343-3,3-3S11,6.343,11,8z M14,7h-2.142C11.942,7.322,12,7.653,12,8s-0.058,0.678-0.142,1H14c0.552,0,1-0.448,1-1C15,7.448,14.552,7,14,7z M4,8c0-0.347,0.058-0.678,0.142-1H2C1.448,7,1,7.448,1,8c0,0.552,0.448,1,1,1h2.142C4.058,8.678,4,8.347,4,8z';
    LegendSize[Constants.CIRCLE] = {
        width:16,
        height:16
    };

    LegendPath[Constants.SCATTER_ICON + Constants.NULL_MARKER] = 'M0,0L12,0L12,12L0,12Z';
    LegendSize[Constants.SCATTER_ICON + Constants.NULL_MARKER] = {
        width:12,
        height:12
    };

    LegendPath[Constants.SCATTER_ICON + Constants.NORMAL_ICON] = 'M0,0L12,0L12,12L0,12Z';
    LegendSize[Constants.SCATTER_ICON + Constants.NORMAL_ICON] = {
        width:12,
        height:12
    };

    LegendPath[Constants.SCATTER_ICON + Constants.CIRCLE] = "M4,8C2.897,8,1.897,7.551,1.173,6.827S0,5.103,0,4s0.449-2.103,1.173-2.827S2.897,0,4,0s2.103,0.449,2.827,1.173S8,2.897,8,4S7.551,6.103,6.827,6.827S5.103,8,4,8";
    LegendSize[Constants.SCATTER_ICON + Constants.CIRCLE] = {
        width:8,
        height:8
    };

    LegendPath[Constants.SQUARE] = 'M11,11H5V5h6V11z M14,7h-2v2h2c0.552,0,1-0.448,1-1C15,7.448,14.552,7,14,7z M4,7H2C1.448,7,1,7.448,1,8c0,0.552,0.448,1,1,1h2V7z';
    LegendSize[Constants.SQUARE] = {
        width:16,
        height:16
    };
    LegendPath[Constants.SCATTER_ICON + Constants.SQUARE] = "M0,0h8c0,0,0,3.889,0,8C4,8,0,8,0,8V0z";
    LegendSize[Constants.SCATTER_ICON + Constants.SQUARE] = {
        width:8,
        height:8
    };

    LegendPath[Constants.DIAMOND] = 'M8,11L5,8l3-3l3,3L8,11z M14,7h-2.586l1,1l-1,1H14c0.552,0,1-0.448,1-1C15,7.448,14.552,7,14,7z M3.586,8l1-1H2C1.448,7,1,7.448,1,8c0,0.552,0.448,1,1,1h2.586L3.586,8z';
    LegendSize[Constants.DIAMOND] = {
        width:16,
        height:16
    };
    LegendPath[Constants.SCATTER_ICON + Constants.DIAMOND] = "M0,4.5L4.502,0l4.5,4.5c0,0,0,0-4.5,4.5C0,4.5,0,4.5,0,4.5z";
    LegendSize[Constants.SCATTER_ICON + Constants.DIAMOND] = {
        width:9,
        height:9
    };

    LegendPath[Constants.TRIANGLE] = 'M5,10l3-5.196L11,10H5z M14,7h-3.577l1.155,2H14c0.552,0,1-0.448,1-1C15,7.448,14.552,7,14,7z M5.577,7H2C1.448,7,1,7.448,1,8c0,0.552,0.448,1,1,1h2.423L5.577,7z';
    LegendSize[Constants.TRIANGLE] = {
        width:16,
        height:16
    };
    LegendPath[Constants.SCATTER_ICON + Constants.TRIANGLE] = "M4.5,0L9,8c0,0-4.617,0-9,0L4.5,0z";
    LegendSize[Constants.SCATTER_ICON + Constants.TRIANGLE] = {
        width:9,
        height:8
    };

    LegendPath[Constants.CIRCLE_HOLLOW] = 'M4.142,9H2C1.448,9,1,8.552,1,8c0-0.552,0.448-1,1-1h2.142C4.058,7.322,4,7.653,4,8S4.058,8.678,4.142,9zM14,7h-2.142C11.942,7.322,12,7.653,12,8s-0.058,0.678-0.142,1H14c0.552,0,1-0.448,1-1C15,7.448,14.552,7,14,7z M8,7C7.449,7,7,7.449,7,8s0.449,1,1,1s1-0.449,1-1S8.551,7,8,7 M8,5c1.657,0,3,1.343,3,3s-1.343,3-3,3S5,9.657,5,8S6.343,5,8,5L8,5z';
    LegendSize[Constants.CIRCLE_HOLLOW] = {
        width:16,
        height:16
    };
    LegendPath[Constants.SCATTER_ICON + Constants.CIRCLE_HOLLOW] = "M4,2c1.102,0,2,0.898,2,2S5.102,6,4,6S2,5.102,2,4S2.898,2,4,2 M4,0C1.791,0,0,1.791,0,4s1.791,4,4,4s4-1.791,4-4S6.209,0,4,0";
    LegendSize[Constants.SCATTER_ICON + Constants.CIRCLE_HOLLOW] = {
        width:8,
        height:8
    };

    LegendPath[Constants.SQUARE_HOLLOW] = 'M4,9H2C1.448,9,1,8.552,1,8c0-0.552,0.448-1,1-1h2V9z M14,7h-2v2h2c0.552,0,1-0.448,1-1C15,7.448,14.552,7,14,7z M9,7H7v2h2V7 M11,5v6H5V5H11L11,5z';
    LegendSize[Constants.SQUARE_HOLLOW] = {
        width:16,
        height:16
    };
    LegendPath[Constants.SCATTER_ICON + Constants.SQUARE_HOLLOW] = "M6,6H2V2h4V6z M8,0H0v8h8V0z";
    LegendSize[Constants.SCATTER_ICON + Constants.SQUARE_HOLLOW] = {
        width:8,
        height:8
    };

    LegendPath[Constants.DIAMOND_HOLLOW] = 'M4.157,9H2C1.448,9,1,8.552,1,8c0-0.552,0.448-1,1-1h2.157l-1,1L4.157,9z M14,7h-2.157l1,1l-1,1H14c0.552,0,1-0.448,1-1C15,7.448,14.552,7,14,7z M8,5.986L5.986,8L8,10.014L10.014,8L8,5.986 M8,4.571L11.429,8L8,11.429L4.571,8L8,4.571L8,4.571z';
    LegendSize[Constants.DIAMOND_HOLLOW] = {
        width:16,
        height:16
    };
    LegendPath[Constants.SCATTER_ICON + Constants.DIAMOND_HOLLOW] = "M2.121,4.999L5,2.121l2.878,2.878L5,7.879L2.121,4.999z M5,0L0,4.999L5,10l4.999-5.001L5,0z";
    LegendSize[Constants.SCATTER_ICON + Constants.DIAMOND_HOLLOW] = {
        width:10,
        height:10
    };

    LegendPath[Constants.TRIANGLE_HOLLOW] = 'M4.5,9H2C1.448,9,1,8.552,1,8s0.448-1,1-1h3.655L4.5,9z M14,7h-3.655L11.5,9H14c0.552,0,1-0.448,1-1S14.552,7,14,7z M8,6.938L6.232,10h3.536L8,6.938 M8,4.938L11.5,11h-7L8,4.938L8,4.938z';
    LegendSize[Constants.TRIANGLE_HOLLOW] = {
        width:16,
        height:16
    };
    LegendPath[Constants.SCATTER_ICON + Constants.TRIANGLE_HOLLOW] = "M5.001,3.34L7.402,7.5H2.598L5.001,3.34z M5.001,0.34L0,9h10L5.001,0.34z";
    LegendSize[Constants.SCATTER_ICON + Constants.TRIANGLE_HOLLOW] = {
        width:10,
        height:9
    };

    function getLegendIconPath(name){
        return LegendPath[name];
    }

    function getLegendIconSize(name){
        return LegendSize[name] ? LegendSize[name] : LegendSize[Constants.NORMAL_ICON];
    }

    function hasIcon(name){
        return LegendPath[name];
    }
    
    return {
        getLegendIconPath:getLegendIconPath,
        getLegendIconSize:getLegendIconSize,
        hasIcon:hasIcon
    }
});
/**
 * Created by eason on 15/5/4.
 * 图表中所有可以显现的内容都作为一个组件
 */
define('component/Base',['require','../utils/BaseUtils','../utils/ColorUtils','../Constants','../render/RenderFactory','../utils/QueryUtils','../utils/Formatter','../render/LegendIconFactory','../utils/Class'],function(require){
    var BaseUtils = require('../utils/BaseUtils');
    var ColorUtils = require('../utils/ColorUtils');
    var Constants = require('../Constants');
    var RenderFactory = require('../render/RenderFactory');
    var QueryUtils = require('../utils/QueryUtils');
    var Formatter = require('../utils/Formatter');
    var LegendIconFactory = require('../render/LegendIconFactory');

    var Class = require('../utils/Class');

    var LABEL_GAP = 2;
    var CATEGORY = 'CATEGORY';
    var SERIES = 'SERIES';
    var VALUE = 'VALUE';
    var PERCENT = 'PERCENT';

    var DEFAULT_MARKER_RADIUS = 4.5;

    var Base = Class.extend({

        initialize:function(vanchart, option, componentType, componentOption){
            this.vanchart = vanchart;
            this.option = option;
            this.componentType = componentType;
            this.componentOption = componentOption || option[componentType];

            //this.type在prototype里,主要是坐标轴value还是category
            var renderType;
            if (this.type) {
                switch (componentType) {
                    case Constants.RADIUS_AXIS_COMPONENT:
                        renderType = Constants.RADIUS_AXIS_RENDER;
                        break;
                    case Constants.ANGLE_AXIS_COMPONENT:
                        renderType = Constants.ANGLE_AXIS_RENDER;
                        break;
                    default:
                        renderType = this.type;
                }
            } else {
                renderType = componentType;
            }

            this.render = RenderFactory.getRender(renderType, this);

            this.isFloat = false;
            this._needLayout = true;

            this._floatX = 0;
            this._floatY = 0;
            this.bounds = {x:0, y:0, width:0, height:0};

            this.refresh(option, this.componentOption);
        },

        refresh:function(option, componentOption){
            if(option){
                this.option = option;
                this.componentOption = componentOption ? componentOption : option[this.componentType];
            }

            componentOption = this.componentOption;
            if(componentOption){
                this.isFloat = componentOption.floating;
                this._floatX = this._getPercentValue(componentOption.x, this.vanchart.chartWidth());
                this._floatY = this._getPercentValue(componentOption.y, this.vanchart.chartHeight());
            }

            this._refresh && this._refresh();
        },

        //确定占据的大小
        doLayout:function(){

        },

        //根据绘图区的位置确定组件的位置
        fixBoundsByPlot:function(){

        },

        initAttributesWithSeries:function(){

        },

        remove:function(){
            this.render && this.render.remove();
        },

        groupDataByClassName:function(){
            return BaseUtils.pick(this.option.byClassName, true);
        },

        //在图形创建之前就要知道
        getMaxBubbleRadius:function(){

            var maxSize = 0;

            //配置的系列
            var series = this.vanchart.series;
            series.forEach(function(sery){
                if(sery.visible && sery.type == Constants.BUBBLE_CHART){
                    maxSize = Math.max(maxSize, sery.maxSize);
                }
            });

            return maxSize/2;
        },

        //默认的系列颜色
        _getDefaultSeriesColor:function(seriesName){
            return this.vanchart.getDefaultSeriesColor(seriesName);
        },

        _getLegendType:function(sery){

            var marker = sery.marker;

            var icon = '';

            switch (sery.type) {
                case Constants.MULTIPIE_CHART:
                case Constants.PIE_CHART:
                    if (sery.innerRadius && parseFloat(sery.innerRadius) > 0) {
                        icon = Constants.DONUT_ICON;
                    }else{
                        icon = Constants.PIE_ICON;
                    }
                    break;
                case Constants.RADAR_CHART:
                    if (sery.columnType) {
                        icon = Constants.NORMAL_ICON;
                    }
                    break;
                case Constants.BUBBLE_CHART:
                    icon = Constants.BUBBLE_ICON;
                    break;
                default:
                    icon = Constants.NORMAL_ICON;
            }

            //有marker的图例,跟marker的类型一致,跟具体的图表类型无关
            if(marker){
                icon = marker.symbol;
                if(sery.type == Constants.SCATTER_CHART && !BaseUtils.isImageMarker(icon)){
                    icon = Constants.SCATTER_ICON + marker.symbol;
                }
            }else if(sery.type == Constants.POINT_MAP && sery.icon){
                icon = sery.icon.iconUrl;
            }else if(sery.image){
                //图片类型的填充系列用图片作为图例标记
                icon = sery.image;
            }

            return icon;
        },

        //用百分比表示或者数字表示的值
        _getPercentValue:function(value, total){
            if(value){
                value += '';
                if(value.indexOf('%') != -1){
                    value = parseFloat(value) * total / 100;
                }
                return parseFloat(value);
            }
            return 0;
        },

        _setComponentBounds:function(position, usedSize){
            if(this.isFloat){
                this._updateFloatBounds(position, usedSize);
            }else{
                this._updateComponentBounds(position, usedSize);
            }
        },

        _updateFloatBounds:function(position, usedSize){
            usedSize = Math.ceil(usedSize);

            var originBounds = this.vanchart.getPlotBounds();

            var x = this._floatX;
            var y = this._floatY;

            var width = originBounds.x + originBounds.width - x;
            var height = originBounds.y + originBounds.height - y;

            switch (position){
                case Constants.TOP:
                    this.bounds = {x:x, y:y, width:width, height:usedSize};
                    break;
                case Constants.BOTTOM:
                    this.bounds = {x:x, y:y, width:width, height:usedSize};
                    break;
                case Constants.LEFT:
                    this.bounds = {x:x, y:y, width:usedSize, height:height};
                    break;
                case Constants.RIGHT_TOP:
                case Constants.RIGHT:
                    this.bounds = {x:x, y:y, width:usedSize, height:height};
                    break
            }

        },

        /**
         * 从原始区域裁减出一块区域以后作为组件区域，并且更新原始区域
         * @param position{string} 位置
         * @para usedSize 占据的大小
         * @private
         */
        _updateComponentBounds:function(position, usedSize){
            usedSize = Math.ceil(usedSize);

            var originBounds = this.vanchart.getPlotBounds();
            var x = originBounds.x;
            var y = originBounds.y;
            var width = originBounds.width;
            var height = originBounds.height;

            switch (position){
                case Constants.TOP:
                    this.bounds = {x:x, y:y, width:width, height:usedSize};
                    break;
                case Constants.BOTTOM:
                    this.bounds = {x:x, y:y+height-usedSize, width:width, height:usedSize};
                    break;
                case Constants.LEFT:
                    this.bounds = {x:x, y:y, width:usedSize, height:height};
                    break;
                case Constants.RIGHT_TOP:
                case Constants.RIGHT:
                    this.bounds = {x:x+width-usedSize, y:y, width:usedSize, height:height};
                    break
            }
            this.vanchart.setPlotBounds(originBounds);

            this._clipPlotBounds(position, usedSize);
        },

        _clipPlotBounds:function(position, usedSize){

            usedSize = Math.ceil(usedSize);

            var originBounds = this.vanchart.getPlotBounds();
            var x = originBounds.x;
            var y = originBounds.y;
            var width = originBounds.width;
            var height = originBounds.height;

            switch (position){
                case Constants.TOP:
                    originBounds = {x:x, y:y+usedSize, width:width, height:height - usedSize};
                    break;
                case Constants.BOTTOM:
                    originBounds = {x:x, y:y, width:width, height:height - usedSize};
                    break;
                case Constants.LEFT:
                    originBounds = {x:x+usedSize, y:y, width:width-usedSize, height:height};
                    break;
                case Constants.RIGHT_TOP:
                case Constants.RIGHT:
                    originBounds = {x:x, y:y, width:width-usedSize, height:height};
                    break
            }
            this.vanchart.setPlotBounds(originBounds);
        },

        _getBackgroundColor:function(){

            var opt = this.option;

            var plotColor = (typeof opt.plotBackgroundColor == 'string');

            var chartColor = (typeof opt.backgroundColor == 'string');

            var color =  plotColor ? opt.plotBackgroundColor : (chartColor ? opt.backgroundColor : 'white');

            return ColorUtils.colorToHex(color);
        },

        getPosition:function(){
            return this.componentOption.position;
        },

        isHorizontal:function(){

            return this.getPosition() == Constants.TOP
                || this.getPosition() == Constants.BOTTOM;
        },

        getMousePos:function(event){

            var el = this.vanchart.getParentDom();

            return BaseUtils.getMousePos(event, el);
        },

        isLargeMode:function(){
            return this.option.plotOptions.large;
        },

        _maxHeight:function(max){
            var maxHeight = this.vanchart.chartHeight();

            if(max || this.componentOption.maxHeight){
                return this._getPercentValue(this.componentOption.maxHeight, maxHeight);
            }

            return maxHeight;
        },

        _maxWidth:function(max){
            var maxWidth = this.vanchart.chartWidth();

            if(max || this.componentOption.maxWidth){
                return this._getPercentValue(this.componentOption.maxWidth, maxWidth);
            }

            return maxWidth;
        },

        //每种类型都在一行
        _calculateSingleLineLabelContent:function(formatter, data){

            if(!formatter){
                return '';
            }

            if(typeof formatter == 'object'){
                var content = '';
                var label = formatter.identifier;
                var categoryString = Formatter.format(data.category, formatter.categoryFormat);
                var seriesString = Formatter.format(data.seriesName, formatter.seriesFormat);

                if(label.indexOf(CATEGORY) != -1 || label.indexOf(SERIES) != -1){
                    if(label.indexOf(CATEGORY) != -1 && label.indexOf(SERIES) != -1){
                        content += (categoryString + ' ' + seriesString);
                    }else if(label.indexOf(CATEGORY) != -1){
                        content += categoryString;
                    }else{
                        content += seriesString;
                    }
                }

                if(label.indexOf(VALUE) != -1 || label.indexOf(PERCENT) != -1){

                    if(!BaseUtils.isEmpty(content)){
                        content += ':';
                    }

                    var valueString = Formatter.format(data.value, formatter.valueFormat);
                    var percentString = Formatter.format(data.percentage, formatter.percentFormat);

                    if(label.indexOf(VALUE) != -1 && label.indexOf(PERCENT) != -1){
                        content += (valueString + ' ' + percentString);
                    }else if(label.indexOf(VALUE) != -1){
                        content += valueString;
                    }else{
                        content += percentString;
                    }
                }
                return content;
            }else{
                return BaseUtils.getFormatterFunction(formatter).call(data);
            }

        },

        _createMultiLineLabelContent:function(formatter, data){
            if(!formatter){
                return [];
            }

            if(typeof formatter == 'object'){
                var content = [];

                var label = formatter.identifier;
                var categoryString = Formatter.format(data.category, formatter.categoryFormat);
                var seriesString = Formatter.format(data.seriesName, formatter.seriesFormat);
                var valueString = Formatter.format(data.value, formatter.valueFormat);
                var percentString = Formatter.format(data.percentage, formatter.percentFormat);

                if(label.indexOf(CATEGORY) != -1){
                    content.push(categoryString);
                }

                if(label.indexOf(SERIES) != -1){
                    content.push(seriesString)
                }

                if(label.indexOf(VALUE) != -1){
                    content.push(valueString);
                }

                if(label.indexOf(PERCENT) != -1){
                    content.push(percentString);
                }

                return content;
            }else{
                return [BaseUtils.getFormatterFunction(formatter).call(data)];
            }

        },

        _getTickContent:function(tick, formatter){

            if(!formatter){
                return tick;
            }

            return Formatter.format(tick, formatter);
        },

        getLabelGap:function(){
            return LABEL_GAP;
        },

        getDefaultMarkerRadius:function(){
            return DEFAULT_MARKER_RADIUS;
        },

        getPlotBounds:function(){
            return this.vanchart.getPlotBounds();
        },

        getChartBounds:function(){
            return this.vanchart.getChartBounds();
        },

        getVanchartRender:function(){
            return this.vanchart.getRender();
        },

        getRender:function(){
            return this.render;
        },

        getParentDom:function(){
            return this.vanchart.getParentDom();
        },

        getDivParentDom:function(){
            return this.vanchart.getDivParentDom();
        },

        getTooltipComponent:function(){
            return this.vanchart.components.tooltip;
        }
    });

    return Base;
});
/**
 * Created by eason on 15/5/4.
 * 标题组建，包括图表标题和坐标轴标题
 */
define('component/Title',['require','./Base','../utils/BaseUtils','../Constants','../ComponentLibrary'],function(require){
    var Base = require('./Base');
    var BaseUtils = require('../utils/BaseUtils');
    var Constants = require('../Constants');

    var LINE_GAP_PERCENT = 0.2;
    var PADDING = 5;

    var Title = Base.extend({

        _refresh:function(){
            this.initBarWidth = null;
            this.render && this.render.remove();
        },

        doLayout:function(){

            var cfg = this.componentOption;

            var originBounds = this.vanchart.getPlotBounds();

            var remainWidth = originBounds.width;
            var remainHeight = originBounds.height;

            var textDim;

            // get maximal area
            if (this.isFloat) {

                remainWidth -= (this._floatX - originBounds.x);
                remainHeight -= (this._floatY - originBounds.y);

            } else {

                this.initBarWidth = BaseUtils.pick(this.initBarWidth, this.vanchart.getToolbarWidth());
                remainWidth -= this.initBarWidth;

                if (cfg.align === 'center') {
                    remainWidth -= this.initBarWidth;
                }
            }

            // cut padding to place text
            remainWidth -= 2 * PADDING;
            remainHeight -= 2 * PADDING;

            // try to get minimal text width
            textDim = BaseUtils.getTextWrapDimension(cfg.text, cfg.style, cfg.useHtml);

            // wrap text when too long
            if (textDim.width > remainWidth) {
                var newStyle = BaseUtils.clone(cfg.style);
                newStyle.width = remainWidth + 'px';
                textDim = BaseUtils.getTextWrapDimension(cfg.text, newStyle, cfg.useHtml);
            } else {
                textDim.width += 0.5;
            }

            // title and text height are the same and should be minimal
            textDim.height = Math.min(this._maxHeight(), remainHeight, textDim.height);

            // while widths are different
            // floating title width is text width
            // fixed title width remains plot width; cut toolbar is text width
            if (this.isFloat) {

                this.bounds = {
                    x: this._floatX,
                    y: this._floatY,
                    // contract floating title's background width
                    width: textDim.width + 2 * PADDING,
                    height: textDim.height + 2 * PADDING
                };

            } else {

                var height = textDim.height + 2 * PADDING;

                this._setComponentBounds(Constants.TOP, height);

                // extend to title except toolbar
                if (cfg.align !== 'center') {
                    textDim.width = remainWidth;
                }
            }

            this.textDim = textDim;

        },

        getPadding:function(){
            return PADDING;
        },

        getLineGapPercent:function(){
            return LINE_GAP_PERCENT;
        },

        translateX:function(width) {
            this.render.translateX(width);
        },

        changeTextRightSpace: function (changes) {
            this.render.changeTextRightSpace(changes);
        }
    });
    
    require('../ComponentLibrary').register(Constants.TITLE_COMPONENT, Title);
    return Title;
});
/**
 * Created by eason on 16/5/17.
 */
define('component/DrillTools',['require','./Base','../utils/BaseUtils','../utils/ColorUtils','../Constants','../ComponentLibrary'],function(require){
    var Base = require('./Base');
    var BaseUtils = require('../utils/BaseUtils');
    var ColorUtils = require('../utils/ColorUtils');
    var Constants = require('../Constants');

    var PADDING = 2;
    var FIRST_LEFT_PADDING = 0.417;
    var LEFT_PADDING = 0.583;
    var RIGHT_PADDING = 0.25;
    var ARROW_SIZE = 0.333;
    var TOP_PADDING = 0.1665;

    var DrillTools = Base.extend({

        _refresh:function(){
            this.iconData = [];
        },

        doLayout:function(){
            var cfg = this.componentOption;
            this._setComponentBounds(Constants.TOP, BaseUtils.getTextHeight(cfg.style) * (TOP_PADDING * 2 + 1));
        },

        findDataPointByName:function(name){

            for(var i = 0, len = this.iconData.length; i < len; i++){
                if(this.iconData[i].geo.geoName == name){
                    break;
                }
            }

            if(this.iconData[i - 1]){
                var series = this.iconData[i - 1].series;
                for(var j = 0; j < series.length; j++){
                    for(var k = 0; k < series[j].points.length; k++){
                        var p = series[j].points[k];
                        if(p.drill && p.drill.geo.name == name){
                            return p;
                        }
                    }
                }
            }
        },

        addIconData:function(data){
            this.iconData.push(data);
            data.aniStart = this.getMarkAnimationStartPos(data);
            data.aniEnd = this.getMarkPos(data);
        },

        deleteIconData:function(series){
            var data;
            while((data = this.iconData[this.iconData.length - 1]) && data.series != series){
                this.iconData.pop();
            }
        },

        getIconData:function(){
            return this.iconData;
        },

        getBookMarkPath:function(d){

            var style = this.componentOption.style;
            var dim = BaseUtils.getTextDimension(d.geo.geoName, style);

            var index = d.layerIndex;

            var rectWidth = (index == 0 ? FIRST_LEFT_PADDING : LEFT_PADDING) + RIGHT_PADDING;
            rectWidth = dim.height * rectWidth + dim.width;
            var arrowWidth = dim.height * ARROW_SIZE;
            var rectHeight = (1 + TOP_PADDING * 2) * dim.height;

            var ltop = [0,0], rtop = [rectWidth, 0], cp = [rectWidth + arrowWidth, rectHeight/2];
            var rbottom = [rectWidth, rectHeight], lbottom = [0, rectHeight];

            return 'M' + ltop + 'L' + rtop + 'L' + cp + 'L' + rbottom + 'L' + lbottom + 'Z';
        },

        isCurrent:function(d){
            return this.iconData[this.iconData.length - 1] == d;
        },

        textColor:function(d){
            var cfg = this.componentOption;
            return this.isCurrent(d) ? cfg.currentColor : cfg.style.color;
        },

        mouseOverColor:function(d){
            var mouseOverColor;
            if(!(mouseOverColor = this.componentOption.mouseOverColor)){
                var textColor = this.textColor(d);
                var rgba = ColorUtils.getRGBAColorArray(textColor);
                var hsb = ColorUtils.rgb2hsb(rgba[0], rgba[1], rgba[2]);
                var rgb = ColorUtils.hsb2rgb(hsb[0], hsb[1]/2, (hsb[2] + 1)/2);
                mouseOverColor = ColorUtils.toColor(rgb, 'rgb');
            }

            return mouseOverColor;
        },

        leftPadding:function(d){
            return d.layerIndex == 0 ? FIRST_LEFT_PADDING : LEFT_PADDING;
        },

        topPadding:function(){
            return TOP_PADDING;
        },

        calculateExitAnimation:function(exitData){

            exitData.reverse();

            var time = 600;
            var i = 0, len = exitData.length;
            for(; i < len; i++){
                exitData[i].time = time;
                time = Math.max(time - 100, 0);
            }

            var delay = 0;
            for(i = len - 1; i >= 0; i--){
                if(exitData[i].time){
                    exitData[i].delay = delay;
                    delay += 200;
                }else{
                    exitData[i].delay = 0;
                }
            }
        },

        getMarkPos:function(d){
            var x = 0;
            for(var i = 0; i < d.layerIndex; i++){
                x += this.getBookMarkLength(this.iconData[i], i);
            }
            return x;
        },

        getMarkAnimationStartPos:function(d){
            var index = d.layerIndex;
            return index == 0 ? 0 : (this.getMarkPos(this.iconData[index - 1]) - this.getBookMarkLength(d, index));
        },

        getBookMarkLength:function(data, index){
            var cfg = this.componentOption;
            var textHeight = BaseUtils.getTextHeight(cfg.style);
            var length = BaseUtils.getTextDimension(data.geo.geoName, cfg.style).width;
            var padding = (index == 0 ? FIRST_LEFT_PADDING : LEFT_PADDING) + RIGHT_PADDING;
            return length + padding * textHeight;
        }
    });

    require('../ComponentLibrary').register(Constants.DRILL_TOOLS, DrillTools);
    return DrillTools;
});
/**
 * Created by eason on 15/8/7.
 */
//管理标签位置
define('utils/BoundsManager',['require','./BaseUtils'],function(require){

    var BaseUtils = require('./BaseUtils');

    function BoundsManager(){
        this.addedBounds = [];
    }

    BoundsManager.prototype = {

        constructor:BoundsManager,

        addBounds:function(bounds){
            this.addedBounds.push(bounds);
        },

        isOverlapped:function(bounds){
            for (var i = 0, len = this.addedBounds.length; i < len; i++){
                if (BaseUtils.rectangleOverlapped(bounds, this.addedBounds[i])){
                    return true;
                }
            }
            return false;
        },

        isEmpty:function(){
            return this.addedBounds.length == 0;
        }

    };

    return BoundsManager;
});
/**
 * Created by eason on 15/6/24.
 */
//
//Copyright (c) 2014 Ga?tan Renaudeau
//
//Permission is hereby granted, free of charge, to any person
//obtaining a copy of this software and associated documentation
//files (the "Software"), to deal in the Software without
//restriction, including without limitation the rights to use,
//    copy, modify, merge, publish, distribute, sublicense, and/or sell
//copies of the Software, and to permit persons to whom the
//Software is furnished to do so, subject to the following
//conditions:
//
//    The above copyright notice and this permission notice shall be
//included in all copies or substantial portions of the Software.
//
//    THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
//    EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES
//OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
//NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT
//HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY,
//    WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
//FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR
//OTHER DEALINGS IN THE SOFTWARE.

define('utils/BezierEasing',[],function(){
    var global = this;

    // These values are established by empiricism with tests (tradeoff: performance VS precision)
    var NEWTON_ITERATIONS = 4;
    var NEWTON_MIN_SLOPE = 0.001;
    var SUBDIVISION_PRECISION = 0.0000001;
    var SUBDIVISION_MAX_ITERATIONS = 10;

    var kSplineTableSize = 11;
    var kSampleStepSize = 1.0 / (kSplineTableSize - 1.0);

    var float32ArraySupported = 'Float32Array' in global;

    function A (aA1, aA2) { return 1.0 - 3.0 * aA2 + 3.0 * aA1; }
    function B (aA1, aA2) { return 3.0 * aA2 - 6.0 * aA1; }
    function C (aA1)      { return 3.0 * aA1; }

    // Returns x(t) given t, x1, and x2, or y(t) given t, y1, and y2.
    function calcBezier (aT, aA1, aA2) {
        return ((A(aA1, aA2)*aT + B(aA1, aA2))*aT + C(aA1))*aT;
    }

    // Returns dx/dt given t, x1, and x2, or dy/dt given t, y1, and y2.
    function getSlope (aT, aA1, aA2) {
        return 3.0 * A(aA1, aA2)*aT*aT + 2.0 * B(aA1, aA2) * aT + C(aA1);
    }

    function binarySubdivide (aX, aA, aB, mX1, mX2) {
        var currentX, currentT, i = 0;
        do {
            currentT = aA + (aB - aA) / 2.0;
            currentX = calcBezier(currentT, mX1, mX2) - aX;
            if (currentX > 0.0) {
                aB = currentT;
            } else {
                aA = currentT;
            }
        } while (Math.abs(currentX) > SUBDIVISION_PRECISION && ++i < SUBDIVISION_MAX_ITERATIONS);
        return currentT;
    }

    function BezierEasing (mX1, mY1, mX2, mY2) {
        // Validate arguments
        if (arguments.length !== 4) {
            throw new Error("BezierEasing requires 4 arguments.");
        }
        for (var i=0; i<4; ++i) {
            if (typeof arguments[i] !== "number" || isNaN(arguments[i]) || !isFinite(arguments[i])) {
                throw new Error("BezierEasing arguments should be integers.");
            }
        }
        if (mX1 < 0 || mX1 > 1 || mX2 < 0 || mX2 > 1) {
            throw new Error("BezierEasing x values must be in [0, 1] range.");
        }

        var mSampleValues = float32ArraySupported ? new Float32Array(kSplineTableSize) : new Array(kSplineTableSize);

        function newtonRaphsonIterate (aX, aGuessT) {
            for (var i = 0; i < NEWTON_ITERATIONS; ++i) {
                var currentSlope = getSlope(aGuessT, mX1, mX2);
                if (currentSlope === 0.0) return aGuessT;
                var currentX = calcBezier(aGuessT, mX1, mX2) - aX;
                aGuessT -= currentX / currentSlope;
            }
            return aGuessT;
        }

        function calcSampleValues () {
            for (var i = 0; i < kSplineTableSize; ++i) {
                mSampleValues[i] = calcBezier(i * kSampleStepSize, mX1, mX2);
            }
        }

        function getTForX (aX) {
            var intervalStart = 0.0;
            var currentSample = 1;
            var lastSample = kSplineTableSize - 1;

            for (; currentSample != lastSample && mSampleValues[currentSample] <= aX; ++currentSample) {
                intervalStart += kSampleStepSize;
            }
            --currentSample;

            // Interpolate to provide an initial guess for t
            var dist = (aX - mSampleValues[currentSample]) / (mSampleValues[currentSample+1] - mSampleValues[currentSample]);
            var guessForT = intervalStart + dist * kSampleStepSize;

            var initialSlope = getSlope(guessForT, mX1, mX2);
            if (initialSlope >= NEWTON_MIN_SLOPE) {
                return newtonRaphsonIterate(aX, guessForT);
            } else if (initialSlope === 0.0) {
                return guessForT;
            } else {
                return binarySubdivide(aX, intervalStart, intervalStart + kSampleStepSize, mX1, mX2);
            }
        }

        var _precomputed = false;
        function precompute() {
            _precomputed = true;
            if (mX1 != mY1 || mX2 != mY2)
                calcSampleValues();
        }

        var f = function (aX) {
            if (!_precomputed) precompute();
            if (mX1 === mY1 && mX2 === mY2) return aX; // linear
            // Because JavaScript number are imprecise, we should guarantee the extremes are right.
            if (aX === 0) return 0;
            if (aX === 1) return 1;
            return calcBezier(getTForX(aX), mY1, mY2);
        };

        f.getControlPoints = function() { return [{ x: mX1, y: mY1 }, { x: mX2, y: mY2 }]; };

        var args = [mX1, mY1, mX2, mY2];
        var str = "BezierEasing("+args+")";
        f.toString = function () { return str; };

        //var css = "cubic-bezier("+args+")";
        //f.toCSS = function () {?return css; };

        return f;
    }

    // CSS mapping
    BezierEasing.css = {
        "ease":        BezierEasing(0.25, 0.1, 0.25, 1.0),
        "linear":      BezierEasing(0.00, 0.0, 1.00, 1.0),
        "ease-in":     BezierEasing(0.42, 0.0, 1.00, 1.0),
        "ease-out":    BezierEasing(0.00, 0.0, 0.58, 1.0),
        "ease-in-out": BezierEasing(0.42, 0.0, 0.58, 1.0),
        "swing":       BezierEasing(0.02, 0.01,0.47, 1.0),
        "ease-in-quart":BezierEasing(0.895, 0.03, 0.685, 0.22),
        "ease-out-back":BezierEasing(0.175, 0.885, 0.32, 1.275)
    };

    return BezierEasing;
});
/**
 * Created by eason on 15/6/18.
 */
define('component/BaseAxis',['require','../Constants','../utils/BaseUtils','../utils/QueryUtils','../utils/Formatter','../utils/BoundsManager','./Base','../utils/BezierEasing'],function(require){
    var Constants = require('../Constants');
    var BaseUtils = require('../utils/BaseUtils');
    var QueryUtils = require('../utils/QueryUtils');
    var Formatter = require('../utils/Formatter');
    var BoundsManager = require('../utils/BoundsManager');

    var Base = require('./Base');
    var BezierEasing = require('../utils/BezierEasing');

    var LABEL_LINE_GAP = 3;
    var TICK_LENGTH = 5;
    var TITLE_LABEL_GAP = 5;

    var TICK_COUNT = 5;
    var RADAR_TICK_COUNT = 4;
    var MIN_MAX_GAP = 100;

    var PADDING = 5;

    var PADDING_GAP = 10;
    var LABEL_BORDER_GAP = 8;

    var TOP = 'radar-top';
    var BOTTOM = 'radar-bottom';
    var LEFT = 'radar-left';
    var RIGHT = 'radar-right';

    var ARROW_SIZE = 15;

    var BaseAxis = Base.extend({

        init: function () {
            this.sharedPoints = {};
        },

        getSharedPointsFromSeries: function (series) {
            if (!this.isBaseAxis) {
                return;
            }
            this.sharedPoints = {};
            var self = this;
            series.map(function (seriesItem) {
                if (seriesItem.baseAxis === self &&
                    seriesItem.tooltip &&
                    seriesItem.tooltip.shared &&
                    self._isSeriesVisible(seriesItem)) {
                    if (seriesItem.type === Constants.BAR_CHART ||
                        seriesItem.type === Constants.COLUMN_CHART ||
                        seriesItem.stack === Constants.RADAR_CHART ) {
                        self.highlightType = 'band';
                    }
                    seriesItem.points.map(function (point) {
                        self._getSharedPoints(point);
                    })
                }
            });
        },

        _getSharedPoints: function (point) {
            var series = point.series;

            if (series.supportSharedTooltip &&
                series.visible &&
                series.tooltip &&
                series.tooltip.shared &&
                !point.isNull &&
                point.visible
            ) {
                this.sharedPoints[point.category] || (this.sharedPoints[point.category] = []);
                this.sharedPoints[point.category].push(point);
            }
        },

        doLayout:function(){
            switch (this.componentType) {
                case Constants.X_AXIS_COMPONENT:
                case Constants.Y_AXIS_COMPONENT:
                    this._updateAxisBounds();
                    break;
                case Constants.RADIUS_AXIS_COMPONENT:
                case Constants.ANGLE_AXIS_COMPONENT:
                    this._updatePolarBounds();
                    break;
                default:
            }
            this.getSharedPointsFromSeries(this.vanchart.series);
        },

        refreshPolar: function (option, axisOption) {
            this.refresh(option, axisOption);

            switch (this.componentType) {
                case Constants.RADIUS_AXIS_COMPONENT:
                    this.polar = this.vanchart.polar(axisOption.axisIndex);
                    this.polar.radiusAxis = this;
                    break;
                case Constants.ANGLE_AXIS_COMPONENT:
                    this.polar = this.vanchart.polar(axisOption.axisIndex);
                    this.polar.angleAxis = this;
                    break;
                default:
            }
        },

        _updatePolarBounds: function () {

            if (this.componentType != Constants.ANGLE_AXIS_COMPONENT) {
                return;
            }

            if (this.polar.radius) {
                return;
            }

            // no radius setting, auto adjust
            var plotBounds = this.vanchart.getPlotBounds();
            var center = this.polar.center;

            var tmpBounds = [
                // 0 top
                center[1] - plotBounds.y,
                // 1 right
                plotBounds.x + plotBounds.width - center[0],
                // 2 bottom
                plotBounds.y + plotBounds.height - center[1],
                // 3 left
                center[0] - plotBounds.x
            ];

            var radius = Math.min.apply(null, tmpBounds);
            radius -= PADDING_GAP;

            var testBounds = {
                x: - tmpBounds[3],
                y: - tmpBounds[0],
                width: plotBounds.width,
                height: plotBounds.height
            };

            if (this.componentOption.showLabel) {
                if (!this._testRadius(radius, testBounds)) {
                    radius = this._findNiceRadius(testBounds);
                    this._testRadius(radius, testBounds);
                }
            }

            this.polar.setRadius(radius);

        },

        _updateAxisBounds:function(){

            var axisOption = this.componentOption;
            var position = this.getPosition();

            this.tickLabelLength = this._getTickLabelLength();

            var axisTileLength = this._getAxisTitleLength() + TITLE_LABEL_GAP;

            var usedSize = this.tickLabelLength + axisTileLength;

            var startSize = 0, endSize = 0;

            var isHorizontal = this.isHorizontal();
            var isInverted = this.vanchart.isInverted();

            if(this.tickData && this.tickData.length > 1){
                var t_s, t_e;
                if(this.isAxisReversed()){
                    t_s = this.tickData[this.tickData.length - 1].tickDim;
                    t_e = this.tickData[0].tickDim;
                }else{
                    t_s = this.tickData[0].tickDim;
                    t_e = this.tickData[this.tickData.length - 1].tickDim;
                }
                startSize = isHorizontal ? t_s.width : t_s.height;
                endSize = isHorizontal ? t_e.width : t_s.height
            }

            if(isHorizontal){
                var max = isInverted ? axisOption.maxWidth : axisOption.maxHeight;
                usedSize = max ? Math.min(this._maxHeight(max), usedSize) : usedSize;
            }else{
                var max = isInverted ? axisOption.maxHeight : axisOption.maxWidth;
                usedSize = max ? Math.min(this._maxWidth(max), usedSize) : usedSize;
            }

            //没有定义具体位置的时候
            if(axisOption.onZero){

                var otherAxis = this.componentType == Constants.X_AXIS_COMPONENT ?
                    Constants.Y_AXIS_COMPONENT : Constants.X_AXIS_COMPONENT;

                otherAxis = this.vanchart[otherAxis]();

                axisOption.position = isInverted ^ otherAxis.isHorizontal() ? Constants.RIGHT : Constants.BOTTOM;

                this._updateFloatBounds(position, usedSize);

            }else if(this.getRender()){
                this._setComponentBounds(position, usedSize);
            }

            var plotBounds = this.vanchart.getPlotBounds();
            var chartHeight = this.vanchart.chartHeight();

            // clip vertical axis tick label
            if (!isHorizontal) {

                var topDet = Math.round(endSize/2);

                var bottomDet = Math.round(startSize/2);
                bottomDet = Math.max(bottomDet - (chartHeight - plotBounds.y - plotBounds.height), 0);

                this._clipPlotBounds(Constants.TOP, topDet);
                this._clipPlotBounds(Constants.BOTTOM, bottomDet);
            }
        },

        dealOnZero:function(){

            var cfg = this.componentOption;

            if(cfg.onZero){

                var axisIndex = cfg.onZero === true ? 0 : cfg.onZero;

                var relyOn = this.componentType == Constants.X_AXIS_COMPONENT ?
                    Constants.Y_AXIS_COMPONENT : Constants.X_AXIS_COMPONENT;

                relyOn = this.vanchart.getComponent(relyOn).getAxis(axisIndex);

                var pos;
                if (relyOn.type === Constants.CATEGORY_AXIS_COMPONENT) {
                    pos = 0;
                } else {
                    pos = relyOn.scale(0);
                }

                var plotBounds = this.vanchart.getPlotBounds();

                var x, y, width, height;
                if(this.isHorizontal()){
                    x = plotBounds.x;
                    y = pos + plotBounds.y;
                    width = plotBounds.width;
                    height = this.bounds.height;
                }else{
                    x = pos + plotBounds.x;
                    y = plotBounds.y;
                    width = this.bounds.width;
                    height = plotBounds.height;
                }

                this.bounds = {
                    x:x,
                    y:y,
                    width:width,
                    height:height
                };

            }
        },

        //坐标轴的标签占据的大小
        _getTickLabelLength:function(){

            var axisOption = this.componentOption;

            var tickLength = axisOption.tickPadding || LABEL_LINE_GAP;

            if(axisOption.enableTick){
                tickLength += axisOption.tickLength || TICK_LENGTH;
            }

            var isHorizontal = this.isHorizontal();

            var maxLabelLength  = 0;
            if(axisOption.showLabel && this.tickData.length){
                this.tickData.forEach(function(t){
                    var labelDim = t.tickDim;
                    maxLabelLength = Math.max(maxLabelLength, isHorizontal ? labelDim.height : labelDim.width);
                });
            }

            return tickLength + maxLabelLength;
        },

        //不考虑step和自动间隔
        _updateOriginTickData:function(){
            var labels = this._getTickValues();
            var axisOption = this.componentOption;
            var formatter = axisOption.formatter;

            this.tickData = [];
            for(var i = 0, len = labels.length; i < len; i++){
                var tickValue = labels[i];
                var tickContent = this._getTickContent(tickValue, formatter);
                var labelDim = BaseUtils.getTextDimensionWithRotation(tickContent, axisOption.labelStyle,
                    axisOption.useHtml, axisOption.labelRotation);

                if(axisOption.useHtml){
                    labelDim.width = isNaN(parseFloat(axisOption.labelWidth)) ? labelDim.width : parseFloat(axisOption.labelWidth);
                    labelDim.height = isNaN(parseFloat(axisOption.labelHeight)) ? labelDim.height : parseFloat(axisOption.labelHeight);
                }

                this.tickData.push({
                    tickValue:tickValue,
                    tickContent:tickContent,
                    tickDim:labelDim
                });
            }

            if (axisOption.min && axisOption.min !== labels[0]) {
                var tickValue = axisOption.min;
                var tickContent = '';
                var labelDim = BaseUtils.getTextDimensionWithRotation(tickContent, axisOption.labelStyle,
                    axisOption.useHtml, axisOption.labelRotation);

                if(axisOption.useHtml){
                    labelDim.width = isNaN(parseFloat(axisOption.labelWidth)) ? labelDim.width : parseFloat(axisOption.labelWidth);
                    labelDim.height = isNaN(parseFloat(axisOption.labelHeight)) ? labelDim.height : parseFloat(axisOption.labelHeight);
                }

                this.tickData.unshift({
                    tickValue:tickValue,
                    tickContent:tickContent,
                    tickDim:labelDim
                });
            }
        },

        //确定scale以后计算内容,改变scale的话要重新计算originTickData
        _calculateTickData:function(){

            if (this.componentType === Constants.ANGLE_AXIS_COMPONENT) {

                var radius = this.polar.radius;
                this.tickData.map(function (t) {
                    this._getCateLabelBounds(radius, t);
                }, this);

            } else {
                this._updateTickContent();
            }

            //只有分类轴会走这边
            var startIndex = this._getStartIndex();
            var endIndex = this._getEndIndex() + 1;

            this.usedTickData = [];
            for(var i = startIndex; i < endIndex; i++){
                this.usedTickData.push(this.tickData[i]);
            }

            this.minorTickData = [];
            if(this.componentOption.enableMinorTick && this.usedTickData.length){
                this.type == Constants.CATEGORY_AXIS_COMPONENT ? this._updateCategoryMinorTickData() : this._updateValueMinorTickData();
            }
        },

        _getAxisTitleLength:function(){
            var title = this.componentOption.title;
            var usedSize = 0;
            if(title){
                var dim = BaseUtils.getTextDimensionWithRotation(title.text, title.style, title.useHtml, title.rotation);
                usedSize = this.isHorizontal() ? dim.height : dim.width;
            }
            return usedSize;
        },

        //坐标轴占据的空间
        getAxisTitleBounds:function(){

            var bounds = this.bounds;

            var tickLength = this.tickLabelLength + TITLE_LABEL_GAP;;

            var position = this.getPosition();

            var x = bounds.x;
            var y = bounds.y;
            var width = bounds.width;
            var height = bounds.height;

            switch (position){
                case Constants.LEFT:
                    width -= tickLength;
                    break;

                case Constants.BOTTOM:
                    y += tickLength;
                    height -= tickLength;
                    break;

                case Constants.RIGHT:
                    x += tickLength;
                    width -= tickLength;
                    break;

                case Constants.TOP:
                    height -= tickLength;
                    break;
            }

            return {
                x:x,
                y:y,
                width: Math.max(width, 0),
                height: Math.max(height, 0)
            }
        },

        _updateRange:function(){
            this.scale.rangeRound(this._getRange());
        },

        //边界确定以后,更新domain
        _updateDomainWhenSizeFixed:function(){

        },

        _getRange:function(){
            switch (this.componentType) {
                case Constants.RADIUS_AXIS_COMPONENT:
                    return [0, this.polar.radius];
                default:
                    var plotBounds = this.vanchart.getPlotBounds();

                    if(this.isHorizontal()){
                        return this.isAxisReversed() ? [plotBounds.width, 0] : [0, plotBounds.width];
                    }else{
                        return this.isAxisReversed() ? [0, plotBounds.height] : [plotBounds.height, 0];
                    }
            }
        },

        _preCalculatePlotLines:function(){
            var plotLines = this.componentOption.plotLines || [];
            var position = this.getPosition();
            var plotBounds = this.vanchart.getPlotBounds();
            var axisBounds = this.bounds;

            var scale = this.scale;
            var isDate = this.type == Constants.DATE_AXIS_COMPONENT ;

            var result = [];

            plotLines.forEach(function(d){

                var pos = scale(isDate ? BaseUtils.object2date(d.value) : d.value) + (scale.rangeBand ? scale.rangeBand()/2 : 0);
                var startPos;
                var endPos;

                pos = BaseUtils.lineSubPixelOpt(pos, d.width);

                if (this.isOnZero()) {
                    if (this.isHorizontal()) {
                        startPos = {x: pos, y: 0};
                        endPos = {x: pos, y: plotBounds.height};
                    } else {
                        startPos = {x:plotBounds.width, y:pos};
                        endPos = {x:0, y:pos};
                    }
                } else {
                    switch (position) {
                        case Constants.TOP:
                            startPos = {x: pos, y: axisBounds.y + axisBounds.height - plotBounds.y};
                            endPos = {x: pos, y: plotBounds.height};
                            break;
                        case Constants.BOTTOM:
                            startPos = {x: pos, y: 0};
                            endPos = {x: pos, y: axisBounds.y - plotBounds.y};
                            break;
                        case Constants.LEFT:
                            startPos = {x: axisBounds.x + axisBounds.width - plotBounds.x, y: pos};
                            endPos = {x: plotBounds.width, y: pos};
                            break;
                        case Constants.RIGHT:
                            startPos = {x: axisBounds.x - plotBounds.x, y: pos};
                            endPos = {x: 0, y: pos};
                            break;
                    }
                }

                var textX, textY, text, style;
                textX = textY = 0, text = '', style = {};

                var minX = Math.min(startPos.x, endPos.x);
                var maxX = Math.max(startPos.x, endPos.x);
                var minY = Math.min(startPos.y, endPos.y);
                var maxY = Math.max(startPos.y, endPos.y);

                if(position == Constants.TOP || position == Constants.BOTTOM){
                    if(minX < 0 || maxX > plotBounds.width){
                        return;
                    }
                }else{
                    if(minY < 0 || maxY > plotBounds.height){
                        return;
                    }
                }

                if(d.label && d.label.text && d.label.style){
                    style = d.label.style;
                    text = d.label.text;
                    var align = d.label.align;
                    var textDim = BaseUtils.getTextDimension(text, style, d.label.useHtml);

                    if(d.label.useHtml){
                        textDim.width = BaseUtils.pick(d.label.labelWidth, textDim.width);
                        textDim.height = BaseUtils.pick(d.label.labelHeight, textDim.height);
                    }

                    switch (align){
                        case Constants.TOP:
                            textX = minX - textDim.width;
                            textY = minY;
                            break;
                        case Constants.BOTTOM:
                            textX = minX - textDim.width;
                            textY = maxY - textDim.height;
                            break;
                        case Constants.LEFT:
                            textX = minX;
                            textY = minY - textDim.height - LABEL_LINE_GAP;
                            break;
                        case Constants.RIGHT:
                            textX = maxX - textDim.width;
                            textY = minY - textDim.height - LABEL_LINE_GAP;
                            break;
                    }
                }

                result.push({
                    color: d.color,
                    startPos:startPos,
                    endPos:endPos,
                    width: d.width,
                    dataArray:Constants.DASH_TYPE[d.dashStyle],

                    text:text,
                    textDim:textDim,
                    style:style,
                    textX:textX,
                    textY:textY
                });
            }, this);

            return result;
        },

        _preCalculatePlotBands:function(){

            var plotBands = this._getPlotBands();
            var scale = this.scale;
            var isRangeBand = !!scale.rangeBand;
            var rangeBand = isRangeBand ? scale.rangeBand() : 0;

            var result = [];
            var plotBounds = this.vanchart.getPlotBounds();
            var self = this;

            var domain = this.scale.domain();

            plotBands.forEach(function(d){

                var from, to;

                var t_f = scale(d.from);
                var t_t = scale(d.to);

                from = Math.min(t_f, t_t);
                to = Math.max(t_f, t_t);

                to += rangeBand;

                var x = 0, y = 0, width = plotBounds.width, height = plotBounds.height;

                if(self.isHorizontal()){
                    from = Math.max(x, from);
                    to = Math.min(width + x, to);
                    x = from;
                    width = to - from;
                }else{
                    from = Math.max(y, from);
                    to = Math.min(height + y, to);
                    y = from;
                    height = to - from;
                }

                if (width <= 0 || height <= 0) {
                    return;
                }

                result.push({x:x, y:y, width:width, height:height, color: d.color});
            });

            return result;
        },

        _getPlotBands:function(){

            var plotBands = this.componentOption.plotBands;
            var scale = this.scale;
            var isRangeBand = !!scale.rangeBand;

            if(typeof plotBands == 'string'){

                var color = plotBands;
                plotBands = [];

                var labels = this._getTickValuesWithEndValue();

                var endIndex = isRangeBand ? -1 : 0;

                for(var index = labels.length - 1; index > endIndex; index -= 2){
                    plotBands.push({
                        color:color,
                        from:isRangeBand ? labels[index] : labels[index - 1],
                        to:labels[index]
                    });
                }

            }else{

                plotBands = plotBands || [];

                var result = [];

                for(var i = 0, count = plotBands.length; i < count; i++){

                    var t_bands = plotBands[i];

                    if(BaseUtils.hasDefined(t_bands.from) && BaseUtils.hasDefined(t_bands.to)){
                        result.push(t_bands);
                    }

                }

                plotBands = result;
            }

            return plotBands;

        },

        //考虑tickFormat的作用
        _getTickValues:function(){
            return [];
        },

        _getTickInterval:function(){

            //考虑一开始的区间不满一个tick
            if(this.valueList.length > 2){
                return BaseUtils.accAdd(this.valueList[2], -this.valueList[1]);
            }else{
                return BaseUtils.accAdd(this.valueList[1], -this.valueList[0])
            };

        },

        _getTickValuesWithEndValue:function(){
            return this._getTickValues();
        },

        //画的时候计算自定义标签间隔等
        getTickData:function(){
            return this.usedTickData;
        },

        getMaxTickWidth:function(){
            var maxWidth = 0;

            this.usedTickData.forEach(function(data){

                maxWidth = Math.max(maxWidth, data.tickDim.width);

            });
            return maxWidth;
        },

        getTickHeight:function(){

            if(this.componentOption.labelStyle){
                return BaseUtils.getTextHeight(this.componentOption.labelStyle);
            }

            return 0;

        },

        getMinorTickData:function(){
            return this.minorTickData;
        },

        //todo 这个方法要删掉
        getMainTickData:function(){

            var cfg = this.componentOption;

            var update = !cfg.log && !this.byPercent && this.type == Constants.VALUE_AXIS_COMPONENT;

            if(update){

                var interval = this._getTickInterval();

                if(this.usedTickData.length > 3){

                    var secondMin = this.usedTickData[1].tickValue;

                    var secondMax = this.usedTickData[this.usedTickData.length - 2].tickValue;

                    var startIndex = 0;
                    var endIndex = this.usedTickData.length;

                    if(BaseUtils.hasDefined(cfg.min) && BaseUtils.accAdd(secondMin, -interval) < cfg.min){
                        startIndex += 1;
                    }

                    if(BaseUtils.hasDefined(cfg.max) && BaseUtils.accAdd(secondMax, interval) > cfg.max){
                        endIndex -= 1;
                    }

                    var mainTickData = [];
                    for(var i = startIndex; i < endIndex; i++){
                        mainTickData.push(this.usedTickData[i]);
                    }

                    return mainTickData;
                }

            }

            return this.getTickData();
        },

        _updateCategoryMinorTickData:function(){
            var minorTickLength = Math.round(this.getTickLength() / 5);
            var endIndex = this.usedTickData.length;
            endIndex = this.scale.rangeBand ? endIndex : endIndex - 1;
            for(var i = 0; i < endIndex; i++){
                var startPos = this.usedTickData[i].tickPos;
                for(var j = 1; j < 5; j++){
                    this.minorTickData.push(
                        startPos + minorTickLength * j
                    );
                }
            }
        },

        _updateValueMinorTickData:function(){

            var cfg = this.componentOption;
            var interval = this._getTickInterval();
            var minorInterval = cfg.minorTickInterval ? cfg.minorTickInterval : interval / 5;

            for(var i = 0, count = this.usedTickData.length; i < count - 1; i++){

                var start = this.usedTickData[i].tickValue;

                var end = this.usedTickData[i + 1].tickValue;

                var isDate = (start instanceof Date && end instanceof Date);

                start = isDate ? BaseUtils.date2int(start) : start;
                end = isDate ? BaseUtils.date2int(end) : end;

                if(i == 0){
                    for(var value = BaseUtils.accAdd(end, -minorInterval); value > start; value = BaseUtils.accAdd(value, -minorInterval)){
                        this.minorTickData.push(isDate ? BaseUtils.int2date(value) : value);
                    }
                }else{
                    for(var value = BaseUtils.accAdd(start,minorInterval); value < end; value = BaseUtils.accAdd(value, minorInterval)){
                        this.minorTickData.push(isDate ? BaseUtils.int2date(value) : value);
                    }
                }
            }

            var endValue = this.tickData[this.tickData.length - 1].tickValue;
            var maxValue = this.scale.domain()[1];

            var isDate = (endValue instanceof Date) && (maxValue instanceof Date);
            endValue = isDate ? BaseUtils.date2int(endValue) : endValue;
            maxValue = isDate ? BaseUtils.date2int(maxValue) : maxValue;

            if(endValue < maxValue){
                for(var value = endValue + minorInterval; value <= maxValue; value += minorInterval){
                    this.minorTickData.push(isDate ? BaseUtils.int2date(value) : value);
                }
            }
        },

        _updateTickContent:function(){
            var axisOption = this.componentOption;
            var scale = this.scale;

            var det = scale.rangeBand ? scale.rangeBand()/2 : 0;
            this.tickData.forEach(function(t){
                t.tickPos = scale(t.tickValue);
                t.tickLabelPos = t.tickPos + det;
            });

            if(!axisOption.showLabel){
                this.tickData.forEach(function(t){
                    t.tickContent = '';
                })
            }else if(axisOption.step){
                var index = 0;
                this.tickData.forEach(function(t){
                    if(index++ % axisOption.step){
                        t.tickContent = '';
                    }
                });
            }else{
                var manager = new BoundsManager();
                var isHorizontal = this.isHorizontal();

                var testStep = 1;
                var longestStep = 1;

                this.tickData.forEach(function(t){

                    var pos = isHorizontal ? {x:scale(t.tickValue), y:0} : {x:0, y:scale(t.tickValue)};
                    var bounds = BaseUtils.makeBounds(pos, t.tickDim);

                    if(manager.isOverlapped(bounds)){

                        testStep++;
                        longestStep = Math.max(longestStep, testStep);

                    }else{
                        testStep = 1;
                        manager.addBounds(bounds);
                    }
                });

                var index = 0;
                this.tickData.forEach(function(t){
                    if(index++ % longestStep){
                        t.tickContent = '';
                    }
                });
            }
        },

        _getStartIndex:function(){
            return BaseUtils.pick(this.componentOption.startIndex, 0);
        },

        _getEndIndex:function(){
            return BaseUtils.pick(this.componentOption.endIndex, this.tickData.length - 1);
        },

        _getOriginDet:function(){
            var plotOrigin = this._getPlotOriginPoint();
            var axisOrigin = this._getAxisOriginPoint();
            return {x:plotOrigin.x - axisOrigin.x, y:plotOrigin.y - axisOrigin.y};
        },

        //坐标轴如果靠近plotBounds的话的原点位置，考虑多个坐标轴的的时候
        _getPlotOriginPoint:function(){
            var plotBounds = this.vanchart.getPlotBounds();
            var position = this.getPosition();
            var x,y;

            switch(position){
                case Constants.TOP:
                    x = plotBounds.x;
                    y = plotBounds.y;
                    break;

                case Constants.BOTTOM:
                    x = plotBounds.x;
                    y = plotBounds.y + plotBounds.height;
                    break;

                case Constants.LEFT:
                    x = plotBounds.x;
                    y = plotBounds.y;
                    break;

                case Constants.RIGHT:
                    x = plotBounds.x + plotBounds.width;
                    y = plotBounds.y;
                    break;
            }

            return {x:x, y:y};
        },

        _getAxisOriginPoint:function(){
            var axisBounds = this.bounds;
            var position = this.getPosition();
            var x,y;

            switch(position){
                case Constants.TOP:
                    x = axisBounds.x;
                    y = axisBounds.y + axisBounds.height;
                    break;

                case Constants.BOTTOM:
                    x = axisBounds.x;
                    y = axisBounds.y;
                    break;

                case Constants.LEFT:
                    x = axisBounds.x + axisBounds.width;
                    y = axisBounds.y;
                    break;

                case Constants.RIGHT:
                    x = axisBounds.x;
                    y = axisBounds.y;
                    break;
            }

            return {x:x, y:y};
        },

        getTickScale:function(){
            return this.scale;
        },

        axisZoom:function(downPos, upPos){

        },

        _initZoomStatus:function(){

        },

        getPosition:function(){
            if (this.vanchart.isInverted() &&
                [
                    Constants.X_AXIS_COMPONENT,
                    Constants.Y_AXIS_COMPONENT
                ].indexOf(this.componentType) !== -1) {
                switch (this.componentOption.position) {
                    case Constants.TOP:
                        return Constants.RIGHT;
                    case Constants.RIGHT:
                        return Constants.BOTTOM;
                    case Constants.BOTTOM:
                        return Constants.LEFT;
                    case Constants.LEFT:
                        return Constants.TOP;
                }
            } else {
                return this.componentOption.position;
            }
        },

        isAxisReversed:function(){
            if (this.componentType === Constants.X_AXIS_COMPONENT &&
                this.vanchart.isInverted()) {
                return !this.componentOption.reversed;
            }
            return this.componentOption.reversed;
        },

        isOnZero:function(){
            return this.componentOption.onZero;
        },

        getLineWidth:function(){
            return this.componentOption.lineWidth;
        },

        showArrow:function(){
            return this.componentOption.showArrow;
        },

        getTitleAlign: function () {
            var title = this.componentOption.title;
            if (!title) {
                return null;
            }

            if (this.vanchart.isInverted()) {
                switch (title.align) {
                    case Constants.TOP:
                        return Constants.RIGHT;
                    case Constants.RIGHT:
                        return Constants.BOTTOM;
                    case Constants.BOTTOM:
                        return Constants.LEFT;
                    case Constants.LEFT:
                        return Constants.TOP;
                }
            }

            if (this.isHorizontal()) {
                return title.align || Constants.LEFT;
            } else {
                return title.align || Constants.TOP;
            }
        },

        getTitleLabelGap:function(){
            return TITLE_LABEL_GAP;
        },

        getAxisIndex:function(){
            return this.componentOption.axisIndex;
        },

        //普通的值轴
        _calculateValueNiceDomain:function(minValue, maxValue, fixedMin, fixedMax, zoomFix){

            var fromZero = this.type == Constants.VALUE_AXIS_COMPONENT;

            var axisOption = this.componentOption;

            minValue = fromZero ? Math.min(0, minValue) : minValue;

            minValue = BaseUtils.hasDefined(fixedMin) ? fixedMin : minValue;
            maxValue = BaseUtils.hasDefined(fixedMax) ? fixedMax : maxValue;

            // if any exceeded min, adjust max to min + 100
            if(minValue >= maxValue){
                maxValue = minValue + MIN_MAX_GAP * (this.type === Constants.DATE_AXIS_COMPONENT ? 1000 : 1);
            }

            var tickInterval = axisOption.tickInterval || this._linearTickInterval(minValue, maxValue);

            var domain = this._linearNiceDomain(minValue, maxValue, tickInterval);
            minValue = BaseUtils.hasDefined(fixedMin) ? fixedMin : domain[0];
            maxValue = BaseUtils.hasDefined(fixedMax) ? fixedMax : domain[1];

            if(minValue >= maxValue){
                maxValue = minValue + MIN_MAX_GAP * (this.type === Constants.DATE_AXIS_COMPONENT ? 1000 : 1);
            }

            var start = domain[0];

            if(BaseUtils.hasDefined(fixedMin)){

                // ceil( (fixedMin - start) / tickInterval ) * tickInterval
                var diff = BaseUtils.accMul(
                    Math.ceil(
                        BaseUtils.accDiv(BaseUtils.accAdd(fixedMin, -start), tickInterval)
                    ),
                    tickInterval
                );

                start = BaseUtils.accAdd(start, diff);
            }

            this.valueList = [];

            for(; start <= maxValue; start = BaseUtils.accAdd(start, tickInterval)){
                this.valueList.push(start);
            }

            this.lastScale = this.scale && this.scale.copy();

            this.scale = this.scale ?
                this.scale.domain([minValue, maxValue]) : d3.scale.linear().domain([minValue, maxValue]);

            return {minValue: minValue, maxValue: maxValue};
        },

        _linearTickInterval:function(minValue, maxValue, m){

            m = m || this._getDefaultTickCount();
            var span = maxValue - minValue;
            var step = Math.pow(10, Math.floor(Math.log(span / m) / Math.LN10));
            var err = m / span * step;

            if (err <= .15) step *= 10; else if (err <= .35) step *= 5; else if (err <= .75) step *= 2;

            return step;
        },

        _linearNiceDomain:function(minValue, maxValue, tickInterval){

            minValue = BaseUtils.accMul(Math.floor(minValue / tickInterval), tickInterval);

            maxValue = BaseUtils.accMul(Math.ceil(maxValue / tickInterval), tickInterval);

            return [minValue, maxValue];
        },

        _getDefaultTickCount:function(){
            return this.option.chartType == Constants.RADAR_CHART ? RADAR_TICK_COUNT : TICK_COUNT;
        },

        _isSeriesVisible:function(sery){
            var queryList = [
                sery,
                this.option.plotOptions[sery.type],
                this.option.plotOptions
            ];
            return BaseUtils.pick(QueryUtils.queryList(queryList, 'visible'), true);
        },

        //gauge,radar的时候不用画
        getRender:function(){

            var chartType = this.option.chartType;

            if (chartType === Constants.GAUGE_CHART
                || this.option.plotOptions.force) {
                return null;
            }

            return this.render;

        },

        // Polar's

        getPolarInitPoint: function () {
            // begin from 0 at present
            return BaseUtils.getArcPoint(this.polar.radius, 0);
        },

        getRadiusPlotBands:function(){

            var plotBands = this._getPlotBands();

            var result = [];

            var self = this;

            plotBands.forEach(function(d){
                result.push({
                    path: self._getRadiusPlotBandsPath(d.from, d.to),
                    color: d.color
                });
            });

            return result;
        },

        _getRadiusPlotBandsPath: function (from, to) {

            var shape = this.polar.shape;

            if (shape === Constants.POLYGON_RADAR) {
                return this._getRadiusGridPath(Math.min(from, to)) + this._getRadiusGridPath(Math.max(from, to), true)
            } else {
                var arc = d3.svg.arc().startAngle(0).endAngle(2 * Math.PI);
                return arc.innerRadius(this.scale(Math.min(from, to)))
                    .outerRadius(this.scale(Math.max(from, to)))();
            }

        },

        getPlotLines:function(){

            var plotLines = this.componentOption.plotLines || [];
            var self = this;

            var result = [];
            plotLines.forEach(function(d){

                var text, style, align;
                if(d.label && d.label.text && d.label.style){
                    text = d.label.text;
                    style = d.label.style;
                    align = d.label.align;
                }

                result.push({
                    color: d.color,
                    value: d.value,
                    width: d.width,
                    dataArray:Constants.DASH_TYPE[d.dashStyle],
                    text:text,
                    baseY:-self.scale(d.value),
                    textAnchor:align == Constants.LEFT ? 'end' : 'start',
                    style:style
                });
            });

            return result;
        },

        //两个点的时候多边形计算有问题
        _getClipSeriesPath:function(value){
            var radiusScale = this.scale;
            var categories = this.polar.angleAxis.scale.domain();
            var shape = this.polar.shape;
            if (shape === Constants.POLYGON_RADAR && categories.length <= 2) {
                var arc = d3.svg.arc().startAngle(0).endAngle(2 * Math.PI).innerRadius(0);
                return arc.outerRadius(radiusScale(value))();
            }else{
                return this._getRadiusGridPath(value);
            }
        },

        // radius grids are circles
        _getRadiusGridPath: function (value, reversed) {

            var data = this._getRadiusGridData(value, reversed);

            return this._getRadiusGridPathByData(data);
        },

        _getRadiusGridData: function (value, reversed, scale) {

            var radiusScale = scale || this.scale;
            var angleAxis = this.polar.angleAxis;

            var shape = this.polar.shape;

            if (shape === Constants.POLYGON_RADAR) {

                var points = [];

                var cateScale = angleAxis.scale;
                var categories = cateScale.domain();

                categories.forEach(function(category){

                    var radian = cateScale(category) * angleAxis.piece;

                    var r = radiusScale(value);

                    points.push(BaseUtils.getArcPoint(r, radian));

                });

                if (reversed) {
                    points.reverse();
                }

                return points;

            } else {
                return radiusScale(value);
            }
        },

        _getRadiusGridPathByData: function(data) {

            if(BaseUtils.isArray(data)){

                var path = "";

                if(data.length){
                    for(var i = 0, count = data.length; i < count; i++){

                        var mOrl = i ? 'L' : 'M';

                        path += (mOrl + BaseUtils.dealFloatPrecision(data[i][0]) + "," + BaseUtils.dealFloatPrecision(data[i][1]));
                    }

                    path += 'Z';
                }

                return path;

            }else{

                var arc = d3.svg.arc().startAngle(0).endAngle(2 * Math.PI).innerRadius(0);

                return arc.outerRadius(data)();
            }

        },

        getAngleGridLineData: function () {

            var points = [];

            var angleAxis = this.polar.angleAxis;
            var categories = angleAxis.scale.domain();
            var self = this;

            categories.forEach(function(category){

                var radian = angleAxis.scale(category) * angleAxis.piece;

                var r = self.polar.radius;

                points.push(BaseUtils.getArcPoint(r, radian));

            });

            points = points.length ? points : [BaseUtils.getArcPoint(this.polar.radius, 0)];

            return points;
        },

        _testRadius:function(radius, testBounds){

            for(var i = 0, count = this.tickData.length; i < count; i++){

                var tick = this.tickData[i];
                var labelBounds = this._getCateLabelBounds(radius, tick);

                if(!BaseUtils.containsRect(testBounds, labelBounds)){
                    return false;
                }

            }
        },

        _getCateLabelBounds:function(radius, cateTick){

            var category = cateTick.tickValue;
            var tickDim = cateTick.tickDim;
            var domain = this.scale.domain();
            var index = domain.indexOf(category);
            var arcPoint = BaseUtils.getArcPoint(radius + PADDING_GAP, index * this.piece);
            var pos;

            var position = this._getPolarPosition(category);

            switch (position){

                case TOP:

                    pos = {
                        x:-tickDim.width/2,
                        y:-radius - tickDim.height * 0.65 - PADDING_GAP
                    };

                    break;

                case RIGHT:

                    pos = {
                        x:arcPoint[0],
                        y:arcPoint[1] - tickDim.height/2
                    };

                    break;

                case BOTTOM:

                    pos = {
                        x:-tickDim.width/2,
                        y:radius + PADDING_GAP
                    };

                    break;

                case LEFT:

                    pos = {
                        x:arcPoint[0] - tickDim.width,
                        y:arcPoint[1] - tickDim.height/2
                    };

                    break;
            }

            cateTick.tickPos = pos;
            return BaseUtils.makeBounds(pos, tickDim);
        },

        _getPolarPosition:function(category){

            var domain = this.scale.domain();
            var index = domain.indexOf(category);
            var midIndex = domain.length / 2;

            if(index == 0){
                return TOP;
            }else if(index > 0 && index < midIndex){
                return RIGHT;
            }else if(index == midIndex){
                return BOTTOM;
            }else if(index > midIndex){
                return LEFT;
            }

        },

        _findNiceRadius:function(testBounds){

            var tmpBounds = [
                - testBounds.y,
                testBounds.width - testBounds.x,
                testBounds.height + testBounds.y,
                - testBounds.x
            ];

            var minRadius = Math.min.apply(null, tmpBounds);

            var domain = this.scale.domain();
            var self = this;

            this.tickData.forEach(function(cateTick){
                if(cateTick.tickContent){

                    var category = cateTick.tickValue;
                    var tickDim = cateTick.tickDim;

                    var index = domain.indexOf(category);
                    var position = self._getPolarPosition(category);

                    var radius;
                    switch (position) {
                        case TOP:
                            radius = tmpBounds[0] - tickDim.height;
                            break;
                        case RIGHT:
                            radius = (tmpBounds[1] - tickDim.width) / Math.abs(Math.sin(index * self.piece));
                            break;
                        case BOTTOM:
                            radius = tmpBounds[2] - tickDim.height;
                            break;
                        case LEFT:
                            radius = (tmpBounds[3] - tickDim.width) / Math.abs(Math.sin(index * self.piece));
                            break;
                        default:
                    }

                    minRadius = Math.min(minRadius, radius);
                }
            });

            return minRadius - PADDING_GAP;
        },

        getIndexByPosition: function (pos) {
            var plotBounds = this.getPlotBounds();
            var scale = this.scale;
            var startX = scale(
                this.isAxisReversed() ?
                    scale.domain()[scale.domain().length - 1] :
                    scale.domain()[0]
            );

            var x;

            if (this.isHorizontal()) {
                x = pos[0] - plotBounds.x - startX;
            } else {
                x = pos[1] - plotBounds.y - startX;
            }

            var index;
            switch (this.type) {
                case Constants.DATE_AXIS_COMPONENT:
                    index = BaseUtils.date2int(scale.invert(x));
                    break;
                default:
                    index = scale.invert(x);
            }

            index = Math.round(index);
            return index;
        }
    });

    //todo to be deleted
    // function BaseAxis(vanchart, option, componentType){
    //     Base.call(this, vanchart, option, componentType);
    //     this.scale = null;
    //     this.lastScale = null;
    //
    //     this.tickLabelLength = 0;
    //
    //     this.tickData = [];
    //     this.minorTickData = [];
    //     this.usedTickData = [];
    //
    //     this.polar = null;
    // }

    BaseAxis.addInitHook(BaseAxis.prototype.init);

    return BaseAxis;
});
/**
 * Created by eason on 15/5/18.
 * 分类轴的定义
 */
define('component/CategoryAxis',['require','./Base','./BaseAxis','../utils/BaseUtils','../Constants','../ComponentLibrary'],function(require){
    var Base = require('./Base');
    var BaseAxis = require('./BaseAxis');
    var BaseUtils = require('../utils/BaseUtils');
    var Constants = require('../Constants');
    
    var CategoryAxis = BaseAxis.extend({

        type:Constants.CATEGORY_AXIS_COMPONENT,
        
        init: function () {
            this.isRangePoints = null;
            this.piece = null;
            this.highlightType = null;
        },

        initAttributesWithSeries:function(){

            var axisOption = this.componentOption;

            var series = this.vanchart.series;
            var stored = {};
            var isBaseAxis = this.isBaseAxis;

            var categories = axisOption.categories || [];

            categories.forEach(function(category){
                stored[category] = true;
            });

            this.isRangePoints = true;
            this.highlightType = 'line';

            for(var i = 0, len = series.length; i < len; i++){

                var sery = series[i];

                var byAxis = sery[this.componentType];

                if(byAxis == this){
                    var points = sery.originalPoints || sery.points;
                    points.forEach(function(point){
                        if (point.isNull) {
                            return;
                        }
                        var label =  isBaseAxis ? point.category : point.value;
                        if(!BaseUtils.isNull(label) && !stored[label]){
                            categories.push(label);
                            stored[label] = true;
                        }
                    });
                    if (!this._isSeriesVisible(sery)) {
                        continue;
                    }
                    if (sery.type !== Constants.AREA_CHART) {
                        this.isRangePoints = false;
                    }
                }
            }
            
            this.categories = categories;

            this.scale = d3.scale.ordinal().domain(this.categories);

            switch(this.componentType) {
                case Constants.ANGLE_AXIS_COMPONENT:
                    this.isRangePoints = true;
                    this.piece = (Math.PI * 2) / Math.max(categories.length, 1);
                    break;
                default:
            }

            this._updateOriginTickData();
        },

        updateCategories:function(newCategories){

            this.categories = newCategories;

            this.scale.domain(newCategories);

            this._updateOriginTickData();
        },

        _updateIndex:function(start, end){
            this.componentOption.startIndex = start;
            this.componentOption.endIndex = end;
        },

        getCategoryCount:function(){
            return this.categories.length;
        },

        indexOfLabel:function(label){
            return BaseUtils.indexInArray(this.categories, label);
        },

        getTickLength:function(){

            var domain = this.scale.domain();

            var range = this.scale.rangeExtent();

            var cateLength = Math.abs(range[1] - range[0]);

            if(this.isRangePoints && domain.length <= 1){
                return cateLength;
            }

            return  this.isRangePoints ? cateLength / (domain.length - 1) : this.scale.rangeBand();
        },

        _updateRange:function(){
            this.updateAxisScale(this._getStartIndex(), this._getEndIndex());
        },

        getValueFromData:function(datum, dIndex){

            var categories = this.componentOption.categories;

            var valueIndex = this.isBaseAxis ? 0 : 1;

            var map = {
                'xAxis': 'x',
                'yAxis': 'y',
                'angleAxis': 'x',
                'radiusAxis': 'y',
                'gaugeAxis': 'y'
            };
            var valueKey = map[this.componentType];

            var cateory = BaseUtils.isArray(datum) ? datum[valueIndex] : datum[valueKey];

            return BaseUtils.hasDefined(cateory) ? cateory : categories[dIndex];
        },

        //考虑tickFormat的作用
        _getTickValues:function(){
            return this.scale.domain();
        },

        getCategories:function(){
            return this.scale.domain();
        },

        axisZoom:function(downPos, upPos){

            var startPos, endPos;

            var plotBounds = this.vanchart.getPlotBounds();

            //坐标轴是横向的
            if(this.isHorizontal()){
                startPos = Math.min(downPos[0], upPos[0]) - plotBounds.x;
                endPos = Math.max(downPos[0], upPos[0]) - plotBounds.x;
            }else{
                startPos = Math.min(downPos[1], upPos[1]) - plotBounds.y;
                endPos = Math.max(downPos[1], upPos[1]) - plotBounds.y;
            }

            var domain = this.scale.domain();
            var range = this.scale.rangeExtent();

            range = this._getRangeWithMinMax(range[0], range[1]);

            var tmpScale = d3.scale.quantize().domain(range).range(domain);

            var start = BaseUtils.indexInArray(this.categories, tmpScale(startPos));
            var end = BaseUtils.indexInArray(this.categories, tmpScale(endPos));

            this.updateAxisScale(Math.min(start, end), Math.max(start, end));
        },

        updateAxisScale:function(start, end){
            var domain = this.scale.domain();

            if (start == -1 || end == -1) {
                return;
            }

            var range;
            if (this.componentType === Constants.ANGLE_AXIS_COMPONENT) {
                range = [0, this.categories.length - 1];
            } else {

                var tmp = [];

                for (var index = start; index <= end; index++) {
                    tmp.push(domain[index]);
                }

                this._updateIndex(start, end);

                var plotRange = this._getRange();

                var rangeBands;
                if (this.isRangePoints) {
                    rangeBands = Math.abs(plotRange[0] - plotRange[1]) / Math.max(tmp.length - 1, 1);
                } else {
                    rangeBands = Math.abs(plotRange[0] - plotRange[1]) / tmp.length
                }

                var minValue = Math.min(plotRange[0], plotRange[1]);
                var maxValue = Math.max(plotRange[0], plotRange[1]);
                var t_s = start;
                var t_e = end;
                if (this.isAxisReversed()) {
                    var totalCount = this.categories.length - 1;
                    t_s = Math.min(totalCount - start, totalCount - end);
                    t_e = Math.max(totalCount - start, totalCount - end);
                }

                if (this.isHorizontal()) {
                    minValue -= t_s * rangeBands;
                    maxValue += (this.categories.length - t_e - 1) * rangeBands;
                } else {
                    minValue -= (this.categories.length - t_e - 1) * rangeBands;
                    maxValue += t_s * rangeBands;
                }

                range = this._getRangeWithMinMax(minValue, maxValue);
            }

            this.isRangePoints ? this.scale.rangePoints(range) : this.scale.rangeBands(range);

            this._updateOriginTickData();
            this._calculateTickData();

        },

        _getRangeWithMinMax:function(min, max){
            var reversed = this.isAxisReversed();

            if(this.isHorizontal()){
                return reversed ? [max, min] : [min, max];
            }else{
                return reversed ? [min, max] : [max, min];
            }
        },

        _initZoomStatus:function(){
            var zoom = this.vanchart.getComponent(Constants.ZOOM_COMPONENT);
            if(zoom && zoom.zoomToolEnabled() && BaseUtils.isSupportSVG()){

                if(this.vanchart.isInitOrRestoreState()){

                    var start = 0;
                    var end = this.categories.length - 1;

                    var zoomTool = zoom.componentOption.zoomTool;

                    if(zoomTool.from && BaseUtils.indexInArray(this.categories, zoomTool.from) != -1){
                        start = BaseUtils.indexInArray(this.categories, zoomTool.from);
                    }

                    if(zoomTool.to && BaseUtils.indexInArray(this.categories, zoomTool.to) != -1){
                        end = BaseUtils.indexInArray(this.categories, zoomTool.to);
                    }

                    this.updateAxisScale(Math.min(start, end), Math.max(start, end));

                }else{
                    this.updateAxisScale(this._getStartIndex(), this._getEndIndex());
                }
            }
        },

        getHighlightType: function () {
            return this.highlightType;
        },

        getIndexByPosition: function (pos) {

            switch (this.componentType) {
                case Constants.X_AXIS_COMPONENT:
                case Constants.Y_AXIS_COMPONENT:

                    return this._getIndexByXYCoordinate(pos);

                case Constants.ANGLE_AXIS_COMPONENT:

                    return this._getIndexByPolarCoordinate(pos);
            }

        },

        _getIndexByPolarCoordinate: function (pos) {
            var center = this.polar.center;
            var r = this.polar.radius;
            var isReversed = this.isAxisReversed();

            var x = pos[0]-center[0];
            var y = center[1]-pos[1];

            if ((x*x + y*y) > r*r) {
                return -1;
            }

            var arc = BaseUtils.getArcByPoint(x, y);

            var index;
            var categories = this.getCategories();
            if (categories.length > 1) {
                var unitLength = 2 * Math.PI / categories.length;
                index = isReversed ? categories.length - 1 - arc / unitLength : arc / unitLength;
            } else {
                index = 0;
            }

            index = Math.round(index);

            index = index % categories.length;

            return index;
        },

        _getIndexByXYCoordinate: function (pos) {
            var plotBounds = this.getPlotBounds();
            var scale = this.scale;
            var isHorizontal = this.isHorizontal();
            var isReversed = this.isAxisReversed() ^ !isHorizontal;

            var startX = scale(
                isReversed ?
                    scale.domain()[scale.domain().length - 1] :
                    scale.domain()[0]
            );

            var x;

            if (isHorizontal) {
                x = pos[0] - plotBounds.x - startX;
            } else {
                x = pos[1] - plotBounds.y - startX;
            }

            var index;
            var categories = this.getCategories();
            if (categories.length > 1) {
                var unitLength = Math.abs(scale(scale.domain()[1]) - scale(scale.domain()[0]));
                index = isReversed ? categories.length - 1 - x / unitLength : x / unitLength;
            } else {
                index = 0;
            }

            if (this.getHighlightType() === 'line' && this.isRangePoints) {
                index = Math.round(index);
            } else {
                index = isReversed ? Math.ceil(index) : Math.floor(index);
            }

            return index;
        },

        _getBandByIndex: function (index){
            switch (this.componentType) {
                case Constants.X_AXIS_COMPONENT:
                case Constants.Y_AXIS_COMPONENT:

                    return this._getXYBandByIndex(index);

                case Constants.ANGLE_AXIS_COMPONENT:

                    return this._getPolarBandByIndex(index);
            }
        },

        _getPolarBandByIndex: function (index) {
            var scale = this.scale;
            var domain = scale.domain();

            var r = this.polar.radius;
            var center = this.polar.center;
            var radian = scale(domain[index]) / domain.length * 2 * Math.PI;

            var band;
            if (this.getHighlightType() === 'line') {
                var point = BaseUtils.getArcPoint(r, radian);

                band = {
                    x: point[0],
                    y: point[1]
                };
            } else {
                var halfSize = 1 / domain.length * 2 * Math.PI * 0.5;
                var startRadian = radian - halfSize;
                var endRadian = radian + halfSize;

                var arc = d3.svg.arc()
                    .innerRadius(0)
                    .outerRadius(r)
                    .startAngle(startRadian)
                    .endAngle(endRadian);

                band = {
                    d: arc()
                }

            }

            return band;
        },

        _getXYBandByIndex: function (index) {
            var plotBounds = this.getPlotBounds();
            var ticks = this._getTickValuesWithEndValue();
            var scale = this.scale;
            var domain = scale.domain();
            var isHorizontal = this.isHorizontal();
            var isReversed = this.isAxisReversed() ^ !isHorizontal;
            var from;
            var to;

            from = scale(domain[index]);

            var boundary = isHorizontal ? plotBounds.width : plotBounds.height;

            switch (this.getHighlightType()) {
                case 'band':
                    if (isReversed) {
                        if (index === 0) {
                            to = boundary;
                        } else {
                            to = scale(domain[index - 1]);
                        }
                    } else {
                        if (index + 1 === ticks.length) {
                            to = boundary;
                        } else {
                            to = scale(domain[index + 1]);
                        }
                    }
                    break;
                case 'line':
                default:
                    var det = this.isRangePoints ? 0 : scale.rangeBand()/2;
                    from += det;
                    to = from;
            }

            var band;

            if (isHorizontal) {
                band = {
                    x: plotBounds.x + from,
                    y: plotBounds.y,
                    width: Math.abs(to - from),
                    height: plotBounds.height
                };
            } else {
                band = {
                    x: plotBounds.x,
                    y: plotBounds.y + from,
                    width: plotBounds.width,
                    height: Math.abs(to - from)
                }
            }

            return band;
        },

        _getBandByPosition: function (pos) {
            var index = this.getIndexByPosition(pos);
            return this._getBandByIndex(index);
        }
    });
    
    // function (vanchart, option, axisOption, componentType){
    //     BaseAxis.call(this, vanchart, option, componentType);
    //     this.isRangePoints = false;
    //     this.piece = null;
    //     this.refresh(option, axisOption);
    // }
    CategoryAxis.addInitHook(CategoryAxis.prototype.init);

    require('../ComponentLibrary').register(Constants.CATEGORY_AXIS_COMPONENT, CategoryAxis);
    return CategoryAxis;
});
/**
 * Created by eason on 15/5/18.
 * 值轴的定义
 */
define('component/ValueAxis',['require','./Base','./BaseAxis','../utils/BaseUtils','../utils/QueryUtils','../Constants','../Constants','../ComponentLibrary'],function(require){
    var Base = require('./Base');
    var BaseAxis = require('./BaseAxis');
    var BaseUtils = require('../utils/BaseUtils');
    var QueryUtils = require('../utils/QueryUtils');
    var Constants = require('../Constants');
    var Constants = require('../Constants');

    var ValueAxis = BaseAxis.extend({

        type:Constants.VALUE_AXIS_COMPONENT,

        initAttributesWithSeries:function(){

            this._hasInited = true;

            //确定是不是byPercent
            var series = this.vanchart.series;
            this.byPercent = false;
            for(var i = 0,len = series.length; i < len && !this.byPercent; i++){
                var sery = series[i];

                var byAxis = sery[this.componentType];

                if(byAxis == this && sery.visible){
                    this.byPercent = sery.stackByPercent && !this.isBaseAxis;
                }
            }
            
            var minMax = this._calculateMinMaxValue();

            var axisOption = this.componentOption;

            this.originalDomain =
                this._calculateNiceDomain(minMax.minValue, minMax.maxValue, axisOption.min, axisOption.max);

            this._updateOriginTickData();
        },

        _updateDomainWhenSizeFixed:function(){

            var maxRadius = this.getMaxBubbleRadius();

            if(maxRadius && this.type == Constants.VALUE_AXIS_COMPONENT && this._hasInited){

                this._hasInited = false;

                var scale = this.scale;

                var domain = scale.domain();
                var range = scale.range();

                var minMax = this._calculateMinMaxValue();

                var maxRadiusNumber = Math.abs(maxRadius * (domain[0] - domain[1])/(range[1] - range[0]));

                var min = minMax.minValue - maxRadiusNumber;
                var max = minMax.maxValue + maxRadiusNumber;

                var axisOption = this.componentOption;

                this.originalDomain = this._calculateNiceDomain(min, max, axisOption.min, axisOption.max);

                this._updateOriginTickData();
            }

        },

        _calculateNiceDomain:function(minValue, maxValue, fixedMin, fixedMax, zoomFix){

            var axisOption = this.componentOption;

            if(axisOption.log && axisOption.log != 1){
                return this._calculateLogNiceDomain(minValue, maxValue);
            }else if(this.byPercent){
                return this._calculatePercentValueDomain();
            }else{
                return this._calculateValueNiceDomain(minValue, maxValue, fixedMin, fixedMax, zoomFix);
            }

        },

        _calculateLogNiceDomain:function(minValue, maxValue, ignoreMinMax){
            var axisOption = this.componentOption;

            var logBase = axisOption.log;

            var tickInterval = parseInt(BaseUtils.pick(axisOption.tickInterval, 1));

            this.valueList = [];

            minValue = minValue >= 1 ? 1 : minValue;
            minValue = minValue <= 0 ? 1 : minValue;

            minValue = ignoreMinMax ? minValue : BaseUtils.pick(axisOption.min, minValue);
            maxValue = ignoreMinMax ? maxValue : BaseUtils.pick(axisOption.max, maxValue);

            minValue = Math.pow(logBase, Math.floor(BaseUtils.log(logBase, minValue)));
            maxValue = Math.pow(logBase, Math.ceil(BaseUtils.log(logBase, maxValue)));


            this.scale = this.scale ? this.scale.domain([minValue, maxValue])
                : d3.scale.log().base(logBase).domain([minValue, maxValue]);

            var i = 0;
            while(minValue * Math.pow(logBase, i) <= maxValue){
                this.valueList.push(minValue * Math.pow(logBase, i));
                i += tickInterval;
            }

            return {minValue: minValue, maxValue: maxValue};
        },

        _calculatePercentValueDomain:function(){

            var axisOption = this.componentOption;

            var min = BaseUtils.pick(axisOption.min, 0);

            var max = BaseUtils.pick(axisOption.max, 1);

            var interval = BaseUtils.pick(axisOption.tickInterval, 0.25);

            this.valueList = [];

            for(var start = min; start <= max; start = BaseUtils.accAdd(start, interval)){
                this.valueList.push(start);
            }

            this.scale = this.scale ?
                this.scale.domain([min, max]) : d3.scale.linear().domain([min, max]);

            return {minValue: min, maxValue: max};
        },

        //从数据中计算最大最小值
        _calculateMinMaxValue:function(){

            var minValue = Number.MAX_VALUE;
            var maxValue = -minValue;
            var emptyData = true;

            var series = this.vanchart.series;
            var dataMap = {};

            for(var i = 0, len = series.length; i < len; i++){
                var sery = series[i];

                var byAxis = sery[this.componentType];

                if(byAxis == this && sery.visible){
                    this._getSeriesValue(dataMap, sery);
                }
            }

            for(var key in dataMap){
                var data = dataMap[key];
                for(var j = 0, dataCount = data.length; j < dataCount; j++){
                    if(!isNaN(data[j]) && !(this.componentOption.log && data[j] <= 0)){
                        minValue = Math.min(minValue, data[j]);
                        maxValue = Math.max(maxValue, data[j]);

                        emptyData = false;
                    }
                }
            }

            if(emptyData){
                minValue = 0;
                maxValue = 100;
            }

            return {
                minValue:minValue,
                maxValue:maxValue
            };
        },

        //获取系列的值，如果是堆积的话获取系列的和
        _getSeriesValue:function(dataMap, sery){

            var seriesName = sery.name || '';

            var isBaseAxis = this.isBaseAxis;

            if(BaseUtils.hasNotDefined(sery.stack) || isBaseAxis){
                dataMap[seriesName] = dataMap[seriesName] || [];

                sery.points.forEach(function(point){
                    dataMap[seriesName].push(isBaseAxis ? point.category : point.value);
                });

            }else{
                var PK = sery.stack + sery.type + 'STACK_POSITIVE';
                var NK = sery.stack + sery.type + 'STACK_NEGATIVE';
                dataMap[PK] = dataMap[PK] || [];
                dataMap[NK] = dataMap[NK] || [];

                sery.points.forEach(function(point, i){

                    var value = isBaseAxis ? point.category : point.value;

                    if(value > 0){
                        if(dataMap[PK][i] != null && dataMap[PK][i] != undefined){
                            dataMap[PK][i] += value;
                        }else{
                            dataMap[PK][i] = value;
                        }
                    }else{
                        if(dataMap[NK][i] != null && dataMap[NK][i] != undefined){
                            dataMap[NK][i] += value;
                        }else{
                            dataMap[NK][i] = value;
                        }
                    }

                });
            }
        },

        //'-'符号表示空值
        getValueFromData:function(datum){
            var valueIndex = this.componentType == Constants.X_AXIS_COMPONENT ? 0 : 1;
            var valueKey = this.componentType == Constants.X_AXIS_COMPONENT ? 'x' : 'y';

            var value = BaseUtils.isArray(datum) ? datum[valueIndex] : datum[valueKey];

            value = BaseUtils.pick(value, datum);

            value = +value;
            return isNaN(value) ? '-' : value;
        },

        //考虑有正负值的时候的0值对齐的功能
        getStartPos:function(){
            return this.scale(this.getStartPosValue());
        },

        getStartPosValue:function(){

            var axisOption = this.componentOption;

            return axisOption.log && axisOption.log != 1 ? Number.MIN_VALUE : 0;
        },

        getOriginalDomain: function () {
            return this.originalDomain;
        },

        //考虑tickFormat的作用
        _getTickValues:function(){
            return this.valueList;
        },

        _getTickValuesWithEndValue:function(){

            var result = BaseUtils.clone(this.valueList);

            var max = this.scale.domain()[1];

            if(result.length && result[result.length - 1] < max){
                result.push(max);
            }

            return result;
        },

        axisZoom:function(downPos, upPos){

            var startPos, endPos;

            var plotBounds = this.vanchart.getPlotBounds();

            //坐标轴是横向的
            if(this.isHorizontal()){
                startPos = Math.min(downPos[0], upPos[0]) - plotBounds.x;
                endPos = Math.max(downPos[0], upPos[0]) - plotBounds.x;

                startPos = Math.max(startPos, 0);
                endPos = Math.min(endPos, plotBounds.width);
            }else{
                startPos = Math.min(downPos[1], upPos[1]) - plotBounds.y;
                endPos = Math.max(downPos[1], upPos[1]) - plotBounds.y;

                startPos = Math.max(startPos, 0);
                endPos = Math.min(endPos, plotBounds.height);
            }

            var startValue = this.scale.invert(startPos);
            var endValue = this.scale.invert(endPos);

            this.updateAxisScale(Math.min(startValue, endValue), Math.max(startValue, endValue), true);
        },

        updateAxisScale:function(min, max, zoomFix){

            var cfg = this.componentOption;

            //值轴为底轴的时候,固定最大最小值才有效
            var minMax = this._calculateNiceDomain(min, max, this.isBaseAxis ? min : cfg.min, this.isBaseAxis ? max : cfg.max, zoomFix && this.isBaseAxis);

            if(this.isBaseAxis){
                this.componentOption.min = minMax.minValue;
                this.componentOption.max = minMax.maxValue;
            }

            this._updateOriginTickData();

            this._calculateTickData();
        },

        _initZoomStatus:function(){
            var zoom = this.vanchart.getComponent(Constants.ZOOM_COMPONENT);
            if(zoom && zoom.zoomToolEnabled() && BaseUtils.isSupportSVG() && this.isBaseAxis){

                if(this.vanchart.isInitOrRestoreState()){

                    var revisedDomain = zoom.getRevisedDomain();

                    var domain = this.scale.domain();

                    var from = domain[0];

                    var to = domain[1];

                    if(revisedDomain.from){
                        from = parseFloat(revisedDomain.from);
                    }

                    if(revisedDomain.to){
                        to = parseFloat(revisedDomain.to);
                    }

                    this.updateAxisScale(from, to);
                }

            }
        }
    });

    require('../ComponentLibrary').register(Constants.VALUE_AXIS_COMPONENT, ValueAxis);
    return ValueAxis;
});
/**
 * Created by eason on 15/11/2.
 */
define('component/DateAxis',['require','./Base','./BaseAxis','../utils/BaseUtils','../Constants','../utils/Formatter','../ComponentLibrary'],function(require){

    var Base = require('./Base');
    var BaseAxis = require('./BaseAxis');
    var BaseUtils = require('../utils/BaseUtils');
    var Constants = require('../Constants');
    var Formatter = require('../utils/Formatter');
    var TICK_COUNT = 5;

    var DAY = 1000 * 60 * 60 * 24;
    var MONTH = DAY * 31;
    var YEAR = 365 * MONTH;

    var DateAxis = BaseAxis.extend({

        type:Constants.DATE_AXIS_COMPONENT,

        initAttributesWithSeries:function(){

            this.scale = d3.time.scale();

            var minMax = this._calculateMinMaxValue();

            var min = minMax.minValue;
            var max = minMax.maxValue;

            var cfg = this.componentOption;

            var domain = this._calculateValueNiceDomain(min, max, cfg.min, cfg.max);

            min = BaseUtils.int2date(domain.minValue);

            max = BaseUtils.int2date(domain.maxValue);

            this.originalDomain = {minValue:min, maxValue:max};

            this.scale = this.scale ?
                this.scale.domain([min, max]) : d3.time.scale().domain([min, max]);

            this._calculateDateFormat();

            this._updateOriginTickData();
        },

        getOriginalDomain: function () {
            return this.originalDomain;
        },

        _calculateDateFormat:function(){
            var tickInterval = this._getTickInterval();

            var format = 'Dyyyy-MM-dd';

            if(tickInterval < DAY){
                format = 'Dyyyy-M-d H:mm'
            }else if(tickInterval < MONTH){
                format = 'Dyyyy-M-d'
            }else{
                format = 'Dyyyy-MM'
            }

            this.dateFormat = format;
        },

        _getTickContent:function(tick, formatter){

            if(!formatter || formatter == "function(){return arguments[0]}"){
                //todo 换成d3的格式
                var tmpFormat = this.dateFormat;
                formatter = function(){return window.FR ? FR.contentFormat(arguments[0], tmpFormat) : arguments[0]}
            }

            return Formatter.format(tick, formatter)
        },

        _getTickValues:function(){
            var result = [];
            this.valueList.forEach(function(date){
                result.push(BaseUtils.int2date(date));
            });

            return result;
        },

        _calculateMinMaxValue:function(){

            var minValue = Math.ceil(Number.MAX_VALUE);
            var maxValue = -minValue;

            var series = this.vanchart.series;
            var hasData = false;

            for(var i = 0, len = series.length; i < len; i++){
                var sery = series[i];
                var byAxis = sery[this.componentType];
                if(byAxis == this && this._isSeriesVisible(sery)){
                    var data = sery.seriesOption.data;
                    for(var i = 0,len = data.length; i < len; i++){
                        var value = this.getValueFromData(data[i]);

                        if(value.getTime){
                            hasData = true;
                            value = BaseUtils.date2int(value);
                            minValue = Math.min(minValue, value);
                            maxValue = Math.max(maxValue, value);
                        }

                    }
                }
            }

            if(!hasData){
                minValue = maxValue = (new Date()).getTime();
            }

            maxValue = minValue >= maxValue ? minValue + 1000 : maxValue;

            return {
                minValue:minValue,
                maxValue:maxValue
            };
        },

        getValueFromData:function(datum){
            var valueIndex = this.componentType == Constants.X_AXIS_COMPONENT ? 0 : 1;
            var valueKey = this.componentType == Constants.X_AXIS_COMPONENT ? 'x' : 'y';

            var value = BaseUtils.isArray(datum) ? datum[valueIndex] : datum[valueKey];

            return BaseUtils.object2date(value);
        },

        axisZoom:function(downPos, upPos){

            var startPos, endPos;

            var plotBounds = this.vanchart.getPlotBounds();

            //坐标轴是横向的
            if(this.isHorizontal()){
                startPos = Math.min(downPos[0], upPos[0]) - plotBounds.x;
                endPos = Math.max(downPos[0], upPos[0]) - plotBounds.x;
            }else{
                startPos = Math.min(downPos[1], upPos[1]) - plotBounds.y;
                endPos = Math.max(downPos[1], upPos[1]) - plotBounds.y;
            }

            var startValue = this.scale.invert(startPos);
            var endValue = this.scale.invert(endPos);

            startValue = BaseUtils.date2int(startValue);
            endValue = BaseUtils.date2int(endValue);

            var min = Math.min(startValue, endValue);
            var max = Math.max(startValue, endValue);

            this._updateDomain(min, max, true);
        },

        //min, max是毫秒数
        _updateDomain:function(min, max, zoomFix){

            var domain = this._calculateValueNiceDomain(min, max, min, max, zoomFix);

            var minValue = BaseUtils.int2date(domain.minValue);

            var maxValue = BaseUtils.int2date(domain.maxValue);

            this.scale = this.scale ?
                this.scale.domain([minValue, maxValue]) : d3.time.scale().domain([minValue, maxValue]);

            this._calculateDateFormat();

            this._updateOriginTickData();
        },

        updateAxisScale:function(minValue, maxValue, zoomFix){

            minValue = BaseUtils.date2int(minValue);

            maxValue = BaseUtils.date2int(maxValue);

            this.componentOption.min = minValue;
            this.componentOption.max = maxValue;

            this._updateDomain(minValue, maxValue, zoomFix);
        },

        _initZoomStatus:function(){
            var zoom = this.vanchart.getComponent(Constants.ZOOM_COMPONENT);
            if(zoom && zoom.zoomToolEnabled() && BaseUtils.isSupportSVG() && this.isBaseAxis){
                if(this.vanchart.isInitOrRestoreState()){

                    var revisedDomain = zoom.getRevisedDomain();

                    var domain = this.scale.domain();

                    var from = BaseUtils.date2int(domain[0]);

                    var to = BaseUtils.date2int(domain[1]);

                    if(revisedDomain.from){
                        from = BaseUtils.object2date(revisedDomain.from);
                        from = BaseUtils.date2int(from);
                    }

                    if(revisedDomain.to){
                        to = BaseUtils.object2date(revisedDomain.to);
                        to = BaseUtils.date2int(to);
                    }

                    this._updateDomain(from, to);
                }

            }
        }
    });

    require('../ComponentLibrary').register(Constants.DATE_AXIS_COMPONENT, DateAxis);
    return DateAxis;

});
define('component/Polar',['require','../Constants','../utils/BaseUtils','../utils/QueryUtils','../utils/Formatter','../utils/BoundsManager','./Base','../utils/BezierEasing','../theme/options','../ComponentLibrary'],function(require) {
    var Constants = require('../Constants');
    var BaseUtils = require('../utils/BaseUtils');
    var QueryUtils = require('../utils/QueryUtils');
    var Formatter = require('../utils/Formatter');
    var BoundsManager = require('../utils/BoundsManager');

    var Base = require('./Base');
    var BezierEasing = require('../utils/BezierEasing');
    var Options = require('../theme/options');

    var PADDING_GAP = 10;

    var Polar = Base.extend({
        doLayout: function () {
            var option = this.componentOption;

            var radius = option.radius;
            var center = option.center;

            // keep origin radius (include null)
            // adjust radius by angleAxis later

            if (!center || center.length === 0) {
                var plotBounds = this.vanchart.getPlotBounds();
                center = [
                    plotBounds.width / 2 + plotBounds.x,
                    plotBounds.height / 2 + plotBounds.y
                ];
            }

            this.setRadius(radius);
            this.setCenter(center);

            var queryList = [
                this.option.plotOptions[Constants.RADAR_CHART],
                this.option.plotOptions,
                Options[Constants.RADAR_CHART].plotOptions
            ];
            
            this.shape = this.shape || QueryUtils.queryList(queryList, 'shape');
        },

        /**
         * set polar radius and update radiusAxis scale
         * @param {number|string} radius
         */
        setRadius: function (radius) {
            if (!radius) {
                return;
            }

            this.radius = this._numPctHelper(
                radius,
                Math.min(this.vanchart.chartWidth(), this.vanchart.chartHeight()) / 2
            );

            this.radiusAxis && this.radiusAxis._updateRange();
        },

        /**
         * set polar center
         * @param {number[]|string[]} center
         */
        setCenter: function (center) {
            if (!center) {
                return;
            }

            this.center = [];

            this.center[0] = this._numPctHelper(center[0], this.vanchart.chartWidth());

            this.center[1] = this._numPctHelper(center[1], this.vanchart.chartHeight());
        },

        /**
         * convert number or percent to number value
         * @param {number|string} value
         * @param {number} ref Percentage reference
         * @returns {*}
         * @private
         */
        _numPctHelper: function (value, ref) {
            if (!value || !ref) {
                return null;
            }

            if (!isNaN(value)) {
                return value;
            }

            if (typeof(value) === 'string'
                && value.indexOf('%') != -1) {
                return this._getPercentValue(value, ref);
            }
            return null;
        }
    });
    
    require('../ComponentLibrary').register(Constants.POLAR_COMPONENT, Polar);
    return Polar;
});
/**
 * Created by eason on 16/6/20.
 */
/**
 * Created by eason on 16/6/7.
 * vml下面用path来构造所有的形状
 */

define('utils/PathUtils',['require'],function(require){

    var pathCommand = /([achlmrqstvz])[\x09\x0a\x0b\x0c\x0d\x20\xa0\u1680\u180e\u2000\u2001\u2002\u2003\u2004\u2005\u2006\u2007\u2008\u2009\u200a\u202f\u205f\u3000\u2028\u2029,]*((-?\d*\.?\d*(?:e[\-+]?\d+)?[\x09\x0a\x0b\x0c\x0d\x20\xa0\u1680\u180e\u2000\u2001\u2002\u2003\u2004\u2005\u2006\u2007\u2008\u2009\u200a\u202f\u205f\u3000\u2028\u2029]*,?[\x09\x0a\x0b\x0c\x0d\x20\xa0\u1680\u180e\u2000\u2001\u2002\u2003\u2004\u2005\u2006\u2007\u2008\u2009\u200a\u202f\u205f\u3000\u2028\u2029]*)+)/ig;
    var pathValues = /(-?\d*\.?\d*(?:e[\-+]?\d+)?)[\x09\x0a\x0b\x0c\x0d\x20\xa0\u1680\u180e\u2000\u2001\u2002\u2003\u2004\u2005\u2006\u2007\u2008\u2009\u200a\u202f\u205f\u3000\u2028\u2029]*,?[\x09\x0a\x0b\x0c\x0d\x20\xa0\u1680\u180e\u2000\u2001\u2002\u2003\u2004\u2005\u2006\u2007\u2008\u2009\u200a\u202f\u205f\u3000\u2028\u2029]*/ig;
    var concat = "concat", apply = "apply", upperCase = String.prototype.toUpperCase, mmax = Math.max, math = Math, round = math.round;
    var PI = math.PI, abs = Math.abs, split = "split";
    var p2s = /,?([achlmqrstvxz]),?/gi, val = /-?[^,\s-]+/g;
    var S = " ", E = "", fillString = "fill", zoom = 1;

    function path2vml(path){
        var bites = /([clmz]),?([^clmz]*)/gi;
        var map = {M: "m", L: "l", C: "c", Z: "x", m: "t", l: "r", c: "v", z: "x"};
        var total =  /[ahqstv]/ig, command = pathToAbsolute;
        String(path).match(total) && (command = path2curve);
        total = /[clmz]/g;
        if (command == pathToAbsolute && !String(path).match(total)) {
            var res = String(path).replace(bites, function (all, command, args) {
                var vals = [],
                    isMove = command.toLowerCase() == "m",
                    res = map[command];
                args.replace(val, function (value) {
                    if (isMove && vals.length == 2) {
                        res += vals + map[command == "m" ? "l" : "L"];
                        vals = [];
                    }
                    vals.push(round(value * zoom));
                });
                return res + vals;
            });
            return res;
        }
        var pa = command(path), p, r;
        res = [];
        for (var i = 0, ii = pa.length; i < ii; i++) {
            p = pa[i];
            r = pa[i][0].toLowerCase();
            r == "z" && (r = "x");
            for (var j = 1, jj = p.length; j < jj; j++) {
                r += round(p[j] * zoom) + (j != jj - 1 ? "," : E);
            }
            res.push(r);
        }
        return res.join(S);
    }

    function parsePathString(pathString){

        if (!pathString && typeof pathString != 'string') {
            return null;
        }

        var paramCounts = {a: 7, c: 6, h: 1, l: 2, m: 2, r: 4, q: 4, s: 4, t: 2, v: 1, z: 0},
            data = [];

        String(pathString).replace(pathCommand, function (a, b, c) {
            var params = [],
                name = b.toLowerCase();
            c.replace(pathValues, function (a, b) {
                b && params.push(+b);
            });
            if (name == "m" && params.length > 2) {
                data.push([b][concat](params.splice(0, 2)));
                name = "l";
                b = b == "m" ? "l" : "L";
            }
            if (name == "r") {
                data.push([b][concat](params));
            } else while (params.length >= paramCounts[name]) {
                data.push([b][concat](params.splice(0, paramCounts[name])));
                if (!paramCounts[name]) {
                    break;
                }
            }
        });
        data.toString = path2string;
        return data;
    }

    function path2string(){
        return this.join(",").replace(p2s, "$1");
    }

    function path2curve(path, path2){

        var p = pathToAbsolute(path),
            p2 = path2 && pathToAbsolute(path2),
            attrs = {x: 0, y: 0, bx: 0, by: 0, X: 0, Y: 0, qx: null, qy: null},
            attrs2 = {x: 0, y: 0, bx: 0, by: 0, X: 0, Y: 0, qx: null, qy: null},
            processPath = function (path, d, pcom) {
                var nx, ny, tq = {T:1, Q:1};
                if (!path) {
                    return ["C", d.x, d.y, d.x, d.y, d.x, d.y];
                }
                !(path[0] in tq) && (d.qx = d.qy = null);
                switch (path[0]) {
                    case "M":
                        d.X = path[1];
                        d.Y = path[2];
                        break;
                    case "A":
                        path = ["C"][concat](a2c[apply](0, [d.x, d.y][concat](path.slice(1))));
                        break;
                    case "S":
                        if (pcom == "C" || pcom == "S") { // In "S" case we have to take into account, if the previous command is C/S.
                            nx = d.x * 2 - d.bx;          // And reflect the previous
                            ny = d.y * 2 - d.by;          // command's control point relative to the current point.
                        }
                        else {                            // or some else or nothing
                            nx = d.x;
                            ny = d.y;
                        }
                        path = ["C", nx, ny][concat](path.slice(1));
                        break;
                    case "T":
                        if (pcom == "Q" || pcom == "T") { // In "T" case we have to take into account, if the previous command is Q/T.
                            d.qx = d.x * 2 - d.qx;        // And make a reflection similar
                            d.qy = d.y * 2 - d.qy;        // to case "S".
                        }
                        else {                            // or something else or nothing
                            d.qx = d.x;
                            d.qy = d.y;
                        }
                        path = ["C"][concat](q2c(d.x, d.y, d.qx, d.qy, path[1], path[2]));
                        break;
                    case "Q":
                        d.qx = path[1];
                        d.qy = path[2];
                        path = ["C"][concat](q2c(d.x, d.y, path[1], path[2], path[3], path[4]));
                        break;
                    case "L":
                        path = ["C"][concat](l2c(d.x, d.y, path[1], path[2]));
                        break;
                    case "H":
                        path = ["C"][concat](l2c(d.x, d.y, path[1], d.y));
                        break;
                    case "V":
                        path = ["C"][concat](l2c(d.x, d.y, d.x, path[1]));
                        break;
                    case "Z":
                        path = ["C"][concat](l2c(d.x, d.y, d.X, d.Y));
                        break;
                }
                return path;
            },
            fixArc = function (pp, i) {
                if (pp[i].length > 7) {
                    pp[i].shift();
                    var pi = pp[i];
                    while (pi.length) {
                        pcoms1[i]="A"; // if created multiple C:s, their original seg is saved
                        p2 && (pcoms2[i]="A"); // the same as above
                        pp.splice(i++, 0, ["C"][concat](pi.splice(0, 6)));
                    }
                    pp.splice(i, 1);
                    ii = mmax(p.length, p2 && p2.length || 0);
                }
            },
            fixM = function (path1, path2, a1, a2, i) {
                if (path1 && path2 && path1[i][0] == "M" && path2[i][0] != "M") {
                    path2.splice(i, 0, ["M", a2.x, a2.y]);
                    a1.bx = 0;
                    a1.by = 0;
                    a1.x = path1[i][1];
                    a1.y = path1[i][2];
                    ii = mmax(p.length, p2 && p2.length || 0);
                }
            },
            pcoms1 = [], // path commands of original path p
            pcoms2 = [], // path commands of original path p2
            pfirst = "", // temporary holder for original path command
            pcom = ""; // holder for previous path command of original path
        for (var i = 0, ii = Math.max(p.length, p2 && p2.length || 0); i < ii; i++) {
            p[i] && (pfirst = p[i][0]); // save current path command

            if (pfirst != "C") // C is not saved yet, because it may be result of conversion
            {
                pcoms1[i] = pfirst; // Save current path command
                i && ( pcom = pcoms1[i-1]); // Get previous path command pcom
            }
            p[i] = processPath(p[i], attrs, pcom); // Previous path command is inputted to processPath

            if (pcoms1[i] != "A" && pfirst == "C") pcoms1[i] = "C"; // A is the only command
            // which may produce multiple C:s
            // so we have to make sure that C is also C in original path

            fixArc(p, i); // fixArc adds also the right amount of A:s to pcoms1

            if (p2) { // the same procedures is done to p2
                p2[i] && (pfirst = p2[i][0]);
                if (pfirst != "C")
                {
                    pcoms2[i] = pfirst;
                    i && (pcom = pcoms2[i-1]);
                }
                p2[i] = processPath(p2[i], attrs2, pcom);

                if (pcoms2[i]!="A" && pfirst=="C") pcoms2[i]="C";

                fixArc(p2, i);
            }
            fixM(p, p2, attrs, attrs2, i);
            fixM(p2, p, attrs2, attrs, i);
            var seg = p[i],
                seg2 = p2 && p2[i],
                seglen = seg.length,
                seg2len = p2 && seg2.length;
            attrs.x = seg[seglen - 2];
            attrs.y = seg[seglen - 1];
            attrs.bx = parseFloat(seg[seglen - 4]) || attrs.x;
            attrs.by = parseFloat(seg[seglen - 3]) || attrs.y;
            attrs2.bx = p2 && (parseFloat(seg2[seg2len - 4]) || attrs2.x);
            attrs2.by = p2 && (parseFloat(seg2[seg2len - 3]) || attrs2.y);
            attrs2.x = p2 && seg2[seg2len - 2];
            attrs2.y = p2 && seg2[seg2len - 1];
        }

        return p2 ? [p, p2] : p;
    }

    function q2c(x1, y1, ax, ay, x2, y2) {
        var _13 = 1 / 3,
            _23 = 2 / 3;
        return [
            _13 * x1 + _23 * ax,
            _13 * y1 + _23 * ay,
            _13 * x2 + _23 * ax,
            _13 * y2 + _23 * ay,
            x2,
            y2
        ];
    }

    function l2c (x1, y1, x2, y2) {
        return [x1, y1, x2, y2, x2, y2];
    }

    function a2c (x1, y1, rx, ry, angle, large_arc_flag, sweep_flag, x2, y2, recursive) {
        // for more information of where this math came from visit:
        // http://www.w3.org/TR/SVG11/implnote.html#ArcImplementationNotes
        var _120 = PI * 120 / 180,
            rad = PI / 180 * (+angle || 0),
            res = [],
            xy,
            rotate = function (x, y, rad) {
                var X = x * math.cos(rad) - y * math.sin(rad),
                    Y = x * math.sin(rad) + y * math.cos(rad);
                return {x: X, y: Y}
            };
        if (!recursive) {
            xy = rotate(x1, y1, -rad);
            x1 = xy.x;
            y1 = xy.y;
            xy = rotate(x2, y2, -rad);
            x2 = xy.x;
            y2 = xy.y;
            var cos = math.cos(PI / 180 * angle),
                sin = math.sin(PI / 180 * angle),
                x = (x1 - x2) / 2,
                y = (y1 - y2) / 2;
            var h = (x * x) / (rx * rx) + (y * y) / (ry * ry);
            if (h > 1) {
                h = math.sqrt(h);
                rx = h * rx;
                ry = h * ry;
            }
            var rx2 = rx * rx,
                ry2 = ry * ry,
                k = (large_arc_flag == sweep_flag ? -1 : 1) *
                    math.sqrt(abs((rx2 * ry2 - rx2 * y * y - ry2 * x * x) / (rx2 * y * y + ry2 * x * x))),
                cx = k * rx * y / ry + (x1 + x2) / 2,
                cy = k * -ry * x / rx + (y1 + y2) / 2,
                f1 = math.asin(((y1 - cy) / ry).toFixed(9)),
                f2 = math.asin(((y2 - cy) / ry).toFixed(9));

            f1 = x1 < cx ? PI - f1 : f1;
            f2 = x2 < cx ? PI - f2 : f2;
            f1 < 0 && (f1 = PI * 2 + f1);
            f2 < 0 && (f2 = PI * 2 + f2);
            if (sweep_flag && f1 > f2) {
                f1 = f1 - PI * 2;
            }
            if (!sweep_flag && f2 > f1) {
                f2 = f2 - PI * 2;
            }
        } else {
            f1 = recursive[0];
            f2 = recursive[1];
            cx = recursive[2];
            cy = recursive[3];
        }
        var df = f2 - f1;
        if (abs(df) > _120) {
            var f2old = f2,
                x2old = x2,
                y2old = y2;
            f2 = f1 + _120 * (sweep_flag && f2 > f1 ? 1 : -1);
            x2 = cx + rx * math.cos(f2);
            y2 = cy + ry * math.sin(f2);
            res = a2c(x2, y2, rx, ry, angle, 0, sweep_flag, x2old, y2old, [f2, f2old, cx, cy]);
        }
        df = f2 - f1;
        var c1 = math.cos(f1),
            s1 = math.sin(f1),
            c2 = math.cos(f2),
            s2 = math.sin(f2),
            t = math.tan(df / 4),
            hx = 4 / 3 * rx * t,
            hy = 4 / 3 * ry * t,
            m1 = [x1, y1],
            m2 = [x1 + hx * s1, y1 - hy * c1],
            m3 = [x2 + hx * s2, y2 - hy * c2],
            m4 = [x2, y2];
        m2[0] = 2 * m1[0] - m2[0];
        m2[1] = 2 * m1[1] - m2[1];
        if (recursive) {
            return [m2, m3, m4][concat](res);
        } else {
            res = [m2, m3, m4][concat](res).join()[split](",");
            var newres = [];
            for (var i = 0, ii = res.length; i < ii; i++) {
                newres[i] = i % 2 ? rotate(res[i - 1], res[i], rad).y : rotate(res[i], res[i + 1], rad).x;
            }
            return newres;
        }
    }

    function pathToAbsolute(pathArray) {

        if(typeof pathArray == 'string'){
            pathArray = parsePathString(pathArray);
        }

        if(!pathArray || !pathArray.length){
            return [["M", 0, 0]];
        }

        var res = [],
            x = 0,
            y = 0,
            mx = 0,
            my = 0,
            start = 0;
        if (pathArray[0][0] == "M") {
            x = +pathArray[0][1];
            y = +pathArray[0][2];
            mx = x;
            my = y;
            start++;
            res[0] = ["M", x, y];
        }
        var crz = pathArray.length == 3 && pathArray[0][0] == "M" && pathArray[1][0].toUpperCase() == "R" && pathArray[2][0].toUpperCase() == "Z";
        for (var r, pa, i = start, ii = pathArray.length; i < ii; i++) {
            res.push(r = []);
            pa = pathArray[i];
            if (pa[0] != upperCase.call(pa[0])) {
                r[0] = upperCase.call(pa[0]);
                switch (r[0]) {
                    case "A":
                        r[1] = pa[1];
                        r[2] = pa[2];
                        r[3] = pa[3];
                        r[4] = pa[4];
                        r[5] = pa[5];
                        r[6] = +(pa[6] + x);
                        r[7] = +(pa[7] + y);
                        break;
                    case "V":
                        r[1] = +pa[1] + y;
                        break;
                    case "H":
                        r[1] = +pa[1] + x;
                        break;
                    case "R":
                        var dots = [x, y][concat](pa.slice(1));
                        for (var j = 2, jj = dots.length; j < jj; j++) {
                            dots[j] = +dots[j] + x;
                            dots[++j] = +dots[j] + y;
                        }
                        res.pop();
                        res = res[concat](catmullRom2bezier(dots, crz));
                        break;
                    case "M":
                        mx = +pa[1] + x;
                        my = +pa[2] + y;
                    default:
                        for (j = 1, jj = pa.length; j < jj; j++) {
                            r[j] = +pa[j] + ((j % 2) ? x : y);
                        }
                }
            } else if (pa[0] == "R") {
                dots = [x, y][concat](pa.slice(1));
                res.pop();
                res = res[concat](catmullRom2bezier(dots, crz));
                r = ["R"][concat](pa.slice(-2));
            } else {
                for (var k = 0, kk = pa.length; k < kk; k++) {
                    r[k] = pa[k];
                }
            }
            switch (r[0]) {
                case "Z":
                    x = mx;
                    y = my;
                    break;
                case "H":
                    x = r[1];
                    break;
                case "V":
                    y = r[1];
                    break;
                case "M":
                    mx = r[r.length - 2];
                    my = r[r.length - 1];
                default:
                    x = r[r.length - 2];
                    y = r[r.length - 1];
            }
        }
        res.toString = path2string;
        return res;

    }

    function catmullRom2bezier(crp, z) {
        var d = [];
        for (var i = 0, iLen = crp.length; iLen - 2 * !z > i; i += 2) {
            var p = [
                {x: +crp[i - 2], y: +crp[i - 1]},
                {x: +crp[i],     y: +crp[i + 1]},
                {x: +crp[i + 2], y: +crp[i + 3]},
                {x: +crp[i + 4], y: +crp[i + 5]}
            ];
            if (z) {
                if (!i) {
                    p[0] = {x: +crp[iLen - 2], y: +crp[iLen - 1]};
                } else if (iLen - 4 == i) {
                    p[3] = {x: +crp[0], y: +crp[1]};
                } else if (iLen - 2 == i) {
                    p[2] = {x: +crp[0], y: +crp[1]};
                    p[3] = {x: +crp[2], y: +crp[3]};
                }
            } else {
                if (iLen - 4 == i) {
                    p[3] = p[2];
                } else if (!i) {
                    p[0] = {x: +crp[i], y: +crp[i + 1]};
                }
            }
            d.push(["C",
                (-p[0].x + 6 * p[1].x + p[2].x) / 6,
                (-p[0].y + 6 * p[1].y + p[2].y) / 6,
                (p[1].x + 6 * p[2].x - p[3].x) / 6,
                (p[1].y + 6*p[2].y - p[3].y) / 6,
                p[2].x,
                p[2].y
            ]);
        }

        return d;
    }

    function rectPath(x, y, w, h, r){
        if (r) {
            return [["M", x + r, y], ["l", w - r * 2, 0], ["a", r, r, 0, 0, 1, r, r], ["l", 0, h - r * 2], ["a", r, r, 0, 0, 1, -r, r], ["l", r * 2 - w, 0], ["a", r, r, 0, 0, 1, -r, -r], ["l", 0, r * 2 - h], ["a", r, r, 0, 0, 1, r, -r], ["z"]];
        }
        return [["M", x, y], ["l", w, 0], ["l", 0, h], ["l", -w, 0], ["z"]];
    }

    return {
        pathToAbsolute:pathToAbsolute,
        path2vml:path2vml,
        rectPath:rectPath
    }

});
/**
 * Created by eason on 15/8/16.
 */

define('utils/LabelDivManager',['require','./BaseUtils','./ColorUtils','./BezierEasing'],function(require){

    var BaseUtils = require('./BaseUtils');
    var ColorUtils = require('./ColorUtils');
    var BezierEasing = require('./BezierEasing');

    var DEFAULT_KEY = 'div-label-key'

    function LabelDivManager(dom){
        this.dom = dom;
        this.labelList = {};
    }


    LabelDivManager.prototype = {
        constructor:LabelDivManager,

        //bounds是绝对坐标
        addLabel:function(label, posOrDim, style, key, wrap, useHTML){
            // to keep previous default behavior
            if (typeof wrap === 'undefined') {
                wrap = false;
            }
            
            if (typeof useHTML === 'undefined') {
                useHTML = true;
            }

            key = key || DEFAULT_KEY;

            if(!this.labelList[key]){
                this.labelList[key] = [];
            }

            var labelArray = this.labelList[key];

            var div = document.createElement('div');
            if (useHTML) {
                div.innerHTML = label;
            } else {
                div.textContent ?
                    (div.textContent = label) :
                    (div.innerText = label);
            }
            
            div.style.zIndex = 1001;
            div.style.position = 'absolute';
            div.style.left = posOrDim.x + 'px';
            div.style.top = posOrDim.y + 'px';
            div.style.overflow = 'hidden';
            if (wrap) {
                div.style.whiteSpace = "normal";
                div.style.wordWrap = 'break-word';
            } else {
                div.style.whiteSpace = 'nowrap';
            }

            if(BaseUtils.hasDefined(posOrDim.width) && BaseUtils.hasDefined(posOrDim.height)){
                div.style.width = posOrDim.width + 'px';
                div.style.height = posOrDim.height + 'px';
            }

            for(var fontStyle in style){
                //ie789的color属性只能是16进制的值
                if(fontStyle == 'color' && !BaseUtils.isSupportSVG()){
                    div.style.color = ColorUtils.colorToHex(style.color);
                }else {
                    div.style[fontStyle] = style[fontStyle];
                }

            }

            this.dom.appendChild(div);
            labelArray.push(div);

            return div;
        },


        addLabelWidthBounds:function(label, bounds, style, key, wrap, useHTML){

            var div = this.addLabel(label, bounds, style, key, wrap, useHTML);

            div.style.width = bounds.width + 'px';
            div.style.height = bounds.height + 'px';

            return div;
        },

        clearLabels:function(key){
            key = key || DEFAULT_KEY;

            var labelArray = this.labelList[key] || [];

            for(var i = 0, len = labelArray.length; i < len; i++){
                this.dom.removeChild(labelArray[i]);
            }

            this.labelList[key] = [];
        },

        //删除所有层级的div标签
        clearAllLabels:function(){
            for(var key in this.labelList){
                this.clearLabels(key);
            }
        },

        translateLabelsHorizontal:function(transX, key){

            key = key || DEFAULT_KEY;
            var labelArray = this.labelList[key] || [];

            for(var i = 0, len = labelArray.length; i < len; i++){
                var label = labelArray[i];
                var left = parseFloat(label.style.left);
                left += transX;

                if(BaseUtils.isSupportSVG()){

                    d3.select(label)
                        .transition()
                        .ease(BezierEasing.css.swing)
                        .duration(300)
                        .style('left', left + 'px')

                }else{
                    label.style.left = left + 'px';
                }
            }
        },

        /**
         * change labels' size and position
         * @param {object} [changes] style key - change value
         * (key: left, top, right, bottom, width, height)
         * @param [key] label key
         */
        changeLabelDim: function (changes, key) {
            if (!changes) {
                return;
            }

            key = key || DEFAULT_KEY;
            var labelArray = this.labelList[key] || [];

            labelArray.map(function (label) {
                var changedValues = {};
                for (var name in changes) {
                    var value = parseFloat(label.style[name]);
                    changedValues[name] = value + changes[name] + 'px';
                }

                if(BaseUtils.isSupportSVG()){

                    d3.select(label)
                        .transition()
                        .ease(BezierEasing.css.swing)
                        .duration(300)
                        .style(changedValues);

                }else{
                    for (var name in changedValues) {
                        label.style[name] = changedValues[name];
                    }
                }
            })
        },

        setLabelOpacity: function (key, opacity) {
            var labelArray = this.labelList[key] || [];

            for(var i = 0, len = labelArray.length; i < len; i++){
                var label = labelArray[i];
                label.style.opacity = opacity;
            }
        }
    };


    return LabelDivManager;

});
/**
 * Created by eason on 16/3/23.
 */

define('render/CanvasRender',['require','../utils/BaseUtils','../Constants'],function(require){

    var BaseUtils = require('../utils/BaseUtils');
    var Constants = require('../Constants');


    function CanvasRender(dom, vanchart){

        this._init(dom, vanchart)
    }

    CanvasRender.prototype = {

        constructor:CanvasRender,

        _init:function(dom, vanchart){

            var plotBounds = vanchart.getPlotBounds();

            this.width = plotBounds.width;
            this.height = plotBounds.height;

            this.dom = this._createCanvas(dom, plotBounds);
            this.ctx = this.dom.getContext("2d");
        },

        _createCanvas:function(dom, plotBounds){

            var canvas = document.createElement('canvas');
            var width = plotBounds.width;
            var height = plotBounds.height;

            canvas.style.position = 'absolute';
            canvas.style.left = plotBounds.x + 'px';
            canvas.style.top = plotBounds.y + 'px';
            canvas.style.width = width + 'px';
            canvas.style.height = height + 'px';

            canvas.width = width;
            canvas.height = height;

            canvas.onselectstart = function(){return false};
            canvas.style['-webkit-user-select'] = 'none';
            canvas.style['user-select'] = 'none';
            canvas.style['-webkit-touch-callout'] = 'none';

            dom.appendChild(canvas);

            //excanvas
            window.vmlCanvasManager && vmlCanvasManager.initElement(canvas);

            return canvas;
        },

        clearAll:function(){
            this.ctx.clearRect(0, 0, this.width, this.height);
        },

        addBubbleSeries:function(series){
            var ctx = this.ctx;
            ctx.save();

            for(var i = 0, len = series.points.length; i < len; i++){
                var point = series.points[i];

                if(point.visible){

                    ctx.fillStyle = point.color;
                    ctx.globalAlpha = point.fillColorOpacity;

                    ctx.beginPath();
                    ctx.arc(point.posX, point.posY, point.radius, 0, 2 * Math.PI);
                    ctx.fill();
                }
            }

            ctx.restore();
        },

        addScatterSeries:function(series){
            var ctx = this.ctx;
            ctx.save();
            for(var i = 0, len = series.points.length; i < len; i++){
                var point = series.points[i];
                if(point.visible){
                    var markerType = point.marker.symbol;
                    var radius =  point.marker.radius || 4.5;
                    var color = point.marker.fillColor || point.color;

                    ctx.translate(point.posX, point.posY);
                    ctx.fillStyle = color;
                    ctx.strokeStyle = color;
                    ctx.globalAlpha = point.fillColorOpacity;

                    this._drawMarker(ctx, markerType, radius);

                    ctx.translate(-point.posX, -point.posY);
                }
            }
            ctx.restore();
        },

        addSeries:function(series){

            series.chart.componentType == Constants.SCATTER_CHART ?
                                        this.addScatterSeries(series) : this.addBubbleSeries(series);
        },

        _drawMarker:function(ctx, markerType, R){

            if(markerType.indexOf(Constants.CIRCLE) != -1){

                ctx.beginPath();
                ctx.arc(0, 0, R, 0, 2 * Math.PI);

            }else if(markerType.indexOf(Constants.SQUARE) != -1){

                ctx.beginPath();
                ctx.moveTo(-R, -R);
                ctx.lineTo(R, -R);
                ctx.lineTo(R, R);
                ctx.lineTo(-R, R);
                ctx.closePath();

            }else if(markerType.indexOf(Constants.DIAMOND) != -1){

                R = R * 2 / Math.sqrt(2);
                ctx.beginPath();
                ctx.moveTo(-R, 0);
                ctx.lineTo(0, -R);
                ctx.lineTo(R, 0);
                ctx.lineTo(0, R);
                ctx.closePath();

            }else if(markerType.indexOf(Constants.TRIANGLE) != -1){

                ctx.beginPath();
                ctx.moveTo(-R, R/Math.sqrt(3));
                ctx.lineTo(0, -(2 * Math.sqrt(3) / 3) * R);
                ctx.lineTo(R, R/Math.sqrt(3));
                ctx.closePath();

            }else{

                ctx.beginPath();
                ctx.arc(0, 0, R, 0, 2 * Math.PI);

            }

            if(markerType.indexOf('hollow') == -1){
                //满填充
                ctx.fill();
            }else{
                ctx.fillStyle = 'white';
                ctx.lineWidth = 2;

                ctx.fill();
                ctx.stroke();
            }

        }
    };



    return CanvasRender;
});

/**
 * Created by eason on 15/8/13.
 */

define('render/BaseRender',['require','../utils/BaseUtils','../utils/PathUtils','../utils/LabelDivManager','../utils/ColorUtils','../utils/Class','../Constants','./CanvasRender'],function(require){

    var BaseUtils = require('../utils/BaseUtils');
    var PathUtils = require('../utils/PathUtils');
    var LabelDivManager = require('../utils/LabelDivManager');
    var ColorUtils = require('../utils/ColorUtils');
    var Class = require('../utils/Class');
    var Constants = require('../Constants');
    var CanvasRender = require('./CanvasRender');

    var MARKER_G = 'markerG';
    var MARKER = 'markerPath';
    var MARKER_STROKE = 'markerStrokePath';
    var MIN_MARKER_R = 2;

    var BaseRender = Class.extend({

        initialize:function(component){

            this.component = component;

            if(component && component.getParentDom){
                this.labelDivManager = new LabelDivManager(component.getDivParentDom());
            }

            this.drawLabelTimeOut = {};
        },

        _createHorizontalLinearGradient:function(defs, id, startColor, endColor){
            this._createLinearGradient(defs, id, startColor, endColor, true);
        },

        _createVerticalLinearGradient:function(defs, id, startColor, endColor){
            this._createLinearGradient(defs, id, startColor, endColor, false);
        },

        _createLinearGradient:function(defs, id, startColor, endColor, isHorizontal){

            var  x2 = '0%', y2 = '0%';

            isHorizontal ? x2 = '100%' : y2 = '100%';

            var gradient = defs.append('linearGradient')
                .attr('x1', '0%').attr('y1', '0%')
                .attr('x2', x2).attr('y2', y2)
                .attr("id", id);

            gradient.append("stop").attr("offset", '0%').style("stop-color", startColor);

            gradient.append('stop').attr('offset', '100%').style('stop-color', endColor);
        },

        _createDropShadowFilter:function(defs, id, dx, dy, alpha, deviation){
            var dropFilter = defs.append('filter')
                .attr('id', id)
                .attr('x', '-50%')
                .attr('y', '-50%')
                .attr('width', '200%')
                .attr('height', '200%');

            dropFilter
                .append('feOffset')
                .attr('in', 'SourceAlpha')
                .attr('dx', dx)
                .attr('dy', dy)
                .attr('result', 'offOut');

            dropFilter
                .append('feColorMatrix')
                .attr('in', 'offOut')
                .attr('type', 'matrix')
                .attr('values', '0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 '+alpha+' 0')
                .attr('result', 'matrixOut');

            dropFilter
                .append('feGaussianBlur')
                .attr('in', 'matrixOut')
                .attr('stdDeviation', deviation)
                .attr('result', 'blurOut');

            dropFilter
                .append('feBlend')
                .attr('in', 'SourceGraphic')
                .attr('in2', 'blurOut')
                .attr('mode', 'normal');
        },

        _createInnerShadowFilter:function(defs, id, dx, dy, alpha, deviation){

            var innerFilter = defs.append('filter')
                .attr('id', id)
                .attr('x', '-50%')
                .attr('y', '-50%')
                .attr('width', '200%')
                .attr('height', '200%');

            innerFilter.append('feComponentTransfer')
                .attr('in', 'SourceAlpha')
                .append('feFuncA')
                .attr('type', 'table')
                .attr('tableValues', '1 0');

            innerFilter.append('feGaussianBlur')
                .attr('stdDeviation', deviation);

            innerFilter.append('feOffset')
                .attr('dx', dx)
                .attr('dy', dy)
                .attr('result', 'offsetblur');

            innerFilter.append('feFlood')
                .attr('flood-color', 'black')
                .attr('flood-opacity', alpha)
                .attr('result', 'color');

            innerFilter.append('feComposite')
                .attr('in2', 'offsetblur')
                .attr('operator', 'in');

            innerFilter.append('feComposite')
                .attr('in2', 'SourceAlpha')
                .attr('operator', 'in');

            var merge = innerFilter.append('feMerge');
            merge.append('feMergeNode').attr('in', 'SourceGraphic');
            merge.append('feMergeNode');
        },

        _createVmlMarker:function(paper, point, position){

            var plotBounds = this.component.getPlotBounds();

            var defaultRadius = this.component.getDefaultMarkerRadius();
            var radius =  point.marker.radius;

            if(BaseUtils.hasDefined(radius) && radius < MIN_MARKER_R){
                return {};
            }

            radius = radius || defaultRadius;


            if(BaseUtils.outsideRect(plotBounds, BaseUtils.makeBounds(position, [radius, radius]))){
                return {};
            }

            var markerType = point.marker.symbol;
            var isNullMarker = markerType == Constants.NULL_MARKER;
            var backgroundColor = this.component._getBackgroundColor();

            var markerRadius = this._isHollowMarker(markerType) ? radius - 1 : radius;
            var opacity = ColorUtils.getColorOpacityWithoutDefault(point.marker.fillColor);
            opacity = BaseUtils.hasDefined(opacity) ? opacity : point.fillColorOpacity;

            var marker;
            if(BaseUtils.isImageMarker(markerType)){

                var width = point.marker.width;
                var height = point.marker.height;
                marker = paper
                    .image(markerType, -width/2, -height/2, width, height)
                    .datum(point)
                    .transform(BaseUtils.makeTranslate(position));;

            }else{

                marker = paper.path(this._getMarkerPath(markerType, markerRadius))
                    .attr({
                        'fill':(this._isHollowMarker(markerType) || isNullMarker) ? backgroundColor : point.marker.fillColor,
                        'fill-opacity':isNullMarker ? 0 : opacity,
                        'stroke-opacity':isNullMarker ? 0 : opacity,
                        'stroke':point.marker.fillColor,
                        'stroke-width':this._isHollowMarker(markerType) ? 2 : 0
                    })
                    .datum(point)
                    .transform(BaseUtils.makeTranslate(position));

                var strokeMarker;
                if(this.component.type == Constants.LINE_CHART){
                    strokeMarker = paper.path(this._getMarkerPath(markerType, radius + 1))
                        .attr({
                            'stroke-width':isNullMarker ? 0 : 2,
                            'stroke': backgroundColor,
                            'fill':'none'
                        })
                        .transform(BaseUtils.makeTranslate(position));
                }
            }

            this.addShapeEventHandler(marker);

            return {
                marker:marker,
                strokeMarker:strokeMarker
            }
        },

        _getMarkerGroupClass:function(d){
            return d.className + ' ' + MARKER_G;
        },

        _createSvgMarker:function(updateS){
            var self = this;
            var defaultRadius = this.component.getDefaultMarkerRadius();

            updateS.enter().append('g')
                .attr('class', function(d){
                    return self._getMarkerGroupClass(d);
                })
                .filter(function(d){
                    var radius = d.marker.radius;
                    return d.visible && (BaseUtils.hasNotDefined(radius) || radius >= MIN_MARKER_R);
                })
                .each(function(data){
                    if(data.isNull){
                        return;
                    }
                    var markerG = d3.select(this);
                    var markerType = data.marker.symbol;

                    if(BaseUtils.isImageMarker(markerType)){
                        //创建图片的标记点
                        self._createImageMarker(markerType, function(width, height){
                            var width = data.marker.width || width;
                            var height = data.marker.height || height;
                            data.marker.width = width;
                            data.marker.height = height;

                            markerG
                                .append('image')
                                .attr('preserveAspectRatio', 'none')
                                .attr('xlink:href', markerType)
                                .attr('x', -width/2)
                                .attr('y', -height/2)
                                .attr('width', width)
                                .attr('height', height);
                        });
                    }else{
                        markerG.append('path').attr('class', MARKER)
                            .attr('d', function(d){
                                var radius =  d.marker.radius || defaultRadius;

                                if(self._isHollowMarker(markerType))
                                    radius -= 1;

                                return self._getMarkerPath(markerType, radius);
                            });

                        if(self.component.type == Constants.LINE_CHART){
                            markerG
                                .append('path')
                                .attr('class', MARKER_STROKE)
                                .attr('d', function(d){
                                    var radius =  d.marker.radius || defaultRadius;
                                    return self._getMarkerPath(markerType, radius + 1);
                                });
                        }

                        self._updateMarkerStyle(markerG, data);
                    }

                    self.addShapeEventHandler(markerG);
                });
        },

        _updateMarkerStyle:function(markerG, data){
            var markerType = data.marker.symbol;
            var isNullMarker = markerType == Constants.NULL_MARKER;
            var self = this, backgroundColor = this.component._getBackgroundColor();
            if(!BaseUtils.isImageMarker(markerType)){

                markerG.select('path.' + MARKER)
                    .style('fill', function(d){
                        return self._isHollowMarker(markerType) ? backgroundColor : d.marker.fillColor;
                    })
                    .style('fill-opacity', isNullMarker ? 0 : function (d) {
                        return d.fillColorOpacity;
                    })
                    .style('stroke', function(d){
                        return d.marker.fillColor;
                    })
                    .style('stroke-opacity', function(d){
                        return d.fillColorOpacity;
                    })
                    .style('stroke-width', function(){
                        return self._isHollowMarker(markerType) ? 2 : 0;
                    });

                markerG.select('path.' + MARKER_STROKE)
                    .style('stroke-width', isNullMarker ? 0 : 2)
                    .style('stroke', backgroundColor)
                    .style('fill', 'none')
            }
        },

        _createImageMarker:function(src, callBack){
            var img = new Image();
            img.onload = function() {
                callBack(this.width, this.height);
            };
            img.src = src;
        },

        _getMarkerClass:function(){
            return MARKER_G;
        },

        _makeVmlMarkerChosenState:function(d){

            var markerType = d.marker.symbol;

            if(BaseUtils.isImageMarker(markerType)){
                return;
            }

            var radius =  d.marker.radius || this.component.getDefaultMarkerRadius();
            var pathR = this._isHollowMarker(markerType) ? radius - 1 : radius;
            var backgroundColor = this.component._getBackgroundColor();

            var makerSet = this.getElementByData(d);

            if(!makerSet || !makerSet.marker){
                return;
            }

            var marker = makerSet.marker;
            var strokeMarker = makerSet.strokeMarker;

            marker.attr({
                'path':this._getMarkerPath(markerType, pathR + 2),
                'fill':!this._isHollowMarker(markerType) ? d.marker.fillColor : backgroundColor,
                'fill-opacity':1
            });

            if(strokeMarker){
                strokeMarker.attr({
                    'path':this._getMarkerPath(markerType, radius + 3)
                });
            }
        },

        _cancelVmlMarkerChosenState:function(d){

            var markerType = d.marker.symbol;

            if(BaseUtils.isImageMarker(markerType)){
                return;
            }

            var isNullMarker = markerType == Constants.NULL_MARKER;
            var radius =  d.marker.radius || this.component.getDefaultMarkerRadius();
            var pathR = this._isHollowMarker(markerType) ? radius - 1 : radius;
            var backgroundColor = this.component._getBackgroundColor();

            var makerSet = this.getElementByData(d);

            if(!makerSet || !makerSet.marker){
                return;
            }

            var marker = makerSet.marker;
            var strokeMarker = makerSet.strokeMarker;

            marker.attr({
                'path':this._getMarkerPath(markerType, pathR),
                'fill':(this._isHollowMarker(markerType) || isNullMarker) ? backgroundColor : d.marker.fillColor,
                'fill-opacity':isNullMarker ? 0 : 1
            });

            if(strokeMarker){
                strokeMarker.attr({
                    'path':this._getMarkerPath(markerType, radius + 1),
                    'stroke-width': isNullMarker ? 0 : 2
                });
            }

        },

        _makeMarkerClickedState:function(parentS, d){
            var markerG = parentS.select('g.' + d.className);

            var backgroundColor = this.component._getBackgroundColor();
            var markerFillColor = d.marker.fillColor;

            backgroundColor = ColorUtils.getClickColor(backgroundColor);
            markerFillColor = ColorUtils.getClickColor(markerFillColor);

            var markerType = d.marker.symbol;

            markerG
                .select('path.' + MARKER)
                .style('fill',  this._isHollowMarker(markerType) ? backgroundColor : markerFillColor)
                .style('stroke', markerFillColor);

            markerG
                .select('path.' + MARKER_STROKE).style('stroke', backgroundColor);
        },

        _cancelMarkerClickedState:function(markerG, d){
            
            var backgroundColor = this.component._getBackgroundColor();
            var markerFillColor = d.marker.fillColor;

            var markerType = d.marker.symbol;

            markerG
                .select('path.' + MARKER)
                .style('fill',  this._isHollowMarker(markerType) ? backgroundColor : markerFillColor)
                .style('stroke', markerFillColor);

            markerG
                .select('path.' + MARKER_STROKE).style('stroke', backgroundColor);

        },

        _makeMarkerChosenState:function(markerG, d, addSize, animationTime){
            addSize = addSize || 2;
            animationTime = animationTime || 0;

            var markerType = d.marker.symbol;
            var radius =  d.marker.radius || this.component.getDefaultMarkerRadius();
            var isNullMarker = markerType == Constants.NULL_MARKER;

            var pathR = radius;
            var backgroundColor = ColorUtils.getHighLightColor(this.component._getBackgroundColor());
            var markerHighlightColor = ColorUtils.getHighLightColor(d.marker.fillColor);

            var self = this;

            if(this._isHollowMarker(markerType))
                pathR -= 1;

            if(markerG){
                markerG
                    .select('path.' + MARKER)
                    .style('fill', !this._isHollowMarker(markerType) ? markerHighlightColor : backgroundColor)
                    .style('fill-opacity', isNullMarker ? 1 : BaseUtils.pick(d.fillColorOpacity, 1))
                    .interrupt(Constants.SELECT_ANIMATION)
                    .transition(Constants.SELECT_ANIMATION)
                    .duration(animationTime)
                    .ease('ease-out-expo')
                    .attr('d', self._getMarkerPath(markerType, isNullMarker ? pathR : (pathR + addSize)))
                ;

                markerG
                    .select('path.' + MARKER_STROKE)
                    .attr('d', self._getMarkerPath(markerType, isNullMarker ? radius : (radius + 3)))
                    .style('stroke-width', 2);

                var image = markerG.select('image');
                if(!image.empty()){
                    var width = d.marker.width + 4;
                    var height = d.marker.height + 4;
                    image
                        .attr('x', -width/2)
                        .attr('y', -height/2)
                        .attr('width', width)
                        .attr('height', height)
                }
            }

        },

        _cancelMarkerChosenState:function(markerG, d){

            var backgroundColor = this.component._getBackgroundColor();

            var markerType = d.marker.symbol;
            var isNullMarker = markerType == Constants.NULL_MARKER;
            var radius =  d.marker.radius || this.component.getDefaultMarkerRadius();
            var self = this;

            var pathR = radius;
            if(this._isHollowMarker(markerType))
                pathR -= 1;

            if(markerG){
                //stop animation
                markerG
                    .select('path.' + MARKER)
                    .interrupt(Constants.SELECT_ANIMATION)
                    .transition(Constants.SELECT_ANIMATION);

                markerG
                    .select('path.' + MARKER)
                    .attr('d', self._getMarkerPath(markerType, pathR))
                    .style('fill', self._isHollowMarker(markerType) ? backgroundColor : d.marker.fillColor)
                    .style('fill-opacity', isNullMarker ? 0 : BaseUtils.pick(d.fillColorOpacity, 1));

                markerG
                    .select('path.' + MARKER_STROKE)
                    .attr('d', function(){
                        return self._getMarkerPath(markerType, radius + 1);
                    })
                    .style('stroke-width', isNullMarker ? 0 : 2);

                var image = markerG.select('image');
                if(!image.empty()){
                    var width = d.marker.width;
                    var height = d.marker.height;
                    image
                        .interrupt()
                        .attr('x', -width/2)
                        .attr('y', -height/2)
                        .attr('width', width)
                        .attr('height', height);
                }
            }
        },

        _renderDivLabels:function(points, transX, transY, key){

            var plotBounds = this.component.getPlotBounds();

            var isPieChart = this.component.componentType == Constants.PIE_CHART;

            for(var i = 0, len = points.length; i < len; i++){
                var p = points[i];
                if(p.visible && p.dataLabels && p.dataLabels.enabled && p.dataLabels.useHtml && p.labelPos && p.labelContent.length){

                    var labelX = p.labelPos.x + transX;
                    var labelY = p.labelPos.y + transY;
                    var labelContent = p.labelContent;

                    //ie低版本字体会出现大小
                    for(var index = 0, count = labelContent.length; index < count; index++){

                        var label = labelContent[index];

                        var labelDim = label.dim;

                        var pos = {x:labelX, y:labelY};

                        if(!BaseUtils.outsideRect(plotBounds, BaseUtils.makeBounds(pos, labelDim))){
                            var div = this.labelDivManager.addLabel(label.text, BaseUtils.makeBounds(pos, labelDim) , label.style, key);
                        }

                        labelY += (labelDim.height + this.component.getLabelGap());
                    }


                }
            }
        },

        _removeSvgDataLabels:function(parentG, key){

            parentG.selectAll('text').remove();
            parentG.selectAll('path').remove();

            this.labelDivManager.clearLabels(key);
        },


        _updateChartBodyTranslate:function(GlyphArray, supportAnimation, animationTime) {
            var plotBounds = this.component.getPlotBounds();
            var clipID = this.component.vanchart.getBodyClipID();

            GlyphArray.forEach(function (Glyph) {
                Glyph
                    .attr('clip-path', "url(#" + clipID +")")
                    .transition()
                    .duration(supportAnimation ? animationTime : 0)
                    .ease('back-out')
                    .attr('transform', 'translate('+plotBounds.x+','+plotBounds.y+')');

            });
        },

        _drawNormalChartLabels: function (parentG, delay) {
            var seriesS = this.component.getVisibleChartData();

            var plotBounds = this.component.getPlotBounds();

            var allPoints = [];
            seriesS.forEach(function(sery){
                allPoints = allPoints.concat(sery.points);
            });

            var validPoints = [];
            var tmpBounds = BaseUtils.makeBounds(0, 0, plotBounds.width, plotBounds.height);
            allPoints.forEach(function(point){
                if(point.labelPos && point.labelDim){

                    var x = point.labelPos.x + point.labelDim.width/2;
                    var y = point.labelPos.y + point.labelDim.height/2;

                    if(BaseUtils.containsPoint(tmpBounds, [x, y])){
                        validPoints.push(point);
                    }
                }
            });

            this._drawSvgDataLabels(parentG, validPoints, plotBounds.x, plotBounds.y, delay);
        },

        _drawSvgDataLabels:function(parentG, points, transX, transY, delay, key){

            delay = delay || 0;

            key = key || 'default-label-key';

            clearTimeout(this.drawLabelTimeOut[key]);

            var self = this;

            this._removeSvgDataLabels(parentG, key);

            this.drawLabelTimeOut[key] = setTimeout(function(){
                parentG
                    .style('opacity', 0)
                    .selectAll('text')
                    .data(points)
                    .enter()
                    .append('text')
                    .filter(function(d){
                        return d.visible
                            && d.labelPos
                            && d.dataLabels
                            && d.dataLabels.enabled
                            && !d.dataLabels.useHtml ;
                    })
                    .each(function(d){

                        var labelContent = d.labelContent;

                        var centerX = d.labelPos.x + d.labelDim.width/2;

                        var startY = d.labelPos.y;

                        for(var i = 0, count = labelContent.length; i < count; i++){
                            var label = labelContent[i];

                            var labelDim = label.dim;
                            var labelText = label.text;
                            var labelStyle = label.style;

                            d3.select(this)
                                .append('tspan')
                                .attr('x', centerX)
                                .attr('y', startY + labelDim.height/2)
                                .attr('dy', '.32em')
                                .attr("text-anchor", "middle")
                                .text(labelText)
                                .call(BaseUtils.setTextStyle, labelStyle);

                            startY += (labelDim.height + self.component.getLabelGap());
                        }
                    });

                parentG
                    .transition('linear')
                    .duration(400)
                    .style('opacity', 1);

                self._renderDivLabels(points, transX, transY, key);

                if(self.component.componentType == Constants.PIE_CHART ||
                    self.component.componentType == Constants.BUBBLE_CHART ||
                    self.component.componentType == Constants.MULTIPIE_CHART){

                    //饼图气泡图标签 加。
                    parentG.selectAll('text').filter(function(d){
                        return d.dataLabels && d.dataLabels.align != Constants.OUTSIDE;
                    }).style('pointer-events', 'none');

                    parentG
                        .selectAll('path').data(points)
                        .enter()
                        .append('path')
                        .filter(function(d){
                            return d.visible
                                && d.labelPos
                                && d.dataLabels
                                && d.dataLabels.enabled
                                && d.dataLabels.align == Constants.OUTSIDE;
                        })
                        .attr('d', function(d){
                            var startPos = d.labelPos.startPos;
                            var midPos = d.labelPos.midPos;
                            var endPos = d.labelPos.endPos;

                            return 'M' + startPos.x + ',' + startPos.y
                                + 'L' + midPos.x + ',' + midPos.y
                                + 'L' + endPos.x + ',' + endPos.y;
                        })
                        .style('fill', 'none')
                        .style('stroke', function(d){
                            return d.dataLabels.connectorColor || d.color;
                        })
                        .style('stroke-width', function(d){
                            return d.dataLabels.connectorWidth || 0;
                        });
                }

            }, delay);
        },

        _createSingleDataLabel: function (d, labelG) {
            this._createSingleSvgDataLabel(d, labelG);
            this._createSingleDivDataLabel(d);
        },

        _createSingleSvgDataLabel:function(d, labelG){

            if(d.labelPos && d.dataLabels && d.dataLabels.enabled && !d.dataLabels.useHtml){

                var labelContent = d.labelContent;

                var centerX = d.labelPos.x + d.labelDim.width/2;

                var startY = d.labelPos.y;

                for(var i = 0, count = labelContent.length; i < count; i++){
                    var label = labelContent[i];

                    var labelDim = label.dim;
                    var labelText = label.text;
                    var labelStyle = label.style;

                    labelG
                        .append('tspan')
                        .attr('x', centerX)
                        .attr('y', startY + labelDim.height/2)
                        .attr('dy', '.32em')
                        .attr("text-anchor", "middle")
                        .text(labelText)
                        .call(BaseUtils.setTextStyle, labelStyle);
                    startY += (labelDim.height + this.component.getLabelGap());
                }
            }
        },

        _createSingleDivDataLabel: function (p) {
            var plotBounds = this.component.getPlotBounds();

            if(p.visible && p.dataLabels && p.dataLabels.enabled && p.dataLabels.useHtml && p.labelPos && p.labelContent.length){

                var labelX = p.labelPos.x + plotBounds.x;
                var labelY = p.labelPos.y + plotBounds.y;
                var labelContent = p.labelContent;

                //ie低版本字体会出现大小
                for(var index = 0, count = labelContent.length; index < count; index++){

                    var label = labelContent[index];

                    var labelDim = label.dim;

                    var pos = {x:labelX, y:labelY};

                    if(!BaseUtils.outsideRect(plotBounds, BaseUtils.makeBounds(pos, labelDim))){
                        var div = this.labelDivManager.addLabel(label.text, BaseUtils.makeBounds(pos, labelDim) , label.style, p.className);
                    }

                    labelY += (labelDim.height + this.component.getLabelGap());
                }
            }
        },

        _drawTitleWithHtml:function(cfg, bounds, reservedWidth){
            var style = BaseUtils.clone(cfg.style);

            var padding = this.component.getPadding();
            style.textAlign = cfg.align || 'left';

            var usedBounds = {
                x:bounds.x + padding,
                y:bounds.y + padding,
                width:bounds.width - 2 * padding - reservedWidth,
                height:bounds.height - 2 * padding
            };

            this.labelDivManager.addLabelWidthBounds(cfg.text, usedBounds, style, 0, false, true);
        },

        _drawTitle:function(cfg, bounds){
            var style = BaseUtils.clone(cfg.style);

            style.textAlign = cfg.align || 'left';

            var div = this.labelDivManager.addLabelWidthBounds(cfg.text, bounds, style, 0, true, cfg.useHtml);
            if (!cfg.useHtml) {
                div.style.pointerEvents = 'none';
            }
        },

        _renderVmlBackground: function (parentSet, paper, option, bounds) {
            if(option.shadow){
                var borderWidth = option.borderWidth || 0;

                var det = borderWidth % 2 == 0 ? 0.5 : 0;

                var width = [5, 3, 1];
                var opacity = [0.05, 0.1, 0.15];
                for(var i = 0; i < 3; i++){
                    parentSet.push(
                        paper.rect(bounds.x + det, bounds.y + det, bounds.width, bounds.height)
                            .attr({
                                fill: 'none',
                                stroke: 'rgb(0,0,0)',
                                'stroke-opacity':opacity[i],
                                'stroke-width': width[i],
                                'rx': option.borderRadius,
                                'ry': option.borderRadius
                            })
                            .transform('t1,1')
                    );
                }

                parentSet.push(
                    paper.rect(bounds.x, bounds.y, bounds.width, bounds.height)
                        .attr({
                            fill: 'white',
                            stroke: 'none',
                            'rx': option.borderRadius,
                            'ry': option.borderRadius
                        }));
            }

            parentSet.push(
                paper.rect(bounds.x, bounds.y, bounds.width, bounds.height)
                    .attr('class', 'legend-background')
                    .attr('rx', option.borderRadius)
                    .attr('ry', option.borderRadius)
                    .attr('fill', this._getRaphaelFill(option.backgroundColor))
                    .attr('fill-opacity', this._getFillOpacity(option.backgroundColor))
                    .attr('stroke', option.borderColor)
                    .attr('stroke-width', option.borderWidth)
            );
        },

        _renderSvgBackground:function(parentG, option, bounds, gradualID){

            if(bounds.width <= 0 || bounds.height <= 0){
                return;
            }

            if(option.backgroundColor && parentG.select('defs').empty()){
                this._createGradualDefs(parentG, option.backgroundColor, gradualID);
            }

            var borderWidth = option.borderWidth || 0;
            var borderBounds = BaseUtils.rectSubPixelOpt(0, 0, bounds.width, bounds.height, borderWidth);

            if(option.shadow){

                var det =  BaseUtils.lineSubPixelOpt(0, borderWidth);

                var width = [5, 3, 1];
                var opacity = [0.05, 0.1, 0.15];

                var shadowRect = parentG.selectAll('rect.shadow').data(width);
                shadowRect.enter().append('rect').attr('class', 'shadow');
                shadowRect.attr('x', det).attr('y', det)
                    .attr('width', bounds.width).attr('height', bounds.height)
                    .attr('rx', option.borderRadius).attr('ry', option.borderRadius)
                    .attr('transform', 'translate(1, 1)')
                    .style('fill', 'none').style('stroke', 'black')
                    .style('stroke-width', function(d){return d})
                    .style('stroke-opacity', function(d, i){return opacity[i]});

                var background = parentG.selectAll('rect.shadowBackground').data([0]);
                background.enter().append('rect').attr('class', 'shadowBackground');

                background
                    .attr('x', borderBounds.x)
                    .attr('y', borderBounds.y)
                    .attr('width', borderBounds.width)
                    .attr('height', borderBounds.height)
                    .attr('rx', option.borderRadius)
                    .attr('ry', option.borderRadius)
                    .style('fill', 'white');
            }

            var background = parentG.selectAll('rect.background').data([0]);
            background.enter().append('rect').attr('class', 'background');

            background
                .attr('x', borderBounds.x)
                .attr('y', borderBounds.y)
                .attr('width', borderBounds.width)
                .attr('height', borderBounds.height)
                .attr('rx', option.borderRadius)
                .attr('ry', option.borderRadius)
                .style('fill', option.backgroundColor ? (typeof option.backgroundColor == 'string' ? option.backgroundColor : "url(#" + gradualID + ")") : 'none')
                .style('stroke', option.borderColor)
                .style('stroke-width', option.borderWidth);
        },

        _createGradualDefs:function(gElement, color, ID){
            if(color){
                if(typeof color == 'object'){
                    var linearGradient = gElement
                        .append('defs')
                        .append('linearGradient')
                        .attr('id', ID)
                        .attr('x1', color.x1)
                        .attr('y1', color.y1)
                        .attr('x2', color.x2)
                        .attr('y2', color.y2);

                    linearGradient.append('stop')
                        .attr('offset', '0%')
                        .style('stop-color', color.startColor);

                    linearGradient.append('stop')
                        .attr('offset', '100%')
                        .style('stop-color', color.endColor);
                }
            }
        },

        //可能是渐变色
        _getRaphaelFill:function(color){
            if(color){

                if(typeof color == 'string'){
                    return color;
                }else{
                    //渐变色
                    var angle = 0;
                    var start = parseFloat(color.x1);
                    var end = parseFloat(color.x2);

                    if(color.x1 == color.x2){
                        angle = 270;
                        start = parseFloat(color.y1) * 100;
                        end = parseFloat(color.y2) * 100;
                    }

                    return angle + '-' + color.startColor + ':' + start + '-' + color.endColor + ':' + end;

                }
            }

            return 'none';
        },

        _drawVmlDataLabels:function(paper, labelSet, points, transX, transY){

            var plotBounds = this.component.getPlotBounds();

            var labelPoints = [];
            for(var i = 0, len = points.length; i < len; i++){

                var point = points[i];

                if(point && point.visible && point.dataLabels && point.dataLabels.enabled && point.labelPos){

                    var labelAbsPos = {
                        x:point.labelPos.x + transX,
                        y:point.labelPos.y + transY
                    };

                    if(BaseUtils.containsPoint(plotBounds, labelAbsPos)){
                        labelPoints.push(point);
                    }
                }
            }

            for(var i = 0, len = labelPoints.length; i < len; i++){
                var point = labelPoints[i];

                var labelContent  = point.labelContent;
                var wholeLabelDim = point.labelDim;

                var labelX = point.labelPos.x + transX;
                var labelY = point.labelPos.y + transY;

                //ie低版本字体会出现大小
                for(var index = 0, count = labelContent.length; index < count; index++){

                    var label = labelContent[index];

                    var labelDim = label.dim;

                    var midGap = (wholeLabelDim.width - labelDim.width)/2;
                    midGap = Math.max(0, midGap);

                    this.labelDivManager.addLabel(label.text, BaseUtils.makeBounds({x:labelX + midGap, y:labelY}, labelDim), label.style, point.category);

                    labelY += (labelDim.height + this.component.getLabelGap());
                }

                if(point.dataLabels.align === Constants.OUTSIDE &&
                    (this.component.componentType === Constants.PIE_CHART ||
                    this.component.componentType === Constants.MULTIPIE_CHART)){

                    var startPos = point.labelPos.startPos;
                    var midPos = point.labelPos.midPos;
                    var endPos = point.labelPos.endPos;

                    var leadLine = paper.path(
                            'M' + BaseUtils.dealFloatPrecision(startPos.x) + ',' + BaseUtils.dealFloatPrecision(startPos.y)
                            + 'L' + BaseUtils.dealFloatPrecision(midPos.x) + ',' + BaseUtils.dealFloatPrecision(midPos.y)
                            + 'L' + BaseUtils.dealFloatPrecision(endPos.x) + ',' + BaseUtils.dealFloatPrecision(endPos.y))
                        .transform(('t' + transX + ',' + transY))
                        .attr('fill', 'none')
                        .attr('stroke', point.dataLabels.connectorColor || point.color)
                        .attr('stroke-width', point.dataLabels.connectorWidth || 0);

                    labelSet.push(leadLine);

                }

            }

        },

        _isHollowMarker:function(markerType){
            if (!markerType) {
                return false;
            }
            return markerType.indexOf('hollow') != -1 && markerType != Constants.NULL_MARKER;
        },

        _getMarkerPath:function(markerType, R){
            switch(markerType){
                case Constants.NULL_MARKER:
                case Constants.CIRCLE:
                case Constants.CIRCLE_HOLLOW:
                    return d3.svg.arc().outerRadius(R)({startAngle:0, endAngle:2 * Math.PI});

                case Constants.SQUARE:
                case Constants.SQUARE_HOLLOW:
                    var leftTop = -R + ',' + -R;
                    var rightTop = R + ',' + -R;
                    var rightBottom = R + ',' + R;
                    var leftBottom = -R + ',' + R;
                    return 'M' + leftTop + 'L' + rightTop + 'L' + rightBottom + 'L' + leftBottom + 'Z';

                case Constants.DIAMOND:
                case Constants.DIAMOND_HOLLOW:
                    R = R * 2 / Math.sqrt(2);

                    var left = -R + ',' + 0;
                    var top = 0 + ',' + -R;
                    var right = R + ',' + 0;
                    var bottom = 0 + ',' + R;
                    return 'M' + left + 'L' + top + 'L' + right + 'L' + bottom + 'Z';

                case Constants.TRIANGLE:
                case Constants.TRIANGLE_HOLLOW:

                    var left = -R + ',' + R/Math.sqrt(3);
                    var top = 0 + ',' + -(2 * Math.sqrt(3) / 3) * R;
                    var right = R + ',' + R/Math.sqrt(3);

                    return 'M' + left + 'L' + top + 'L' + right + 'Z';
            }
        },

        path2vml:function(path){
            return PathUtils.path2vml(path);
        },

        //用path来构造line
        _getLinePath:function(p1, p2){
            return 'M' + this._dealWithFloat(p1[0]) + ',' + this._dealWithFloat(p1[1])
                + 'L' + this._dealWithFloat(p2[0]) + ',' + this._dealWithFloat(p2[1]);
        },

        _dealWithFloat:function(v){
            return Math.abs(v) < 1e-6 ? 0 : v;
        },

        _getFillOpacity:function(color){
            if(color && typeof color == 'string'){
                return ColorUtils.getColorOpacity(color);
            }

            return 1;
        },

        removeDivLabels:function(){
            if(this.labelDivManager){
                this.labelDivManager.clearAllLabels();
            }
        },

        addSeriesEventHandler:function(shapeS){
            var self = this;

            if(BaseUtils.isSupportSVG()){
                shapeS.each(function () {
                    self._addSingleSeriesEventHandler(d3.select(this));
                });
            }else{
                this._addSingleSeriesEventHandler(shapeS);
            }

        },

        _addSingleSeriesEventHandler:function(layer){

            var handler = this.component.vanchart.handler;

            handler.addInteractiveTarget(layer, this._getSeriesTypes(), this);
        },

        addShapeEventHandler:function(shapeS){

            var self = this;

            if(BaseUtils.isSupportSVG()){
                shapeS.each(function(){
                    self._addSingleShapeEventHandler(d3.select(this));
                });
            }else{
                this._addSingleShapeEventHandler(shapeS);
            }

        },

        _addSingleShapeEventHandler:function(layer){

            var handler = this.component.vanchart.handler;

            handler.addInteractiveTarget(layer, this._getTypes(), this);
        },

        _getTypes:function(){

            return BaseUtils.hasTouch() ? {
                'touchstart':this._touchStart,
                'forceTouchEnd':this._touchEnd
            } : {
                'mouseover':this._mouseOver,
                'mouseout':this._mouseOut,
                'mousedown':this.mouseDown,
                'mouseup':this.mouseUp,
                'cover':this.mouseOver,
                'leave':this.mouseOut
            };
        },

        _getSeriesTypes:function(){
            return BaseUtils.hasTouch() ? {
                'touchstart':this._seriesTouchStart,
                'forceTouchEnd':this._seriesTouchEnd
            } : {
                'mouseover':this._seriesMouseOver,
                'forceMouseOut':this._seriesMouseOut
            }
        },

        _touchStart:function(event){
            var point = event.target.datum();

            var series = point.series,
                chart = series.chart.vanchart,
                handler = chart.handler,
                hoverPoint = chart.hoverPoint,
                hoverSeries = chart.hoverSeries;

            if (!this._shouldHover(point)) {
                chart.hoverPoint = point;
                return;
            }

            if (hoverSeries !== series) {
                handler.fireEventByData(hoverSeries, 'forceMouseOut', event);
                handler.fireEventByData(series, 'touchstart', event);
                chart.hoverSeries = series;
            }

            if (hoverPoint && hoverPoint !== point) {
                handler.fireEventByData(hoverPoint, 'forceTouchEnd', event);
            }

            point.series && (chart.hoverPoint = point);
            chart.getTooltip().showWithPoint(point, event.originalEvent);
            this.mouseOver(event);
        },

        _touchEnd:function(event){
            var point = event.target.datum();
            if (point.series.supportSharedTooltip &&
                point.tooltip &&
                point.tooltip.shared) {
                return;
            }
            this.mouseOut(event);
        },

        _seriesTouchStart:function(event){
            var series = event.target.datum(),
                chart = series.chart.vanchart,
                hoverPoint = chart.hoverPoint,
                hoverSeries = chart.hoverSeries,
                handler = chart.handler;

            // set normal state to previous series
            if (hoverSeries && hoverSeries !== series) {
                handler.fireEventByData(hoverSeries, 'forceTouchEnd', event);
            }

            chart.hoverSeries = series;
            var closestPoint = series.chart.getClosestPoint(event.containerPoint);

            if(!hoverPoint || (hoverPoint && hoverPoint.series != series)){
                handler.fireEventByData(hoverPoint, 'forceTouchEnd', event);

                if (!this._shouldHover(closestPoint)) {
                    chart.hoverPoint = null;
                    chart.hoverPoint = null;
                    return;
                }

                handler.fireEventByData(closestPoint, 'touchstart', event);

                chart.hoverPoint = closestPoint;
            }

            this.seriesMouseOver(event);
        },

        _seriesTouchEnd:function(event){
            var series = event.target.datum(),
                chart = series.chart.vanchart,
                hoverSeries = chart.hoverSeries,
                hoverPoint = chart.hoverPoint,
                handler = chart.handler;

            chart.hoverSeries = null;

            this.seriesMouseOut(event);
        },

        _mouseOver:function(event){

            var point = event.target.datum();
            var series = point.series,
                chart = series.chart.vanchart,
                handler = chart.handler,
                hoverPoint = chart.hoverPoint,
                hoverSeries = chart.hoverSeries;

            if (!this._shouldHover(point)) {
                chart.hoverPoint = point;
                return;
            }

            if (hoverSeries !== series) {
                handler.fireEventByData(hoverSeries, 'forceMouseOut', event);
                handler.fireEventByData(series, 'mouseover', event);
                chart.hoverSeries = series;
            }

            if (hoverPoint && hoverPoint !== point) {
                handler.fireEventByData(hoverPoint, 'mouseout', event);
            }

            point.series && (chart.hoverPoint = point);

            this.mouseOver(event);
        },

        _mouseOut:function(event){

            var point = event.target.datum();
            if (!this._shouldHover(point)) {
                this.component.vanchart.hoverPoint = null;
                return;
            }
            var series = point.series,
                chart = series.chart.vanchart;

            //标记点类型的数据点根据位置来判断
            if(chart.hoverPoint && !chart.hoverPoint.marker){
                chart.hoverPoint = null;
            }

            this.mouseOut(event);
        },

        _seriesMouseOver:function(event){

            var series = event.target.datum(),
                chart = series.chart.vanchart,
                hoverPoint = chart.hoverPoint,
                hoverSeries = chart.hoverSeries,
                handler = chart.handler;

            // set normal state to previous series
            if (hoverSeries && hoverSeries !== series) {
                handler.fireEventByData(hoverSeries, 'forceMouseOut', event);
            }
            
            chart.hoverSeries = series;
            var closestPoint = series.chart.getClosestPoint(event.containerPoint);

            if(!hoverPoint || (hoverPoint && hoverPoint.series != series)){
                handler.fireEventByData(hoverPoint, 'mouseout', event);

                if (!this._shouldHover(closestPoint)) {
                    chart.hoverPoint = null;
                    chart.hoverPoint = null;
                    return;
                }

                handler.fireEventByData(closestPoint, 'mouseover', event);

                chart.hoverPoint = closestPoint;
            }

            this.seriesMouseOver(event);
        },

        _seriesMouseOut:function(event){

            var series = event.target.datum(),
                chart = series.chart.vanchart,
                hoverSeries = chart.hoverSeries,
                hoverPoint = chart.hoverPoint,
                handler = chart.handler;

            chart.hoverSeries = null;

            this.seriesMouseOut(event);
        },

        _shouldHover: function (point) {
            if (!point) {
                return false;
            }
            var chart = this.component.vanchart;
            var handler = chart.handler;
            var sharedAxis = chart.getSharedAxis();
            if (sharedAxis && sharedAxis.type === Constants.CATEGORY_AXIS_COMPONENT &&
                handler._getCoveredPointsByKey(point.category).length !== 0) {
                return false;
            }

            return true;
        },

        _canvasRender:function(){

            var dom = this.component.vanchart.getParentDom();
            var plotBounds = this.component.getPlotBounds();

            if(!this._canvas){
                this._canvas = new CanvasRender(dom, this.component.vanchart);
            }

            this._canvas.clearAll();

            var data = this.component.getVisibleChartData();

            for(var i = 0, len = data.length; i < len; i++){
                this._canvas.addSeries(data[i], plotBounds);
            }
        },

        _drawHorizontalAxisTitleWithHtml:function(title, titleBounds){
            var rotation = title.rotation || 0;
            var textDim = BaseUtils.getTextDimension(title.text, title.style, title.useHtml);
            var x, y;
            var align = this.component.getTitleAlign();
            switch(align){
                case 'left':
                    x = titleBounds.x;
                    break;
                case 'center':
                    x = titleBounds.x + titleBounds.width/2 - textDim.width/2;
                    break;
                case 'right':
                    x = titleBounds.x + titleBounds.width - textDim.width;
                    break;
            }

            y = titleBounds.y + titleBounds.height/2 - textDim.height/2;
            var div = this.labelDivManager.addLabel(title.text, {x:x, y:y}, title.style);
            BaseUtils.divRotate(div, rotation);

            //ie8 bug
            div.style.left = x + 'px';
            div.style.top = y + 'px';
        },

        _drawVerticalAxisTitleWithHtml:function(title, titleBounds){
            var rotation = title.rotation || 0;
            var textDim = BaseUtils.getTextDimension(title.text, title.style, title.useHtml);
            var rotatedDim = BaseUtils.getTextDimensionWithRotation(title.text, title.style, title.useHtml, rotation);
            var x, y;
            x = titleBounds.x + titleBounds.width/2 - textDim.width/2;
            var align = this.component.getTitleAlign();
            switch(align){
                case 'top':
                    y = Math.max(rotatedDim.height/2 - textDim.height, 0);
                    break;
                case 'center':
                    y = (titleBounds.height - textDim.height)/2;
                    break;
                case 'bottom':
                    y = titleBounds.height - rotatedDim.height/2 - textDim.height/2;
                    break;
            }

            y += titleBounds.y;
            var div = this.labelDivManager.addLabel(title.text, {x:x, y:y}, title.style);
            BaseUtils.divRotate(div, rotation);

            //ie bug
            div.style.left = x + 'px';
            div.style.top = y + 'px';
        },

        //可能只是更新选中系列,但没有选中效果
        seriesMouseOut:function(){

        },

        seriesMouseOver:function(){

        },

        mouseDown:function(){

        },

        mouseUp:function(){

        },

        mouseOver:function(){

        },

        mouseOut:function(){

        },

        remove:function(){

        }
    });
    
    return BaseRender;
});
/**
 * Created by eason on 15/9/25.
 */
define('render/AxisRender',['require','./BaseRender','../Constants','./RenderLibrary'],function(require){

    var BaseRender = require('./BaseRender');
    var Constants = require('../Constants');

    var AxisRender = BaseRender.extend({

        render:function(){
            var axisRenders = this.component.getAxisRender();

            for(var i = 0, len = axisRenders.length; i < len ; i++){
                axisRenders[i].render();
            }

        },

        dataChangeRender:function(){
            var axisRenders = this.component.getAxisRender();
            for(var i = 0, len = axisRenders.length; i < len ; i++){
                axisRenders[i].dataChangeRender();
            }
        },

        monitorRender:function(){
            var axisRenders = this.component.getAxisRender();

            for(var i = 0, len = axisRenders.length; i < len ; i++){
                axisRenders[i].monitorRender();
            }
        }
    });

    require('./RenderLibrary').register(Constants.AXIS_RENDER, AxisRender);

    return AxisRender;

});
/**
 * Created by eason on 15/5/15.
 * 坐标轴组建的定义
 */
define('component/Axis',['require','./Base','../utils/BaseUtils','../Constants','./CategoryAxis','./ValueAxis','./DateAxis','./Polar','../render/AxisRender','../ComponentLibrary'],function(require){

    var Base = require('./Base');
    var BaseUtils = require('../utils/BaseUtils');
    var Constants = require('../Constants');

    var CategoryAxis = require('./CategoryAxis');
    var ValueAxis = require('./ValueAxis');
    var DateAxis = require('./DateAxis');
    var Polar = require('./Polar');

    require('../render/AxisRender');

    var Axis = Base.extend({
        _refresh:function(){
            this._axisList = this._axisList || [];

            var option = this.option;
            var axisOption = this.componentOption;
            if(!BaseUtils.isArray(axisOption)){
                axisOption  = [axisOption];
            }

            //最终生成的坐标轴数应该和新的option一样
            var len = axisOption.length;

            for(var axisIndex = len; axisIndex < this._axisList.length; axisIndex++){
                this._axisList[axisIndex].remove();
                this._axisList[axisIndex] = null;
            }

            this._axisList.length = len;

            for(var axisIndex = len - 1; axisIndex >= 0; axisIndex--){

                //增加一个坐标轴序号的标记
                axisOption[axisIndex].axisIndex = axisIndex;

                if(this._axisList[axisIndex] && this._axisList[axisIndex].type != axisOption[axisIndex].type){
                    this._axisList[axisIndex].remove();
                    this._axisList[axisIndex] = null;
                }

                if(this._axisList[axisIndex]){
                    this._axisList[axisIndex].refresh(option, axisOption[axisIndex]);
                }else{
                    var AxisClass;
                    if (this.componentType === Constants.POLAR_COMPONENT) {
                        AxisClass = Polar;
                    } else {
                        var axisType = axisOption[axisIndex].type || Constants.VALUE_AXIS_COMPONENT;

                        if (axisType == Constants.VALUE_AXIS_COMPONENT) {
                            AxisClass = ValueAxis;
                        } else if (axisType == Constants.CATEGORY_AXIS_COMPONENT) {
                            AxisClass = CategoryAxis;
                        } else if (axisType == Constants.DATE_AXIS_COMPONENT) {
                            AxisClass = DateAxis;
                        }
                    }

                    this._axisList[axisIndex] = new AxisClass(this.vanchart, this.option, this.componentType, axisOption[axisIndex]);
                }

                this._axisList[axisIndex].refreshPolar && this._axisList[axisIndex].refreshPolar(this.option, axisOption[axisIndex]);
            }
        },

        fixBoundsByPlot:function(){

            var plotBounds = this.vanchart.getPlotBounds();

            var map = {};

            for(var i = 0, axisCount = this._axisList.length; i < axisCount; i++){

                var axis = this._axisList[i];

                var position = axis.getPosition();

                map[position] = map[position] || [];

                map[position].push(axis);
            }

            for(var position in map){

                var axisList = map[position];
                var isHorizontal = position == Constants.TOP || position == Constants.BOTTOM;

                for(var i = 0, count = axisList.length; i < count; i++){

                    var axis = axisList[i];

                    var baseBounds = plotBounds;
                    if (i > 0 && !axisList[i-1].isOnZero() ) {
                        baseBounds = axisList[i - 1].bounds;
                    }

                    var axisBounds = axis.bounds;

                    if(isHorizontal){

                        var y = position == Constants.TOP ? baseBounds.y - axisBounds.height : baseBounds.y + baseBounds.height;
                        axis.bounds = BaseUtils.makeBounds(baseBounds.x, y, baseBounds.width, axisBounds.height);

                    }else{

                        var x = position == Constants.LEFT ? baseBounds.x - axisBounds.width : baseBounds.x + baseBounds.width;
                        axis.bounds = BaseUtils.makeBounds(x, baseBounds.y, axisBounds.width, baseBounds.height);
                    }

                    axis._updateRange();

                    axis._updateDomainWhenSizeFixed();

                    axis._calculateTickData();

                    axis._initZoomStatus();
                }
            }

        },

        calculateTickData: function () {
            this._axisList.forEach(function (axis) {
                axis._updateRange();
                axis._calculateTickData();
            });
        },

        initAttributesWithSeries:function(){
            var axisCount = this._axisList.length;
            for(var i = axisCount - 1; i >= 0; i--){
                this._axisList[i].initAttributesWithSeries();
            }
        },

        doLayout:function(){

            var axisCount = this._axisList.length;
            for(var i = axisCount - 1; i >= 0; i--){
                this._axisList[i].doLayout();
            }
        },

        getAxis:function(axisIndex){
            if (axisIndex >= this._axisList.length) {
                axisIndex = 0;
            }
            return this._axisList[axisIndex];
        },

        axisZoom:function(downPos, upPos){
            this._axisList.forEach(function(axis){
                axis.axisZoom(downPos, upPos);
            });
        },

        //处理0值对齐
        dealOnZero:function(){
            this._axisList.forEach(function(axis){

                if(axis.isOnZero()){

                    axis.dealOnZero();

                    axis._updateRange();

                    axis._calculateTickData();

                    axis._initZoomStatus();
                }
            });
        },

        getAllAxis:function(){
            return this._axisList;
        },

        getAxisRender:function(){

            var axisRenders = [];

            this._axisList.forEach(function(axis){
                var axisRender = axis.getRender();
                if(axisRender){
                    axisRenders.push(axisRender);
                }
            });

            return axisRenders;
        }
    });
    
    require('../ComponentLibrary').register(Constants.AXIS_COMPONENT, Axis);

    return Axis;
});
/**
 * Created by Yuqian on 16/5/19.
 */

define('theme/Options',['require','../Constants'],function (require) {
    var Constants = require('../Constants');

    var options = {};

    options[Constants.PIE_CHART] = {
        plotOptions: {

        }
    };

    options[Constants.MULTIPIE_CHART] = {
        innerRadiusPct: 2/3,
        
        plotOptions: {
            borderWidth: 1,
            borderColor: 'rgb(255,255,255)',
            rotatable: true,
            gradual: 'lighter',
            center: [],
            innerRadius: 0,
            startAngle: 0,
            endAngle: 360,
            drilldown: true
        }
    };

    options[Constants.COLUMN_CHART] = {
        plotOptions: {
            categoryGap: '20%',
            gap: '20%'
        }

    };

    options[Constants.BAR_CHART] = {
        plotOptions: {

        }

    };

    options[Constants.LINE_CHART] = options[Constants.AREA_CHART] = {

        plotOptions:{
            large:false,

            marker:{
                symbol:'null_marker'
            },

            dataLabels:{
                "enabled": false,
                "align": "outside"
            }
        }
    };

    options[Constants.GAUGE_CHART] = {
        plotOptions: {

        }

    };

    options[Constants.RADAR_CHART] = {

        plotOptions:{
            columnType:false,
            marker:{
                symbol:'null_marker'
            },

            borderWidth:1,

            borderColor:'white',

            lineWidth:1,

            shape: 'circle'
        }

    };

    options[Constants.SCATTER_CHART] = {
        plotOptions: {
            fillColorOpacity:1,
            opacity:1
        }

    };

    options[Constants.BUBBLE_CHART] = {
        plotOptions: {
            fillColorOpacity:0.75,
            opacity:0.75
        }

    };

    options[Constants.AREA_MAP] = {
        plotOptions:{
            fillColor:'#cccccc',
            fillColorOpacity:0.75,
            borderColor:'#ffffff',
            borderWidth:1,
            borderOpacity:1
        }
    };

    options[Constants.POINT_MAP] = {
        plotOptions:{
            icon:{
                iconUrl:'../../doc/example/marker-icon.png',
                iconSize: [25, 41]
            }
        }
    };

    return options
});
/**
 * Created by eason on 16/5/23.
 * 地理坐标系的定义
 */

define('component/Geo',['require','./Base','../utils/BaseUtils','../utils/QueryUtils','../Constants','../theme/Options','../ComponentLibrary'],function(require){

    var Base = require('./Base');
    var BaseUtils = require('../utils/BaseUtils');
    var QueryUtils = require('../utils/QueryUtils');
    var Constants = require('../Constants');
    var Options = require('../theme/Options');

    var POINT  = 'Point';

    var getAllPoints = function(object, pointsArray) {
        if (object && d3_geo_streamObjectType.hasOwnProperty(object.type)) {
            d3_geo_streamObjectType[object.type](object, pointsArray);
        } else {
            d3_geo_streamGeometry(object, pointsArray);
        }
    };
    function d3_geo_streamGeometry(geometry, pointsArray) {
        if (geometry && d3_geo_streamGeometryType.hasOwnProperty(geometry.type)) {
            d3_geo_streamGeometryType[geometry.type](geometry, pointsArray);
        }
    }
    var d3_geo_streamObjectType = {
        Feature: function(feature, pointsArray) {
            d3_geo_streamGeometry(feature.geometry, pointsArray);
        },
        FeatureCollection: function(object, pointsArray) {
            var features = object.features, i = -1, n = features.length;
            while (++i < n) d3_geo_streamGeometry(features[i].geometry, pointsArray);
        }
    };
    var d3_geo_streamGeometryType = {
        Point: function(object, pointsArray) {
            pointsArray.push(object.coordinates);
        },
        MultiPoint: function(object, pointsArray) {
            var coordinates = object.coordinates, i = -1, n = coordinates.length;
            while (++i < n) object = coordinates[i], pointsArray.push(object);
        },
        LineString: function(object, pointsArray) {
            d3_geo_streamLine(object.coordinates, pointsArray);
        },
        MultiLineString: function(object, pointsArray) {
            var coordinates = object.coordinates, i = -1, n = coordinates.length;
            while (++i < n) d3_geo_streamLine(coordinates[i], pointsArray);
        },
        Polygon: function(object, pointsArray) {
            d3_geo_streamPolygon(object.coordinates, pointsArray);
        },
        MultiPolygon: function(object, pointsArray) {
            var coordinates = object.coordinates, i = -1, n = coordinates.length;
            while (++i < n) d3_geo_streamPolygon(coordinates[i], pointsArray);
        },
        GeometryCollection: function(object, pointsArray) {
            var geometries = object.geometries, i = -1, n = geometries.length;
            while (++i < n) d3_geo_streamGeometry(geometries[i], pointsArray);
        }
    };
    function d3_geo_streamLine(coordinates, pointsArray) {
        var i = -1, n = coordinates.length, coordinate;
        while (++i < n) coordinate = coordinates[i], pointsArray.push(coordinate);
    }

    function d3_geo_streamPolygon(coordinates, pointsArray) {
        var i = -1, n = coordinates.length;
        while (++i < n) d3_geo_streamLine(coordinates[i], pointsArray);
    }

    function get(resource){
        var mapData, key;
        if(typeof resource === 'string'){
            try{
                mapData = JSON.parse(resource);
            }catch (e){
                if(window.FR && window.FR.ajax){
                    FR.ajax({
                        type: 'GET',
                        url: resource,
                        dataType: 'json',
                        async: false,
                        success: function (result) {
                            key = resource;
                            mapData = result;
                        }
                    });
                }else{
                    d3.json(resource, function(result){
                        key = resource;
                        mapData = result;
                    });
                }
            }
        }else if(resource && typeof resource === 'object'){
            mapData = resource;
        }

        if(mapData){
            //给每个feature打个标记
            mapData.features.forEach(function(feature){
                feature.properties = feature.properties || {};
                feature.properties.id = BaseUtils.stamp(feature);
            });
        }

        return mapData;
    }

    var Geo = Base.extend({

        _refresh:function(){
            this._loaded = false;
            this.geoName = this.componentOption.name;
        },

        //每次钻取的时候要loadGeo的数据
        loadGeo:function(){

            if(this._loaded){
                return;
            }

            this._loaded = true;
            this.scale = 1;

            var cfg = this.componentOption, geo = this;
            var leaflet = this.vanchart._leaflet;

            this.maps = []; this._validPointName = {}; this._validAreaName = {};

            if(cfg.data){
                var maps = BaseUtils.isArray(cfg.data) ? cfg.data : [cfg.data];
                this.maps = maps.map(get);

                this.imageString = this.imageSuffix = this.imageWidth = this.imageHeight = null;
                if(this.maps.length){
                    this.imageString = this.maps[0].imageString;
                    this.imageSuffix = this.maps[0].imageSuffix;
                    this.imageWidth = this.maps[0].imageWidth;
                    this.imageHeight = this.maps[0].imageHeight;
                }

                this.maps.forEach(function(mapData){
                    var features = mapData.features || [];
                    for(var i = 0, len = features.length; i < len; i++){
                        var feature = features[i];
                        var geometry = feature.geometry;
                        if(geometry.type == POINT){//点地图
                            geo._validPointName[feature.properties.name] = geo._validPointName[feature.properties.name] || [];
                            geo._validPointName[feature.properties.name].push(feature);
                        }else{//区域地图
                            geo._validAreaName[feature.properties.name] = geo._validAreaName[feature.properties.name] || [];
                            geo._validAreaName[feature.properties.name].push(feature);
                        }
                    }
                });
            }

            if(cfg.tileLayer && !cfg.imageMap){
                // gis层级
                L.tileLayer(cfg.tileLayer).addTo(leaflet);
            }

            if(cfg.wmsUrl && cfg.wmsLayer){
                L.tileLayer.wms(cfg.wmsUrl, {layers: cfg.wmsLayer.join(',')}).addTo(leaflet);
            }

            if(this.imageString){
                leaflet._imageBackgroundLayer && leaflet._imageBackgroundLayer.remove();

                var chartWidth = this.vanchart.chartWidth();
                var chartHeight = this.vanchart.chartHeight();

                var wR = chartWidth / this.imageWidth;
                var wH = chartHeight / this.imageHeight;
                this.scale = Math.min(wR, wH);

                var showWidth = this.imageWidth, showHeight = this.imageHeight;

                showWidth *= this.scale;
                showHeight *= this.scale;
                this._scaleGeoJson(this.maps, this.scale);
                var bounds = [[0,0], [showHeight, showWidth]];
                var url = "data:image/"+this.imageSuffix+";base64," + this.imageString;
                leaflet._imageBackgroundLayer = L.imageOverlay(url, bounds).addTo(leaflet);
            }
        },

        //对图片类型的json数据,要更具具体的绘图区域大小做自适应
        _scaleGeoJson:function(maps, scale){
            if(maps && maps.length){
                maps.forEach(function(map){
                    var features = map.features;
                    for(var i = 0, len = features.length; i < len; i++){
                        var center = features[i].properties.center;
                        if(center){
                            center[0] *= scale;
                            center[1] *= scale;
                        }
                    }

                    var points = [];
                    getAllPoints(map, points);
                    for(var i = 0, len = points.length; i < len; i++){
                        points[i][0] *= scale;
                        points[i][1] *= scale;
                    }
                });
            }
        },

        //point的feature
        getDataPointLatLng:function(point, type){

            this.loadGeo();

            var type = type || point.series.type;

            var lnglat = [0, 0];

            if(point){
                if(point.lnglat){
                    lnglat = point.lnglat;
                }else if(point.feature || this._validPointName[point.name]){

                    var feature = point.feature || this._validPointName[point.name][0];
                    lnglat = type == Constants.POINT_MAP ? feature.geometry.coordinates : feature.properties.center;

                    if(!lnglat){
                        if(this._isImageMap()){
                            var points = [];
                            var lngMin = this.imageWidth,lngMax = 0;
                            var latMin = this.imageHeight, latMax = 0;
                            getAllPoints(feature, points);
                            points.forEach(function (point) {
                                lngMin = Math.min(lngMin, point[0]);
                                lngMax = Math.max(lngMax, point[0]);

                                latMin = Math.min(latMin, point[1]);
                                latMax = Math.max(latMax, point[1]);
                            });
                            lnglat = [(lngMax + lngMin)/2, (latMax + latMin)/2];
                        }else{
                            var bounds = d3.geo.bounds(feature);
                            var lng = (bounds[0][0] + bounds[1][0])/2;
                            var lat = (bounds[0][1] + bounds[1][1])/2;
                            lnglat = [lng, lat];
                        }
                    }
                }
            }

            return [lnglat[1], lnglat[0]];
        },

        getDefaultMapStyle:function(){
            var plotOptions = this.option.plotOptions;
            var queryList = [plotOptions[Constants.AREA_MAP],plotOptions,Options[Constants.AREA_MAP].plotOptions];
            var style =  {
                fillColor:QueryUtils.queryList(queryList, 'fillColor'),
                fillColorOpacity:QueryUtils.queryList(queryList, 'fillColorOpacity'),
                borderWidth:QueryUtils.queryList(queryList, 'borderWidth'),
                borderColor:QueryUtils.queryList(queryList, 'borderColor'),
                borderOpacity:QueryUtils.queryList(queryList, 'borderOpacity')
            };
            return style;
        },

        getDefaultIcon:function () {
            var plotOptions = this.option.plotOptions;
            var queryList = [plotOptions, plotOptions[Constants.POINT_MAP], Options[Constants.POINT_MAP].plotOptions];
            return QueryUtils.queryList(queryList, 'icon');
        },

        getZoomListener:function(){
            return this.componentOption.zoomListener;
        },

        getFeatureMap:function(series){

            this.loadGeo();

            var dStyle = this.getDefaultMapStyle();

            var areaFeatures = [], bubbleFeatures = [], scatterFeatures = [], imageFeatures = [];

            var validArea = {}, validPoint = {},geo = this, hasAreaMap = false;

            for(var i = 0, len = series.length; i < len; i++){
                var sery = series[i];

                //产品说是原始的系列里有area的时候才显示没有数据定义的区块
                if(sery.type == Constants.AREA_MAP){
                    hasAreaMap = true;
                }

                if(!sery.visible){
                    continue;
                }
                var type = sery.type;
                if(type == Constants.AREA_MAP){//面积类型的地图计算第一个有效的系列,考虑到多系列的情况
                    var points = sery.points;
                    for(var pIndex = points.length - 1; pIndex >= 0; pIndex--){
                        var point = points[pIndex];
                        var feature = geo._validAreaName[point.name];
                        //这一步是过滤数据里多余的和json里没有对应的数据
                        if(feature && feature.length){
                            if(point.visible && !validArea[point.name]){
                                validArea[point.name] = true;
                                feature.forEach(function(f, index){
                                    var p = BaseUtils.extend({}, point);
                                    BaseUtils.extend(p, f);
                                    BaseUtils.extend(p, point.isNull ? dStyle : point.mapStyle);
                                    p.feature = f;
                                    p.className = point.className + index;
                                    areaFeatures.push(p);
                                });
                            }
                        }
                    }
                }else{
                    //对于点地图,包括图片的点,和散点图和气泡图
                    var defaultIcon = this.getDefaultIcon();
                    sery.points.forEach(function(point){

                        if(!point.visible || point.isNull){
                            return ;
                        }

                        //注意过滤掉数据不对的点
                        if(point.lnglat || geo._validPointName[point.name]){

                            var duplicated = [point];

                            if(!point.lnglat){
                                duplicated = [];
                                var pointFeatures = geo._validPointName[point.name];
                                pointFeatures.forEach(function(f, index){
                                    var p = BaseUtils.extend({}, point);
                                    p.feature = f;
                                    p.className = point.className + index;
                                    duplicated.push(p);
                                });
                            }

                            for(var pIndex = duplicated.length - 1; pIndex >= 0; pIndex--){
                                var p = duplicated[pIndex];
                                var lnglat = geo.getDataPointLatLng(p).join(',');

                                //对于同一种类型的点,并且经纬度一样的时候,只取当前的第一个有效点
                                if(validPoint[type] && validPoint[type][lnglat]){
                                    continue;
                                }
                                validPoint[type] = validPoint[type] || {};
                                validPoint[type][lnglat] = true;

                                if(type == Constants.BUBBLE_CHART){
                                    bubbleFeatures.push(p);
                                }else if(type == Constants.POINT_MAP){
                                    p.icon = defaultIcon;
                                    imageFeatures.push(p);
                                }else{
                                    if(p.marker && BaseUtils.isImageMarker(p.marker.symbol)){
                                        p.icon = {
                                            iconUrl:point.marker.symbol,
                                            iconSize:[point.marker.width, point.marker.height]
                                        };
                                        imageFeatures.push(p);
                                    }else{
                                        scatterFeatures.push(p);
                                    }
                                }
                            }
                        }
                    });
                 }
            }

            if(hasAreaMap){
                for(var name in this._validAreaName){
                    var features = this._validAreaName[name];
                    features.forEach(function(f){
                        if(f.properties && !validArea[f.properties.name]){
                            areaFeatures.push(BaseUtils.extend({}, f, dStyle));
                        }
                    });
                }
            }

            return {
                areaFeatures:areaFeatures,
                bubbleFeatures:bubbleFeatures,
                scatterFeatures:scatterFeatures,
                imageFeatures:imageFeatures
            };
        },

        fitMapBounds:function(){

            this.loadGeo();

            var leaflet = this.vanchart._leaflet;
            var cfg = this.componentOption;

            var level;
            if(BaseUtils.hasDefined(cfg.zoomListener)){
                level = cfg.zoomListener;
            }else if(BaseUtils.hasDefined(cfg.zoomLevel)){
                level = cfg.zoomLevel;
            }

            var center = cfg.viewCenter ? L.latLng(cfg.viewCenter[1], cfg.viewCenter[0]) : null;

            if(!isNaN(+level) && center){
                leaflet.setView(center, level);
            }else{
                if(!isNaN(+level)){
                    leaflet.fitBounds(this._getFitBounds(),{animate:false});
                    var center = leaflet.getCenter();
                    leaflet.setView(center, level);
                }else{
                    leaflet.fitBounds(this._getFitBounds());
                }
                center && leaflet.panTo(center);
            }
        },

        _isImageMap:function(){
            return this.componentOption.imageMap;
        },

        //这个fitbounds既需要考虑json文件,还要考虑点地图的时候的在数据里写死了经纬度
        _getFitBounds:function(){

            //先统计数据里写死的经纬度信息,已写死的经纬度信息为准
            var byJson = true;
            var lngMin = 180, lngMax = -180, latMin = 90, latMax = -90;

            if(this._isImageMap()){
                lngMin = this.imageWidth; lngMax = 0;
                latMin = this.imageHeight; latMax = 0;
            }
            
            var series = this.vanchart.series;
            for(var i = 0, len = series.length; i < len; i++){
                if(series[i].visible && series[i].type != Constants.AREA_MAP){
                    series[i].points.forEach(function(point){
                        var lnglat = point.lnglat;
                        if(lnglat){

                            byJson = false;

                            lngMin = Math.min(lngMin, lnglat[0]);
                            lngMax = Math.max(lngMax, lnglat[0]);

                            latMin = Math.min(latMin, lnglat[1]);
                            latMax = Math.max(latMax, lnglat[1]);
                        }
                    });
                }
            }

            if(byJson && this.maps && this.maps.length){

                if(this._isImageMap()){

                    var allPoints = [];
                    this.maps.forEach(function(map){
                        getAllPoints(map, allPoints)
                    });

                    if(allPoints.length > 1){
                        allPoints.forEach(function (point) {
                            lngMin = Math.min(lngMin, point[0]);
                            lngMax = Math.max(lngMax, point[0]);

                            latMin = Math.min(latMin, point[1]);
                            latMax = Math.max(latMax, point[1]);
                        });
                    }

                }else{
                    var boxes = this.maps.map(d3.geo.bounds);

                    var southWest = boxes[0][0];
                    var northEast = boxes[0][1];

                    for(var i = boxes.length - 1; i > 0; i--){

                        var fitBounds = boxes[i];

                        southWest[0] = Math.min(fitBounds[0][0], southWest[0]);
                        southWest[1] = Math.min(fitBounds[0][1], southWest[1]);

                        northEast[0] = Math.max(fitBounds[1][0], northEast[0]);
                        northEast[1] = Math.max(fitBounds[1][1], northEast[1]);
                    }

                    return [[southWest[1], southWest[0]], [northEast[1], northEast[0]]];
                }
            }

            return [[latMin, lngMin],[latMax, lngMax]];
        }
    });
    
    require('../ComponentLibrary').register(Constants.GEO_COMPONENT, Geo);
    return Geo;
});
/**
 * Created by eason on 15/5/4.
 * 图例
 */
define('component/Legend',['require','./Base','../utils/BaseUtils','../utils/ColorUtils','../Constants','../utils/QueryUtils','../render/LegendIconFactory','../ComponentLibrary'],function(require){
    var Base = require('./Base');
    var BaseUtils = require('../utils/BaseUtils');
    var ColorUtils = require('../utils/ColorUtils');
    var Constants = require('../Constants');
    var QueryUtils = require('../utils/QueryUtils');
    var LegendIconFactory = require('../render/LegendIconFactory');

    var PADDING = 10;
    var GAP = 8;
    var BUTTON_HEIGHT = 12;
    var BUTTON_WIDTH = 52;
    var LINE_GAP = 4;
    var HORIZONTAL_GAP = 16;

    var Legend = Base.extend({

        _refresh:function(){
            this.render && this.render.remove();
        },

        initAttributesWithSeries:function(){

            this.items = [];

            this._updateLegendItems();
        },

        doLayout:function(){

            if(!this.componentOption.visible){
                return;
            }

            var usedSize = this._getLegendSize();

            this._setComponentBounds(this.componentOption.position || Constants.RIGHT_TOP, usedSize);

            this._resetLegendBounds();

            this._calculateVerticalPages();

            this.verticalAlign = 0;
            if(!this.hasEnoughSpace){
                var buttonWidth = BUTTON_WIDTH + 2 * PADDING;

                var moreSpace = Math.max(buttonWidth - this.bounds.width, 0);

                this.vanchart.bounds.width -= moreSpace;

                this.bounds.width += moreSpace;
                this.bounds.x -= moreSpace;

                this.verticalAlign = moreSpace/2;
            }
        },

        _updateLegendItems:function(){

            var series = this.vanchart.series;

            var namedSeries = {};

            var legend = this;

            series.map(function(sery){

                switch (sery.type) {
                    case Constants.GAUGE_CHART:
                        break;
                    case Constants.PIE_CHART:
                    case Constants.MULTIPIE_CHART:
                        var key = sery.type === Constants.PIE_CHART ? 'seriesName' : 'name';

                        sery.points.map(function (point) {
                            if(!(namedSeries[point[key]])){

                                var item = {color:point._color, itemName:point[key], visible:point.visible, pieDataIndex:point.index};

                                legend._mergeCommonLegendAttr(sery, item);

                                namedSeries[point[key]] = true;

                                legend.items.push(item);
                            }
                        });

                        legend.items.sort(function (a,b) {
                            return a.pieDataIndex - b.pieDataIndex;
                        });

                        break;

                    default:
                        if(!(namedSeries[sery.name])) {
                            var item = {color: sery.color, itemName: sery.name, visible: sery.visible};

                            legend._mergeCommonLegendAttr(sery, item);

                            namedSeries[sery.name] = true;

                            legend.items.push(item);
                        }
                }

            });

        },

        _calculateVerticalPages:function(){

            var position = this.componentOption.position || Constants.RIGHT;
            this.pages = [];

            if(position == Constants.TOP || position == Constants.BOTTOM){
                return;
            }

            var height = this.bounds.height;

            var preHeight = this.getPreHeight(this.items.length);

            if(preHeight <= height){
                this.hasEnoughSpace = true;
                return;
            }

            this.hasEnoughSpace = false;

            var pageIndex = 0;
            var startIndex = 0;
            var preHeight = 0;
            for(var itemIndex = 0, itemCount = this.items.length; itemIndex < itemCount; itemIndex++){

                var pageHeight = preHeight;
                preHeight = this.getPreHeight(startIndex, itemIndex + 1);

                if(preHeight > height){
                    pageIndex++;
                    startIndex = itemIndex;
                    this.bounds.height = pageHeight + BUTTON_HEIGHT;
                }

                this.pages[pageIndex] = this.pages[pageIndex] || [];
                this.pages[pageIndex].push(this.items[itemIndex]);
            }
        },

        _mergeCommonLegendAttr:function(sery, item){
            var cfg = this.componentOption;
            var hiddenColor = cfg.hiddenColor;
            var hoverColor = cfg.hoverColor || cfg.style.color;
            var colorOpacity = ColorUtils.getColorOpacityWithoutDefault(item.color);
            var color = ColorUtils.colorToHex(item.color);
            if(sery.type == Constants.RADAR_CHART && !sery.columnType){//雷达图的填充色透明度不影响图例
                colorOpacity = colorOpacity || 1;
            }else{
                colorOpacity = BaseUtils.hasDefined(colorOpacity) ? colorOpacity : sery.fillColorOpacity;
                colorOpacity = BaseUtils.hasDefined(colorOpacity) ? colorOpacity : 1;
            }


            BaseUtils.extend(item, {
                series:sery,
                color:color,
                fillColorOpacity:colorOpacity,
                hiddenColor:hiddenColor,
                hoverColor:hoverColor,
                legendIconType:this._getLegendType(sery),
                lineIndex:0//记录下如果换行的行号
            });

        },

        _getLegendSize:function(){
            var cfg = this.componentOption;
            var position = cfg.position || Constants.RIGHT;
            var padding = PADDING * 2;

            if(position == Constants.TOP || position == Constants.BOTTOM){

                var legendSize = this._getTopAndBottomLegendSize() + padding;

                var maxHeight = this._maxHeight();

                return (cfg.maxHeight && legendSize > maxHeight) ? maxHeight : legendSize;

            }else{

                var legendSize = this._getLeftAndRightLegendSize() + padding;

                //预测下能否放下
                var usedHeight = this.getPreHeight() + PADDING;
                var chartHeight = this.vanchart.getPlotBounds().height;
                if(usedHeight < chartHeight){
                    legendSize = Math.max(legendSize, BUTTON_WIDTH);
                }

                var maxWidth = this._maxWidth();

                return (cfg.maxWidth && legendSize > maxWidth) ? maxWidth : legendSize;
            }
        },

        _getLeftAndRightLegendSize:function(){
            this.maxLabelWidth = 0;
            this.maxLabelHeight = 0;

            this.maxIconWidth = 0;
            this.maxIconHeight = 0;

            for(var i = 0, len = this.items.length; i < len; i++){
                var labelDim = BaseUtils.getTextDimension(this.items[i].itemName, this.componentOption.style, true);
                this.maxLabelWidth = Math.max(this.maxLabelWidth, labelDim.width);
                this.maxLabelHeight = Math.max(this.maxLabelHeight, labelDim.height);

                var iconDim = LegendIconFactory.getLegendIconSize(this.items[i].legendIconType);
                this.maxIconWidth = Math.max(this.maxIconWidth, iconDim.width);
                this.maxIconHeight = Math.max(this.maxIconHeight, iconDim.height);
            }

            return PADDING * 2 + this.maxIconWidth + GAP + this.maxLabelWidth;
        },

        _getTopAndBottomLegendSize:function(){

            this.lineHeight = [];//换行的画记录每一行的高度

            var plotBonds = this.vanchart.getPlotBounds();

            var offeredWidth = plotBonds.width - 4 * PADDING;

            var usedWidth = 0;
            var maxLineHeight = 0;
            var lineIndex = 0;

            for(var i = 0, len = this.items.length; i < len; i++){

                var item = this.items[i];

                var iconSize = LegendIconFactory.getLegendIconSize(item.legendIconType);
                var labelDim = BaseUtils.getTextDimension(item.itemName, this.componentOption.style, true);

                //限制每个图例的最大宽度不会超过整个图例区域的宽度
                var iconWidth = Math.min(iconSize.width + GAP + labelDim.width, offeredWidth - 1);

                if(usedWidth + iconWidth < offeredWidth){
                    item.lineIndex = lineIndex;
                    maxLineHeight = Math.max(maxLineHeight, labelDim.height, iconSize.height);
                    usedWidth += iconWidth + HORIZONTAL_GAP;
                } else {
                    this.lineHeight.push(maxLineHeight);
                    if (i !== 0) {
                        lineIndex++;
                    }

                    item.lineIndex = lineIndex;
                    usedWidth = iconWidth;
                    maxLineHeight = Math.max(labelDim.height, iconSize.height);
                }

                if(i == len - 1){
                    this.lineHeight.push(maxLineHeight);
                }
            }

            var totalHeight = 0;
            this.lineHeight.forEach(function(d){
                totalHeight += (d + PADDING);
            });

            this.maxLineIndex = this.lineHeight.length - 1;

            if(this.componentOption.maxHeight){
                var maxHeight = this._maxHeight();

                this.maxLineIndex = -1;

                totalHeight = 0;

                while(totalHeight < maxHeight && this.maxLineIndex < this.lineHeight.length - 1){
                    var nextLineHeight = totalHeight + this.lineHeight[this.maxLineIndex + 1] + PADDING;
                    if(nextLineHeight < maxHeight){
                        totalHeight = nextLineHeight;
                        this.maxLineIndex++;
                    }else{
                        break;
                    }
                }
            }

            return  totalHeight;
        },

        _resetLegendBounds:function(){

            var position = this.componentOption.position;

            if(position == Constants.LEFT || position == Constants.RIGHT || position == Constants.RIGHT_TOP){

                //右或者右上方的时候剪掉可能占据的工具栏的高度
                if(!this.isFloat && (position == Constants.RIGHT || position == Constants.RIGHT_TOP)){
                    var toolbarHeight = this.vanchart.getToolbarHeight();
                    this.bounds.y += toolbarHeight;
                    this.bounds.height -= toolbarHeight;
                }

                var x = this.bounds.x + PADDING;
                var y = this.bounds.y + PADDING;
                var height = this.bounds.height - PADDING * 2;
                var width = this.bounds.width - PADDING * 2;

                var usedHeight = this.getPreHeight();

                usedHeight = Math.min(usedHeight, height);

                y += Math.round((height - usedHeight) / 2);

                if(position == Constants.RIGHT_TOP || this.isFloat){
                    this.bounds.height = usedHeight;
                }else{
                    this.bounds = {x:x, y:y, width:width, height:usedHeight};
                }

            }else{

                var x = this.bounds.x + PADDING;
                var y = this.bounds.y + PADDING;
                var height = this.bounds.height - PADDING * 2;
                var width = this.bounds.width - PADDING * 2;

                var usedWidth = width;
                //小于一行的时候区域比计算的要小
                if(this.lineHeight.length == 1){

                    usedWidth = PADDING * 2;
                    for(var i = 0, len = this.items.length; i < len; i++) {

                        var item = this.items[i];

                        var iconSize = LegendIconFactory.getLegendIconSize(item.legendIconType);
                        var labelDim = BaseUtils.getTextDimension(item.itemName, this.componentOption.style, true);

                        usedWidth += (iconSize.width + labelDim.width + GAP);
                    }

                    usedWidth += HORIZONTAL_GAP * (this.items.length - 1);

                    x += (width - usedWidth) / 2;
                }

                this.bounds = {x:x, y:y, width:usedWidth, height:height};

                if(position == Constants.BOTTOM) {
                    var zoomComponent = this.vanchart.getComponent(Constants.ZOOM_COMPONENT);
                    if (zoomComponent && zoomComponent.zoomToolEnabled()) {
                        this.bounds.y += zoomComponent.bounds.height;
                    }
                }
            }
        },

        getLegendItems:function(){
            if(this.isHorizontal()){

                var items = [];

                var maxLineIndex = this.maxLineIndex;

                this.items.forEach(function(item){
                    if(item.lineIndex <= maxLineIndex){
                        items.push(item);
                    }
                });

                return items;

            }else{
                return this.items;
            }
        },

        getLineHeight:function(){
            return this.lineHeight;
        },

        getPadding:function(){
            return PADDING;
        },

        getGap:function(){
            return GAP;
        },

        getHorizontalGap:function(){
            return HORIZONTAL_GAP;
        },

        getPreHeight:function(){

            var startIndex = 0;
            var endIndex = this.items.length;

            if(arguments.length == 1){
                endIndex = arguments[0];
            }else if(arguments.length == 2){
                startIndex = arguments[0];
                endIndex = arguments[1];
            }

            var height = PADDING;
            var labelHeight = this.maxLabelHeight;

            for(var i = startIndex; i < endIndex; i++){
                var item = this.items[i];
                var iconSize = LegendIconFactory.getLegendIconSize(item.legendIconType);
                height += (Math.max(iconSize.height, labelHeight) + LINE_GAP)
            }

            return Math.floor(height);
        },

        getVerticalItemHeight:function(index){
            var height = PADDING;
            var labelHeight = this.maxLabelHeight;

            var item = this.items[index];
            var iconSize = LegendIconFactory.getLegendIconSize(item.legendIconType);
            height += (Math.max(iconSize.height, labelHeight) + LINE_GAP);

            return height;
        },

        getHorizontalItemWidth:function(index){
            var item = this.items[index];
            var cfg = this.componentOption;

            var iconSize = LegendIconFactory.getLegendIconSize(item.legendIconType);
            var labelDim = BaseUtils.getTextDimension(item.itemName, cfg.style, true);

            return iconSize.width + GAP + labelDim.width + HORIZONTAL_GAP;
        },

        getHorizontalItemsWidth:function(items){

            var cfg = this.componentOption;
            var usedWidth = 0;

            for(var i = 0, len = items.length; i < len; i++) {

                var item = items[i];

                var iconSize = LegendIconFactory.getLegendIconSize(item.legendIconType);
                var labelDim = BaseUtils.getTextDimension(item.itemName, cfg.style, true);

                usedWidth += (iconSize.width + labelDim.width + GAP);
            }

            usedWidth += HORIZONTAL_GAP * (items.length - 1);

            return usedWidth;
        },

        getHorizontalLineItems:function(){
            var lineItems = [];
            for(var i = 0, len = this.items.length; i < len; i++){
                var item = this.items[i];
                if(item.lineIndex <= this.maxLineIndex){
                    lineItems[item.lineIndex] = lineItems[item.lineIndex] || [];
                    lineItems[item.lineIndex].push(item);
                }
            }

            return lineItems;
        },

        getVerticalPages:function(){
            return this.pages;
        },

        hasEnoughVerticalSpace:function(){
            return this.hasEnoughSpace;
        },

        getButtonHeight:function(){
            return BUTTON_HEIGHT;
        }
    });

    require('../ComponentLibrary').register(Constants.LEGEND_COMPONENT, Legend);
    return Legend;
});
/**
 * Created by eason on 15/7/3.
 * reused and modified tooltip component from echarts
 */
//Copyright (c) 2013, Baidu Inc.
//    All rights reserved.
//
//    Redistribution and use of this software in source and binary forms, with or
//    without modification, are permitted provided that the following conditions
//are met:
//
//    Redistributions of source code must retain the above copyright notice, this
//list of conditions and the following disclaimer.
//
//    Redistributions in binary form must reproduce the above copyright notice,
//    this list of conditions and the following disclaimer in the documentation
//and/or other materials provided with the distribution.
//
//    Neither the name of Baidu Inc. nor the names of its contributors may be used
//to endorse or promote products derived from this software without specific
//prior written permission of Baidu Inc.
//
//    THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
//AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
//IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
//DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR
//ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
//(INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
//LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON
//ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
//(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
//SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.

define('component/Tooltip',['require','./Base','../utils/BaseUtils','../Constants','../utils/ColorUtils','../ComponentLibrary'],function(require){

    var Base = require('./Base');
    var BaseUtils = require('../utils/BaseUtils');
    var Constants = require('../Constants');
    var ColorUtils = require('../utils/ColorUtils');

    var DEFAULT_DURATION = 0.4;

    var Tooltip = Base.extend({

        _gCssText: 'position:absolute;display:block;border-style:solid;white-space:nowrap;z-index:2000;-webkit-user-select:none;-moz-user-select:none;-o-user-select:none;user-select:none;pointer-events:none;',

        _style: function (opt) {
            if (!opt) {
                return '';
            }
            var cssText = [];
            if (opt.animation && !opt.follow) {
                var transitionText = 'left ' + DEFAULT_DURATION + 's,'
                    + 'top ' + DEFAULT_DURATION + 's';
                cssText.push(
                    'transition:' + transitionText
                );
                cssText.push(
                    '-moz-transition:' + transitionText
                );
                cssText.push(
                    '-webkit-transition:' + transitionText
                );
                cssText.push(
                    '-o-transition:' + transitionText
                );
            }

            if(opt.style){
                var fontStyle = BaseUtils.cssNormalization(opt.style);

                for(var styleName in fontStyle){
                    if(styleName == 'color'){
                        cssText.push(styleName + ':' + ColorUtils.colorToHex(fontStyle[styleName]));
                    }else{
                        cssText.push(styleName + ':' + fontStyle[styleName]);
                    }
                }
            }

            if (opt.backgroundColor) {
                if(typeof opt.backgroundColor == 'string'){
                    if(BaseUtils.isSupportSVG()){
                        cssText.push('background-Color:' + opt.backgroundColor);
                    }else{
                        var hexAlpha = ColorUtils.colorToHexAlpha(opt.backgroundColor);
                        cssText.push('background-Color:' + hexAlpha.hex);
                        cssText.push('filter:alpha(opacity=' + hexAlpha.alpha + ')')
                    }
                }else if(typeof opt.backgroundColor == 'object'){

                    var color = opt.backgroundColor;
                    var startColor = ColorUtils.colorToHex(color.startColor);
                    var endColor = ColorUtils.colorToHex(color.endColor);

                    var start = 'left';

                    var startPos = 'left top';
                    var endPos = 'right top';
                    var type = 1;

                    if(color.x1 == color.x2){
                        start = 'top';

                        startPos = 'left top';
                        endPos = 'left bottom';

                        type = 0;
                    }

                    cssText.push('background: -ms-linear-gradient(' + start + ', '+ startColor +', '+ endColor +')');

                    cssText.push('background-image: -moz-linear-gradient(' + start + ', '+ startColor +', '+ endColor +')');

                    cssText.push('background-image: -webkit-gradient(linear, '+startPos+', '+endPos+', color-stop(0, '+ startColor +'), color-stop(1, '+ endColor+'))');

                    cssText.push('filter: progid:DXImageTransform.Microsoft.gradient(startColorstr='+startColor + ', endColorstr='+endColor+', GradientType='+type+')');
                }
            }

            if (opt.borderWidth != null) {
                cssText.push('border-width:' + opt.borderWidth + 'px');
            }

            if (opt.borderColor != null) {
                cssText.push('border-color:' + opt.borderColor);
            }

            if (opt.borderRadius != null) {
                cssText.push(
                    'border-radius:' + opt.borderRadius + 'px'
                );
                cssText.push(
                    '-moz-border-radius:' + opt.borderRadius + 'px'
                );
                cssText.push(
                    '-webkit-border-radius:' + opt.borderRadius + 'px'
                );
                cssText.push(
                    '-o-border-radius:' + opt.borderRadius + 'px'
                );
            }

            if(opt.shadow){
                cssText.push('box-shadow:1px 1px 2px rgba(0,0,0,0.2)');
            }

            var padding = opt.padding;
            if (padding != null && padding != undefined) {
                padding = BaseUtils.reformCssArray(padding);
                cssText.push(
                    'padding:' + padding[0] + 'px '
                    + padding[1] + 'px '
                    + padding[2] + 'px '
                    + padding[3] + 'px'
                );
            }

            cssText = cssText.join(';') + ';';

            return cssText;
        },

        doLayout:function(){
            if(!this._tDom){
                var dom = this.vanchart.getDivParentDom();

                this._tDom = document.createElement('div');

                this._tDom.onselectstart = function() {
                    return false;
                };

                this._tDom.style.position = 'absolute';

                dom.appendChild(this._tDom);

                this._tooltipHideTick = null;
            }
        },

        remove:function(){
            if(this._tDom){
                var dom = this.vanchart.getDivParentDom();
                dom.removeChild(this._tDom);
            }
        },

        showWithPoint:function(point, event){
            if(point && point.visible && point.series.visible){
                var opt = point.tooltip;
                var tooltipDim  = this.calculateTooltipDivDim(opt, point.tooltipText);
                //优先从地图那边取数据点提示的位置
                var seriesChart = point.series.chart, vanchart = seriesChart.vanchart;
                var map = vanchart.getChart(Constants.MAP_CHART);
                var pos = (map || seriesChart).getTooltipPos(point, tooltipDim, event);
                this.show(pos, opt, point.tooltipText);
            }
        },
        
        showWithSharedPoints: function (points, event) {
            if (!points || points.length === 0) {
                this.hide();
                return;
            }
            var d = points.reduce(function (prev, curr) {
                return (prev.value > curr.value) ? prev : curr;
            });
            var opt = points[0].tooltip;
            var text = this._calculateTooltipContent(points);
            var tooltipDim  = this.calculateTooltipDivDim(opt, text);
            var tooltipPos = d.series.chart.getTooltipPos(d, tooltipDim, event);
            this.show(tooltipPos, opt, text);
        },

        show:function(pos, opt, tooltipText){

            if(pos && opt && tooltipText && !this.vanchart.isMouseDown){
                clearTimeout(this._tooltipHideTick);

                this._tDom.innerHTML = tooltipText;

                this._tDom.style.cssText = this._gCssText
                    + this._style(opt)
                    + 'left:' + pos[0] + 'px;top:' + pos[1] + 'px;';
            }

            if(BaseUtils.hasTouch()){
                this._tooltipHideTick = setTimeout(function(){
                    this._tDom.style.display = 'none';
                }.bind(this), 3000);
            }
        },

        hide:function(){

            clearTimeout(this._tooltipHideTick);

            this._tooltipHideTick = setTimeout(function(){
                this._tDom.style.display = 'none';
            }.bind(this), 400);

        },

        immediateHide:function(){
            this._tDom.style.display = 'none';
        },

        calculateTooltipDivDim:function(opt, tooltipText){

            opt = opt || '';

            var body = document.getElementsByTagName("body")[0];
            var testDiv = document.createElement('div');
            testDiv.innerHTML = tooltipText;
            testDiv.style.cssText = this._gCssText + this._style(opt) + 'visibility:hidden;';
            body.appendChild(testDiv);
            var width = testDiv.offsetWidth;
            var height = testDiv.offsetHeight;
            body.removeChild(testDiv);
            return {
                width:width,
                height:height
            };
        },

        _calculateTooltipContent:function(points){

            var categoryPoint;

            var tooltipContent = points.reduce(function (a, b) {

                var tooltip = b.tooltip;
                var formatter = tooltip.formatter;

                if (!formatter) {
                    return a;
                }

                categoryPoint = categoryPoint || b;

                if (typeof formatter == 'object') {

                    var style = tooltip.style;
                    var label = formatter.identifier;

                    var content = '';

                    content += '<span style="font-size:20px; font-family: verdana; color: ' + b.color + '">' + '&#9679  ' + '</span>';

                    content += b.series.chart._createSeriesLine(b, label, style, formatter);

                    content += '<br />';

                    return a + content;

                } else {
                    return a + BaseUtils.getFormatterFunction(formatter).call(b) + '<br />';
                }

            }, '');

            if (categoryPoint) {

                var tooltip = categoryPoint.tooltip;
                var formatter = tooltip.formatter;
                var style = tooltip.style;
                var label = formatter.identifier;
                var cateLabel;
                if(typeof formatter == 'object'){
                    cateLabel = categoryPoint.series.chart._createCategoryLine(categoryPoint, label, style, formatter)
                }else{
                    cateLabel = BaseUtils.getFormatterFunction(formatter).call(categoryPoint);
                }

                tooltipContent = cateLabel + tooltipContent;
            }

            return tooltipContent;
        }

    });

    require('../ComponentLibrary').register(Constants.TOOLTIP_COMPONENT, Tooltip);
    return Tooltip;
});
//Copyright (c) 2013 The New York Times
//
//Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the "Software"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions:
//
//    The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software.
//
//    THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE

define('utils/ExportUtils',['require','./BaseUtils'],function(require) {

    var BaseUtils = require('./BaseUtils');

    var doctype = '<?xml version="1.0" standalone="no"?><!DOCTYPE svg PUBLIC "-//W3C//DTD SVG 1.1//EN" "http://www.w3.org/Graphics/SVG/1.1/DTD/svg11.dtd">';

    window.URL = (window.URL || window.webkitURL);

    var body = document.body;

    var prefix = {
        xmlns: "http://www.w3.org/2000/xmlns/",
        xlink: "http://www.w3.org/1999/xlink",
        svg: "http://www.w3.org/2000/svg"
    };

    function cleanup() {
        var crowbarElements = document.querySelectorAll(".svg-export");

        [].forEach.call(crowbarElements, function(el) {
            el.parentNode.removeChild(el);
        });
    }


    function getSources(svg) {

        var styles =  "" ;

        svg.setAttribute("version", "1.1");

        var defsEl = document.createElement("defs");

        svg.insertBefore(defsEl, svg.firstChild);

        var styleEl = document.createElement("style")
        defsEl.appendChild(styleEl);
        styleEl.setAttribute("type", "text/css");

        svg.removeAttribute("xmlns");
        svg.removeAttribute("xlink");

        if (!svg.hasAttributeNS(prefix.xmlns, "xmlns")) {
            svg.setAttributeNS(prefix.xmlns, "xmlns", prefix.svg);
        }

        if (!svg.hasAttributeNS(prefix.xmlns, "xmlns:xlink")) {
            svg.setAttributeNS(prefix.xmlns, "xmlns:xlink", prefix.xlink);
        }

        var source = (new XMLSerializer()).serializeToString(svg).replace('</style>', '<![CDATA[' + styles + ']]></style>');

        return [doctype + source];
    }

    function toSvg(svgNode, config) {

        cleanup();

        var source = getSources(svgNode);

        var fileName = config.fileName;

        var url = window.URL.createObjectURL(new Blob(source, { "type" : "text\/xml" }));

        var a = document.createElement("a");
        body.appendChild(a);
        a.setAttribute("class", "svg-export");
        a.setAttribute("download", fileName + ".svg");
        a.setAttribute("href", url);
        a.style["display"] = "none";
        a.click();

        setTimeout(function() {
            window.URL.revokeObjectURL(url);
        }, 10);
    }

    function toImage(svgNode, config, chartDim){
        toSvg(svgNode, config, chartDim);
    }

    return {
        toImage:toImage
    };
});
/**
 * Created by eason on 15/8/24.
 */

define('render/ToolbarIconSvgRender',['require','../utils/BaseUtils','../Constants','../utils/ExportUtils','../dom/DomEvent'],function(require){

    //icon的几种状态
    var SELECTED = 'selected';
    var HOVER = 'hover';

    //icon的几种背景颜色
    var OPEN_NOMAL = 'rgba(0,0,0,0.05)';
    var OPEN_HOVER = 'rgba(0,0,0,0.1)';
    var OPEN_SELECTED = 'rgba(0,0,0,0.1)';

    var CLOSED_NORMAL = 'rgba(0,0,0,0.0)';
    var CLOSED_HOVER = 'rgba(0,0,0,0.05)';
    var CLOSED_SELECTED = 'rgba(0,0,0,0.1)';

    var RECT_R = 2;

    var BaseUtils = require('../utils/BaseUtils');
    var Constants = require('../Constants');
    var ExportUtils = require('../utils/ExportUtils');
    var DomEvent = require('../dom/DomEvent');

    function ToolbarIconSvgRender(toolbarIcon, toolbar){
        this.toolbarIcon = toolbarIcon;
        this.toolbar = toolbar;
    }

    ToolbarIconSvgRender.prototype = {
        constructor:ToolbarIconSvgRender,

        render:function(toolBarG){

            var iconSize = this.toolbar.getIconSize();
            var pos = this.toolbarIcon.getIconPos();
            var isVisible = this.toolbarIcon.visible;

            this.iconG = toolBarG
                .append('g')
                .attr('transform', 'translate('+ pos.x +','+ pos.y +')')
                .attr('display', isVisible ? '' : 'none');

            this.iconG.append('rect')
                .attr('width', iconSize)
                .attr('height', iconSize)
                .attr('rx', RECT_R)
                .attr('ry', RECT_R)
                .style('fill', this._isOpen() ? OPEN_NOMAL : CLOSED_NORMAL);

            this._createIcon();

            this._addListeners();
        },

        _iconAnimation:function(moveIndex, delay, visible){

            var iconG = this.iconG;
            var pos = this.toolbarIcon.getIconPos();

            setTimeout(function(){

                if(visible){
                    iconG.attr('display', '');
                }

                var moveDet = 4 * moveIndex;

                var leftX = pos.x - moveDet;

                iconG
                    .transition()
                    .ease('circle-out')
                    .duration(100)
                    .attr('transform', 'translate('+ leftX +','+ pos.y +')')
                    .transition()
                    .ease('circle-in')
                    .duration(100)
                    .attr('transform', 'translate('+ pos.x +','+ pos.y +')')
                    .each('end', function(){
                        d3.select(this).attr('display', visible ? '' : 'none')
                    });

                iconG.select('rect')
                    .style('fill', visible ? CLOSED_NORMAL : OPEN_NOMAL)
                    .transition()
                    .ease('linear')
                    .duration(200)
                    .style('fill', visible ? OPEN_NOMAL : CLOSED_NORMAL);

                iconG.select('g')
                    .style('opacity', visible ? 0 : 1)
                    .transition()
                    .ease('linear')
                    .duration(200)
                    .style('opacity', visible ? 1 : 0);

            }, delay);

        },

        backToOrigin:function(){
            var pos = this.toolbarIcon.getIconPos();
            this.iconG.attr('transform', 'translate('+ pos.x +','+ pos.y +')');
        },

        showIcon:function(){
            if(arguments.length){
                this._iconAnimation(arguments[0], arguments[1], true);
            }else{
                this.iconG.attr('display', '');
            }

        },

        hideIcon:function(){
            if(arguments.length){
                this._iconAnimation(arguments[0], arguments[1], false);
            }else{
                this.iconG.attr('display', 'none');
            }
        },

        refreshMove:function(left, right){

            var pos = this.toolbarIcon.getIconPos();

            var translate = d3.transform(this.iconG.attr('transform')).translate;

            var currentX = translate[0];

            var leftPos = currentX - left;
            var rightPos = leftPos + right;

            this.iconG
                .transition()
                .ease('circle-out')
                .duration(220)
                .attr('transform', 'translate('+ leftPos +','+ pos.y +')')
                .transition()
                .ease('circle-in')
                .duration(220)
                .attr('transform', 'translate('+ rightPos +','+ pos.y +')');
        },

        refreshMoveWithoutAnimation:function(left, right){

            var pos = this.toolbarIcon.getIconPos();
            var translate = d3.transform(this.iconG.attr('transform')).translate;

            var currentX = translate[0];

            var rightPos = currentX - left + right;

            this.iconG
                .attr('transform', 'translate('+ rightPos +','+ pos.y +')');

        },

        _isOpen:function(){
            return this.toolbar.isOpen;
        },

        _addListeners:function(){
            var iconG = this.iconG;
            var self = this;

            var toolBar = this.toolbar;
            var vanchart = toolBar.vanchart;
            var toolBarOption = toolBar.componentOption;
            var dom = toolBar.vanchart.getParentDom();
            var svgRoot = this.toolbar.getVanchartRender().getRenderRoot();

            var icon = this.toolbarIcon;
            var refreshIcon = toolBar.getRefreshIcon();

            var chartDim = {width:vanchart.chartWidth(), height:vanchart.chartHeight()};

            iconG
                .style('cursor', 'pointer')
                .on('click', function(){
                    switch (icon.iconType){
                        case Constants.REFRESH_ICON:
                            vanchart.refreshRestore();
                            refreshIcon.hideIcon();
                            break;
                        case Constants.INCREASE_ICON:
                            icon.iconType = Constants.DECREASE_ICON;
                            iconG.select('path').attr('d', icon.getDecreaseIconPath());
                            vanchart.refreshIncreaseOrder();
                            refreshIcon.showIcon();
                            break;
                        case Constants.DECREASE_ICON:
                            icon.iconType = Constants.INCREASE_ICON;
                            iconG.select('path').attr('d', icon.getIncreaseIconPath());
                            vanchart.refreshDecreaseOrder();
                            refreshIcon.showIcon();
                            break;
                        case Constants.EXPORT_ICON:
                            ExportUtils.toImage(svgRoot.node(), toolBarOption['toImage'], chartDim);
                            break;
                        case Constants.MAX_ICON:
                            BaseUtils.showLightBox(toolBar.vanchart.restoreOption);
                            break;
                        case Constants.MIN_ICON:
                            BaseUtils.hideLightBox(dom);
                            break;
                        case Constants.MENU_ICON:
                            toolBar.showOrHide();
                            break;
                    }
                })
                .on('mouseenter', function(){

                    iconG.select('rect').style('fill', self._isOpen() ? OPEN_HOVER : CLOSED_HOVER);

                })
                .on('mouseleave', function(){

                    iconG.select('rect').style('fill', self._isOpen() ? OPEN_NOMAL : CLOSED_NORMAL);

                })
                .on('mouseup', function(){
                    DomEvent.stopPropagation(d3.event);
                })
                .on('mousedown', function(){
                    DomEvent.stopPropagation(d3.event);
                });

        },

        _createIcon:function(){
            var iconG = this.iconG;

            var icon = this.toolbarIcon;
            var iconType = icon.iconType;

            switch (iconType){
                case Constants.REFRESH_ICON:
                    iconG.append('path')
                        .attr('d', icon.getRefreshIconPath())
                        .style('fill', '#FF9933');
                    break;
                case Constants.INCREASE_ICON:
                    iconG.append('path')
                        .attr('d', icon.getIncreaseIconPath())
                        .style('fill', '#33CCFF');
                    break;
                case Constants.DECREASE_ICON:
                    iconG.append('path')
                        .attr('d', icon.getDecreaseIconPath())
                        .style('fill', '#33CCFF');
                    break;
                case Constants.EXPORT_ICON:
                    iconG.append('path')
                        .attr('d', icon.getExportIconPath())
                        .style('fill', '#6666CC');
                    break;
                case Constants.MAX_ICON:
                    iconG.append('path')
                        .attr('d', icon.getMaxIconPath())
                        .style('fill', '#33CC66');
                    break;
                case Constants.MIN_ICON:
                    iconG.append('path')
                        .attr('d', icon.getMinIconPath())
                        .style('fill', '#33CC66');
                    break;
                case Constants.MENU_ICON:
                    iconG.append('path')
                        .attr('d', icon.getMenuIconPath())
                        .style('stroke-width', 2)
                        .style('stroke', '#AAAAAA');
                    break;
            }
        }
    };

    return ToolbarIconSvgRender;

});
/**
 * Created by eason on 15/8/24.
 */

define('render/ToolbarIconVmlRender',['require','../utils/BaseUtils','../Constants','../utils/ExportUtils','../dom/DomEvent'],function(require){

    //icon的几种状态
    var SELECTED = 'selected';
    var HOVER = 'hover';

    //icon的几种背景颜色
    var OPEN_NOMAL = 'rgb(0,0,0)';
    var OPEN_NORMAL_OPACITY = 0.05;

    var OPEN_HOVER = 'rgb(0,0,0)';
    var OPEN_HOVER_OPACITY = 0.1;

    var CLOSED_NORMAL = 'rgb(0,0,0)';
    var CLOSED_NORMAL_OPACITY = 0;

    var CLOSED_HOVER = 'rgb(0,0,0)';
    var CLOSED_HOVER_OPACITY = 0.05;

    var RECT_R = 2;

    var BaseUtils = require('../utils/BaseUtils');
    var Constants = require('../Constants');
    var ExportUtils = require('../utils/ExportUtils');
    var DomEvent = require('../dom/DomEvent');

    function ToolbarIconVmlRender(toolbarIcon, toolbar){
        this.toolbarIcon = toolbarIcon;
        this.toolbar = toolbar;
        this.currentPos = [];
    }

    ToolbarIconVmlRender.prototype = {
        constructor:ToolbarIconVmlRender,

        render:function(paper){

            var toolbarPos = this.toolbar.getToolbarPos();
            var pos = this.toolbarIcon.getIconPos();
            var x = pos.x + toolbarPos.x;
            var y = pos.y + toolbarPos.y;

            this.currentPos = [x, y];

            var iconSize = this.toolbar.getIconSize();
            var isVisible = this.toolbarIcon.visible;

            this.itemSet = paper.set();

            this.background = paper.rect(0, 0, iconSize, iconSize)
                .attr('fill', this._isOpen() ? OPEN_NOMAL : CLOSED_NORMAL)
                .attr('fill-opacity', this._isOpen() ? OPEN_NORMAL_OPACITY : CLOSED_NORMAL_OPACITY)
                .attr('rx', RECT_R)
                .attr('ry', RECT_R)
                .attr('stroke-width', 0);

            this.foreground = paper.path().attr(this._getIconStyle());

            this.itemSet.push(this.background);
            this.itemSet.push(this.foreground);

            this.itemSet.transform('t' + x + ',' + y);

            if(!isVisible){
                this.itemSet.hide();
            }

            this._addListeners();
        },

        _getIconStyle:function(){
            var icon = this.toolbarIcon;
            var iconType = icon.iconType;
            switch (iconType){
                case Constants.REFRESH_ICON:
                    return {
                        path:icon.getRefreshIconPath(),
                        fill:'#FF9933',
                        'stroke-width':0
                    };
                case Constants.INCREASE_ICON:
                    return {
                        path:icon.getIncreaseIconPath(),
                        fill:'#33CCFF',
                        'stroke-width':0
                    };
                case Constants.DECREASE_ICON:
                    return {
                        path:icon.getDecreaseIconPath(),
                        fill:'#33CCFF',
                        'stroke-width':0
                    };
                case Constants.EXPORT_ICON:
                    return {
                        path:icon.getExportIconPath(),
                        fill:'#6666CC',
                        'stroke-width':0
                    };
                case Constants.MAX_ICON:
                    return {
                        path:icon.getMaxIconPath(),
                        fill:'#33CC66',
                        'stroke-width':0
                    };
                case Constants.MIN_ICON:
                    return {
                        path:icon.getMinIconPath(),
                        fill:'#33CC66',
                        'stroke-width':0
                    };
                case Constants.MENU_ICON:
                    return {
                        path:icon.getMenuIconPath(),
                        'stroke-width':2,
                        stroke:'#AAAAAA',
                        fill:'none'
                    };
            }
        },

        _addListeners:function(){
            var iconG = this.iconG;
            var self = this;

            var toolBar = this.toolbar;
            var toolBarOption = toolBar.componentOption;
            var dom = toolBar.vanchart.getDivParentDom();
            var paper = this.toolbar.getVanchartRender().getRenderRoot();

            var icon = this.toolbarIcon;
            var vanchart = toolBar.vanchart;
            var refreshIcon = toolBar.getRefreshIcon();

            var chartDim = {width:vanchart.chartWidth(), height:vanchart.chartHeight()};

            this.itemSet.forEach(function(comp){

                var self = this;

                comp.attr('cursor', 'pointer');

                comp.click(function(e){
                    switch (icon.iconType){
                        case Constants.REFRESH_ICON:
                            vanchart.refreshRestore();
                            refreshIcon.hideIcon();
                            break;
                        case Constants.INCREASE_ICON:
                            icon.iconType = Constants.DECREASE_ICON;
                            self.foreground.attr('path', icon.getDecreaseIconPath());
                            vanchart.refreshIncreaseOrder();
                            refreshIcon.showIcon();
                            break;
                        case Constants.DECREASE_ICON:
                            icon.iconType = Constants.INCREASE_ICON;
                            self.foreground.attr('path', icon.getIncreaseIconPath());
                            vanchart.refreshDecreaseOrder();
                            refreshIcon.showIcon();
                            break;
                        case Constants.EXPORT_ICON:
                            ExportUtils.toImage(paper, toolBarOption['toImage'], chartDim);
                            break;
                        case Constants.MAX_ICON:
                            BaseUtils.showLightBox(toolBar.vanchart.restoreOption);
                            break;
                        case Constants.MIN_ICON:
                            BaseUtils.hideLightBox(dom);
                            break;
                        case Constants.MENU_ICON:
                            toolBar.showOrHide();
                            break;
                    }
                });

                comp.mouseover(function(){

                    self.background
                        .attr('fill', self._isOpen() ? OPEN_HOVER : CLOSED_HOVER)
                        .attr('fill-opacity', self._isOpen ? OPEN_HOVER_OPACITY: CLOSED_HOVER_OPACITY);

                });

                comp.mouseout(function(){

                    self.background
                        .attr('fill', self._isOpen() ? OPEN_NOMAL : CLOSED_NORMAL)
                        .attr('fill-opacity', self._isOpen() ? OPEN_NORMAL_OPACITY : CLOSED_NORMAL_OPACITY);

                });

                comp.mouseup(function(e){
                    DomEvent.stopPropagation(e);
                });

                comp.mousedown(function(e){
                    DomEvent.stopPropagation(e);
                })

            }, this);

        },

        _isOpen:function(){
            return this.toolbar.isOpen;
        },

        showIcon:function(){
            this.itemSet.show();
        },

        hideIcon:function(){
            this.itemSet.hide();
        },

        refreshMove:function(left, right){

            var det = right - left;
            this.currentPos[0] += det;

            var x = this.currentPos[0];
            var y = this.currentPos[1];

            this.itemSet.transform('t' + x + ',' + y);
        },

        refreshMoveWithoutAnimation:function(left, right){
            this.refreshMove(left, right);
        },

        backToOrigin:function(){
            var toolbarPos = this.toolbar.getToolbarPos();
            var pos = this.toolbarIcon.getIconPos();
            var x = pos.x + toolbarPos.x;
            var y = pos.y + toolbarPos.y;
            this.currentPos = [x, y];
            this.itemSet.transform('t' + x + ',' + y);
        }
    };

    return ToolbarIconVmlRender;

});
/**
 * Created by eason on 15/8/24.
 */

define('component/ToolbarIcon',['require','./Base','../utils/BaseUtils','../Constants','../utils/ExportUtils','../render/ToolbarIconSvgRender','../render/ToolbarIconVmlRender'],function(require){

    //icon的几种状态
    var SELECTED = 'selected';
    var HOVER = 'hover';

    //icon的几种背景颜色
    var OPEN_NOMAL = 'rgba(0,0,0,0.05)';
    var OPEN_HOVER = 'rgba(0,0,0,0.1)';
    var OPEN_SELECTED = 'rgba(0,0,0,0.1)';

    var CLOSED_NORMAL = 'rgba(0,0,0,0.0)';
    var CLOSED_HOVER = 'rgba(0,0,0,0.05)';
    var CLOSED_SELECTED = 'rgba(0,0,0,0.1)';

    var RECT_R = 2;
    var ICON_SIZE = 32;
    var ICON_GAP = 1;
    var GAP = ICON_SIZE + ICON_GAP;

    var Base = require('./Base');
    var BaseUtils = require('../utils/BaseUtils');
    var Constants = require('../Constants');
    var ExportUtils = require('../utils/ExportUtils');

    var SvgRender = require('../render/ToolbarIconSvgRender');
    var VmlRender = require('../render/ToolbarIconVmlRender');

    function ToolbarIcon(iconType, toolbar, pos, visible){
        this.iconType = iconType;
        this.toolbar = toolbar;
        this.visible = visible;
        this.pos = pos;
        this.iconG = null;
        this.iconRender = BaseUtils.isSupportSVG() ? new SvgRender(this, toolbar) : new VmlRender(this, toolbar);
    }

    ToolbarIcon.prototype = {
        constructor:ToolbarIcon,

        render:function(toolBarG){
            this.iconRender.render(toolBarG);
        },

        showIcon:function(){
            if (this.visible) {
                return;
            }

            if(arguments.length){
                this.iconRender.showIcon(arguments[0], arguments[1]);
            }else{
                this.iconRender.showIcon();
            }
            this.visible = true;

            var title = this.toolbar.vanchart.getComponent(Constants.TITLE_COMPONENT);

            if (this.iconType === Constants.REFRESH_ICON) {
                title && title.changeTextRightSpace(GAP);
            }
        },

        hideIcon:function(index, delay){
            if (!this.visible) {
                return;
            }

            if(arguments.length){
                this.iconRender.hideIcon(arguments[0], arguments[1]);
            }else{
                this.iconRender.hideIcon();
            }
            this.visible = false;

            var title = this.toolbar.vanchart.getComponent(Constants.TITLE_COMPONENT);

            if (this.iconType === Constants.REFRESH_ICON) {
                title && title.changeTextRightSpace(-GAP);
            }

            if(!this.toolbar.isOpen && this.iconType == Constants.REFRESH_ICON){
                this.iconRender.backToOrigin();
            }
        },

        refreshMove:function(left, right){
            this.iconRender.refreshMove(left, right);
        },

        refreshMoveWithoutAnimation:function(left, right){
            this.iconRender.refreshMoveWithoutAnimation(left, right);
        },

        getIconPos:function(){
            return this.pos;
        },

        getMaxIconPath:function(){
            return 'M24,8v6.5L21.5,12l-3,3L17,13.5l3-3L17.5,8H24z M15,18.5l-3,3l2.5,2.5H8v-6.5l2.5,2.5l3-3L15,18.5z';
        },

        getMinIconPath:function(){
            return 'M15,17v6.5L12.5,21l-3,3L8,22.5l3-3L8.5,17H15z M24,9.5l-3,3l2.5,2.5H17V8.5l2.5,2.5l3-3L24,9.5z';
        },

        getIncreaseIconPath:function(){
            return 'M8,20h16v2H8V20z M10,16h2v3h-2V16z M13,14h2v5h-2V14z M16,12h2v7h-2V12z M19,9h2v10h-2V9z';
        },

        getDecreaseIconPath:function(){
            return 'M8,20h16v2H8V20z M10,9h2v10h-2V9z M13,12h2v7h-2V12z M16,15h2v4h-2V15z M19,16h2v3h-2V16z';
        },

        getExportIconPath:function(){
            return 'M22,8H8v16h16V10L22,8z M16,10h2v4h-2V10z M22,22H10V10h1v5h9v-5h1.171L22,10.829V22z';
        },

        getRefreshIconPath:function(){
            return 'M21.656,10.344C20.209,8.896,18.209,8,16,8c-3.43,0-6.354,2.158-7.492,5.19l1.873,0.703C11.234,11.619,13.428,10,16,10c1.657,0,3.156,0.672,4.243,1.757L18,14h6V8L21.656,10.344z M16,22c-1.657,0-3.156-0.671-4.243-1.757L14,18H8v6l2.344-2.344C11.791,23.104,13.791,24,16,24c3.43,0,6.354-2.158,7.492-5.19l-1.873-0.703C20.766,20.381,18.572,22,16,22z';
        },

        getMenuIconPath:function(){
            return 'M8,10L24,10 M8,15L24,15 M8,20L24,20';
        }

    };

    return ToolbarIcon;
});
/**
 * Created by eason on 15/7/27.
 * 工具栏组建
 */
define('component/Toolbar',['require','./Base','../utils/BaseUtils','../Constants','../utils/ExportUtils','./ToolbarIcon','../ComponentLibrary'],function(require){
    var Base = require('./Base');
    var BaseUtils = require('../utils/BaseUtils');
    var Constants = require('../Constants');
    var ExportUtils = require('../utils/ExportUtils');
    var ToolbarIcon = require('./ToolbarIcon');

    var ICON_SIZE = 32;
    var ICON_GAP = 1;
    var DEFAULT_GAP = 5;

    var Toolbar = Base.extend({
        doLayout:function(){

            var option = this.componentOption;

            if(!option.enabled || !this._needLayout){
                return;
            }

            //工具栏只需要布局一次
            this._needLayout = false;

            this.toolbarIcons = [];
            this.pos = {x:0, y:0};

            var icons = [Constants.REFRESH_ICON];
            this._registerIcons('sort', Constants.INCREASE_ICON, icons);

            //ie678不支持前台导出
            if(BaseUtils.isSupportSVG() && !BaseUtils.isIE() && !this.option.geo){
                this._registerIcons('toImage', Constants.EXPORT_ICON, icons);
            }

            this._registerIcons('fullScreen', Constants.MAX_ICON, icons);
            this._registerIcons('exitFullScreen', Constants.MIN_ICON, icons);

            if(this.componentOption.hidden){
                icons.push(Constants.MENU_ICON);
            }

            var GAP = ICON_SIZE + ICON_GAP;
            var size = icons.length * GAP + DEFAULT_GAP;

            var startX = this.vanchart.chartWidth() - size;

            this.pos = {x:startX, y:DEFAULT_GAP};
            var isOpen = !this.componentOption.hidden;
            for(var iconIndex = 0, len = icons.length; iconIndex < len; iconIndex++){
                var pos = {x:iconIndex * GAP, y:0};
                var type = icons[iconIndex];

                if(type == Constants.MENU_ICON){
                    this.menuIcon = new ToolbarIcon(type, this, pos, true);
                }else if(type == Constants.REFRESH_ICON){
                    this.refreshIcon = new ToolbarIcon(type, this, pos, false);
                }else{
                    this.toolbarIcons.push(new ToolbarIcon(type, this, pos, isOpen));
                }
            }
        },

        _registerIcons:function(iconKey, iconType, icons){
            var option = this.componentOption;
            if(option[iconKey] && option[iconKey].enabled){
                icons.push(iconType);
            }
        },

        getToolbarPos:function(){
            return this.pos;
        },

        getToolbarIcons:function(){
            return this.toolbarIcons;
        },

        getRefreshIcon:function(){
            return this.refreshIcon;
        },

        showRefreshIconWhenZoom:function(){

            if(!this.refreshIcon.visible){

                if(this.menuIcon){

                    if(this.isOpen){
                        this.refreshIcon.showIcon();
                    }else{

                        this.refreshIcon.showIcon();

                        var toolbarIcons = this.toolbarIcons;
                        var iconSize = toolbarIcons.length;

                        var refreshIcon = this.refreshIcon;

                        var left = 4 * (iconSize + 1) ;
                        var right = 4 * (iconSize + 1) + 33 * iconSize;

                        if(refreshIcon.visible){
                            refreshIcon.refreshMoveWithoutAnimation(left, right);
                        }

                    }

                }else{
                    this.refreshIcon.showIcon();
                }

                var title = this.vanchart.getComponent(Constants.TITLE_COMPONENT);

                if(title && !title.isFloat){
                    //横向平移
                    var GAP = ICON_SIZE + ICON_GAP;
                    title.changeTextRightSpace(this.refreshIcon.visible ? GAP : -GAP);
                }
            }

        },

        showOrHide:function(){
            this.isOpen ? this.render.hide() : this.render.show();

            this.isOpen = !this.isOpen;

            var GAP = ICON_SIZE + ICON_GAP;

            var width = this.toolbarIcons.length * GAP;

            if(this.isOpen){
                width = -width;
            }

            var title = this.vanchart.getComponent(Constants.TITLE_COMPONENT);

            if(title && !title.isFloat){
                //横向平移
                title.changeTextRightSpace(-width);
            }

        },

        getIconSize:function(){
            return ICON_SIZE;
        },

        getToolbarWidth:function(){
            if (!this.componentOption.enabled) {
                return 0;
            }
            //每个控件
            var GAP = ICON_SIZE + ICON_GAP;

            var width = DEFAULT_GAP;

            if(this.refreshIcon && this.refreshIcon.visible){
                width += GAP;
            }

            //不收缩的时候没有菜单
            if(this.menuIcon && this.menuIcon.visible){
                width += GAP;
            }

            if(this.isOpen || !this.componentOption.hidden){
                width += this.toolbarIcons.length * GAP;
            }

            return width;
        },

        getToolbarHeight:function(){
            return ICON_SIZE;
        }
    });

    // function (vanchart, option, componentType){
    //     Base.call(this, vanchart, option, componentType);
    //     this.menuIcon = null;
    //     this.refreshIcon = null;
    //     this.pos = {x:0, y:0};
    //     this.toolbarIcons = [];
    //     this.refresh(option);
    //     this.isOpen = !this.componentOption.hidden;
    // }
    
    require('../ComponentLibrary').register(Constants.TOOLBAR_COMPONENT, Toolbar);
    return Toolbar;
});
/**
 * Created by eason on 15/7/17.
 * 用来记录所有默认的config
 */
define('theme/config',['require','../Constants'],function(require){

    var Constants = require('../Constants');

    var config = {};

    config[Constants.PIE_CHART] = {
    };

    config[Constants.COLUMN_CHART] = {

        xAxis:{
            type:'category',
            position:'bottom',

            lineWidth:1,
            lineColor:'#cccccc',
            enableTick:true,
            enableMinorTick:true,
            showLabel:true,

            minorTickColor:'#cccccc',
            minorTickWidth:1,
            minorTickLength:2,

            tickColor:'#cccccc',
            tickWidth:1,
            tickLength:4,

            tickPadding:6,
            gridLineWidth:0,
            gridLineColor:'#cccccc',
            labelStyle:{
                color:'#666666',
                fontFamily:'Verdana',
                fontSize:'16px'
            },
            formatter:"function(){return arguments[0]}"
        },

        yAxis:{
            type:'value',
            position:'left',

            lineWidth:1,
            lineColor:'#cccccc',
            enableTick:true,
            enableMinorTick:false,
            showLabel:true,

            minorTickColor:'#cccccc',
            minorTickWidth:1,
            minorTickLength:2,

            tickColor:'#cccccc',
            tickWidth:1,
            tickLength:4,

            tickPadding:6,
            gridLineWidth:1,
            gridLineColor:'#dddddd',
            labelStyle:{
                color:'#666666',
                fontFamily:'Verdana',
                fontSize:'16px'
            },
            formatter:"function(){return arguments[0]}"
        }

    };

    config[Constants.BAR_CHART] = {

        xAxis:{
            type:'value',
            position:'bottom',

            lineWidth:1,
            lineColor:'#cccccc',
            enableTick:true,
            enableMinorTick:true,
            showLabel:true,

            minorTickColor:'#cccccc',
            minorTickWidth:1,
            minorTickLength:2,

            tickColor:'#cccccc',
            tickWidth:1,
            tickLength:4,

            tickPadding:6,
            gridLineWidth:0,
            gridLineColor:'#cccccc',
            labelStyle:{
                color:'#666666',
                fontFamily:'Verdana',
                fontSize:'16px'
            },
            formatter:"function(){return arguments[0]}"
        },

        yAxis:{
            type:'category',
            position:'left',

            lineWidth:1,
            lineColor:'#cccccc',
            enableTick:true,
            enableMinorTick:false,
            showLabel:true,

            minorTickColor:'#cccccc',
            minorTickWidth:1,
            minorTickLength:2,

            tickColor:'#cccccc',
            tickWidth:1,
            tickLength:4,

            tickPadding:6,
            gridLineWidth:1,
            gridLineColor:'#dddddd',
            labelStyle:{
                color:'#666666',
                fontFamily:'Verdana',
                fontSize:'16px'
            },
            formatter:"function(){return arguments[0]}"
        }
    };

    config[Constants.LINE_CHART] = config[Constants.AREA_CHART] = {

        xAxis:{
            type:'category',
            position:'bottom',

            lineWidth:1,
            lineColor:'#cccccc',
            enableTick:true,
            showLabel:true,

            tickColor:'#cccccc',
            tickWidth:1,
            tickLength:4,
            tickPadding:6,

            minorTickColor:'#cccccc',
            minorTickWidth:1,
            minorTickLength:2,

            gridLineWidth:0,
            gridLineColor:'#cccccc',
            labelStyle:{
                color:'#666666',
                fontFamily:'Verdana',
                fontSize:'16px'
            },
            formatter:"function(){return arguments[0]}"
        },

        yAxis:{
            type:'value',
            position:'left',

            minorTickLength:2,
            lineWidth:0,
            lineColor:'#cccccc',
            enableTick:true,
            showLabel:true,

            tickColor:'#cccccc',
            tickWidth:2,
            tickLength:4,
            tickPadding:3,

            minorTickColor:'#cccccc',
            minorTickWidth:1,

            gridLineWidth:1,
            gridLineColor:'#dddddd',
            labelStyle:{
                color:'#666666',
                fontFamily:'Verdana',
                fontSize:'16px'
            },
            formatter:function(d){return d}
        }
    };

    config[Constants.GAUGE_CHART] = {

        legend:{

            enabled:false

        },

        gaugeAxis:{
            type:'value',
            showLabel:true,
            step:1,

            enableTick:true,
            tickColor:'#BBBBBB',
            tickWidth:1,

            enableMinorTick:true,
            minorTickColor:'#e2e2e2',
            minorTickWidth:1,

            labelStyle:{
                color:'#666666',
                fontFamily:'Verdana',
                fontSize:'10px'
            }

        },

        pointer:{

            tickStyle:{
                color:'#BBBBBB',
                fontSize:'8px',
                fontFamily:'Verdana'
            },

            tickWidth:1,
            tickColor:'#666666',
            minorTickWidth:1,
            minorTickColor:'#FCFCFC',

            seriesLabel:{
                enabled:true,
                align:Constants.BOTTOM,
                useHtml:false,
                style:{
                    color:'#333333',
                    fontSize:'14px',
                    fontFamily:'Verdana'
                },
                formatter:{
                    identifier: "${CATEGORY}"
                }
            },

            valueLabel:{
                enabled:true,
                useHtml:false,
                backgroundColor:'#F5F5F7',
                style:{
                    color:'#333333',
                    fontSize:'11px',
                    fontFamily:'Verdana'
                },
                formatter:{
                    identifier: "${SERIES}${VALUE}",
                    valueFormat: d3.format('.2')
                }
            },

            needle:'#E5715A',
            hinge:'#656B6D',
            hingeBackgroundColor:'#DCF2F9',
            paneBackgroundColor:'#FCFCFC'
        },

        slot:{
            percentageLabel:{
                enabled:true,
                useHtml:false,
                style:{
                    fontSize:'36px',
                    fontFamily:'Verdana',
                    fontWeight:'bold',
                    textShadow:'0px 2px 0px rgba(0,0,0,0.08)'
                },

                formatter:{
                    identifier: "${PERCENT}",
                    percentFormat: d3.format('.2%')
                }
            },

            valueLabel:{
                enabled:true,
                useHtml:false,
                style:{
                    color:'#666666',
                    fontSize:'14px',
                    fontFamily:'Verdana'
                },
                formatter:{
                    identifier: "${CATEGORY}${VALUE}",
                    valueFormat: d3.format('.2')
                }
            },

            needle:'#ffffff',
            slotBackgroundColor:'#eeeeee'
        },

        thermometer:{

            percentageLabel:{
                enabled:true,

                useHtml:false,

                align:'left',

                style:{
                    color:'#333333',
                    fontSize:'12px',
                    fontFamily:'Verdana',
                    fontWeight:'bold'
                },

                formatter:{
                    identifier: "${PERCENT}",
                    percentFormat: d3.format('.2%')
                }
            },

            valueLabel:{
                enabled:true,

                useHtml:false,

                align:'left',

                style:{
                    color:'#bababa',
                    fontSize:'12px',
                    fontFamily:'Verdana'
                },

                formatter:{
                    identifier: "${CATEGORY}${VALUE}",
                    valueFormat: d3.format('.2')
                }

            },

            needle:'#ffffff',
            slotBackgroundColor:'#eeeeee',
            thermometerLayout:'vertical'
        },

        ring:{

            percentageLabel:{
                enabled:true,

                useHtml:false,

                style:{
                    fontSize:'24px',
                    fontFamily:'Verdana',
                    fontWeight:'bold'
                },

                formatter:{
                    identifier: "${PERCENT}",
                    percentFormat: d3.format('.2%')
                }

            },

            valueLabel:{
                enabled:true,

                useHtml:false,

                style:{
                    color:'#777777',
                    fontSize:'12px',
                    fontFamily:'Verdana'
                },

                formatter:{
                    identifier: "${CATEGORY}${VALUE}",
                    valueFormat: d3.format('.2')
                }
            },

            clockwise:false,
            paneBackgroundColor:'#eeeeee',
            innerPaneBackgroundColor:'#f4f4f4'
        }
    };

    config[Constants.RADAR_CHART] = {

        polar: {

        },

        angleAxis:{
            type:'category',

            step:1,

            lineWidth:1,

            lineColor:'#cccccc',

            showLabel:true,

            gridLineWidth:1,
            gridLineColor:'#dddddd',

            labelStyle:{
                color:'#666666',
                fontFamily:'Verdana',
                fontSize:'9pt'
            },
            formatter:"function(){return arguments[0]}"
        },

        radiusAxis:{
            type:'value',

            labelRotation:0,

            step:1,

            lineWidth:1,

            lineColor:'#cccccc',

            showLabel:true,

            gridLineWidth:1,
            gridLineColor:'#dddddd',

            formatter:"function(){return arguments[0]}",

            labelStyle:{
                color:'#666666',
                fontFamily:'Verdana',
                fontSize:'9pt'
            }
        }
    };

    config[Constants.SCATTER_CHART] = {
        legend:{
            enabled:false
        },

        xAxis:{
            type:'value',
            position:'bottom',

            lineWidth:1,
            lineColor:'#cccccc',
            enableTick:true,
            enableMinorTick:true,
            showLabel:true,

            minorTickColor:'#cccccc',
            minorTickWidth:1,
            minorTickLength:2,

            tickColor:'#cccccc',
            tickWidth:1,
            tickLength:4,

            tickPadding:6,
            gridLineWidth:0,
            gridLineColor:'#cccccc',
            labelStyle:{
                color:'#666666',
                fontFamily:'Verdana',
                fontSize:'16px'
            },
            formatter:"function(){return arguments[0]}"
        },

        yAxis:{
            type:'value',
            position:'left',

            lineWidth:1,
            lineColor:'#cccccc',
            enableTick:true,
            enableMinorTick:false,
            showLabel:true,

            minorTickColor:'#cccccc',
            minorTickWidth:1,
            minorTickLength:2,

            tickColor:'#cccccc',
            tickWidth:1,
            tickLength:4,

            tickPadding:6,
            gridLineWidth:1,
            gridLineColor:'#dddddd',
            labelStyle:{
                color:'#666666',
                fontFamily:'Verdana',
                fontSize:'16px'
            },
            formatter:"function(){return arguments[0]}"
        }

    };

    config[Constants.BUBBLE_CHART] = {
        legend:{
            enabled:false
        },
        xAxis:{
            type:'value',
            position:'bottom',

            lineWidth:1,
            lineColor:'#cccccc',
            enableTick:true,
            enableMinorTick:true,
            showLabel:true,

            minorTickColor:'#cccccc',
            minorTickWidth:1,
            minorTickLength:2,

            tickColor:'#cccccc',
            tickWidth:1,
            tickLength:4,

            tickPadding:6,
            gridLineWidth:0,
            gridLineColor:'#cccccc',
            labelStyle:{
                color:'#666666',
                fontFamily:'Verdana',
                fontSize:'16px'
            },
            formatter:"function(){return arguments[0]}"
        },

        yAxis:{
            type:'value',
            position:'left',

            lineWidth:1,
            lineColor:'#cccccc',
            enableTick:true,
            enableMinorTick:false,
            showLabel:true,

            minorTickColor:'#cccccc',
            minorTickWidth:1,
            minorTickLength:2,

            tickColor:'#cccccc',
            tickWidth:1,
            tickLength:4,

            tickPadding:6,
            gridLineWidth:1,
            gridLineColor:'#dddddd',
            labelStyle:{
                color:'#666666',
                fontFamily:'Verdana',
                fontSize:'16px'
            },
            formatter:"function(){return arguments[0]}"
        }
    };

    config[Constants.AREA_MAP] = {
        legend:{
            enabled:false
        }
    };

    config[Constants.POINT_MAP] = {
        legend:{
            enabled:false
        }
    };


    return config;
});
/**
 * Created by eason on 15/10/12.
 */

define('render/ZoomBarRender',['require','./BaseRender','../utils/BaseUtils','../Constants','../theme/config','./RenderLibrary'],function(require){

    var BaseRender = require('./BaseRender');
    var BaseUtils = require('../utils/BaseUtils');
    var Constants = require('../Constants');

    var ZoomBarRender = BaseRender.extend({
        render:function(){

            if(!this.component.zoomToolEnabled() || this._zoomG){
                return ;
            }

            var bounds = this.component.bounds;
            var svgRoot = this.component.getVanchartRender().getRenderRoot();

            this._zoomG = svgRoot
                .append('g')
                .attr('transform', 'translate(' + bounds.x + ',' + bounds.y + ')');

            this._initUnitLength();

            var startX = this.component.getStartX();
            var endX = this.component.getEndX();

            this._zoomG.append('g')
                .call(this._createLines.bind(this));

            this.leftRect = this._zoomG.append('g').call(this._createSideRect.bind(this), startX, true);

            this.rightRect = this._zoomG.append('g').call(this._createSideRect.bind(this), endX, false);

            this.innerRect = this._zoomG.append('g').call(this._createInnerRect.bind(this), startX, endX);

            this.leftButton = this._zoomG.append('g').call(this._createButton.bind(this), startX, true);

            this.rightButton = this._zoomG.append('g').call(this._createButton.bind(this), endX, false);

            var buttonWidth = this.component.getZoomBarWidth();
            var height = this.component.getZoomBarHeight();

            this.l_bounds = {
                x:startX,
                y:0,
                width:buttonWidth,
                height:height
            };

            this.r_bounds = {
                x:endX - buttonWidth,
                y:0,
                width:buttonWidth,
                height:height
            };

            this.c_bounds = {
                x:startX + buttonWidth,
                y:0,
                width:endX - startX - 2*buttonWidth,
                height:height
            };

            this._addEventListeners(svgRoot);
        },

        remove:function(){
            if(this._zoomG){
                this._zoomG.remove();
                this._zoomG = null;
            }
        },

        _initUnitLength:function(){
            var axis = this.component.vanchart.xAxis();

            if(axis.type == Constants.CATEGORY_AXIS_COMPONENT){
                var bounds = this.component.bounds;
                var categories = axis.getCategories();
                this.unitLength = categories.length ? bounds.width/categories.length : bounds.width;
            }else{
                this.unitLength = 1;
            }
        },

        _addEventListeners:function(svgRoot){

            var self = this;

            svgRoot
                .on('mousedown.zoom', function(){

                    var downPos = d3.mouse(self._zoomG.node());

                    if(BaseUtils.containsPoint(self.l_bounds, downPos)){
                        this.tartget = self.leftButton;
                    }else if(BaseUtils.containsPoint(self.r_bounds, downPos)){
                        this.tartget = self.rightButton;
                    }else if(BaseUtils.containsPoint(self.c_bounds, downPos)){
                        this.tartget = self.innerRect;
                    }

                    if(this.tartget){
                        this.downX = downPos[0];
                        this.initX = d3.transform(this.tartget.attr('transform')).translate[0];
                        self._zoomG.style('cursor', 'ew-resize');
                        self._initStartEndIndex();
                    }
                })
                .on('mousemove.zoom', function(){

                    if(this.tartget){

                        var component = this.tartget.attr('class');

                        switch (component){

                            case Constants.LEFT:
                                if(self.component.resizable()){
                                    self._leftButtonMove(this.downX, this.initX);
                                }
                                break;

                            case Constants.RIGHT:
                                if(self.component.resizable()){
                                    self._rightButtonMove(this.downX, this.initX);
                                }
                                break;

                            case Constants.CENTER:
                                self._centerRectMove(this.downX);
                                break;
                        };

                        self._zoomRefresh();
                    }

                })
                .on('mouseup.zoom', function(){

                    if(this.tartget){
                        this.tartget = null;
                        self._updateBounds();

                        var axis = self.component.vanchart.xAxis();
                        if(axis){
                            axis.render.render();
                        }

                    }

                });

        },

        _leftButtonMove:function(downX, initX){

            var barWidth = this.component.getZoomBarWidth();

            var minTransX = 0;

            var maxTransX = d3.transform(this.rightButton.attr('transform')).translate[0] - barWidth;

            var currentX = d3.mouse(this._zoomG.node())[0];

            var transX = initX + currentX - downX;

            transX = Math.max(Math.min(transX, maxTransX), minTransX);

            this.leftButton.attr('transform', 'translate(' + transX + ',0)');
            this.leftRect.select('rect').attr('width', transX);

            this.innerRect.selectAll('line').attr('x1', transX + barWidth);
            this.innerRect.select('rect')
                .attr('x', transX + barWidth)
                .attr('width', maxTransX - transX);
        },

        _rightButtonMove:function(downX, initX){
            var barWidth = this.component.getZoomBarWidth();

            var minTransX = d3.transform(this.leftButton.attr('transform')).translate[0] + barWidth;

            var maxTransX = this.component.getBoundsEndX() - barWidth;

            var currentX = d3.mouse(this._zoomG.node())[0];

            var transX = initX + currentX - downX;

            transX = Math.max(Math.min(transX, maxTransX), minTransX);

            this.rightButton.attr('transform', 'translate(' + transX + ',0)');
            this.rightRect.select('rect')
                .attr('x', transX + barWidth)
                .attr('width', this.component.getBoundsEndX() - (transX + barWidth));

            this.innerRect.selectAll('line').attr('x2', transX);
            this.innerRect.select('rect').attr('width', transX - minTransX);
        },

        _centerRectMove:function(downX){

            var endX = this.component.getBoundsEndX();
            var barWidth = this.component.getZoomBarWidth();

            var currentX = d3.mouse(this._zoomG.node())[0];


            var detX = currentX - downX;

            if(this.l_bounds.x + detX >=0 && this.r_bounds.x + this.r_bounds.width + detX <= endX){

                var l_transX = this.l_bounds.x + detX;

                this.leftButton.attr('transform', 'translate(' + l_transX + ',0)');

                this.leftRect.select('rect').attr('width', l_transX);

                var r_transX = this.r_bounds.x + detX;
                this.rightButton.attr('transform', 'translate(' + r_transX + ',0)');
                this.rightRect.select('rect')
                    .attr('x', r_transX + barWidth)
                    .attr('width', this.component.getBoundsEndX() - (r_transX + barWidth));


                this.innerRect.selectAll('line')
                    .attr('x1', l_transX + barWidth)
                    .attr('x2', r_transX);

                this.innerRect.select('rect')
                    .attr('x', l_transX + barWidth)
            }
        },

        _initStartEndIndex:function(){
            var l_transX = d3.transform(this.leftButton.attr('transform')).translate[0];
            var r_transX = d3.transform(this.rightButton.attr('transform')).translate[0];

            this.initStart = this._getIndexByPosition(l_transX);
            this.initEnd = this._getIndexByPosition(r_transX);
        },

        _getIndexByPosition:function(x){

            var axis = this.component.vanchart.xAxis();

            switch (axis.type) {
                case Constants.CATEGORY_AXIS_COMPONENT:
                    var categories = axis.getCategories();
                    return axis.isAxisReversed() ? categories.length - 1 - Math.floor(x/this.unitLength) : Math.floor(x/this.unitLength);
                case Constants.DATE_AXIS_COMPONENT:
                    return BaseUtils.date2int(this.xScale.invert(x));
                default:
                    return this.xScale.invert(x);
            }
        },

        _zoomRefresh:function(){

            var l_transX = d3.transform(this.leftButton.attr('transform')).translate[0];
            var r_transX = d3.transform(this.rightButton.attr('transform')).translate[0];

            var startIndex = this._getIndexByPosition(l_transX);
            var endIndex = this._getIndexByPosition(r_transX);

            if(this.initStart != startIndex || this.initEnd != endIndex){

                var axis = this.component.vanchart.xAxis();

                axis.updateAxisScale(Math.min(startIndex, endIndex), Math.max(startIndex, endIndex), true);

                var vanchart = this.component.vanchart;
                vanchart.currentOption.state = Constants.STATE_ZOOM_REFRESH;

                vanchart.layoutComponentsAndCharts();

                this.initStart = startIndex;
                this.initEnd = endIndex;
            }

        },

        _updateBounds:function(){

            var l_transX = d3.transform(this.leftButton.attr('transform')).translate[0];
            var r_transX = d3.transform(this.rightButton.attr('transform')).translate[0];

            var barWidth = this.component.getZoomBarWidth();

            this.l_bounds.x = l_transX;
            this.r_bounds.x = r_transX;

            this.c_bounds.x = l_transX + barWidth;
            this.c_bounds.width = r_transX - l_transX - barWidth;
        },

        _createSideRect:function(g, startX, isLeft){

            var barHeight = this.component.getZoomBarHeight();

            var x, width;

            if(isLeft){
                x = 0;
                width = startX;
            }else{
                x = startX;
                width = this.component.bounds.width - startX;
            }

            g.append('rect')
                .attr('x', x)
                .attr('y', 0)
                .attr('width', width)
                .attr('height', barHeight)
                .style('fill', 'rgba(220,221,221,0.4)');

        },

        _createInnerRect:function(g, startX, endX){

            var barWidth = this.component.getZoomBarWidth();
            var barHeight = this.component.getZoomBarHeight();

            g.attr('class', Constants.CENTER);

            g.append('rect')
                .attr('x', startX + barWidth)
                .attr('y', 0)
                .attr('width', endX - startX - 2 * barWidth)
                .attr('height', barHeight)
                .style('fill', 'rgba(255,255,255,0)');

            g.append('line')
                .attr('x1', startX + barWidth)
                .attr('y1', 0)
                .attr('x2', endX - barWidth)
                .attr('y2', 0);

            g.append('line')
                .attr('x1', startX + barWidth)
                .attr('y1', barHeight)
                .attr('x2', endX - barWidth)
                .attr('y2', barHeight);

            g.selectAll('line')
                .style({
                    fill:'none',
                    stroke:'#29ABE2',
                    'stroke-width':1
                });

        },

        //缩放底边上的线
        _createLines:function(g){

            var config = require('../theme/config');

            var bounds = this.component.bounds;

            var axis = this.component.vanchart.xAxis();

            this.xScale = this.component._getAxisScale();

            var xScale = this.xScale;

            var series = this.component.option.series;
            var chartType = this.component.option.chartType;
            var usedSeries = [];
            series.forEach(function(sery){
                if(!sery.xAxis && config[sery.type || chartType].xAxis){
                    usedSeries.push(sery);
                }
            });

            var lines = [];

            var minValueY = Number.MAX_VALUE;
            var maxValueY = Number.MIN_VALUE;

            usedSeries.forEach(function(sery){

                var points = [];

                lines.push(points);

                var dCount = sery.data.length;

                for (var dIndex = 0; dIndex < dCount; dIndex++) {
                    var datum = sery.data[dIndex];
                    var point = {
                        x:axis.getValueFromData(datum),
                        y:BaseUtils.pick(datum.y, datum)
                    };

                    if(isNaN(+point.y)){
                        continue;
                    }

                    points.push(point);

                    minValueY = Math.min(minValueY, point.y);
                    maxValueY = Math.max(maxValueY, point.y);
                }
            });

            minValueY = minValueY >= 0 ? 0 : minValueY;

            var det = xScale.rangeBand ? xScale.rangeBand()/2 : 0;

            var yScale = d3.scale.linear().domain([minValueY, maxValueY]).range([bounds.height, 0]);

            lines.forEach(function(points){

                points.forEach(function(point){
                    point.x = xScale(point.x) + det;
                    point.y = yScale(point.y);
                })

            });

            lines.forEach(function(points){

                points.sort(function(a, b){
                    return a.x - b.x;
                })

            });

            var lineSvg = d3.svg.line()
                .interpolate("linear")
                .x(function (d) { return d.x; })
                .y(function (d) { return d.y; });

            g.selectAll('path')
                .data(lines)
                .enter()
                .append('path')
                .attr('d', function(points){
                    return lineSvg(points);
                })
                .style({
                    fill:'none',
                    stroke:'black',
                    'stroke-width':1
                });
        },

        _createButton:function(g, startX, isLeft){

            startX = isLeft ? startX : startX - this.component.getZoomBarWidth();

            g.attr('transform', 'translate(' + startX + ',' + '0)')
                .attr('class', isLeft ? Constants.LEFT : Constants.RIGHT);

            g.append('path')
                .attr('d', isLeft ? 'M4,30h6V0L4,0C1.791,0,0,1.791,0,4v22C0,28.209,1.791,30,4,30z' : 'M6,30H0V0h6c2.209,0,4,1.791,4,4v22C10,28.209,8.209,30,6,30z')
                .style('fill', '#29ABE2');

            g.append('line')
                .attr('x1', 3)
                .attr('y1', 11)
                .attr('x2', 3)
                .attr('y2', 18);

            g.append('line')
                .attr('x1', 7)
                .attr('y1', 11)
                .attr('x2', 7)
                .attr('y2', 18);

            g.selectAll('line')
                .style({
                    fill: '#FFFFFF',
                    stroke: '#7ADAF4',
                    'stroke-width': 2,
                    'stroke-linecap': 'round',
                    'stroke-linejoin': 'round',
                    'stroke-miterlimit': 10
                });
        }
    });

    require('./RenderLibrary').register(Constants.ZOOM_SVG, ZoomBarRender);
});
/**
 * Created by eason on 15/10/12.
 */
define('component/ZoomBar',['require','../render/ZoomBarRender','./Base','../utils/BaseUtils','../Constants','../ComponentLibrary'],function(require){

    require('../render/ZoomBarRender');

    var Base = require('./Base');
    var BaseUtils = require('../utils/BaseUtils');
    var Constants = require('../Constants');

    //缩放控件默认的高度
    var HEIGHT = 30;
    var WIDTH = 10;

    var ZoomBar = Base.extend({
        doLayout:function(){

            if(this.zoomToolEnabled()){
                this._setComponentBounds(Constants.BOTTOM, HEIGHT);
            }

        },

        fixBoundsByPlot:function(){

            var plotBounds = this.vanchart.getPlotBounds();

            var zoomY = plotBounds.y + plotBounds.height;

            var xAxisComponent = this.vanchart.getComponent(Constants.X_AXIS_COMPONENT);

            if(xAxisComponent && xAxisComponent._axisList.length){
                xAxisComponent._axisList.forEach(function(axis){

                    if(axis.getPosition() == Constants.BOTTOM){

                        zoomY = Math.max(zoomY, axis.bounds.y + axis.bounds.height);
                    }

                })
            }

            this.bounds = BaseUtils.makeBounds(plotBounds.x, zoomY, plotBounds.width, HEIGHT);
        },

        // ensure they are within the axis
        getRevisedDomain: function () {
            var revisedDomain = {
                from: this.componentOption.zoomTool.from,
                to: this.componentOption.zoomTool.to
            };

            var axis = this.vanchart.xAxis();
            if (axis.type === Constants.VALUE_AXIS_COMPONENT ||
                axis.type === Constants.DATE_AXIS_COMPONENT) {

                var tmp = [this.componentOption.zoomTool.from, this.componentOption.zoomTool.to];

                if (axis.type === Constants.DATE_AXIS_COMPONENT) {
                    tmp[0] = BaseUtils.date2int(tmp[0]);
                    tmp[1] = BaseUtils.date2int(tmp[1]);
                }

                revisedDomain.from = Math.min.apply(null, tmp);
                revisedDomain.to = Math.max.apply(null, tmp);

                var axisDomain = axis.getOriginalDomain();

                revisedDomain.from =
                    Math.max(revisedDomain.from, axisDomain.minValue);
                revisedDomain.to =
                    Math.min(revisedDomain.to, axisDomain.maxValue);
            }

            return revisedDomain;
        },

        zoomToolEnabled:function(){
            var axis = this.option.xAxis;
            if(axis){
                axis = axis[0] || axis;
            }

            return this.componentOption
                && this.componentOption.zoomTool
                && this.componentOption.zoomTool.visible
                && !this.option.dataSheet
                && !this.option.plotOptions.force
                && axis;
        },

        resizable:function(){

            return this.componentOption
                && this.componentOption.zoomTool
                && this.componentOption.zoomTool.resize;

        },

        getZoomBarWidth:function(){
            return WIDTH;
        },

        getZoomBarHeight:function(){
            return HEIGHT;
        },

        _getAxisScale:function(){

            var axis = this.vanchart.xAxis();

            var scale = axis.scale.copy();

            if (axis.type == Constants.CATEGORY_AXIS_COMPONENT) {
                scale.rangeBand ? scale.rangeBands(axis._getRange()) : scale.range(axis._getRange());
            } else {
                var domain = axis.getOriginalDomain();
                scale.domain([domain.minValue, domain.maxValue]);
            }
            return scale;

        },

        getStartX:function(){
            var revisedDomain = this.getRevisedDomain();
            var startX = 0;

            var scale = this._getAxisScale();

            if(revisedDomain.from && !revisedDomain.to){
                startX = scale(revisedDomain.from);
                startX = isNaN(startX) ? 0 : startX;
            }else if(revisedDomain.from && revisedDomain.to){
                return this._getMinX();
            }

            return startX;
        },

        getEndX:function(){

            var revisedDomain = this.getRevisedDomain();
            var endX = this.bounds.width;
            var scale = this._getAxisScale();

            if(revisedDomain.to && !revisedDomain.from){
                endX = scale(revisedDomain.to) + (scale.rangeBand ? scale.rangeBand() : 0);
                endX = isNaN(endX) ? this.bounds.width : endX;
            }else if(revisedDomain.to && revisedDomain.from){
                return this._getMaxX();
            }

            return endX;
        },

        _getMinX:function(){
            var revisedDomain = this.getRevisedDomain();

            if(revisedDomain.from && revisedDomain.to){

                var scale = this._getAxisScale();

                var x1 = scale(revisedDomain.from);
                var x2 = scale(revisedDomain.to);

                var result = Math.min(x1, x2);

                return isNaN(result) ? 0 : result;
            }
        },

        _getMaxX:function(){
            var revisedDomain = this.getRevisedDomain();

            if(revisedDomain.from && revisedDomain.to){

                var scale = this._getAxisScale();

                var x1 = scale(revisedDomain.from);
                var x2 = scale(revisedDomain.to);

                var result = Math.max(x1, x2) + (scale.rangeBand ? scale.rangeBand() : 0);

                return  isNaN(result) ?  this.bounds.width : result;
            }
        },

        getBoundsEndX:function(){
            return this.bounds.width;
        }
    });
    
    require('../ComponentLibrary').register(Constants.ZOOM_COMPONENT, ZoomBar);
    return ZoomBar;

});
/**
 * Created by eason on 15/5/4.
 * 数据表
 */
define('component/DataSheet',['require','./Base','../utils/BaseUtils','../utils/Formatter','../Constants','../render/LegendIconFactory','../ComponentLibrary'],function(require){

    var Base = require('./Base');
    var BaseUtils = require('../utils/BaseUtils');
    var Formatter = require('../utils/Formatter');
    var Constants = require('../Constants');
    var LegendIconFactory = require('../render/LegendIconFactory');

    var PADDING_GAP = 4;
    var ICON_GAP = 2;
    var MAX_ICON_SIZE = 18;

    var STYLE = { color : "#666666", fontSize: "14px", fontFamily:"Verdana"};

    var DataSheet = Base.extend({

        /**
         *数据表的对象要先于坐标轴存在，但是大小需要最后确定
         */
        doLayout:function(){

            this.remove();

            var plotBounds = this.vanchart.getPlotBounds();
            var leftDet =  Math.round(this.getSeriesNameLength());
            this._clipPlotBounds(Constants.LEFT, Math.max(leftDet - plotBounds.x, 0));

            this._setComponentBounds(Constants.BOTTOM, this.getDataSheetHeight());
        },

        fixBoundsByPlot:function() {

            var plotBounds = this.vanchart.getPlotBounds();

            this.bounds = {
                x: plotBounds.x - this.maxSeriesWidth,
                y: plotBounds.y + plotBounds.height,
                width: this.maxSeriesWidth + plotBounds.width,
                height: this.sheetHeight
            };

        },
        //最长的系列名
        getSeriesNameLength:function(){

            this.seriesNames = [];
            this.maxSeriesLine = [];

            var series = this.option.series;

            var style = this._seriesStyle();

            var limitedWidth = this.vanchart.getChartBounds().width / 4 - (MAX_ICON_SIZE + ICON_GAP * 2);

            var maxWidth = 0;

            var iconSize = 0;

            for(var sIndex = 0, sCount = series.length; sIndex < sCount; sIndex++){
                this.maxSeriesLine[sIndex] = 0;

                var sery = series[sIndex];
                var width = BaseUtils.getTextDimension(sery.name, style, false).width + PADDING_GAP * 2;

                if(width > limitedWidth){

                    var s_names = BaseUtils.splitText(sery.name, style, limitedWidth, PADDING_GAP);

                    this.maxSeriesLine[sIndex] = s_names.length;

                    this.seriesNames.push(s_names);

                    maxWidth = limitedWidth;
                }else{
                    this.maxSeriesLine[sIndex] = 1;

                    this.seriesNames.push([sery.name]);

                    maxWidth = Math.max(width, maxWidth);
                }

                var iconType = this.getLegendIconTypeWithSeriesIndex(sIndex);

                iconSize = Math.max(iconSize, LegendIconFactory.getLegendIconSize(iconType).width);
            }

            this.maxSeriesWidth = Math.ceil(maxWidth + ICON_GAP * 2 + iconSize);

            return  this.maxSeriesWidth + PADDING_GAP;
        },

        getLegendIconTypeWithSeriesIndex: function (index) {
            return this._getLegendType(this.vanchart.series[index]);
        },

        getDataSheetHeight:function(){

            this.maxCateLine = 0;
            this.categoryNames = [];
            this.values = [];
            this.maxValueLine = [];

            var axis = this.vanchart.xAxis();

            var categories = axis.getCategories();

            if(axis.isAxisReversed()){
                categories = BaseUtils.clone(categories).reverse();
            }

            var cateStyle = this._categoryStyle();

            var unitLength = this.vanchart.getPlotBounds().width / categories.length;

            var self = this;

            categories.forEach(function(category){

                var sCateName = BaseUtils.splitText(category, cateStyle, unitLength, PADDING_GAP);

                self.maxCateLine = Math.max(self.maxCateLine, sCateName.length);

                self.categoryNames.push(sCateName);

            });

            var valueStyle = this._valueStyle();
            var format = this.componentOption.formatter;

            var series = this.vanchart.series;

            for(var sIndex = 0, sCount = series.length; sIndex < sCount; sIndex++){
                var seryValue = [];
                this.values.push(seryValue);

                this.maxValueLine[sIndex] = 0;

                var sery = series[sIndex];
                var points = sery.originalPoints || sery.points;
                for(var dIndex = 0, len = points.length; dIndex < len; dIndex++){
                    var point = points[dIndex];
                    var value = point.value;

                    var f_value = point.isNull ? '-' : this._getTickContent(value, format);
                    var sValue = BaseUtils.splitText(f_value, valueStyle, unitLength, PADDING_GAP);

                    seryValue[BaseUtils.indexInArray(categories, point.category)] = sValue;

                    this.maxValueLine[sIndex] = Math.max(this.maxValueLine[sIndex], sValue.length);
                }
            }


            //开始计算高度
            var cateHeight = this.getCategoryHeight();

            var valueHeight = 0;

            for(var sIndex = 0, sCount = series.length; sIndex < sCount; sIndex++){
                valueHeight += this.getSeriesHeight(sIndex);
            }

            this.sheetHeight = Math.ceil(cateHeight + valueHeight);

            return this.sheetHeight
        },

        _categoryStyle:function(){
            return this.option.xAxis.labelStyle || this.option.xAxis[0].labelStyle || STYLE;
        },

        _seriesStyle:function(){
            return this.option.legend ? this.option.legend.style : STYLE;
        },

        _valueStyle:function(){
            return this.componentOption.style;
        },

        getCategoryHeight:function(){

            var cateStyle = this._categoryStyle();

            return PADDING_GAP * 2
                + this.maxCateLine * BaseUtils.getTextHeight(cateStyle)
                + (this.maxCateLine - 1) * PADDING_GAP

        },

        getSeriesHeight:function(sIndex){

            var seriesLineHeight = BaseUtils.getTextHeight(this._seriesStyle());
            var valueLineHeight = BaseUtils.getTextHeight(this._valueStyle());

            var s_count = this.maxSeriesLine[sIndex];
            var s_height = PADDING_GAP * 2 + s_count * seriesLineHeight + (s_count - 1) * PADDING_GAP;

            var v_count = this.maxValueLine[sIndex];
            var v_height = PADDING_GAP * 2 + v_count * valueLineHeight + (v_count - 1) * PADDING_GAP;

            return Math.max(s_height, v_height);
        },

        getMaxSeriesWidth:function(){
            return this.maxSeriesWidth;
        },

        getTextPadding:function(){
            return PADDING_GAP;
        }
    });

    require('../ComponentLibrary').register(Constants.DATA_SHEET_COMPONENT, DataSheet);
    return DataSheet;
});
/**
 * Created by Mitisky on 16/3/21.
 */
define ('component/RangeLegend',['require','./Base','../utils/BaseUtils','../Constants','../utils/ColorUtils','../utils/Formatter','../ComponentLibrary'],function(require){
    var Base = require('./Base');
    var BaseUtils = require('../utils/BaseUtils');
    var Constants = require('../Constants');
    var ColorUtils = require('../utils/ColorUtils');
    var Formatter = require('../utils/Formatter');

    var PADDING = 10;

    var WIDTH = 15;
    var HEIGHT = 100;
    var BAR_WIDTH = 15;
    var BAR_HEIGHT = 10;
    var BAR_TEXT_GAP = 5;
    var ITEM_WIDTH = 25;
    var ITEM_GAP = 2;

    var RangeLegend = Base.extend({
        doLayout: function () {
            if(this.componentOption.visible){
                if(this.isIntervalLegend){
                    this._setItemsPoints();
                }

                //占用绘图区的宽或者高或者没有
                var usedSize = this._calculateUsedSize();
                this._setComponentBounds(this.componentOption.position || Constants.RIGHT_TOP, usedSize);

                this._calculateRangeLegendFinalBounds(usedSize);
            }
        },

        _calculateAutoMinMaxAndGap:function(minValue, maxValue, splitNumber){

            if(maxValue < minValue){
                minValue = 0; maxValue = 100;
            }

            var increment = maxValue - minValue;
            var order = BaseUtils.getOrder(increment);
            var pow = Math.pow(10, order);

            if(order <= 0){
                minValue = BaseUtils.accMul(minValue, Math.pow(10, 1 - order));
                minValue = BaseUtils.accDiv(Math.floor(minValue), Math.pow(10, 1 - order));
            }else{
                minValue = Math.floor(minValue / pow) * pow;
            }

            var base = BaseUtils.accDiv(splitNumber, 10) * pow;
            var gap = 0;
            while(gap < increment){
                gap = BaseUtils.accAdd(base, gap);
            }

            var bd = BaseUtils.accDiv(gap, splitNumber);

            while(minValue + bd * splitNumber < maxValue){
                gap = BaseUtils.accAdd(base, gap);
                bd = BaseUtils.accDiv(gap, splitNumber);
            }
            gap = BaseUtils.accDiv(gap, splitNumber);

            maxValue = BaseUtils.accAdd(minValue,  BaseUtils.accMul(gap, splitNumber));

            return [minValue, maxValue, gap];
        },

        _refresh: function () {
            if(this.vanchart.isZoomRefreshState()){
                return;
            }
            var cfg = this.componentOption, range = cfg.range || {};
            var minMax = this.vanchart.getMinMaxFromSeries();

            var minValue = cfg.min, maxValue = cfg.max;

            //自动计算的情况区域段图例
            if(cfg.continuous && BaseUtils.hasNotDefined(minValue) && BaseUtils.hasNotDefined(maxValue)){
                var para = this._calculateAutoMinMaxAndGap(minMax[0], minMax[1], Math.max(2, range.color.length - 1));
                minValue = para[0], maxValue = para[1];
            }else if(!cfg.continuous && !BaseUtils.isArray(range)){
                //区域段图例
                var splitNumber = range.splitNumber || 5;
                var color = range.color || 'blue';
                var colors = ColorUtils.createColorsWithHsb(color, splitNumber);
                var para = this._calculateAutoMinMaxAndGap(minMax[0], minMax[1], splitNumber);
                minValue = para[0];
                var gap = para[2];

                range = [];
                for(var i = 0; i < splitNumber; i++) {
                    range.push({
                        from:BaseUtils.accAdd(minValue, BaseUtils.accMul(gap, (splitNumber - i - 1))),
                        to:BaseUtils.accAdd(minValue,  BaseUtils.accMul(gap, (splitNumber - i))),
                        color:colors[i]
                    });
                }
            }

            var self = this;

            this.isIntervalLegend = BaseUtils.isArray(range);

            if(this.isIntervalLegend) {
                var hiddenColor = this.componentOption.hiddenColor;
                var hoverColor = this.componentOption.hoverColor;
                var formatter = this.componentOption.formatter;
                this.items = [];
                range.forEach(function(band){
                    var label = self._getIntervalLabelContent(band.from, band.to, formatter);
                    self.items.push(
                        {
                            from: band.from,
                            to: band.to,
                            color: band.color,
                            label: label,
                            points: [],
                            visible: true,
                            hiddenColor: hiddenColor,
                            hoverColor: hoverColor
                        }
                    )
                });

                this.items.sort(function (itemA, itemB) {
                    var itemAMin = Math.min(itemA.from, itemA.to);
                    var itemBMin = Math.min(itemB.from, itemB.to);
                    return self.isHorizontal() ? itemAMin - itemBMin : itemBMin - itemAMin;
                });

            } else {
                this.min = BaseUtils.pick(range.min, minValue);
                this.max = BaseUtils.pick(range.max, maxValue);
                this.valueAndColors = range.color;
                this.valueAndColors.sort(function(d1, d2){
                    return d1[0] - d2[0];
                });
                var valueArray = [];
                var colorArray = [];
                for(var i = 0, len = this.valueAndColors.length; i < len; i ++ ){
                    valueArray[i] = this.valueAndColors[i][0];
                    colorArray[i] = this.valueAndColors[i][1];
                }

                this.valueScale = d3.scale.linear()
                    .domain([this.min, this.max])
                    .range([0, 1]);

                this.colorScale = d3.scale.linear()
                    .domain(valueArray)
                    .range(colorArray);
            }
        },

        _getIntervalLabelContent:function(from, to, formatter){
            if(!formatter){
                return from + '-' + to;
            }

            return Formatter.format({'from':from,'to':to}, formatter);
        },

        _getGradientMinLabelContent: function () {
            return this._getGradientLabelWithFormatter(this.min);
        },

        _getGradientMaxLabelContent: function () {
            return this._getGradientLabelWithFormatter(this.max);
        },

        _getGradientLabelWithFormatter: function (value) {
            var formatter = this.componentOption.formatter;
            if(!formatter){
                return value;
            }

            return Formatter.format(value, formatter);
        },

        getValueAndColors: function () {
            return this.valueAndColors;
        },

        getGradientLabelContent: function (value) {
            return this._getGradientLabelWithFormatter(this._gradientScale(value));
        },

        _gradientScale: function (value) {
            var unit = BaseUtils.accDiv(BaseUtils.accAdd(this.max, -this.min), HEIGHT);
            value = BaseUtils.accMul(unit, this.isHorizontal() ? value : (HEIGHT - value));
            value = BaseUtils.accAdd(value, this.min);
            return value;
        },

        getColorWithSize: function (size) {
            if(this.isIntervalLegend){
                var item = this._getPointItem(size);
                if(item) {
                    return item.color;
                } else {
                    return null;
                }
            } else {
                if (size >= this.min && size <= this.max) {
                    return this.colorScale(this.valueScale(size));
                } else {
                    return null;
                }
            }
        },

        _setItemsPoints: function () {
            var self = this;
            var seriesS = this.vanchart.series;
            seriesS.forEach(function (sery) {
                var pointS = sery.points;
                pointS.forEach(function (point) {

                    //todo 这个指标的含义
                    var size = BaseUtils.hasDefined(point.size) ? point.size : point.value;

                    var item = self._getPointItem(size);
                    if(item) {
                        item.points.push(point);
                    }
                })
            })
        },

        _getPointItem:function(size){
            for(var i = 0, len = this.items.length; i < len; i++){
                var item = this.items[i];
                var min = Math.min(item.from, item.to);
                var max = Math.max(item.from, item.to);

                if(size >= min && size <= max){
                    return item;
                }
            }
        },

        _calculateUsedSize: function () {
            var cfg = this.componentOption;
            var position = cfg.position || Constants.RIGHT;
            var size = PADDING * 4;

            if(position == Constants.TOP || position == Constants.BOTTOM){

                var maxLimitSize = this._maxHeight();

                size += this.isIntervalLegend ? this._calculateIntervalTopAndBottomSize()
                    : this._calculateGradientTopAndBottomSize();


                return cfg.maxHeight ? Math.min(size, maxLimitSize) : size;

            }else{
                var maxLimitSize = this._maxWidth();

                size += this.isIntervalLegend ? this._calculateIntervalLeftAndRightSize()
                    : this._calculateGradientLeftAndRightSize();

                return cfg.maxWidth ? Math.min(size, maxLimitSize) : size;
            }
        },

        _calculateGradientTopAndBottomSize: function () {
            var height = WIDTH + BAR_WIDTH + BAR_TEXT_GAP;
            var d = BaseUtils.getTextDimension(this._getGradientMinLabelContent(), this.componentOption.style);
            return height + d.height;
        },

        _calculateGradientLeftAndRightSize: function () {
            var width = WIDTH + BAR_WIDTH + BAR_TEXT_GAP;
            var d1 = BaseUtils.getTextDimension(this._getGradientMinLabelContent(), this.componentOption.style);
            var d2 = BaseUtils.getTextDimension(this._getGradientMaxLabelContent(), this.componentOption.style);
            return width + Math.max(d1.width, d2.width);
        },

        _calculateIntervalTopAndBottomSize: function () {
            var height = WIDTH + BAR_TEXT_GAP * 2;
            var d = BaseUtils.getTextDimension("0", this.componentOption.style);
            return height + d.height * 2;
        },

        _calculateIntervalLeftAndRightSize : function () {
            var width = 0;
            var style = this.componentOption.style;
            this.items.forEach(function (item) {
                var labelDim = BaseUtils.getTextDimension(item.label, style);
                width = Math.max(width, labelDim.width);
            });
            return width + WIDTH + BAR_TEXT_GAP;
        },

        _calculateRangeLegendFinalBounds: function () {
            var cfg = this.componentOption;
            var position = cfg.position || Constants.RIGHT;

            var temp = PADDING * 4;

            if(position == Constants.TOP || position == Constants.BOTTOM){
                temp += this.isIntervalLegend ? this._calculateIntervalTopAndBottomFinalSize()
                    : this._calculateGradientTopAndBottomFinalSize();
                temp = Math.max(this.bounds.width - temp, 0);
                this.bounds.x += temp/2;
                this.bounds.width -= temp;
            }else if(position == Constants.LEFT || position == Constants.RIGHT){
                temp += this.isIntervalLegend ? this._calculateIntervalLeftAndRightFinalSize()
                    : this._calculateGradientLeftAndRightFinalSize();
                temp = Math.max(this.bounds.height - temp, 0);
                this.bounds.y += temp/2;
                this.bounds.height -= temp;
            } else if(position == Constants.RIGHT_TOP) {
                temp += this.isIntervalLegend ? this._calculateIntervalLeftAndRightFinalSize()
                    : this._calculateGradientLeftAndRightFinalSize();
                this.bounds.height = temp;
            }

            if(!this.isFloat){
                var gap = this.componentOption.borderWidth + PADDING * 2;
                this.bounds.x += gap/2;
                this.bounds.y += gap/2;
                this.bounds.width -= gap;
                this.bounds.height -= gap;

                if(position == Constants.BOTTOM) {
                    var zoomComponent = this.vanchart.getComponent(Constants.ZOOM_COMPONENT);
                    if (zoomComponent && zoomComponent.zoomToolEnabled()) {
                        this.bounds.y += zoomComponent.bounds.height;
                    }
                }

                if(position == Constants.RIGHT || position == Constants.RIGHT_TOP){
                    var toolbarHeight = this.vanchart.getToolbarHeight();
                    this.bounds.y += toolbarHeight;
                }
                
            }
        },

        _calculateGradientTopAndBottomFinalSize: function() {
            var d1 = BaseUtils.getTextDimension(this._getGradientMinLabelContent(), this.componentOption.style);
            var d2 = BaseUtils.getTextDimension(this._getGradientMaxLabelContent(), this.componentOption.style);
            var gap = Math.max(d1.width, d2.width, BAR_HEIGHT);
            return HEIGHT + gap * 2;
        },

        _calculateGradientLeftAndRightFinalSize: function () {
            var d = BaseUtils.getTextDimension(this._getGradientMinLabelContent(), this.componentOption.style);
            var gap = Math.max(d.height/2, BAR_HEIGHT/2);
            gap *= 2;
            return HEIGHT + gap * 2;
        },

        _calculateIntervalTopAndBottomFinalSize: function () {
            var len = this.items.length;
            if(len > 0){
                var d1 = BaseUtils.getTextDimension(this.items[0].label, this.componentOption.style);
                var d2 = BaseUtils.getTextDimension(this.items[len - 1].label, this.componentOption.style);
                var gap = Math.max(0, d1.width - ITEM_WIDTH, d2.width - ITEM_WIDTH);
                return len * ITEM_WIDTH + (len - 1) * ITEM_GAP + gap;
            }
            return 0;
        },

        _calculateIntervalLeftAndRightFinalSize: function () {
            var len = this.items.length;
            if(len > 0){
                var d1 = BaseUtils.getTextDimension(this.items[0].label, this.componentOption.style);
                var d2 = BaseUtils.getTextDimension(this.items[len - 1].label, this.componentOption.style);
                var gap = Math.max(0, d1.height - ITEM_WIDTH, d2.height - ITEM_WIDTH);
                return len * ITEM_WIDTH + (len - 1) * ITEM_GAP + gap;
            }
            return 0;
        },

        getTopBarPath: function () {
            return 'M7.236,10H13c1.105,0,2-0.895,2-2V2c0-1.105-0.895-2-2-2L2.618,0C1.875,0,1.391,0.782,1.724,1.447l3.724,7.447C5.786,9.572,6.479,10,7.236,10z';
        },

        getBottomBarPath: function () {
            return 'M7.236,0L13,0c1.105,0,2,0.895,2,2v6c0,1.105-0.895,2-2,2H2.618c-0.743,0-1.227-0.782-0.894-1.447l3.724-7.447C5.786,0.428,6.479,0,7.236,0z';
        },

        getLeftBarPath: function () {
            return 'M0,7.236V13c0,1.105,0.895,2,2,2h6c1.105,0,2-0.895,2-2V2.618c0-0.743-0.782-1.227-1.447-0.894L1.106,5.447C0.428,5.786,0,6.479,0,7.236z';
        },

        getRightBarPath: function () {
            return 'M10,7.236V13c0,1.105-0.895,2-2,2H2c-1.105,0-2-0.895-2-2L0,2.618c0-0.743,0.782-1.227,1.447-0.894l7.447,3.724C9.572,5.786,10,6.479,10,7.236z';
        },

        refreshPoints: function (min, max) {
            var minSize = this._gradientScale(min);
            var maxSize = this._gradientScale(max);
            var vanChart = this.vanchart;
            var change = false;
            var hasMap = this.vanchart.getChart(Constants.MAP_CHART);

            var points;
            vanChart.series.forEach(function (sery) {
                sery.points.forEach(function (point) {
                    if(!hasMap || (hasMap && point.points && point.points[0] == point)){
                        var temp = point.visible;

                        var size = BaseUtils.hasDefined(point.size) ? point.size : point.value;

                        point.visible = (size >= minSize && size <= maxSize) || (size >= maxSize && size <= minSize);

                        change = change || temp != point.visible;

                        if(hasMap){
                            points = point.points;
                            for(var i = 1, len = points.length; i < len; i++){
                                points[i].visible = point.visible;
                            }
                        }
                    }
                });
            });

            if(change) {
                vanChart.renderOnlyCharts();
            }
        }
    });

    require('../ComponentLibrary').register(Constants.RANGE_LEGEND_COMPONENT, RangeLegend);
    return RangeLegend;

});

/**
 * Created by eason on 15/6/15.
 * 默认主题
 */
define('theme/default',[],function(){

    var config = {
        colors:['#63b2ee','#76da91','#f8cb7f','#f89588','#7cd6cf','#9192ab','#7898e1','#efa666','#eddd86','#9987ce'],

        plotOptions:{

            visible:true,

            fillColorOpacity:1,

            dataLabels:{
                enabled:false
            }

        },

        tooltip:{
            enabled:true
        },

        tools:{
            enabled:true,
            "hidden": false
        },

        dTools:{
            style:{
                "fontFamily": "Microsoft Yahei",
                "color": "#b2b2b2",
                "fontSize": "12px",
                "fontWeight": ""
            },
            currentColor:'#62b2ef',
            backgroundColor:'white',
            enabled:false
        },

        legend:{
            visible:true,
            enabled:false,
            hiddenColor:'#cccccc',
            hoverColor:'green',
            borderRadius:0,
            borderColor:'rgb(204,204,204)',
            borderWidth:0,
            style:{
                color:'#666666',
                fontFamily:'Verdana',
                fontSize:'14px'
            },
            position:'right'
        },

        rangeLegend:{
            visible:true,
            enabled:false,
            borderWidth:0,
            hiddenColor:'#cccccc',
            hoverColor:'green',
            style:{
                color:'#666666',
                fontFamily:'Verdana',
                fontSize:'14px'
            },
            position:'right'
        },

        backgroundColor:null,
        backgroundImage:null,
        borderColor:  '#CCCCCC',
        borderWidth: 0,
        borderRadius: 0,
        shadow: false,

        plotBackgroundColor:null,
        plotBackgroundImage:null,
        plotBorderColor:  '#CCCCCC',
        plotBorderWidth: 0,
        plotBorderRadius: 0,
        plotShadow: false
    };

    return config;
});
/**
 * Created by eason on 15/6/17.
 */
define('VanChart',['require','./utils/BaseUtils','./utils/QueryUtils','./utils/Class','./ComponentLibrary','./ChartLibrary','./Constants','./render/RenderFactory','./Handler','./component/Series','./component/CoordinateSystem','./component/Title','./component/DrillTools','./component/Axis','./component/Geo','./component/CategoryAxis','./component/ValueAxis','./component/DateAxis','./component/Polar','./component/Legend','./component/Tooltip','./component/Toolbar','./component/ZoomBar','./component/DataSheet','./component/RangeLegend','./theme/config','./theme/default'],function(require){

    var BaseUtils = require('./utils/BaseUtils');
    var QueryUtils = require('./utils/QueryUtils');
    var Class = require('./utils/Class');

    var ComponentLibrary = require('./ComponentLibrary');
    var ChartLibrary = require('./ChartLibrary');
    var Constants = require('./Constants');
    var RenderFactory = require('./render/RenderFactory');
    var Handler = require('./Handler');
    var Series = require('./component/Series');
    var CoordinateSys = require('./component/CoordinateSystem');

    var COMPONENTS = [
        Constants.GEO_COMPONENT,
        Constants.TOOLBAR_COMPONENT,
        Constants.TITLE_COMPONENT,
        Constants.DRILL_TOOLS,
        Constants.LEGEND_COMPONENT,
        Constants.RANGE_LEGEND_COMPONENT,
        Constants.Y_AXIS_COMPONENT,
        Constants.X_AXIS_COMPONENT,
        Constants.POLAR_COMPONENT,
        Constants.RADIUS_AXIS_COMPONENT,
        Constants.ANGLE_AXIS_COMPONENT,
        Constants.GAUGE_AXIS_COMPONENT,
        Constants.ZOOM_COMPONENT,
        Constants.DATA_SHEET_COMPONENT,
        Constants.TOOLTIP_COMPONENT
    ];

    var AXES = [
        Constants.X_AXIS_COMPONENT,
        Constants.Y_AXIS_COMPONENT,
        Constants.POLAR_COMPONENT,
        Constants.RADIUS_AXIS_COMPONENT,
        Constants.ANGLE_AXIS_COMPONENT,
        Constants.GAUGE_AXIS_COMPONENT
    ];

    var PADDING = 5;

    //默认加载所有组件
    require('./component/Title');
    require('./component/DrillTools')
    require('./component/Axis');
    require('./component/Geo');
    require('./component/CategoryAxis');
    require('./component/ValueAxis');
    require('./component/DateAxis');
    require('./component/Polar');
    require('./component/Legend');
    require('./component/Tooltip');
    require('./component/Toolbar');
    require('./component/ZoomBar');
    require('./component/DataSheet');
    require('./component/RangeLegend');

    var VanChart = Class.extend({
        initialize:function(option, dom, vancharts){
            //组件
            this.width = this._getDomWidth(dom);
            this.height = this._getDomHeight(dom);
            this.ID_PREFIX = dom.getAttribute(Constants.INSTANCES_KEY) + vancharts.charts.length;

            this.coordinateSys = new CoordinateSys(Constants.PLANE);

            dom = this._initLeafLet(option, dom);
            option.state = Constants.STATE_INIT;

            this.dom = dom;
            this.dom.style.cssText += ';-ms-user-select:none;-webkit-user-select:none;-moz-user-select:none;-o-user-select:none;user-select:none;';
            this.dom.onselectstart = this.dom.ondrag = function(){
                return false;
            };
            this.vancharts = vancharts;

            this.handler = new Handler(this, dom);
            this.render = RenderFactory.getRender(Constants.VANCHART, this);

            this.components = {};
            this.charts = {};

            //这两个变量不应该出现在这里
            this.series = [];

            this.colorMap = {};

            this.refresh(option);
        },

        componentType:Constants.VANCHART,

        _initLeafLet:function(option, dom){
            if(option.geo){
                var chart = this;
                function viewreset(){

                    var map = chart.getChart(Constants.MAP_CHART);
                    var hoverPoint = chart.hoverPoint;
                    var zoomLevel = chart._leaflet.getZoom();
                    var layerIndex = map.layerIndex;

                    //检查是否要做自动下钻,如果下钻成功,则直接返回
                    if(hoverPoint && hoverPoint.geo && hoverPoint.drill){
                        var zoomListener = hoverPoint.geo.getZoomListener();
                        if(zoomListener && zoomListener <= zoomLevel){
                            map.drillDown(hoverPoint);
                            return ;
                        }
                    }

                    //检查是否做自动上钻,上钻则返回
                    var lastData = chart.lastIconData && chart.lastIconData[layerIndex - 1];
                    if(lastData && lastData.zoomListener > zoomLevel){
                        map.drillUp(lastData);
                        return ;
                    }

                    //没有自动上下钻取,则在当前地图上更新标签等内容
                    map.viewreset();
                };

                this.coordinateSys.setType(Constants.GEO);

                var options = {zoomControl:false, doubleClickZoom:false};
                option.geo.imageMap && BaseUtils.extend(options, {crs:L.CRS.Simple});

                this._leaflet = this._leaflet || L.map(dom, options);
                this._leaflet.on('zoom', viewreset, this._leaflet);
                this._leaflet.vanchart = this;

                BaseUtils.setDomBackground(dom, {
                    backgroundColor:option.backgroundColor,
                    borderColor:option.borderColor,
                    borderWidth:option.borderWidth,
                    borderRadius:option.borderRadius,
                    shadow:option.shadow
                });

                var root = document.createElement('div');
                root.setAttribute('class', 'leaflet-pane leaflet-map-pane');

                dom.appendChild(root);

                dom = this._leaflet._controlContainer.getElementsByTagName('div')[0];
            }
            return dom;
        },

        //外部调用接口，传入新的配置
        refresh:function(options){
            var sys = this.coordinateSys;
            if((options.geo && sys.type != Constants.GEO) || (!options.geo && sys.type == Constants.GEO)){
                this.remove();
                var dom = this.vancharts.dom;
                dom.className = '';
                this.initialize(options, dom, this.vancharts);
            }else{
                this._init(options);
                this._refreshOptions();
            }
        },

        refreshRestore:function(){

            this.currentOption = BaseUtils.clone(this.restoreOption);

            this.currentOption.state = Constants.STATE_RESTORE_REFRESH;

            this.scale = 1;

            this._refreshOptions();
        },

        isInitOrRestoreState: function () {
            return this.currentOption.state == Constants.STATE_INIT || this.currentOption.state == Constants.STATE_RESTORE_REFRESH;
        },

        isChangeDataState: function () {
            return this.currentOption.state == Constants.STATE_CHANGE_DATA_REFRESH;
        },

        isZoomRefreshState: function () {
            return this.currentOption.state == Constants.STATE_ZOOM_REFRESH;
        },

        dealAxisZoom:function(downPos, upPos){
            var bubble = this.getChart(Constants.BUBBLE_CHART);

            if(bubble && bubble.isForceBubble()){

                var isUpdateWithForce = bubble.isUpdateWithForce();

                if(isUpdateWithForce){
                    bubble.render.force.stop();
                }

                var plotBounds = this.getPlotBounds();

                var minX = Math.min(downPos[0], upPos[0]) - plotBounds.x;
                var minY = Math.min(downPos[1], upPos[1]) - plotBounds.y;

                var detX = Math.abs(downPos[0] - upPos[0]);
                var detY = Math.abs(downPos[1] - upPos[1]);

                var scale = Math.min(plotBounds.width/detX, plotBounds.height/detY);

                var wWidth = plotBounds.width / scale;
                var wHeight = plotBounds.height / scale;

                var shiftX = (plotBounds.width - wWidth)/2 - minX;
                var shiftY = (plotBounds.height - wHeight)/2 - minY;

                var series = bubble.getVisibleChartData();

                series.forEach(function(sery){

                    sery.points.forEach(function(point){

                        point.radius *= scale;

                        var x = point.x + shiftX;
                        var y = point.y + shiftY;

                        x -= plotBounds.width/2;
                        y -= plotBounds.height/2;

                        point.x = x * scale + plotBounds.width/2 - shiftX;
                        point.y = y * scale + plotBounds.height/2 - shiftY;

                        if(!isUpdateWithForce){
                            point.posX = point.x;
                            point.posY = point.y;
                        }

                        if(point.labelContent && point.labelDim){

                            var radius = point.radius;
                            if((point.labelDim.width > 2 * radius) || (point.labelDim.height > 2 * radius)){
                                point.labelPos = null;
                            }else{

                                point.labelPos = {
                                    x:-point.labelDim.width/2 + (isUpdateWithForce ? 0 : point.posX),
                                    y:-point.labelDim.height/2 + (isUpdateWithForce ? 0 : point.posY)
                                }
                            }
                        }
                    })
                });

                this.scale = scale * BaseUtils.pick(this.scale, 1);
                bubble.render.scaleRender();
            }else{
                this.currentOption.state = Constants.STATE_ZOOM_REFRESH;
                var zoomType = this.currentOption.zoom.zoomType;

                if(this.components.xAxis && zoomType.indexOf('x') != -1){
                    this.components.xAxis.axisZoom(downPos, upPos);
                }

                if(this.components.yAxis && zoomType.indexOf('y') != -1){
                    this.components.yAxis.axisZoom(downPos, upPos);
                }

                this.layoutComponentsAndCharts();
            }
        },

        refreshIncreaseOrder:function(){

            this.currentOption.orderType = Constants.ASCENDING;

            this.layoutComponentsAndCharts();
        },

        refreshDecreaseOrder:function(){

            this.currentOption.orderType = Constants.DESCENDING;

            this.layoutComponentsAndCharts();
        },

        //走这边的话要重画缩放控件
        _refreshOptions:function(){

            this.series = [];//置空

            this.colorMap = {};

            var option = this.currentOption;

            //先构建组件的对象,主要是构建坐标轴
            var coSys = this.coordinateSys;
            var ComponentClass, componentType, component;
            for(var i = 0; i < COMPONENTS.length; i++){
                componentType = COMPONENTS[i];
                component = this.components[componentType];
                if(option[componentType] && this._isComponentEnabled(option[componentType]) && coSys.accept(componentType)){
                    if(component){
                        component.refresh(option);
                    }else{
                        //新建component
                        ComponentClass = ComponentLibrary.get(
                            AXES.indexOf(componentType) > -1 ?
                                Constants.AXIS_COMPONENT :
                                componentType
                        );
                        component = new ComponentClass(this, option, componentType);
                        this.components[componentType] = component;
                    }
                }else if(component){
                    component.remove();
                    this.components[componentType] = null;
                    delete this.components[componentType];
                }
            }

            //先确定构成图的种类
            var chartType = option.chartType || Constants.LINE_CHART;
            var ChartClass;

            //地图算钻取的系列的时候需要纪录是第几个系列
            this.totalSeriesCount = 0;

            for(var i = 0, len = option.series.length; i < len; i++){
                var sery = option.series[i];
                var seryChartType = sery.type || chartType;
                var classType = seryChartType.toLowerCase().indexOf(Constants.MAP_CHART) != -1 ? Constants.MAP_CHART : seryChartType;
                ChartClass = ChartLibrary.get(classType);
                if(ChartClass){
                    var chart = this.charts[classType];
                    if(chart){
                        chart.refresh(option)
                    }else{
                        chart = new ChartClass(this, option, classType);
                        this.charts[classType] = chart;
                    }

                    sery.type = seryChartType;
                    this.series.push(new Series(chart, sery));
                }
            }

            this.series.originSeries = option.series;

            //对于所有的type都是bubble,scatter的地图,chartType也需要构造一个map对象
            var isMap = chartType.toLowerCase().indexOf(Constants.MAP_CHART) != -1;
            var mapKey = Constants.MAP_CHART;
            if(isMap){
                var map = this.charts[mapKey], MapClass = ChartLibrary.get(mapKey);
                if(map){
                    map.refresh(option);
                }else if(MapClass){
                    this.charts[mapKey] = new MapClass(this, option, mapKey);
                }
            }

            var padding = PADDING + (option.padding ? option.padding : 0);

            this.bounds = BaseUtils.makeBounds(padding, padding, this.width - 3 * padding, this.height - 3 * padding);

            var zoom = this.components[Constants.ZOOM_COMPONENT];
            if(zoom){
                zoom.doLayout();
                zoom.remove();
            }

            var map = this.charts[Constants.MAP_CHART];
            map && map.initLayerInfo();

            this.plotBounds = this.bounds;

            this.refreshComponentsAndSeries();
        },

        _isValidPoint: function (rangeLegend, point) {
            return !this._isBubbleAndNegative(point) && !this._isNullPoint(point) && !this._isOutRangeLegend(rangeLegend, point);
        },

        _isBubbleAndNegative: function (p) {
            var isBubble = p.series.type == Constants.BUBBLE_CHART;
            var isNegative = !p.displayNegative && p.size < 0;
            return isBubble && isNegative;
        },

        _isNullPoint: function (p) {
            var isBubbleNull = p.series.type == Constants.BUBBLE_CHART && (p.size == '-' || p.isNull);
            var isScatterNull = p.series.type == Constants.SCATTER_CHART && p.isNull;
            return isBubbleNull || isScatterNull;
        },

        _isOutRangeLegend: function (rangeLegend, p) {
            if(rangeLegend){
                return !rangeLegend.getColorWithSize(BaseUtils.hasDefined(p.size) ? p.size : p.value);
            } else {
                return false;
            }
        },

        refreshComponentsAndSeries:function(){

            this.hoverPoint = null;
            this.hoverSeries = null;

            for(var component in this.components){
                this.components[component].initAttributesWithSeries();
            }

            var hasChart = this.charts[Constants.MAP_CHART];
            var rangeLegend = this.components[Constants.RANGE_LEGEND_COMPONENT];

            if(!hasChart){
                var vanchart = this;
                this.series.forEach(function(sery){
                    sery.points = sery.points.filter(function (point) {
                        return vanchart._isValidPoint(rangeLegend, point);
                    });
                });
            }

            this.layoutComponentsAndCharts();
        },


        layoutComponentsAndCharts:function(){

            if(this.currentOption.orderType){
                for(var chart in this.charts){
                    this.charts[chart].orderData();
                }
            }

            this.bounds = BaseUtils.clone(this.plotBounds);

            for(var component in this.components){
                if(component != Constants.ZOOM_COMPONENT){
                    this.components[component].doLayout();
                }
            }

            //坐标轴,数据表,缩放控件要根据绘图区的区域来确定边界
            var components = this.components;
            [
                Constants.Y_AXIS_COMPONENT,
                Constants.X_AXIS_COMPONENT,
                Constants.DATA_SHEET_COMPONENT
            ]
                .forEach(function(cName){

                    var component = components[cName];

                    if(component){
                        component.fixBoundsByPlot();
                    }
                });

            [
                Constants.GAUGE_AXIS_COMPONENT,
                Constants.RADIUS_AXIS_COMPONENT,
                Constants.ANGLE_AXIS_COMPONENT
            ]
                .forEach(function (cName) {
                    var component = components[cName];

                    if (component) {
                        component.calculateTickData();
                    }
                });

            //处理0值对齐的坐标轴的位置
            [Constants.Y_AXIS_COMPONENT, Constants.X_AXIS_COMPONENT]
                .forEach(function(cName){
                    var component = components[cName];
                    if(component){
                        component.dealOnZero();
                    }
                });

            [
                Constants.ZOOM_COMPONENT,
            ]
                .forEach(function(cName){

                    var component = components[cName];

                    if(component){
                        component.fixBoundsByPlot();
                    }
                });

            //缩放之前的位置
            this.plotOriginalBounds = this.plotOriginalBounds || BaseUtils.clone(this.bounds);

            // stack
            this._buildStacked(this.series);

            for(var chart in this.charts){
                this.charts[chart].getRender() && this.charts[chart].doLayout();
            }

            this.handler.initTargets();

            
            var hasChart = this.charts[Constants.MAP_CHART];
            var rangeLegend = this.components[Constants.RANGE_LEGEND_COMPONENT];
            if(hasChart && rangeLegend){//地图的过滤要过滤两次
                this.series.forEach(function(sery){
                    sery.points = sery.points.filter(function (p) {

                        if(p.points && p.points.length){
                            p = p.points[0];
                        }
                        var withinRange = rangeLegend.getColorWithSize(BaseUtils.hasDefined(p.size) ? p.size : p.value);

                        return withinRange || p.drillSeries;
                    });
                });
            }

            this.render.render();
        },

        _buildStacked: function (series) {
            var stackMap = {};

            series.map(function (ser) {
                if (ser.type === Constants.SCATTER_CHART ||
                    ser.type === Constants.BUBBLE_CHART ||
                    !ser.visible ||
                    !ser.baseAxis) {
                    return;
                }
                ser.points.map(function (p) {
                    var key = [
                        ser.baseAxis.componentType,
                        ser.baseAxis.getPosition(),
                        ser.stack || (ser.isValueAxisBased() ? ser.name : ser.type),
                        p.category
                    ].join('');

                    stackMap[key] || (stackMap[key] = []);
                    stackMap[key].push(p);
                });
            });

            for (var key in stackMap) {
                this._calculatePercentage(stackMap[key]);
                //
                stackMap[key][0].series.chart._mergeTooltipAttributes(stackMap[key]);
                this._calculateStackedValue(stackMap[key]);
            }
        },

        _calculatePercentage:function(points, key){
            key = key || 'value';
            var total = 0;
            points.forEach(function(d){
                total += Math.abs(d[key]);
            });

            total = total > 0 ? total : 1;
            points.forEach(function(point){
                point.setPercentage(Math.abs(point[key]) / total);
            });
        },

        _calculateStackedValue:function(points){

            if(points && points.length){

                var byPercent = points[0].series.stackByPercent;
                var stack = points[0].series.stack || byPercent;
                var valueAxis = points[0].series.valueAxis;

                var preSumP = valueAxis ? valueAxis.getStartPosValue() : 0;
                var preSumN = valueAxis ? -valueAxis.getStartPosValue() : 0;

                for(var i = 0, count = points.length; i < count; i++){

                    var point = points[i];

                    if(stack){
                        var usedValue = byPercent ? point.percentage : point.value;

                        point.y = usedValue;

                        if(usedValue >= 0){
                            point.y0 = preSumP;
                            preSumP += usedValue;
                        }else{
                            point.y0 = preSumN;
                            preSumN += usedValue;
                        }
                    }else{
                        point.y = byPercent ? point.percentage : point.value;
                        point.y0 = valueAxis ? valueAxis.getStartPosValue() : 0;
                    }
                }
            }
        },

        _init:function(option){

            option.series = (option.series && option.series.length) ? option.series : [{}];//保证series不为空

            option.series.forEach(function(sery){
                sery.data = sery.data || [];
            });

            //坐标轴可能是数组
            this.themeConfig = this._normalizeOption(this._mergeThemeConfig(option), option);

            this.restoreOption = QueryUtils.merge(BaseUtils.clone(option), this.themeConfig, false);

            if(this.restoreOption.chartType == Constants.SCATTER_CHART
                || this.restoreOption.chartType == Constants.BUBBLE_CHART){

                var sort = this.restoreOption.tools.sort || {};
                sort.enabled = false;
            }
            
            if (this.restoreOption.plotOptions.inverted) {
                if (this.restoreOption.zoom && this.restoreOption.zoom.zoomTool) {
                    this.restoreOption.zoom.zoomTool.visible = false;
                }
                if (this.restoreOption.dataSheet) {
                    this.restoreOption.dataSheet = false;
                }
            }

            this.currentOption = BaseUtils.clone(this.restoreOption);
        },

        renderOnlyCharts:function() {

            var bubble = this.getChart(Constants.BUBBLE_CHART);
            if(bubble && bubble.isUpdateWithForce()) {
                bubble.render.force.stop();
            }

            for(var chart in this.charts){
                this.charts[chart].getRender() && this.charts[chart].doLayout();
            }

            var charts = this.getChartRenders();
            charts.forEach(function(render){
                render.filterRender();
            });

            if(!BaseUtils.isSupportSVG()){
                var components = this.components;

                COMPONENTS.forEach(function(type){
                    if(components[type]){
                        var component = components[type];
                        if(component.isFloat){
                            var render = component.getRender();
                            if(render){
                                render.render();
                            }
                        }
                    }
                });
            }
        },

        _getDomWidth:function(root){
            var stl = root.currentStyle || document.defaultView.getComputedStyle(root);
            return ((root.clientWidth || parseInt(stl.width, 10)) - parseInt(stl.paddingLeft, 10) - parseInt(stl.paddingRight, 10)).toFixed(0) - 0;
        },

        _getDomHeight:function(root){
            var stl = root.currentStyle || document.defaultView.getComputedStyle(root);
            return ((root.clientHeight || parseInt(stl.height, 10)) - parseInt(stl.paddingTop, 10) - parseInt(stl.paddingBottom, 10)).toFixed(0) - 0;
        },

        _normalizeOption:function(themeConfig, option){

            themeConfig = BaseUtils.clone(themeConfig);

            AXES.map(function (axis) {
                if (!option[axis]) {
                    return;
                }

                if (!Array.isArray(option[axis])) {
                    option[axis] = [option[axis]];
                }

                if (option[axis].length) {
                    themeConfig[axis] =
                        option[axis].map(function () {
                            return themeConfig[axis];
                        });
                } else if (themeConfig[axis]) {
                    option[axis][0] = themeConfig[axis];
                }

                return null;
            });

            return themeConfig;

        },

        //默认配置，主题配置的组合
        _mergeThemeConfig:function(option){
            var defaultConfig = require('./theme/config');
            var themeConfig = require('./theme/default');

            var chartTypes = [];
            var result = {};
            
            QueryUtils.merge(result, themeConfig, true);

            if(option.chartType) {
                chartTypes.push(option.chartType);
                QueryUtils.merge(result, defaultConfig[option.chartType], true);
            }

            option.series.map(function (item) {
                var type = item.type;
                if (type && chartTypes.indexOf(type) === -1) {
                    chartTypes.push(item);
                    QueryUtils.merge(result, defaultConfig[type], true);
                }
            });

            if (chartTypes.length === 0) {
                QueryUtils.merge(result, defaultConfig[Constants.LINE_CHART], true);
            }

            return result;
        },

        _isComponentEnabled:function(componentOption){
            if(BaseUtils.hasDefined(componentOption.enabled)){
                return componentOption.enabled;
            }
            return true;
        },

        getPlotBackgroundOption:function(){
            var option = this.currentOption;
            return {
                color:option.plotBackgroundColor,
                image:option.plotBackgroundImage,
                borderColor:option.plotBorderColor,
                borderWidth:option.plotBorderWidth,
                borderRadius:option.plotBorderRadius,
                plotShadow:option.plotShadow
            }
        },

        getChartBackgroundOption:function(){
            var option = this.currentOption;

            var geo = this.restoreOption.geo;

            return {
                color:geo ? '' : option.backgroundColor,
                image:geo ? '' : option.backgroundImage,
                borderColor:option.borderColor,
                borderWidth:geo ? 0 : option.borderWidth,
                borderRadius:option.borderRadius,
                chartShadow:option.shadow
            }

        },

        getTrendLineOption:function(){

            var trendLines = [];
            var series = this.series;

            for(var i = 0, len = series.length; i < len; i++){
                var sery = series[i];

                var trendLine = sery.trendLine;

                //堆积的系列用趋势线没意义吧
                if(!trendLine || !sery.visible){
                    continue;
                }

                var XY = sery.chart.getTrendLineXYValues(sery);
                var xValues = XY[0];
                var yValues = XY[1];
                var location = XY[2];

                if(xValues.length <= 1){
                    continue;
                }

                var x1,x2,y1,y2;

                if(location == Constants.TOP || location == Constants.BOTTOM){
                    var leastSquaresCoeff = this._leastSquares(XY[0], XY[1]);

                    x1 = xValues[0];
                    y1 = leastSquaresCoeff[0] * x1 + leastSquaresCoeff[1];
                    x2 = xValues[xValues.length - 1];
                    y2 = leastSquaresCoeff[0] * x2 + leastSquaresCoeff[1];
                }else{

                    var leastSquaresCoeff = this._leastSquares(XY[1], XY[0]);

                    y1 = yValues[0];
                    x1 = leastSquaresCoeff[0] * y1 + leastSquaresCoeff[1];
                    y2 = yValues[yValues.length - 1];
                    x2 = leastSquaresCoeff[0] * y2 + leastSquaresCoeff[1];
                }

                trendLines.push({
                    x1:x1,
                    y1:y1,
                    x2:x2,
                    y2:y2,
                    trendLine:trendLine
                })
            }

            return trendLines;
        },

        _leastSquares:function(xValues, yValues){
            var reduceSumFunc = function(prev, cur) { return prev + cur; };

            var xBar = xValues.reduce(reduceSumFunc) * 1.0 / xValues.length;
            var yBar = yValues.reduce(reduceSumFunc) * 1.0 / yValues.length;

            var ssXX = xValues.map(function(d) { return Math.pow(d - xBar, 2); })
                .reduce(reduceSumFunc);

            var ssYY = yValues.map(function(d) { return Math.pow(d - yBar, 2); })
                .reduce(reduceSumFunc);

            var ssXY = xValues.map(function(d, i) { return (d - xBar) * (yValues[i] - yBar); })
                .reduce(reduceSumFunc);

            var slope = ssXY / ssXX;
            var intercept = yBar - (xBar * slope);

            return [slope, intercept];
        },

        //地图和别的图表类型不一样,而且这个计算
        getMinMaxFromSeries:function(){

            var options = this.currentOption;
            var accountPoints = [], series = options.series, chartType = options.chartType;
            if(options.geo){
                var validArea = {}, validPoint = {}, geo = this.components[Constants.GEO_COMPONENT];

                for(var i = 0, len = series.length; i < len; i++){
                    var sery = series[i], type = sery.type || chartType;

                    if(!sery.data || !sery.data.length){
                        continue;
                    }

                    if(type == Constants.AREA_MAP){//面积类型的地图计算第一个有效的系列,考虑到多系列的情况
                        var points = sery.data;
                        for(var pIndex = points.length - 1; pIndex >= 0; pIndex--){
                            var point = points[pIndex];
                            if(validArea[point.name] || !point.value){
                                continue;
                            }
                            validArea[point.name] = true;
                            accountPoints.push(point);
                        }
                    }else{
                        sery.data.forEach(function(point){
                            var key = point.lnglat ? point.lnglat.join(',') : point.name;
                            //对于同一种类型的点,并且经纬度一样的时候,只取当前的第一个有效点
                            if((validPoint[type] && validPoint[type][key]) || (!point.size && !point.value)){
                                return;
                            }
                            validPoint[type] = validPoint[type] || {};
                            validPoint[type][key] = true;
                            accountPoints.push(point);
                        });
                    }
                }
            }else{
                for(var i = series.length - 1; i >= 0; i--){
                    series[i].data.forEach(function(point){
                        accountPoints.push(point)
                    });
                }
            }

            return this._getMinMaxFromPoints(accountPoints);
        },

        _getMinMaxFromPoints:function(points){

            if(!points.length){
                return [0, 0];
            }

            var isForceBubble =  this.currentOption.plotOptions.force;
            var min = Number.MAX_VALUE, max = -min;
            points.forEach(function (point) {
                //到现在为止用来当作指标的有size,和value
                var value = BaseUtils.hasDefined(point.size) ? point.size : point.value;
                if(isForceBubble){
                    value = point.y;
                }

                if(!isNaN(parseFloat(value))){
                    min = Math.min(value, min);
                    max = Math.max(value, max);
                }
            });

            if(isNaN(min) || isNaN(max) || max < min){
                min = 0; max = 100;
            }

            return [min, max]
        },

        getParentDom:function(){
            return this.dom;
        },

        getDivParentDom:function(){
            return this.vancharts.dom;
        },

        isInverted: function () {
            return !!this.getOptions().plotOptions.inverted;
        },

        chartWidth:function(){
            return this.width;
        },

        chartHeight:function(){
            return this.height;
        },

        setPlotBounds:function(newBounds){
            this.bounds = newBounds;
        },

        getPlotClipBounds:function(){

            var x = 0;
            var y = 0;
            var width = this.bounds.width;
            var height = this.bounds.height;

            var locationMap = {};
            var all = [];
            if(this.components.xAxis){
                all = all.concat(this.components.xAxis.getAllAxis());
            }

            if(this.components.yAxis){
                all = all.concat(this.components.yAxis.getAllAxis());
            }

            all.forEach(function(axis){
                var position = axis.getPosition();
                if(!axis.isOnZero() && !locationMap[position]){
                    locationMap[position] = axis.getLineWidth();
                }
            });

            y = locationMap[Constants.TOP] ? Math.ceil(locationMap[Constants.TOP]/2) : 0;
            height -= y;
            height = locationMap[Constants.BOTTOM] ? height - Math.ceil(locationMap[Constants.BOTTOM]/2 - 0.5) : height;

            x = locationMap[Constants.LEFT] ? Math.ceil(locationMap[Constants.LEFT]/2) : 0;
            width -= x;
            width = locationMap[Constants.RIGHT] ? width - Math.ceil(locationMap[Constants.RIGHT]/2) : width;

            return {
                x:x,
                y:y,
                width:width,
                height:height
            };

        },

        getPlotBounds:function(){
            return this.bounds;
        },

        getChartBounds:function(){
            return BaseUtils.makeBounds(0, 0, this.width, this.height);
        },

        xAxis:function(axisIndex){
            if(!axisIndex){
                axisIndex = 0;
            }
            var axis = this.components.xAxis;
            return axis ? axis.getAxis(axisIndex) : null;
        },

        yAxis:function(axisIndex){
            if(!axisIndex){
                axisIndex = 0;
            }
            var axis = this.components.yAxis;
            return axis ? axis.getAxis(axisIndex) : null;
        },

        polar:function(axisIndex){
            if(!axisIndex){
                axisIndex = 0;
            }
            var axis = this.components.polar;
            return axis ? axis.getAxis(axisIndex) : null;
        },

        angleAxis: function (axisIndex) {
            if(!axisIndex){
                axisIndex = 0;
            }
            var axis = this.components.angleAxis;
            return axis ? axis.getAxis(axisIndex) : null;
        },

        radiusAxis: function (axisIndex) {
            if(!axisIndex){
                axisIndex = 0;
            }
            var axis = this.components.radiusAxis;
            return axis ? axis.getAxis(axisIndex) : null;
        },

        gaugeAxis: function (axisIndex) {
            if(!axisIndex){
                axisIndex = 0;
            }
            var axis = this.components.gaugeAxis;
            return axis ? axis.getAxis(axisIndex) : null;
        },

        getSharedAxis: function () {
            var axes = [this.xAxis(), this.yAxis(), this.angleAxis()];

            for (var i = 0; i < axes.length; i++) {
                var axis = axes[i];
                if (!axis) {
                    continue;
                }
                var sharedPointsLength = 0;
                for (var item in axis.sharedPoints) {
                    ++sharedPointsLength;
                    break;
                }

                if (sharedPointsLength) {
                    return axis;
                }
            }

            return null;
        },

        getRender:function(){
            return this.render;
        },

        getChartRenders:function(){
            var renders = [];
            for(var chart in this.charts){
                var render = this.charts[chart].getRender();
                if(render){
                    renders.push(render);
                }
            }
            return renders;
        },

        getComponentRenders:function(){
            var renders = [];

            var components = this.components;

            COMPONENTS.forEach(function(type){
                if(components[type]){
                    var render = components[type].getRender();
                    if(render){
                        renders.push(render);
                    }
                }
            });

            return renders;
        },

        getFixedComponentRenders:function(){

            var renders = [];
            var components = this.components;

            COMPONENTS.forEach(function(type){
                if(components[type]){
                    var component = components[type];
                    if(!component.isFloat){
                        var render = component.getRender();
                        if(render){
                            renders.push(render)
                        }
                    }

                }
            });

            return renders;
        },

        getFloatComponentRenders:function(){
            var renders = [];
            var components = this.components;

            COMPONENTS.forEach(function(type){
                if(components[type]){
                    var component = components[type];
                    if(component.isFloat){
                        var render = component.getRender();
                        if(render){
                            renders.push(render)
                        }
                    }
                }
            });

            return renders;
        },

        getToolbarWidth:function(){
            if(this.components[Constants.TOOLBAR_COMPONENT]){
                return this.components[Constants.TOOLBAR_COMPONENT].getToolbarWidth();
            }
            return 0;
        },

        //没有标题，并且图例在右上方的时候把工具栏的高度空出来
        getToolbarHeight:function(){
            var title = this.components[Constants.TITLE_COMPONENT];
            if(this.components[Constants.TOOLBAR_COMPONENT] && (!title || title.isFloat) ){
                return this.components[Constants.TOOLBAR_COMPONENT].getToolbarHeight();
            }
            return 0;
        },

        getTooltip:function(){
            return this.components.tooltip;
        },

        getComponent:function(type){
            return this.components[type];
        },

        getChart:function(type){
            return this.charts[type];
        },

        getIDPrefix:function(){
            return this.ID_PREFIX;
        },

        getBodyClipID:function(){
            return 'bodyClip' + this.getIDPrefix();
        },

        getOptions:function(){
            return this.currentOption;
        },

        /**
         * return color of previous name
         * or set new color and return
         * @param {string} [name] series item (or pie point) name
         * @returns {*}
         */
        getDefaultSeriesColor: function (name) {
            if (typeof name !== 'string') {
                throw new TypeError(name);
            }

            if (!this.colorMap[name]) {
                var colors = this.currentOption.colors;
                var length = 0;
                for (var item in this.colorMap) {
                    ++length;
                }
                // return next color
                this.colorMap[name] = colors[length % colors.length];
            }

            return this.colorMap[name];
        },

        remove:function(){

            this.render.remove();
            this._leaflet && this._leaflet.remove();
            this.handler.offEvents();

            this.render = this._leaflet = this.handler = null;

            if(this.components[Constants.TOOLTIP_COMPONENT]){
                this.components[Constants.TOOLTIP_COMPONENT].remove();
            }
        }
    });

    return VanChart;
});
/**
 * Created by eason on 15/5/15.
 * 管里当前产生的所有
 */
define('VanCharts',['require','./utils/BaseUtils','./Constants','./VanChart'],function(require){

    var BaseUtils = require('./utils/BaseUtils');
    var Constants = require('./Constants');
    var VanChart = require('./VanChart');

    var _baseIndex = 0;

    var _instances = Object.create(null);

    function init(dom){
        var instanceKey = dom.getAttribute(Constants.INSTANCES_KEY);
        if(!instanceKey){
            instanceKey = Constants.INSTANCES_KEY + _baseIndex++;
            dom.setAttribute(Constants.INSTANCES_KEY, instanceKey);
        }

        if(_instances[instanceKey]){
            //key对应的实例已经存在的话先删掉
            var svgRoot = _instances[instanceKey].svgRoot;
            if(svgRoot){
                svgRoot.remove();
            }
        }else{
            var vanCharts = new VanCharts(dom);
            _instances[instanceKey] = vanCharts;
        }

        return _instances[instanceKey];
    }

    function VanCharts(dom){
        this.dom = dom;
        this.charts = [];
    }

    VanCharts.prototype = {
        constructor:VanCharts,

        setOptions:function(options){
            if(!BaseUtils.isArray(options)){
                options = [options];
            }
            this.options = options;

            for(var i = 0, len = options.length; i < len; i++){
                this.charts.push(new VanChart(options[i], this.dom, this));
            }
        },

        resize:function(options){

            this.clear();

            this.charts = [];

            options = options || this.options;
            this.options = options;

            options && this.setOptions(options);
        },

        setData:function(options){

            if(!BaseUtils.isArray(options)){
                options = [options];
            }
            this.options = options;

            if(BaseUtils.isSupportSVG()){
                this.charts.forEach(function(chart, i){
                    options[i].state = Constants.STATE_CHANGE_DATA_REFRESH;
                    chart.refresh(options[i]);
                });
            }else{
                this.resize(options);
            }
        },

        clear:function(){

            for(var i = 0, len = this.charts.length; i < len; i++){
                this.charts[i].remove();
                this.charts[i] = null;
            }
        },

        addHiddenStyle: function () {
            var cssString = '.' + Constants.CHART_HIDE +' {display:none;}';

            function addCssByStyle(css){
                var style = document.createElement("style");
                var head = document.head || document.getElementsByTagName('head')[0];

                style.setAttribute("type", "text/css");

                if (style.styleSheet){
                    style.styleSheet.cssText = css;
                } else {
                    style.appendChild(document.createTextNode(css));
                }

                head.appendChild(style);
            }

            addCssByStyle(cssString);
        }
    };

    return {
        init:init
    };
});
/**
 * Created by eason on 15/5/4.
 * 一些最常用的工具方法
 */
define('utils/BaseUtils',['require','./ColorUtils','../Constants','VanCharts'],function(require){

    var ColorUtils = require('./ColorUtils');
    var Constants = require('../Constants');

    var lastID = 0;

    var styleToCss = {
        color:'fill',
        font:'font',
        fontFamily:'font-family',
        fontSize:'font-size',
        fontStretch:'font-stretch',
        fontStyle:'font-style',
        fontVariant:'font-variant',
        fontWeight:'font-weight',
        letterSpacing:'letter-spacing',
        lineHeight:'line-height',
        quotes:'quotes',
        textAlign:'text-align',
        textDecoration:'text-decoration',
        textIndent:'text-indent',
        textShadow:'text-shadow',
        textTransform:'text-transform',
        whiteSpace:'white-space',
        wordSpacing:'word-spacing',
        padding:'padding'
    };

    /**
     * pick参数里第一个不为null和undefined的值
     * @returns {*}
     */
    function pick(){
        var arg, length = arguments.length;
        for (var i = 0; i < length; i++) {
            arg = arguments[i];
            if (typeof arg !== 'undefined' && arg !== null) {
                return arg;
            }
        }
        return null;
    }

    /**
     * 判断对象是否是数组
     * @param value 对象
     * @returns {boolean} 是否是数组
     */
    function isArray(value){
        return Object.prototype.toString.apply(value) === '[object Array]';
    }

    /**
     * 将具有length属性的对象转成数组
     * @param sequence 对象
     */
    function toArray(sequence){
        return Array.prototype.slice.call(sequence);
    }

    function setTextStyle(textS, style){
        style = cssNormalization(style);
        for(var attr in style){
            textS.style(attr, style[attr]);
        }
    }

    /**
     * 返回字体是fontSize(有单位，px,em)
     * @param fontSize
     */
    function getTextDimension(text, style, useHtml){
        text = pick(text, "");
        var div = document.createElement("div");
        var container = document.getElementById("container");
        if(!container){
            container = document.getElementsByTagName("body")[0]
        }
        container.appendChild(div);

        div.style.visibility = "hidden";
        div.style.whiteSpace = "nowrap";
        div.style.position = 'absolute';

        var fontSize = '12px';

        for(var property in style){
            if(typeof(style[property]) != "function" && property != 'color'){
                div.style[property] = style[property];
            }

            if(property == 'fontSize'){
                fontSize = style[property];
            }
        }

        if(fontSize.indexOf('pt') != -1){
            fontSize = parseFloat(fontSize) * 4 / 3;
        }else{
            fontSize = parseFloat(fontSize);
        }

        div.innerHTML = text;
        //fireFox下面innerText的话offsetWidth为0
        //useHtml ? span.innerHTML = text : span.innerText = text;
        var width = div.offsetWidth || 0;
        var height = div.offsetHeight || 0;

        container.removeChild(div);

        return {width:width, height:height};
    }

    function getTextWrapDimension(text, style, useHTML){
        text = pick(text, "");
        var div = document.createElement("div");
        var container = document.getElementById("container");
        if(!container){
            container = document.getElementsByTagName("body")[0]
        }
        container.appendChild(div);

        div.style.visibility = "hidden";
        div.style.whiteSpace = "normal";
        div.style.position = 'absolute';
        div.style.wordWrap = 'break-word';

        for(var property in style){
            if(typeof(style[property]) != "function" && property != 'color'){
                div.style[property] = style[property];
            }
        }

        if (useHTML) {
            div.innerHTML = text;
        } else {
            div.textContent ?
                (div.textContent = text) :
                (div.innerText = text);
        }
        //fireFox下面innerText的话offsetWidth为0
        //useHtml ? span.innerHTML = text : span.innerText = text;
        var width = div.offsetWidth || 0;
        var height = div.offsetHeight || 0;

        container.removeChild(div);

        return {width:width, height:height};
    }

    function setDomBackground(dom, opt){

        var cssText = [];
        if (opt.backgroundColor) {
            if(typeof opt.backgroundColor == 'string'){
                if(isSupportSVG()){
                    cssText.push('background-Color:' + opt.backgroundColor);
                }else{
                    var hexAlpha = ColorUtils.colorToHexAlpha(opt.backgroundColor);
                    cssText.push('background-Color:' + hexAlpha.hex);
                    cssText.push('filter:alpha(opacity=' + hexAlpha.alpha + ')')
                }
            }else if(typeof opt.backgroundColor == 'object'){

                var color = opt.backgroundColor;
                var startColor = ColorUtils.colorToHex(color.startColor);
                var endColor = ColorUtils.colorToHex(color.endColor);

                var start = 'left';

                var startPos = 'left top';
                var endPos = 'right top';
                var type = 1;

                if(color.x1 == color.x2){
                    start = 'top';

                    startPos = 'left top';
                    endPos = 'left bottom';

                    type = 0;
                }

                cssText.push('background: -ms-linear-gradient(' + start + ', '+ startColor +', '+ endColor +')');

                cssText.push('background-image: -moz-linear-gradient(' + start + ', '+ startColor +', '+ endColor +')');

                cssText.push('background-image: -webkit-gradient(linear, '+startPos+', '+endPos+', color-stop(0, '+ startColor +'), color-stop(1, '+ endColor+'))');

                cssText.push('filter: progid:DXImageTransform.Microsoft.gradient(startColorstr='+startColor + ', endColorstr='+endColor+', GradientType='+type+')');
            }
        }

        if (opt.borderWidth != null) {
            cssText.push('border-width:' + opt.borderWidth + 'px');
        }

        if (opt.borderColor != null) {
            cssText.push('border-color:' + opt.borderColor);
        }

        if (opt.borderRadius != null) {
            cssText.push(
                'border-radius:' + opt.borderRadius + 'px'
            );
            cssText.push(
                '-moz-border-radius:' + opt.borderRadius + 'px'
            );
            cssText.push(
                '-webkit-border-radius:' + opt.borderRadius + 'px'
            );
            cssText.push(
                '-o-border-radius:' + opt.borderRadius + 'px'
            );
        }

        if(opt.shadow){
            cssText.push('box-shadow:1px 1px 2px rgba(0,0,0,0.2)');
        }

        dom.style.cssText += cssText.join(';') + ';';
    }

    function getTextHeight(style) {

        var fontSize = style.fontSize || '12px';

        return fontSize.indexOf('pt') != -1 ? parseFloat(fontSize) * 4 / 3 : parseFloat(fontSize);
    }

    function stamp(obj){
        obj._vanchart_id = obj._vanchart_id || ++lastID;
        return obj._vanchart_id;
    }

    function falseFn() {
        return false;
    }

    //properties mix in
    function extend(dest) {
        var i, j, len, src;

        for (j = 1, len = arguments.length; j < len; j++) {
            src = arguments[j];
            for (i in src) {
                dest[i] = src[i];
            }
        }

        return dest;
    }

    function divRotate(div, rotation){

        var cssText = [];
        cssText.push('transform:rotate(' + rotation + 'deg)');
        cssText.push('-ms-transform:rotate(' + rotation + 'deg)');
        cssText.push('-webkit-transform:rotate(' + rotation + 'deg)');
        cssText.push('-moz-transform:rotate(' + rotation + 'deg)');
        cssText.push('-o-transform:rotate(' + rotation + 'deg)');

        var costheta = Math.cos(toRadian(rotation));
        var sintheta = Math.sin(toRadian(rotation));

        //ie9的时候filter和ms-transform同时生效了
        if(!isSupportSVG()){
            var filter = rotation ? ['progid:DXImageTransform.Microsoft.Matrix(M11=', costheta,
                ', M12=', -sintheta, ', M21=', sintheta, ', M22=', costheta,
                ', sizingMethod=\'auto expand\')'].join('') : 'none';
            cssText.push('filter:' + filter);
        }

        div.style.cssText += (cssText.join(';') + ';');
    }

    function splitText(text, style, offeredSize, padding){

        if(!text){
            return '';
        }

        text += '';

        padding = padding || 0;

        offeredSize -= 2*padding;

        var result = [];

        var startIndex = 0;
        var textCount = text.length;

        while(startIndex < textCount){
            var i = startIndex;
            while(getTextDimension(text.substring(i, startIndex + 1), style, false).width < offeredSize){
                startIndex++;
                if(startIndex >= textCount){
                    break;
                }
            }

            if(i == startIndex){
                //这里的情况是一个字符都放不下
                return [];
            }else{
                result.push(text.substring(i, startIndex));
            }

        }

        return result;
    }

    function getTextDimensionWithRotation(text, style, useHtml, rotation){

        var dim = getTextDimension(text, style, useHtml);
        var angle = Math.abs(toRadian(rotation || 0));

        var width = dim.width * Math.cos(angle) + dim.height * Math.sin(angle);
        var height = dim.width * Math.sin(angle) + dim.height * Math.cos(angle);

        return {
            width:width,
            height:height
        }

    }

    function clone(source) {
        if (typeof source == 'object' && source !== null) {
            var result = source;
            if (isArray(source)) {
                result = [];
                for (var i = 0, len = source.length; i < len; i++) {
                    result[i] = clone(source[i]);
                }
            }else{
                result = {};
                for (var key in source) {
                    if (source.hasOwnProperty(key)) {
                        result[key] = clone(source[key]);
                    }
                }
            }
            return result;
        }

        return source;
    }

    //style对象的表示方法转css表示
    function cssNormalization(style){
        var result = {};
        for(var attr in style){
            if(styleToCss[attr]){
                result[styleToCss[attr]] = style[attr];
            }

            if(attr == 'color'){
                result.color = style[attr];
            }

            //转px
            if(attr == 'fontSize'){
                var fontSize = style[attr];
                if(fontSize.indexOf('pt') != -1){
                    fontSize = parseFloat(fontSize) * 4 / 3;
                    result['font-size'] = fontSize + 'px';
                }
            }
        }
        return result;
    }

    /**
     * css类属性数组补全，如padding，margin等~
     */
    function reformCssArray(p) {
        if (p instanceof Array) {
            switch (p.length + '') {
                case '4':
                    return p;
                case '3':
                    return [p[0], p[1], p[2], p[1]];
                case '2':
                    return [p[0], p[1], p[0], p[1]];
                case '1':
                    return [p[0], p[0], p[0], p[0]];
                case '0':
                    return [0, 0, 0, 0];
            }
        }
        else {
            return [p, p, p, p];
        }
    }

    function lineSubPixelOpt(xOry, lineWidth){
        return lineWidth % 2 == 0 ? Math.round(xOry) : Math.round(xOry - 0.5) + 0.5;
    }

    function rectSubPixelOpt(x,y,width,height,lineWidth){
        lineWidth = lineWidth || 0;
        x = lineSubPixelOpt(x, lineWidth);
        y = lineSubPixelOpt(y, lineWidth);
        width = Math.round(width);
        height = Math.round(height);
        return {x:x, y:y, width:width, height:height};
    }

    function addArray(targetArray, sourceArray){

        var result = [];

        if(targetArray && targetArray.length){
            for(var i = 0, len = targetArray.length; i < len; i++){
                result.push(targetArray[i]);
            }
        }

        if(sourceArray && sourceArray.length){
            for(var i = 0, len = sourceArray.length; i < len; i++){
                result.push(sourceArray[i]);
            }
        }

        return result;
    }

    function toFront(el){
        if(el && el.parentNode){
            el.parentNode.appendChild(el);
        }
    }

    function toBack(el){
        if(el && el.parentNode){
            el.parentNode.insertBefore(el,el.parentNode.firstChild);
        }
    }

    function toFrontOfAll(el){
        el.ownerSVGElement.appendChild(el);
    }

    function toBackOfAll(el){
        el.ownerSVGElement.appendChild(el,el.ownerSVGElement.firstChild);
    }

    //一定是在同一个坐标原点下
    function containsRect(biggerOne, smallOne){

        return biggerOne.x <= smallOne.x
                    && biggerOne.y <= smallOne.y
                    && biggerOne.x + biggerOne.width >= smallOne.x + smallOne.width
                    && biggerOne.y + biggerOne.height >= smallOne.y + smallOne.height;

    }

    function rectangleOverlapped(aBounds, bBounds){
        if (!aBounds|| !bBounds) {
            return false;
        }
        var minx = Math.max(aBounds.x, bBounds.x);
        var miny = Math.max(aBounds.y, bBounds.y);
        var maxx = Math.min(aBounds.x + aBounds.width, bBounds.x + bBounds.width);
        var maxy = Math.min(aBounds.y + aBounds.height, bBounds.y + bBounds.height);
        return (minx <= maxx && miny <= maxy);
    }

    function outsideRect(biggerOne, smallOne){

        return !containsRect(biggerOne, smallOne) && !rectangleOverlapped(biggerOne, smallOne);

    }

    function containsPoint(rect, point){
        var x = pick(point.x || point[0]);

        var y = pick(point.y || point[1]);

        return rect.x < x && rect.x + rect.width > x
                && rect.y < y && rect.y + rect.height > y;
    }

    function isSupportSVG(){
        return !!(window.SVGSVGElement);
    }

    function makeValueInRange(min, max, value){

        var rMin = Math.min(min, max);
        var rMax = Math.max(min, max);
        var gap = rMax - rMin;

        while(value < rMin){
            value += gap;
        }

        while(value > rMax){
            value -= gap;
        }

        return value;
    }

    function getValueInDomain(value, domain){

        return Math.min(Math.max(value, domain[0]), domain[1]);

    }

    function toRadian(degree){
        return Math.PI * (degree / 180);
    }

    function toDegree(radian){
        return radian * 180 / Math.PI;
    }

    //设计器那边传过来的formatter函数是字符串
    function getFormatterFunction(formatter){

        if(formatter == null || formatter == undefined){
            return null;
        }

        if(typeof formatter == 'string'){
            return (new Function("return "+ formatter))()
        }

        return formatter;
    }

    function clone(obj) {
        // Handle the 3 simple types, and null or undefined
        if (null == obj || "object" != typeof obj) return obj;

        // Handle Date
        if (obj instanceof Date) {
            var copy = new Date();
            copy.setTime(obj.getTime());
            return copy;
        }

        // Handle Array
        if (obj instanceof Array) {
            var copy = [];
            for (var i = 0, len = obj.length; i < len; ++i) {
                copy[i] = clone(obj[i]);
            }
            return copy;
        }

        if(obj instanceof String){
            return new String(obj);
        }

        // Handle Object
        if (obj instanceof Object) {
            var copy = {};
            for (var attr in obj) {
                if (obj.hasOwnProperty(attr)) copy[attr] = clone(obj[attr]);
            }
            return copy;
        }
    }

    function isEmpty(value){
        var result = value === "" || value === null || value === undefined;
        return result;
    }

    function isNull(v){
        return v == undefined || v == null
    }

    function showLightBox(options){

        var VanCharts = require('VanCharts');

        var body = document.getElementsByTagName("body")[0];

        var boxDiv = document.createElement('div');
        boxDiv.style.position = 'absolute';
        boxDiv.style.display = 'inline';
        boxDiv.style.top = '0px';
        boxDiv.style.left = '0px';
        boxDiv.style.width = '100%';
        boxDiv.style.height = '100%';
        boxDiv.style.zIndex = 1000;
        if(isSupportSVG()){
            boxDiv.style.background = 'rgba(0,0,0,0.3)';
        }else{
            boxDiv.style.backgroundColor = 'black';
            boxDiv.style.filter = 'alpha(opacity=30)'
        }

        body.appendChild(boxDiv);

        var myWidth = boxDiv.clientWidth;
        var myHeight = boxDiv.clientHeight;

        var width = 970;
        var height = 600;

        var left = (myWidth - 970) / 2;
        var top = (myHeight - 600) / 2;


        var container = document.createElement('div');
        container.style.position = 'absolute';
        container.style.display = 'inline';
        container.style.top = top + 'px';
        container.style.left = left + 'px';
        container.style.width = width + 'px';
        container.style.height = height + 'px';
        container.style.zIndex = 1001;

        if(isSupportSVG()){
            container.style.background = 'white';
            container.style.boxShadow = '0px 4px 50px rgba(0,0,0,0.5)';
        }else{
            container.style.backgroundColor = 'white';
            container.style.filter = 'alpha(opacity=100)';
        }

        body.appendChild(container);

        boxDiv.onclick = function(e){
            body.removeChild(boxDiv);
            body.removeChild(container);
        };

        container.onclick = function(e){
            e = e || window.event;
            if (e.stopPropagation){
                e.stopPropagation();
            }else{
                e.cancelBubble = true
            };
        }

        var vanCharts = VanCharts.init(container);
        var newOptions = clone(options);

        newOptions.tools.exitFullScreen = newOptions.tools.fullScreen;
        newOptions.tools.fullScreen = null;
        if(newOptions.legend){
            newOptions.legend.initState = false;
        }
        vanCharts.setOptions(newOptions);

        //ie8 bug
        container.style.top = top + 'px';
        container.style.left = left + 'px';
        container.boxDiv = boxDiv;
    }

    function hideLightBox(container){
        var parent = container.parentNode;

        if(parent){
            parent.removeChild(container);
            if(container.boxDiv){
                parent.removeChild(container.boxDiv);
            }
        }
    }

    function isIE() { //ie?
        if (!!window.ActiveXObject || "ActiveXObject" in window)
            return true;
        else
            return false;
    }

    function hasNotDefined(value){
        return value == null || value == undefined;
    }

    function hasDefined(value){
        return !hasNotDefined(value);
    }

    function indexInArray(array, value){
        if(!array.length){
            return -1;
        }

        for(var i = 0, len = array.length; i < len; i++){
            if(array[i] == value){
                return i;
            }
        }

        return -1;
    }

    function makeBounds(){

        var x = 0, y = 0, width = 0, height = 0;

        if(arguments.length == 2){

            var pos = arguments[0];
            var dim = arguments[1];

            x = pick(pos.x, pos[0]);
            y = pick(pos.y, pos[1]);

            width = pick(dim.width, dim[0]);
            height = pick(dim.height, dim[1]);

        }else if(arguments.length == 4){

            x = arguments[0];
            y = arguments[1];

            width = arguments[2];
            height = arguments[3];
        }

        return {
            x:x,
            y:y,
            width:width,
            height:height
        };

    }

    function distance(p1, p2){
        var x1 = pick(p1.x, p1[0]);
        var y1 = pick(p1.y, p1[1]);

        var x2 = pick(p2.x, p2[0]);
        var y2 = pick(p2.y, p2[1]);

        var detX = x1 - x2;
        var detY = y1 - y2;

        return Math.sqrt(detX * detX + detY * detY);
    }

    function isEmptyBounds(bounds){
        return bounds.width <= 0 || bounds.height <= 0;
    }

    function log(logBase, value){
        return Math.log(value) / Math.log(logBase);
    }

    function getOrder(value) {
        var order = 0;
        if(value > 0 && value < 1) {
            while(value < 1) {
                value = accMul(value, 10);
                order--;
            }
        } else if(value >= 10) {
            while(value >= 10) {
                value = accDiv(value, 10);
                order++;
            }
        }

        return order;
    }

    function accAdd(arg1, arg2) {
        var r1 = 0;
        var r2 = 0;
        try {
            r1 = arg1.toString().split('.')[1].length;
        }
        catch(e) {}
        try {
            r2 = arg2.toString().split('.')[1].length;
        }
        catch(e) {}

        var m = Math.pow(10, Math.max(r1, r2));
        return (Math.round(arg1 * m) + Math.round(arg2 * m)) / m;
    }

    function accDiv(arg1,arg2){
        var s1 = arg1.toString();
        var s2 = arg2.toString();
        var m = 0;
        try {
            m = s2.split('.')[1].length;
        }
        catch(e) {}
        try {
            m -= s1.split('.')[1].length;
        }
        catch(e) {}

        return (s1.replace('.', '') - 0) / (s2.replace('.', '') - 0) * Math.pow(10, m);
    }

    function accMul(arg1, arg2){
        var m = 0, s1 = arg1.toString(), s2 = arg2.toString();

        try{
            m += s1.split(".")[1].length;
        }
        catch(e){}
        try{
            m += s2.split('.')[1].length;
        }
        catch(e){}
        return Number(s1.replace(".",""))*Number(s2.replace(".",""))/Math.pow(10,m);
    }


    function objectToArray(object){
        var result = [];
        for(var key in object){
            result.push(object[key]);
        }
        return result;
    }

    function date2int(date){

        if(typeof date == 'string'){
            date = new Date(Date.parse(date.replace(/-|\./g, "/")));
        }

        var baseDate = new Date("1970/01/01");

        if(typeof date == typeof(0)){
            return date;
        }else{
            return date.getTime() - baseDate.getTime();
        }

    }

    function int2date(milliseconds){

        var baseDate = new Date("1970/01/01");

        milliseconds = milliseconds || 0;

        return new Date(milliseconds + baseDate.getTime());
    }

    function object2date(obj){

        var date = obj;

        if(typeof date == 'string'){
            date = new Date(Date.parse(date.replace(/-|\./g, "/")));
        }else if(typeof date == typeof(0)){
            date = new Date(date)
        }

        return date;
    }

    function makeTranslate(pos){
        var x = pick(pos.x, pos[0]);
        var y = pick(pos.y, pos[1]);

        return isSupportSVG() ? 'translate(' + x + ',' + y + ')' : 't' + x + ',' + y;
    }

    function isImageMarker(markerType){
        var ALL_SYMBOLS = Constants.NULL_MARKER + Constants.CIRCLE + Constants.SQUARE + Constants.DIAMOND + Constants.TRIANGLE
            + Constants.CIRCLE_HOLLOW + Constants.SQUARE_HOLLOW + Constants.DIAMOND_HOLLOW + Constants.TRIANGLE_HOLLOW;

        return ALL_SYMBOLS.indexOf(markerType) == -1;
    }

    function isNullMarker(marker){
        return marker.symbol == Constants.NULL_MARKER;
    }

    function getDefaultMarkerSymbol(seriesIndex){
        var ALL_SYMBOLS = [Constants.CIRCLE, Constants.CIRCLE_HOLLOW, Constants.SQUARE, Constants.SQUARE_HOLLOW,
            Constants.DIAMOND, Constants.DIAMOND_HOLLOW, Constants.TRIANGLE, Constants.TRIANGLE_HOLLOW];

        return ALL_SYMBOLS[seriesIndex%ALL_SYMBOLS.length];
    }

    function addEvent(el, type, fn){

        if(el.attachEvent){
            el.attachEvent('on' + type, fn);
        }else if (el.addEventListener){
            el.addEventListener(type, fn, false);
        }
    }

    function splitWords (str) {
        str = str.trim ? str.trim() : str.replace(/^\s+|\s+$/g, '');
        return str.split(/\s+/);
    }

    function removeEvent(el, type, fn){

        if (el.removeEventListener) {
            el.removeEventListener(type, fn, false);
        } else if (el.attachEvent) {
            el.detachEvent('on' + type, fn);
        }

    }

    function dealFloatPrecision(v){
        return Math.abs(v) < 1e-6 ? 0 : v;
    }

    function getMousePos(ev, el){

        var event = ev.originalEvent || ev;

        event = event.touches ?  (event.touches.length ? event.touches.item(0) : event.changedTouches[0]) : event;

        var docElem = document.documentElement,
            box = el.getBoundingClientRect();

        var top = box.top  + (window.pageYOffset || docElem.scrollTop)  - (docElem.clientTop  || 0);
        var left = box.left + (window.pageXOffset || docElem.scrollLeft) - (docElem.clientLeft || 0);

        var chartX, chartY;
        if (event.pageX == undefined) {
            chartX = Math.max(event.x, event.clientX - left);
            chartY = event.y;
        } else {
            chartX = event.pageX - left;
            chartY = event.pageY - top;
        }

        return [chartX, chartY];
    }

    function hasTouch(){
        var doc = window.document;
        return doc && doc.documentElement.ontouchstart !== undefined;
    }

    function getArcPoint(r, radian){
        return [r * Math.sin(radian), -r * Math.cos(radian)]
    }

    function getArcByPoint (x, y) {
        return (2 * Math.PI - (Math.atan2(y, x) - Math.PI/2)) % (2 * Math.PI);
    }

    var utils = {
        getMousePos:getMousePos,
        makeTranslate:makeTranslate,
        clone:clone,
        date2int:date2int,
        int2date:int2date,
        object2date:object2date,
        log:log,
        getOrder:getOrder,
        accAdd:accAdd,
        accDiv:accDiv,
        accMul:accMul,
        dealFloatPrecision:dealFloatPrecision,
        isEmpty:isEmpty,
        isEmptyBounds:isEmptyBounds,
        objectToArray:objectToArray,
        pick:pick,
        isNull:isNull,
        getTextDimension:getTextDimension,
        getTextHeight:getTextHeight,
        splitText:splitText,
        getTextDimensionWithRotation:getTextDimensionWithRotation,
        isArray:isArray,
        indexInArray:indexInArray,
        cssNormalization:cssNormalization,
        reformCssArray:reformCssArray,
        rectSubPixelOpt:rectSubPixelOpt,
        lineSubPixelOpt:lineSubPixelOpt,
        addArray:addArray,
        toFront:toFront,
        toBack:toBack,
        toFrontOfAll:toFrontOfAll,
        toBackOfAll:toBackOfAll,
        containsRect:containsRect,
        rectangleOverlapped:rectangleOverlapped,
        outsideRect:outsideRect,
        containsPoint:containsPoint,
        isSupportSVG:isSupportSVG,
        setTextStyle:setTextStyle,
        divRotate:divRotate,
        makeValueInRange:makeValueInRange,
        getValueInDomain:getValueInDomain,
        toRadian:toRadian,
        toDegree:toDegree,
        getFormatterFunction:getFormatterFunction,
        showLightBox:showLightBox,
        hideLightBox:hideLightBox,
        isIE:isIE,
        hasTouch:hasTouch,
        hasNotDefined:hasNotDefined,
        hasDefined:hasDefined,
        distance:distance,
        makeBounds:makeBounds,
        isImageMarker:isImageMarker,
        isNullMarker:isNullMarker,
        getDefaultMarkerSymbol:getDefaultMarkerSymbol,
        addEvent:addEvent,
        removeEvent:removeEvent,
        getArcPoint:getArcPoint,
        getTextWrapDimension:getTextWrapDimension,
        stamp:stamp,
        splitWords:splitWords,
        falseFn:falseFn,
        extend:extend,
        setDomBackground:setDomBackground,
        getArcByPoint:getArcByPoint
    };

    window.VanUtils = utils;//export to the global env

    return utils;
});
/**
 * Created by eason on 15/5/15.
 * 定义所有图表都有的属性
 */
define('chart/BaseChart',['require','../utils/BaseUtils','../utils/QueryUtils','../utils/ColorUtils','../component/Base','../Constants','../component/Series','../utils/Formatter','../theme/options'],function(require){

    var BaseUtils = require('../utils/BaseUtils');
    var QueryUtils = require('../utils/QueryUtils');
    var ColorUtils = require('../utils/ColorUtils');
    var Base = require('../component/Base');
    var Constants = require('../Constants');
    var Series = require('../component/Series');
    var Formatter = require('../utils/Formatter');
    var Options = require('../theme/options');

    var SERIES = '{SERIES}';
    var X = '{X}';
    var Y = '{Y}';
    var SIZE = '{SIZE}';

    var NAME = 'NAME';
    var CATEGORY = 'CATEGORY';
    var SERIES = 'SERIES';
    var VALUE = 'VALUE';
    var PERCENT = 'PERCENT';

    //折线图和面积图计算延时
    function calculateT(det){
        return det < 0.5 ? Math.sqrt(det/2) : 1 - Math.sqrt(2 - 2*det)/2;
    }

    var BaseChart = Base.extend({

        //根据分类的位置确定各个方向上需要的系列
        _buildLocationMap:function(){

            var p2s = {};//位置到系列数组
            var series = this.vanchart.series;

            //封装series
            for(var seriesIndex = 0; seriesIndex < series.length; seriesIndex++){

                var sery = series[seriesIndex];

                if(sery.chart == this){
                    var baseAxis = sery.baseAxis;
                    var location = baseAxis.getPosition();
                    var axisIndex = baseAxis.getAxisIndex();

                    p2s[location] = p2s[location] || [];
                    p2s[location][axisIndex] = p2s[location][axisIndex] || [];

                    if(sery.visible){
                        p2s[location][axisIndex].push(sery);
                    }
                }
            }

            var stackMap = {};
            var location2Series = {};//上下左右对应的系列数组

            for(var position in p2s){
                var locationMap = [];

                var seriesArray = p2s[position] || [];

                //同一个方向有多个坐标轴
                for(var axisIndex = 0; axisIndex < seriesArray.length; axisIndex++) {

                    var seriesAxis = seriesArray[axisIndex];

                    if(seriesAxis && seriesAxis.length) {
                        var barIndex = 0;
                        for(var index = 0; index < seriesAxis.length; index++){

                            var sery = seriesAxis[index];

                            var key = sery.name;
                            if(sery.stack != null && sery.stack != undefined){
                                key = sery.stack + '';
                            }

                            if(sery.stack && stackMap[key] != null && stackMap[key] != undefined){
                                locationMap[axisIndex][stackMap[key]].push(sery);
                            }else{
                                stackMap[key] = barIndex;
                                locationMap[axisIndex] = locationMap[axisIndex] || [];
                                locationMap[axisIndex][barIndex] = [sery];
                                barIndex++;
                            }
                        }
                    }
                }

                //locationMap里可能会出现空
                var tmp = [];
                locationMap.forEach(function(sameAxis){
                    if(sameAxis){
                        tmp.push(sameAxis);
                    }
                });

                location2Series[position] = tmp;
            }

            return location2Series;
        },

        _calculateValueBasedPercentageAndTooltip:function(locationMap){

            for(var i = 0, len = locationMap.length; i < len; i++){

                var stackedSeries = locationMap[i];

                var stackedMap = {};

                for(var j = 0, count = stackedSeries.length; j < count; j++){

                    var points = stackedSeries[j].points;

                    for(var dIndex = 0, dCount = points.length; dIndex < dCount; dIndex++){
                        var point = points[dIndex];
                        var category = point.category;
                        stackedMap[category] = stackedMap[category] || [];
                        stackedMap[category].push(point);
                    }
                }


                for(var category in stackedMap){

                    var points = stackedMap[category];

                    this._dealStackedPoints(points);
                }
            }
        },

        _calculateCategoryBasedPercentageAndTooltip:function(locationMap){

            var unstackedSeries = [];

            for(var i = 0, len = locationMap.length; i < len; i++){
                var stackedSeries = locationMap[i];
                if(stackedSeries.length){
                    var sery = stackedSeries[0];
                    var stack = sery.stack || sery.stackByPercent;
                    stack ? this.dealStackedSeries(stackedSeries) : unstackedSeries.push(stackedSeries[0]);
                }
            }

            this.dealStackedSeries(unstackedSeries);
        },

        //处理堆积的点或者不堆积的其他的点
        _dealStackedPoints:function(points){
            this._calculatePercentage(points);

            // this._mergeTooltipAttributes(points);

            // this._calculateStackedValue(points);
        },



        dealStackedSeries:function(stackedSeries){

            var pointsInCate = [];

            for(var i = 0, len = stackedSeries.length; i < len; i++){
                var points = stackedSeries[i].points;

                for(var j = 0, count = points.length; j < count; j++){
                    pointsInCate[j] = pointsInCate[j] || [];

                    pointsInCate[j].push(points[j]);
                }
            }

            var chart = this;
            pointsInCate.forEach(function(points){
                chart._dealStackedPoints(points);
            });

        },

        mergeSeriesAttributes:function(sery){

        },

        mergeDataPointAttributes:function(){

        },

        _hideTooltip:function(){
            var tooltip = this.getTooltipComponent();
            tooltip.hide();
        },

        _mergeMarkerAttributes:function(point){

            var pointOption = point.pointOption;
            var seriesOption = point.series.seriesOption;

            var queryList = [
                pointOption,
                seriesOption,
                this.option.plotOptions[this.componentType],
                this.option.plotOptions,
                Options[this.componentType].plotOptions
            ];
            var marker = BaseUtils.clone(QueryUtils.queryList(queryList, 'marker'));
            
            var baseAxis = point.series.baseAxis;

            var axisReversed = baseAxis ? baseAxis.isAxisReversed() : false;

            var dCount = point.series.getDataPointCount();
            var dIndex = point.index;

            //标记点的颜色取的顺序：colors配色、plotOptions的标记点的颜色、范围图例、条件属性系列配色、条件属性系列标记点颜色、条件属性数据点的配色、条件属性数据点的标记点的配色
            marker.fillColor = marker.fillColor || this.vanchart.getDefaultSeriesColor(point.seriesName);

            // are following necessary?
            if(BaseUtils.hasDefined(this.option.plotOptions.marker)){
                marker.fillColor = this.option.plotOptions.marker.fillColor || marker.fillColor;
            }
            var rangeLegend = this.vanchart.getComponent(Constants.RANGE_LEGEND_COMPONENT);
            if(rangeLegend){
                marker.fillColor = rangeLegend.getColorWithSize(this.isForceBubble() ? point.y : point.size) || marker.fillColor;
            }
            marker.fillColor = seriesOption.color || marker.fillColor;
            if(BaseUtils.hasDefined(seriesOption.marker)) {
                marker.fillColor = seriesOption.marker.fillColor || marker.fillColor;
            }
            marker.fillColor = pointOption.color || marker.fillColor;
            if(BaseUtils.hasDefined(pointOption.marker)) {
                marker.fillColor = pointOption.marker.fillColor || marker.fillColor;
            }

            var mouseOverColor = QueryUtils.queryList(queryList, 'mouseOverColor') || ColorUtils.getHighLightColor(marker.fillColor);

            QueryUtils.merge(point, {
                mouseOverColor:mouseOverColor,
                marker:marker,
                delay:calculateT((axisReversed ? (dCount - dIndex - 1) : dIndex)/ dCount) * 800
            }, true);
        },

        getTooltipPos:function(datum, divDim, event){

            if(!datum || !datum.tooltip){
                return;
            }

            var tooltip = datum.tooltip || datum.data.tooltip;
            var svgRoot = this.getVanchartRender().getRenderRoot();

            var leftTopPos;
            if(tooltip.follow){
                var pos = event ? this.getMousePos(event) : d3.mouse(svgRoot.node());

                leftTopPos = [pos[0] + 10, pos[1] + 10];
            }else{
                leftTopPos = this._getFixedPos(datum, divDim);
            }

            //调整位置
            var chartBounds = this.vanchart.getChartBounds();
            var top = chartBounds.y;
            var bottom = chartBounds.y + chartBounds.height;
            var left = chartBounds.x;
            var right = chartBounds.x + chartBounds.width;

            var x = leftTopPos[0];
            var y = leftTopPos[1];

            if(x < left){
                x += (left - x);
            }else if(x + divDim.width > right){
                x -= (x + divDim.width - right);
            }

            if(y < top){
                y += (top - y);
            }else if(y + divDim.height > bottom){
                y -= (y + divDim.height - bottom);
            }

            return [x, y];
        },

        _getArcPoint:function(r, radian){
            return [r * Math.sin(radian), -r * Math.cos(radian)]
        },

        isSupportAnimation:function(){
            var plotOptions = this.option.plotOptions;
            if(plotOptions){
                return !!plotOptions.animation;
            }
            return false;
        },

        _calculatePercentage:function(points, key){
            key = key || 'value';
            var total = 0;
            points.forEach(function(d){
                total += Math.abs(d[key]);
            });

            total = total > 0 ? total : 1;
            points.forEach(function(point){
                point.setPercentage(Math.abs(point[key]) / total);
            });
        },

        // _calculateStackedValue:function(points){
        //
        //     //todo remove this
        //     if(this.componentType == Constants.BUBBLE_CHART){
        //         return;
        //     }
        //
        //     if(points && points.length){
        //
        //         var byPercent = points[0].series.stackByPercent;
        //         var stack = points[0].series.stack || byPercent;
        //         var valueAxis = points[0].series.valueAxis;
        //
        //         var preSumP = valueAxis ? valueAxis.getStartPosValue() : 0;
        //         var preSumN = valueAxis ? -valueAxis.getStartPosValue() : 0;
        //
        //         for(var i = 0, count = points.length; i < count; i++){
        //
        //             var point = points[i];
        //
        //             if(stack){
        //                 var usedValue = byPercent ? point.percentage : point.value;
        //
        //                 point.y = usedValue;
        //
        //                 if(usedValue >= 0){
        //                     point.y0 = preSumP;
        //                     preSumP += usedValue;
        //                 }else{
        //                     point.y0 = preSumN;
        //                     preSumN += usedValue;
        //                 }
        //             }else{
        //                 point.y = byPercent ? point.percentage : point.value;
        //                 point.y0 = valueAxis ? valueAxis.getStartPosValue() : 0;
        //             }
        //         }
        //     }
        // },

        isForceBubble:function(){
            return this.option.plotOptions.force;
        },

        isUpdateWithForce:function(){
            return this.isForceBubble() && BaseUtils.isSupportSVG() && this.isSupportAnimation();
        },

        getNormalTrendLineXYValues:function(sery){

            var xValues = [];
            var yValues = [];
            var key = this.vanchart.isInverted() ? 'y' : 'x';
            var location = this.vanchart.isInverted() ? Constants.LEFT : Constants.BOTTOM;

            sery.points.sort(function(p1, p2){
                return p1[key] - p2[key];
            });

            sery.points.forEach(function(point){

                if(!point.isNull){
                    xValues.push(point.x);
                    yValues.push(point.y);
                }

            });

            return [xValues, yValues, location];
        },

        getBubbleTrendLineXYValues:function(sery){

            var xValues = [];
            var yValues = [];
            var key = this.vanchart.isInverted() ? 'posY' : 'posX';
            var location = this.vanchart.isInverted() ? Constants.LEFT : Constants.BOTTOM;

            sery.points.sort(function(p1, p2){
                return p1[key] - p2[key];
            });

            sery.points.forEach(function(point){

                if(!point.isNull){
                    xValues.push(point.posX);
                    yValues.push(point.posY);
                }

            });

            return [xValues, yValues, location];
        },
        
        //默认是按照分类总值来排序
        orderData:function(){

            var orderType = this.option.orderType;

            var location2Series = this._buildLocationMap();

            for(var location in location2Series){

                var locationMap = location2Series[location];

                for(var index = locationMap.length - 1; index >= 0; index--){

                    var sameAxisLocationMap = locationMap[index];

                    if(sameAxisLocationMap && sameAxisLocationMap.length && sameAxisLocationMap[0].length){

                        var sery = sameAxisLocationMap[0][0];
                        var cateAxis = sery.baseAxis;

                        //排序是按照分类的总和排序,底轴是横轴排序无意义
                        if(cateAxis.type != Constants.CATEGORY_AXIS_COMPONENT){
                            continue;
                        }

                        var totalValue = {};

                        for(var i = 0, len = sameAxisLocationMap.length; i < len; i++){

                            var stackedArray = sameAxisLocationMap[i];

                            for(var j = 0, count = stackedArray.length; j < count; j++){
                                var sery = stackedArray[j];

                                for(var dataIndex = 0, dataCount = sery.points.length; dataIndex < dataCount; dataIndex++){

                                    var point = sery.points[dataIndex];

                                    if(BaseUtils.hasNotDefined(totalValue[point.category])){
                                        totalValue[point.category] = 0;
                                    }

                                    totalValue[point.category] += point.value;
                                }
                            }
                        }

                        //得到每个每类上的总值以后进行排序
                        var categories = [];
                        for(var category in totalValue){
                            categories.push({
                                key:category,
                                value:totalValue[category]
                            });
                        }

                        categories.sort(function(a, b){
                            return orderType == Constants.ASCENDING ? a.value - b.value : b.value - a.value;
                        });

                        var newCategories = [];
                        categories.forEach(function(a){
                            newCategories.push(a.key);
                        });

                        cateAxis.updateCategories(newCategories);
                        //更新className
                        for(var i = 0, len = sameAxisLocationMap.length; i < len; i++){

                            var stackedArray = sameAxisLocationMap[i];

                            for(var j = 0, count = stackedArray.length; j < count; j++){
                                var sery = stackedArray[j];
                                sery.updateClassName();
                            }
                        }
                    }
                }
            }
        },

        getVisibleChartData:function(type){

            type = type || this.componentType;
            var data = [];
            var series = this.vanchart.series;
            for(var i = 0, len = series.length; i < len; i++){
                var sery = series[i];
                if(sery.type == type && sery.visible && sery.points.length){
                    for(var j = 0; j < sery.points.length; ++j) {
                        if (!sery.points[j].isNull) {
                            data.push(series[i]);
                            break;
                        }
                    }
                }
            }

            //考虑到堆积的效果才要排序
            var needSort = this.componentType == Constants.RADAR_CHART
                || this.componentType == Constants.BAR_CHART
                || this.componentType == Constants.COLUMN_CHART;


            return needSort ? data.sort(function(a, b){return b.index - a.index;}) : data;
        },

        getChartData:function(type){
            type = type || this.componentType;
            var data = [];
            var series = this.vanchart.series;
            for(var i = 0, len = series.length; i < len; i++){
                if(series[i].type == type){
                    data.push(series[i]);
                }
            }
            return data;
        },

        _getSeriesInterpolate: function (options) {

            var optionsList;
            if (Array.isArray(options)) {
                optionsList = options;
            } else if (typeof options === 'object') {
                optionsList = [options];
            } else {
                throw new TypeError(options);
            }

            var step = QueryUtils.queryList(optionsList, 'step');
            var curve = QueryUtils.queryList(optionsList, 'curve');

            var interpolate = 'linear';
            if(step){
                interpolate = 'step-after'
            }else if(curve){
                interpolate = 'cardinal';
            }
            return interpolate;
        },

        _getLineSvg: function (interpolate) {
            return  d3.svg.line()
                .interpolate(interpolate)
                .x(function (d) {
                    return d.x;
                })
                .y(function (d) {
                    return d.y;
                })
                .defined(function (d) {
                    return !d.isNull;
                });
        },

        _getAreaSvg: function (interpolate) {
            if (this.vanchart.isInverted()) {
                return d3.svg.area()
                    .interpolate(interpolate)
                    .y(function (d) {
                        return d.y;
                    })
                    .x0(function (d) {
                        return d.x0;
                    })
                    .x1(function (d) {
                        return d.x;
                    })
                    .defined(function (d) {
                        return !d.isNull;
                    });
            } else {
                return d3.svg.area()
                    .interpolate(interpolate)
                    .x(function (d) {
                        return d.x;
                    })
                    .y0(function (d) {
                        return d.y0;
                    })
                    .y1(function (d) {
                        return d.y;
                    })
                    .defined(function (d) {
                        return !d.isNull;
                    });
            }
        },


        _calculateBubbleLabelInfo:function(point, dataLabels, defaultPosition){
            dataLabels = dataLabels || {};
            var formatter = dataLabels.formatter;
            var useHtml = dataLabels.useHtml;
            if(!formatter){
                return {};
            }

            var content = [];
            if(typeof formatter == 'object'){

                var identifier = formatter.identifier;

                if(identifier.indexOf(SERIES) != -1){
                    var seriesString = Formatter.format(point.seriesName, formatter.seriesFormat);
                    var seriesStyle = point.getCategorySeriesStyle(dataLabels, defaultPosition);
                    var seriesDim = BaseUtils.getTextDimension(seriesString, seriesStyle, useHtml);

                    content.push({
                        text:seriesString,
                        style:seriesStyle,
                        dim:seriesDim
                    });
                }

                if(identifier.indexOf(X) != -1 || identifier.indexOf(Y) != -1 || identifier.indexOf(SIZE) != -1){
                    var text = this._getXYSizeString(point, formatter, identifier);
                    var style = point.getValuePercentageStyle(dataLabels, defaultPosition);
                    var dim = BaseUtils.getTextDimension(text, style, useHtml);

                    content.push({
                        text:text,
                        style:style,
                        dim:dim
                    });
                }

            }else{
                point.pushCustomLabelContent(formatter, dataLabels, useHtml, content, defaultPosition);
            }

            var labelDim = point.calculateTextDim(content);

            QueryUtils.merge(point, {
                labelContent: content,
                labelDim: labelDim
            }, true);
        },

        _getXYSizeString:function(point, formatter, identifier) {
            var xString = Formatter.format(point.category, formatter.XFormat);
            var yString = Formatter.format(point.value, formatter.YFormat);
            var sizeString = point.size == '-' ? '-' : Formatter.format(point.size, formatter.sizeFormat);

            var text = '';

            if(identifier.indexOf(X) != -1 || identifier.indexOf(Y) != -1){
                text = '(';
                if(identifier.indexOf(X) != -1){
                    text += xString;
                    if(identifier.indexOf(Y) != -1){
                        text = text + ',' + yString;
                    }
                    text += ')';
                } else {
                    text += yString;
                    text += ')';
                }
                text += ' ';
            }

            if(identifier.indexOf(SIZE) != -1 && sizeString != '-'){
                text += sizeString;
            }
            return text;
        },

        _mergeTooltipAttributes:function(points){
            for(var i = 0, len = points.length; i < len; i++){
                var point = points[i];
                this.mergeSinglePointTooltipAttr(point, points);
            }
        },

        mergeSinglePointTooltipAttr:function(point, points){
            points = points || [point];

            var tooltip = point.tooltip;

            point.tooltipText = tooltip && tooltip.enabled ? this._calculateTooltipContent(tooltip, point, points) : null;
            point.points = points;
        },

        _calculateTooltipContent:function(tooltip, data, points){

            var formatter = tooltip.formatter;

            if(!formatter){
                return "";
            }

            if(typeof formatter == 'object'){

                var style = tooltip.style;
                var label = formatter.identifier;
                var self = this, hasMap = this.vanchart.getChart(Constants.MAP_CHART);
                var hasRangeLegend = this.vanchart.getComponent(Constants.RANGE_LEGEND_COMPONENT);

                var content = '';

                if(tooltip.shared){
                    content += this._createCategoryLine(data, label, style, formatter);

                    points.forEach(function(point){
                        var dotColor = (hasMap && hasRangeLegend) ? points[0].color : point.color;

                        content += '<span style="font-size:12px; color: ' + dotColor + '">'+'&#9679  '+'</span>';

                        content += self._createSeriesLine(point, label, style, formatter);

                        content += '<br />';
                    });
                }else{
                    content += this._createCategoryLine(data, label, style, formatter);
                    content += self._createSeriesLine(data, label, style, formatter);
                }
                return content;
            }else{
                return BaseUtils.getFormatterFunction(formatter).call(data);
            }
        },

        _createCategoryLine:function(data, label, style, formatter){

            var hasMap = this.vanchart.getComponent(Constants.GEO_COMPONENT);
            var isBubbleSeries = (data.series.type == Constants.BUBBLE_CHART) && !hasMap;

            if(isBubbleSeries && !this.isForceBubble()){
                return this._createBubbleTooltipSeriesLine(data, label, style, formatter);
            }else{
                var content = '';

                if (data.series.chart.componentType === Constants.MULTIPIE_CHART) {
                    if (label.indexOf(SERIES) != -1) {
                        content = Formatter.format(data.seriesName, formatter.seriesFormat);
                    }
                } else {
                    if (label.indexOf(CATEGORY) != -1) {
                        content = Formatter.format(data.category, formatter.categoryFormat);
                    }

                    if (label.indexOf(NAME) != -1) {
                        content = Formatter.format(data.name, formatter.nameFormat);
                    }
                }

                if(content){
                    content = (style ? '<span>' : Constants.TOOLTIP_CATEGORY_STYLE) + content +'</span>';
                    content += '<br />';
                }

                return content;
            }
        },

        _createSeriesLine:function(data, label, style, formatter){

            var hasMap = this.vanchart.getComponent(Constants.GEO_COMPONENT);
            var isBubbleSeries = (data.series.type == Constants.BUBBLE_CHART) && !hasMap;

            if(isBubbleSeries && !this.isForceBubble()){
                return this._createBubbleTooltipXYSizeLine(data, label, style, formatter);
            }else{
                var content = '';
                var valueString = Formatter.format(data.value, formatter.valueFormat);
                var percentString = Formatter.format(data.percentage, formatter.percentFormat);

                var textString;
                if (data.series.chart.componentType == Constants.MULTIPIE_CHART) {
                    if (label.indexOf(NAME) != -1) {
                        textString = Formatter.format(data.name, formatter.nameFormat);
                    }
                } else {
                    if (label.indexOf(SERIES) != -1) {
                        textString = Formatter.format(data.seriesName, formatter.seriesFormat);
                    }
                }

                if (textString) {

                    if (label.indexOf(VALUE) != -1 || label.indexOf(PERCENT) != -1) {
                        textString += ':';
                    }

                    content += (style ? '<span >' : Constants.TOOLTIP_SERIES_STYLE) + textString +'</span>';
                }

                if(label.indexOf(VALUE) != -1 && label.indexOf(PERCENT) != -1){
                    content += (style ? '<span>' : Constants.TOOLTIP_VALUE_STYLE) + valueString + '  ' + percentString + '</span>';
                }else if(label.indexOf(VALUE) != -1){
                    content += (style ? '<span>' : Constants.TOOLTIP_VALUE_STYLE) + valueString + '</span>';
                }else if(label.indexOf(PERCENT) != -1){
                    content += (style ? '<span>' : Constants.TOOLTIP_VALUE_STYLE) + percentString +'</span>';
                }

                return content;
            }

        },

        //提示的第一行：气泡的系列
        _createBubbleTooltipSeriesLine:function(data, label, style, formatter){
            var content = '';

            if(label.indexOf(SERIES) != -1){

                var seriesString = Formatter.format(data.seriesName, formatter.seriesFormat);

                content += (style ? '<span >' : Constants.TOOLTIP_SERIES_STYLE) + seriesString +'</span>';

                content += '<br />';
            }

            return content;
        },

        //提示的第二行：气泡的X、Y、SIZE
        _createBubbleTooltipXYSizeLine:function(data, label, style, formatter){

            var content = '';
            if(label.indexOf(X) != -1 || label.indexOf(Y) != -1 || label.indexOf(SIZE) != -1) {
                var text = this._getXYSizeString(data, formatter, label);
                content += (style ? '<span>' : Constants.TOOLTIP_VALUE_STYLE) + text + '</span>';
            }

            return content;
        },

        getClosestPoint:function(){
            
        }
        
    });

    return BaseChart;
});
/**
 * Created by eason on 15/7/13.
 */

define('chart/Pie',['require','../Constants','../utils/BaseUtils','./BaseChart','../utils/QueryUtils','../utils/BoundsManager','../theme/options','../ChartLibrary'],function(require){

    var RIGHT_TOP = 'right-top';
    var RIGHT_BOTTOM = 'right-bottom';
    var LEFT_TOP = 'left-top';
    var LEFT_BOTTOM = 'left-bottom';

    var CIRCLE = 2 * Math.PI;
    var HOVER_PERCENT = 1.1;
    var MAGIC_DET = 3;//很奇怪的3px

    var STEP = Math.PI / 180;

    var LINE_LABEL_GAP = 2;

    var DECREASE = [0.75,0.7,0.65,0.6,0.55];

    var Constants = require('../Constants');
    var BaseUtils = require('../utils/BaseUtils');
    var BaseChart = require('./BaseChart');
    var QueryUtils = require('../utils/QueryUtils');
    var BoundsManager = require('../utils/BoundsManager');
    var Options = require('../theme/options');

    var Pie = BaseChart.extend({

        constructor:Pie,

        mergeSeriesAttributes:function(series){

            var queryList = [
                series.seriesOption,
                this.option.plotOptions[this.componentType],
                this.option.plotOptions,
                Options[this.componentType].plotOptions
            ];

            var innerRadius = QueryUtils.queryList(queryList, 'innerRadius') || 0;

            if(parseFloat(innerRadius) == 0){
                innerRadius = 0;
            }

            var center = QueryUtils.queryList(queryList, 'center');

            var startAngle = QueryUtils.queryList(queryList, 'startAngle') || 0;
            var endAngle = QueryUtils.queryList(queryList, 'endAngle') || 360;

            if(startAngle > endAngle){
                startAngle -= 360;
            }else if(startAngle == endAngle){
                startAngle = 0;
                endAngle = 360;
            }

            var roseType = QueryUtils.queryList(queryList, 'roseType');
            var rotatable = QueryUtils.queryList(queryList, 'rotatable');
            var radius = QueryUtils.queryList(queryList, 'radius') ;
            var style = this.option.style;

            QueryUtils.merge(series, {
                center:center,
                radius:radius,
                innerRadius:innerRadius,
                startAngle:startAngle,
                endAngle:endAngle,
                roseType:roseType,
                rotatable:rotatable,
                style:style
            }, true);

        },

        mergeDataPointAttributes:function(point){

            QueryUtils.merge(point,{
                visible:BaseUtils.pick(point.pointOption.visible, true),
                rotate:0
            }, true);

        },

        doLayout:function(){

            var series = this.getVisibleChartData();
            var plotOptions = this.option.plotOptions;
            var self = this;

            series.forEach(function(sery){

                var queryList = [
                    sery.seriesOption,
                    plotOptions[sery.type],
                    plotOptions,
                    Options[sery.type].plotOptions
                ];

                //重置radius属性
                sery.radius = QueryUtils.queryList(queryList, 'radius');

                self._calculatePercentage(sery.visiblePoints);
                self._mergeTooltipAttributes(sery.visiblePoints);
                // self._dealStackedPoints(sery.visiblePoints);

                var pieLayout = d3.layout.pie()
                    .value(function(d){
                        return sery.roseType == Constants.SAME_ARC ? 1 : Math.abs(d.value);
                    })
                    .startAngle(BaseUtils.toRadian(sery.startAngle))
                    .endAngle(BaseUtils.toRadian(sery.endAngle))
                    .sort(null);

                sery.visiblePoints.forEach(function(point){
                    point.lastShape = self._getArcData(point);
                });

                var pieData = pieLayout(sery.visiblePoints);
                pieData.forEach(function(slice){
                    var point = slice.data;
                    point.startAngle = isNaN(slice.startAngle) ? 0 : slice.startAngle;
                    point.endAngle = isNaN(slice.endAngle) ? 0: slice.endAngle;
                });
            });

            var plotBounds = this.vanchart.getPlotBounds();

            var seriesBounds = this._calculateSeriesBounds();

            for(var i = 0, len = series.length; i < len; i++){
                var sery = series[i];
                var bounds = seriesBounds[sery.name];
                var fixedState = bounds;
                var radius = 0;
                var centerX = 0;
                var centerY = 0;

                if(fixedState == 'fixed'){
                    var centerX = series[i].center[0];
                    var centerY = series[i].center[1];

                    if(series[i].center[0].indexOf('%') != -1){
                        centerX = this._getPercentValue(series[i].center[0], this.vanchart.chartWidth());
                        centerY = this._getPercentValue(series[i].center[1], this.vanchart.chartHeight());
                    }

                    if(sery.radius){
                        radius = sery.radius;
                    }else{
                        //自定义了位置但是没自定义大小
                        var left = centerX - plotBounds.x;
                        var right = plotBounds.x + plotBounds.width - centerX;
                        var top = centerY - plotBounds.y;
                        var bottom = plotBounds.y + plotBounds.height - centerY;
                        radius = Math.min(left, right, top, bottom);
                    }

                    centerX -= plotBounds.x;
                    centerY -= plotBounds.y;

                    bounds = {x:centerX - radius, y:centerY - radius, width:radius * 2, height:radius*2};

                }else{
                    radius = Math.min(bounds.width/2, bounds.height/2);
                    centerX = bounds.x + bounds.width/2;
                    centerY = bounds.y + bounds.height/2;
                }

                QueryUtils.merge(sery,{
                    fixedState:fixedState,
                    bounds:bounds,
                    radius:radius,
                    centerX:centerX,
                    centerY:centerY
                }, true);

                //计算标签的位置,并且更新半径
                this._calculateLabelPos(sery);
            }
        },

        _getArcData:function(d){
            if(BaseUtils.hasDefined(d.startAngle)){
                return {
                    startAngle: d.startAngle,
                    endAngle: d.endAngle,
                    radius: d.radius
                };
            }
        },

        _getFixedPos:function(datum, divDim){

            var plotBounds = this.getPlotBounds();

            var pieConfig = datum.series;

            var translateX = pieConfig.centerX;
            var translateY = pieConfig.centerY;

            var centerAngle = this.getCenterAngle(datum);
            var radius = datum.radius * HOVER_PERCENT;

            var centerX = radius * Math.sin(centerAngle) + translateX + plotBounds.x;
            var centerY = radius * Math.cos(centerAngle + Math.PI) + translateY + plotBounds.y;

            if(centerAngle < Math.PI / 2){
                centerY -= divDim.height;
            }else if(centerAngle >= Math.PI && centerAngle < 3 * Math.PI / 2){
                centerX -= divDim.width;
            }else if(centerAngle >= 3 * Math.PI / 2 && centerAngle < CIRCLE){
                centerY -= divDim.height;
                centerX -= divDim.width;
            }

            return [centerX, centerY];
        },

        recalculateLabelPos:function(pieConfig, rotate){

            var points = pieConfig.visiblePoints;

            for(var i = 0, len = points.length; i < len; i++){
                points[i].labelPos = null;
                points[i].rotate = rotate;
            }

            var outPoints = [];
            var inPoints = [];

            for(var i = 0, len = points.length; i < len; i++){
                var point = points[i];
                var dataLabels = point.dataLabels;
                if(dataLabels && dataLabels.enabled){
                    dataLabels.align == Constants.OUTSIDE ? outPoints.push(point) : inPoints.push(point);
                }
            }

            this._calculateOutsideLabelBounds(outPoints, pieConfig, true);
            this._calculateLeadLineStartPos(outPoints);
            this._calculateInsideLabelBounds(inPoints, pieConfig);
        },

        _calculateLabelPos:function(pieConfig){

            var roseType = pieConfig.roseType;
            var points = pieConfig.visiblePoints;

            var outPoints = [];
            var inPoints = [];

            for(var i = 0, len = points.length; i < len; i++){
                var point = points[i];
                var dataLabels = point.dataLabels;
                if(dataLabels && dataLabels.enabled){
                    dataLabels.align == Constants.OUTSIDE ? outPoints.push(point) : inPoints.push(point);
                }
            }

            //这步会改变半径
            this._calculateOutsideLabelBounds(outPoints, pieConfig);

            if (pieConfig.fixedState !== 'fixed') {
                //有标签在里面,没有标签在外面或者不显示标签
                if ((inPoints.length && !outPoints.length) || (!inPoints.length && !outPoints.length)) {
                    pieConfig.radius = pieConfig.radius / HOVER_PERCENT - MAGIC_DET;
                }
            }

            //内径可能是半径的占比
            this._calculateInnerRadius(pieConfig);

            //玫瑰图根据最后的半径值来确定不同扇形的半径
            if(roseType){
                var points = pieConfig.visiblePoints;
                var radiusGap = pieConfig.radius - pieConfig.innerRadius;
                var maxValue = 0;
                points.forEach(function(d){
                    maxValue = Math.max(maxValue, Math.abs(d.value));
                });

                var sizePerValue = radiusGap / maxValue;

                //maxValue为0之类的情况
                if(isNaN(sizePerValue) || !isFinite(sizePerValue)){
                    sizePerValue = 0;
                }

                points.forEach(function(d){
                    d.radius = pieConfig.innerRadius + sizePerValue * Math.abs(d.value);
                })
            }else{
                var usedR = pieConfig.radius;
                pieConfig.visiblePoints.forEach(function(d){
                    d.radius = usedR;
                });
            }

            this._calculateLeadLineStartPos(outPoints);

            //确定半径以后计算标签在内的标签
            this._calculateInsideLabelBounds(inPoints, pieConfig);
        },

        _calculateInnerRadius:function(pieConfig){
            var innerRadius = pieConfig.innerRadius;

            var radius = pieConfig.radius;

            if(typeof innerRadius == 'string'){
                if(innerRadius.indexOf('%') != -1){
                    innerRadius = parseFloat(innerRadius) * radius / 100;
                }else{
                    innerRadius = parseFloat(innerRadius);
                }
            }

            pieConfig.innerRadius = innerRadius;

            var points = pieConfig.visiblePoints;

            points.forEach(function(d){
                d.innerRadius = innerRadius;
            });

        },

        _calculateLeadLineStartPos:function(outPoints){

            var self = this;
            outPoints.forEach(function(arcPoint){

                var radius = arcPoint.radius;
                var centerAngle = self.getCenterAngle(arcPoint);

                if(arcPoint.labelPos){
                    arcPoint.labelPos.startPos = {
                        x:(radius + 1)*Math.sin(centerAngle),
                        y: (radius + 1) * Math.cos(centerAngle + Math.PI)
                    }
                }

            });
        },

        _calculateOutsideLabelBounds:function(outPoints, pieConfig, isRecalculate){
            if(!outPoints.length){
                return ;
            }

            //清空计算结果
            outPoints.forEach(function(arc){
                arc.labelPos = null;
            });

            isRecalculate = isRecalculate || false;

            //先划分区域
            var rightTop = [];
            var rightBottom = [];
            var leftTop = [];
            var leftBottom = [];

            for(var i = 0, len = outPoints.length; i < len; i++){
                var point = outPoints[i];

                var center = this.getCenterAngle(point);

                if(center < Math.PI / 2){
                    rightTop.push(point)
                }else if(center >= Math.PI / 2 && center < Math.PI){
                    rightBottom.push(point);
                }else if(center >= Math.PI && center < 3 * Math.PI /2){
                    leftBottom.push(point);
                }else{
                    leftTop.push(point);
                }
            }

            isRecalculate ? this._calculateArcR(pieConfig, rightTop, rightBottom, leftTop, leftBottom)
                :this._initCalculateArcR(pieConfig, rightTop, rightBottom, leftTop, leftBottom);
        },

        _initCalculateArcR:function(pieConfig, rightTop, rightBottom, leftTop, leftBottom){
            if (pieConfig.fixedState === 'fixed') {
                var dim = {width: Number.MAX_VALUE, height: Number.MAX_VALUE};
                this._testIfAllFit(pieConfig.radius, dim, rightTop, rightBottom, leftTop, leftBottom, true);
            } else {
                var originR = pieConfig.radius;
                var usedR = originR * 0.5;

                var bounds = pieConfig.bounds;
                var dim = {width: bounds.width / 2, height: bounds.height / 2};

                //半径的下界都不能放下的话
                if (!this._testIfAllHorizontalFit(usedR, dim, rightTop, rightBottom, leftTop, leftBottom)) {
                    pieConfig.radius = usedR;

                    //计算位置
                    this._testIfAllFit(usedR, dim, rightTop, rightBottom, leftTop, leftBottom)

                    return;
                }

                for (var i = 0, len = DECREASE.length; i < len; i++) {
                    usedR = originR * DECREASE[i];

                    if (this._testIfAllFit(usedR, dim, rightTop, rightBottom, leftTop, leftBottom)) {
                        pieConfig.radius = usedR;
                        return;
                    }
                }

                this._testIfAllFit(usedR, dim, rightTop, rightBottom, leftTop, leftBottom, true);
                pieConfig.radius = usedR;
            }
        },

        _calculateArcR:function(pieConfig, rightTop, rightBottom, leftTop, leftBottom){
            if (pieConfig.fixedState === 'fixed') {
                var dim = {width: Number.MAX_VALUE, height: Number.MAX_VALUE};
                this._testIfAllFit(pieConfig.radius, dim, rightTop, rightBottom, leftTop, leftBottom, true);
            } else {
                var usedR = pieConfig.radius;
                var bounds = pieConfig.bounds;
                var dim = {width: bounds.width / 2, height: bounds.height / 2};

                this._testIfAllFit(usedR, dim, rightTop, rightBottom, leftTop, leftBottom, true);
            }
        },

        _testIfAllHorizontalFit:function(usedR, dim, rightTop, rightBottom, leftTop, leftBottom){
            var tmpRightTop = this._ignoreMinArcLabel(usedR, rightTop);
            var tmpRightBottom = this._ignoreMinArcLabel(usedR, rightBottom);
            var tmpLeftTop = this._ignoreMinArcLabel(usedR, leftTop);
            var tmpLeftBottom = this._ignoreMinArcLabel(usedR, leftBottom);

            var rightTopFit = this._testIfHorizontalFit(tmpRightTop, usedR, dim, RIGHT_TOP);
            var rightBottomFit = this._testIfHorizontalFit(tmpRightBottom, usedR, dim, RIGHT_BOTTOM);
            var leftTopFit = this._testIfHorizontalFit(tmpLeftTop, usedR, dim, LEFT_TOP);
            var leftBottomFit = this._testIfHorizontalFit(tmpLeftBottom, usedR, dim, LEFT_BOTTOM);

            return rightTopFit && rightBottomFit && leftTopFit && leftBottomFit;
        },

        _testIfHorizontalFit:function(arcPoints, usedR, dim, location){

            var outerR = usedR * 1.2;
            var hWidth = usedR * 0.1;
            var allLabelBounds = BaseUtils.makeBounds(-dim.width, dim.height, dim.width * 2, dim.height * 2);

            for(var i = 0, len = arcPoints.length; i < len; i++){

                var point = arcPoints[i];

                var labelDim = point.labelDim;

                var centerAngle = this.getCenterAngle(point);

                var centerX = outerR * Math.sin(centerAngle);

                var centerY = outerR * Math.cos(centerAngle + Math.PI);

                var bounds = this._getLabelBounds(location, centerX, centerY, hWidth, labelDim);

                if(bounds.x < allLabelBounds.x || (bounds.x + bounds.width > allLabelBounds.x + allLabelBounds.width)){
                    return false;
                }
            }

            return true;
        },

        _testIfAllFit:function(usedR, dim, rightTop, rightBottom, leftTop, leftBottom, forceFloat){

            var tmpRightTop = this._ignoreMinArcLabel(usedR, rightTop);
            var tmpRightBottom = this._ignoreMinArcLabel(usedR, rightBottom);
            var tmpLeftTop = this._ignoreMinArcLabel(usedR, leftTop);
            var tmpLeftBottom = this._ignoreMinArcLabel(usedR, leftBottom);

            var rightTop = this._testIfFit(rightTop, tmpRightTop, usedR, dim, RIGHT_TOP, forceFloat);
            var rightBottom = this._testIfFit(rightBottom, tmpRightBottom, usedR, dim, RIGHT_BOTTOM, forceFloat);
            var leftTop = this._testIfFit(leftTop, tmpLeftTop, usedR, dim, LEFT_TOP, forceFloat);
            var leftBottom = this._testIfFit(leftBottom, tmpLeftBottom, usedR, dim, LEFT_BOTTOM, forceFloat);

            return rightTop && rightBottom && leftTop && leftBottom;
        },

        _testIfFit:function(totalPoints, arcPoints, usedR, dim, location, forceFloat){

            return (totalPoints.length == arcPoints.length && !forceFloat) ? this._testFixedPositionIfFit(arcPoints, usedR, dim, location)
                :this._testFloatPositionIfFit(arcPoints, usedR, dim, location)

        },

        _testFixedPositionIfFit:function(arcPoints, usedR, dim, location){

            var manager = new BoundsManager();

            var outerR = usedR * 1.2;
            var hWidth = usedR * 0.1;
            var allLabelBounds = BaseUtils.makeBounds(-dim.width, -dim.height, dim.width * 2, dim.height * 2);

            for(var i = 0, len = arcPoints.length; i < len; i++){

                var point = arcPoints[i];

                var labelDim = point.labelDim;

                var centerAngle = this.getCenterAngle(point);

                var centerX = outerR * Math.sin(centerAngle);

                var centerY = outerR * Math.cos(centerAngle + Math.PI);

                var bounds = this._getLabelBounds(location, centerX, centerY, hWidth, labelDim);

                if(manager.isOverlapped(bounds) || !BaseUtils.containsRect(allLabelBounds, bounds)){
                    return false;
                }else{
                    manager.addBounds(bounds);

                    var midPos = {x:centerX, y:centerY};
                    var endPos;
                    if(location == RIGHT_TOP || location == RIGHT_BOTTOM){
                        endPos = {x:centerX + hWidth, y:centerY};
                    }else{
                        endPos = {x:centerX - hWidth, y:centerY};
                    }
                    point.labelPos = {
                        x:bounds.x,
                        y:bounds.y,

                        midPos:midPos,
                        endPos:endPos
                    };
                }
            }

            return true;
        },

        _testFloatPositionIfFit:function(arcPoints, usedR, dim, location){

            var fromStart = this._findNiceBoundsFromStartAngle(arcPoints, usedR, dim, location);

            if(!fromStart){

                arcPoints.forEach(function(arc){
                    arc.labelPos = null;
                });

                return this._findNiceBoundsFromEndAngle(arcPoints, usedR, dim, location);
            }

            return fromStart;
        },

        _findNiceBoundsFromStartAngle:function(arcPoints, usedR, dim, location){
            return this._findNiceBounds(true, arcPoints, usedR, dim, location);
        },

        _findNiceBoundsFromEndAngle:function(arcPoints, usedR, dim, location){
            return this._findNiceBounds(false, arcPoints, usedR, dim, location);
        },

        _findNiceBounds:function(isAngleIncrease, arcPoints, usedR, dim, location){

            var outerR = usedR * 1.2;
            var hWidth = usedR * 0.1;

            var manager = new BoundsManager();
            var angleRange = this._getStartAndEndAngle(location);

            var allLabelBounds = this._getPossibleLabelBoundsByLocation(dim, location);


            var searchEnd = isAngleIncrease ? angleRange.endAngle : angleRange.startAngle;
            var step = isAngleIncrease ? STEP : -STEP;


            var found = true;
            for(var i = 0, len = arcPoints.length; i < len && found; i++){

                var pointIndex = isAngleIncrease ? i : len - i - 1;

                var point = arcPoints[pointIndex];

                var labelDim = point.labelDim;

                var centerAngle = this.getCenterAngle(point);

                var centerX = outerR * Math.sin(centerAngle);

                var centerY = outerR * Math.cos(centerAngle + Math.PI);

                var bounds = this._getLabelBounds(location, centerX, centerY, hWidth, labelDim);

                if(manager.isOverlapped(bounds) || !BaseUtils.containsRect(allLabelBounds, bounds)){
                    found = false;
                    for(var angle = centerAngle + step; (isAngleIncrease ? angle < searchEnd : angle > searchEnd); angle += step){

                        centerX = outerR * Math.sin(angle);
                        centerY = outerR * Math.cos(angle + Math.PI);

                        bounds = this._getLabelBounds(location, centerX, centerY, hWidth, labelDim);

                        if(!manager.isOverlapped(bounds) && BaseUtils.containsRect(allLabelBounds, bounds)){
                            found = true;
                            break;
                        }
                    }
                }

                if(found){

                    var midPos = {x:centerX, y:centerY};
                    var endPos;
                    if(location == RIGHT_TOP || location == RIGHT_BOTTOM){
                        endPos = {x:centerX + hWidth, y:centerY};
                    }else{
                        endPos = {x:centerX - hWidth, y:centerY};
                    }

                    manager.addBounds(bounds);
                    point.labelPos = {
                        x:bounds.x,
                        y:bounds.y,

                        midPos:midPos,
                        endPos:endPos
                    };
                }
            }

            return found;
        },

        _getStartAndEndAngle:function(location){
            switch (location){
                case RIGHT_TOP:
                    return {startAngle:0, endAngle:Math.PI/2};
                case RIGHT_BOTTOM:
                    return {startAngle:Math.PI/2, endAngle:Math.PI};
                case LEFT_BOTTOM:
                    return {startAngle:Math.PI, endAngle:3 * Math.PI / 2};
                case LEFT_TOP:
                    return {startAngle:3 * Math.PI / 2, endAngle: 2 * Math.PI};
            }
        },

        _getLabelBounds:function(location, centerX, centerY, hWidth, labelDim){
            var x,y;
            if(location == RIGHT_TOP || location == RIGHT_BOTTOM){
                x = centerX + hWidth + LINE_LABEL_GAP;
            }else{
                x = centerX - hWidth - LINE_LABEL_GAP - labelDim.width;
            }

            y = centerY - labelDim.height/2;

            return {x:x, y:y, width:labelDim.width, height:labelDim.height};
        },

        getCenterAngle:function(point){
            var centerAngle = point.rotate + (point.startAngle + point.endAngle) / 2 ;
            return BaseUtils.makeValueInRange(0, 2*Math.PI, centerAngle);
        },

        //相对于圆心的标签可占用大小的坐标
        _getPossibleLabelBoundsByLocation:function(dim, location){
            var x , y;
            var width = dim.width;
            var height = dim.height;

            switch (location){
                case RIGHT_TOP:
                    x = 0;
                    y = -height;
                    break;
                case RIGHT_BOTTOM:
                    x = y = 0;
                    break;
                case LEFT_BOTTOM:
                    x = -width;
                    y = 0;
                    break;
                case LEFT_TOP:
                    x = -width;
                    y = -height;
                    break;
            }

            return {x:x, y:y, width:width, height:height};
        },

        //从高度判断是否能够放下标签
        _ignoreMinArcLabel:function(radius, arcs){

            var totalHeight = 0;

            for(var i = 0, len = arcs.length; i < len; i++){
                var labelDim = arcs[i].labelDim;
                totalHeight += labelDim.height;
            }

            //高度不够，需要省略一些标签
            if(radius < totalHeight){

                var det = totalHeight - radius;

                arcs.sort(function(a, b){
                    return a.value - b.value;
                });

                for(var i = 0, len = arcs.length; i < len; i++){
                    if(det < 0){
                        break;
                    }
                    var labelHeight = arcs[i].labelDim.height;
                    det -= labelHeight;
                }

                arcs = arcs.slice(i, arcs.length);
            }

            arcs.sort(function(a, b){
                var startA = a.startAngle;
                var startB = b.startAngle;

                if(startA < startB){
                    return -1;
                }else if(startA > startB){
                    return 1;
                }else{
                    return 0;
                }
            });

            return arcs;
        },

        //算出来的bounds都是相对于centerX和centerY
        _calculateInsideLabelBounds:function(inPoints, pieConfig){
            var innerRadius = pieConfig.innerRadius;

            for(var i = 0, len = inPoints.length; i < len; i++){
                var point = inPoints[i];
                var radius = point.radius;

                var centerAngle = this.getCenterAngle(point);

                var tmpR = innerRadius + (radius - innerRadius) / 2;

                var center = this._getArcPoint(tmpR, centerAngle);

                var x = center[0] - point.labelDim.width/2;
                var y = center[1] - point.labelDim.height/2;

                point.labelPos = {x:x, y:y};
            }
        },

        //计算每个系列的边界
        _calculateSeriesBounds:function(){
            var series = this.getVisibleChartData();
            var plotBounds = this.vanchart.getPlotBounds();
            var seriesBounds = {};

            var usedSize = 0;
            var fixedSize = 0;
            for(var i = 0, len = series.length; i < len; i++){
                if(!series[i].center && series[i].radius){
                    usedSize += (series[i].radius || 0) * 2;
                    fixedSize++;
                }
            }

            //平均半径
            var averageRadius = plotBounds.width / Math.max(1, series.length - fixedSize);
            averageRadius /= 2;

            var leftBounds = {x:0, y:0, width:plotBounds.width, height:plotBounds.height};
            for(var i = 0, len = series.length; i < len; i++){
                if(series[i].center){
                    seriesBounds[series[i].name] = 'fixed';
                }else{
                    var size = (series[i].radius || averageRadius) * 2;
                    seriesBounds[series[i].name] = {
                        x:leftBounds.x,
                        y:leftBounds.y,
                        width:size,
                        height:leftBounds.height
                    };

                    leftBounds.x += size;
                    leftBounds.width -= size;
                }
            }

            return seriesBounds;
        },

        orderData:function(){
            var series = this.getVisibleChartData();
            var chart = this;
            series.forEach(function(sery){

                sery.points.sort(function(sliceA, sliceB){

                    var valueA = sliceA.value;

                    var valueB = sliceB.value;

                    return chart.option.orderType == Constants.ASCENDING ? valueA - valueB : valueB - valueA;
                });

                sery.updateVisiblePoints();
            });

            this.option.byClassName = false;
        },

        onDrag:function(event){
            if(this._draggingSeries){
                this.render.onDrag(this._draggingSeries, event.containerPoint);
            }
        },

        dragEnd:function(event){
            if(this._draggingSeries){
                this.render.onDragEnd(this._draggingSeries, event.containerPoint);
                this._draggingSeries = null;
            }
        },

        findDraggingTarget:function(event){

            var pos = event.containerPoint;

            var plotBounds = this.getPlotBounds();

            var x = pos[0] - plotBounds.x;
            var y = pos[1] - plotBounds.y;

            var series = this.getVisibleChartData();

            for(var i = series.length - 1; i >= 0; i--){
                if(BaseUtils.containsPoint(series[i].bounds, [x,y]) && series[i].rotatable){
                    this.render.onDragStart(series[i], pos);
                    this._draggingSeries = series[i];
                    return this;
                }
            }
            
        }

    });

    require('../ChartLibrary').register(Constants.PIE_CHART, Pie);
});
/**
 * Created by Jeffrey on 16/6/15.
 */

define('chart/MultiPie',['require','../Constants','../utils/BaseUtils','./BaseChart','../utils/QueryUtils','../utils/ColorUtils','../utils/BoundsManager','../theme/options','../component/Point','../ChartLibrary'],function(require){

    var Constants = require('../Constants');
    var BaseUtils = require('../utils/BaseUtils');
    var BaseChart = require('./BaseChart');
    var QueryUtils = require('../utils/QueryUtils');
    var ColorUtils = require('../utils/ColorUtils');
    var BoundsManager = require('../utils/BoundsManager');
    var Options = require('../theme/options');
    var Point = require('../component/Point');

    var RIGHT_TOP = 'right-top';
    var RIGHT_BOTTOM = 'right-bottom';
    var LEFT_TOP = 'left-top';
    var LEFT_BOTTOM = 'left-bottom';

    var INNER_RADIUS_PCT = Options[Constants.MULTIPIE_CHART].innerRadiusPct;
    var INNER_RING_RADIUS = 15;

    var CIRCLE = 2 * Math.PI;
    var LINE_LABEL_GAP = 2;
    var STEP = Math.PI / 180;

    var DECREASE = [0.9, 0.85, 0.8, 0.75, 0.7, 0.65, 0.6, 0.55, 0.5];

    var VIS_MIN = 1E-10;

    var multiPie = BaseChart.extend({
        
        nodes: [],
        
        root: null,

        ordered: null,

        drilldownNow: null,

        // for convenient
        center: [],
        innerRadius: null,
        radius: null,
        startAngle: null,
        endAngle: null,
        drilldown: null,
        rotatable: null,

        _refresh: function () {
            // this.nodes = [];
            this.root = null;
            this.ordered = null;
            this.sx = d3.scale.linear();
            this.sy = d3.scale.linear();
        },

        mergeSeriesAttributes: function (series) {
            
            var queryList = [
                series.seriesOption,
                this.option.plotOptions[this.componentType],
                this.option.plotOptions,
                Options[this.componentType].plotOptions
            ];

            var center = QueryUtils.queryList(queryList, 'center');
            var innerRadius = QueryUtils.queryList(queryList, 'innerRadius');
            var radius = QueryUtils.queryList(queryList, 'radius');
            var gradual = QueryUtils.queryList(queryList, 'gradual');
            var drilldown = QueryUtils.queryList(queryList, 'drilldown');
            var startAngle = QueryUtils.queryList(queryList, 'startAngle');
            var endAngle = QueryUtils.queryList(queryList, 'endAngle');
            var rotatable = QueryUtils.queryList(queryList, 'rotatable');

            startAngle = BaseUtils.toRadian(startAngle);
            endAngle = BaseUtils.toRadian(endAngle);

            QueryUtils.merge(series, {
                _center: center,
                center: center,
                innerRadius: innerRadius,
                _radius: radius, // test
                radius: radius,
                gradual: gradual,
                drilldown: drilldown,
                startAngle: startAngle,
                endAngle: endAngle,
                rotatable: rotatable
            }, true);

            this.drilldown = drilldown;
            this.rotatable = rotatable;
        },

        doLayout: function () {

            // only first one; multi-pie's series are special
            var series = this.getChartData()[0];

            var center = series.center;
            var innerRadius = series.innerRadius;
            var radius = series.radius;

            var plotBounds = this.vanchart.getPlotBounds();
            if (!series._center || series._center.length === 0) {
                center = [
                    plotBounds.width / 2 + plotBounds.x,
                    plotBounds.height / 2 + plotBounds.y
                ];
            } else {
                series.fixedState = 'fixed';
                center[0] = this._getPercentValue(center[0], this.vanchart.chartWidth());
                center[1] = this._getPercentValue(center[1], this.vanchart.chartHeight());
            }
            series.center = center;
            series.centerX = center[0];
            series.centerY = center[1];
            series.bounds = {x: plotBounds.x, y: plotBounds.y, width: plotBounds.width, height: plotBounds.height};
            
            if (!(series._radius || series.radius)) {
                var left = center[0] - plotBounds.x;
                var right = plotBounds.x + plotBounds.width - center[0];
                var top = center[1] - plotBounds.y;
                var bottom = plotBounds.y + plotBounds.height - center[1];
                radius = Math.min(left, right, top, bottom);
                series.radius = radius;
            } else {
                series.fixedState = 'fixed';
            }

            if (radius && innerRadius) {
                innerRadius = this._getPercentValue(innerRadius, radius);
                series.innerRadius = innerRadius;
            }

            this._initData(series);

        },

        _initData: function (series) {
            // making a Series object as a root node
            // has several problems in interactive events.
            // We need a 'true' Point object as a root.
            if (!this.root) {
                this.root = new Point(series, series.seriesOption, -1);
            }

            this._dfsTraverseData(this.root, this.option.orderType);
            this.nodes = this._bfsTraverseData(this.root);

            // better sequence?
            if (series.fixedState === 'fixed') {
                this._calcData(this.root);
                this._calculateLabelPos();
            } else {
                this._calcData(this.root);

                var outPoints = this.nodes.filter(function (node) {
                    return (node.depth &&
                        node.dx &&
                        node.dataLabels &&
                        node.dataLabels.enabled &&
                        node.dataLabels.align === Constants.OUTSIDE)
                });

                this._calculateOutsideLabelBounds(outPoints, this.root.series);

                this._calcData(this.root);

                this._calculateLabelPos();
            }

            this.sx = this.sx.range([this.startAngle, this.endAngle]).domain([this.startAngle, this.endAngle]);
            this.sy = this.sy.range([0, this.innerRadius, this.radius]).domain([0, this.innerRadius, this.radius]);

            // a log for different render ease functions
            this.isChanged = this.ordered != this.option.orderType;
            this.ordered = this.option.orderType;

        },

        orderData: function () {

        },

        _bfsTraverseData: function (root) {
            var queue = [];
            var stack = [];
            queue.push(root);

            while (node = queue.shift()) {
                var node;
                stack.push(node);
                var children = node.children;
                if (children && (n = children.length)) {
                    var i = -1, n;
                    while (++i < n) {
                        queue.push(children[i]);
                    }
                }
            }
            return stack;
        },

        _dfsTraverseData: function (root, orderType) {
            // get depth, parent, ancestor, chSum, value, height
            // 'ancestor' is inner pie node.
            // as value !== chSum, original value is pointOption.value.
            // Math.abs(node.value) is display value
            function dfsData(node, depth, parent, ancestor) {
                if (!node.children) {
                    switch (depth) {
                        case 0:
                            node.children = node.series.points;
                            break;
                        case 1:
                            // depth 1 node has been a Point, children is a reference
                            // Clone option here so that it has no effect with original option
                            node.children = BaseUtils.clone(node.pointOption.children);
                            break;
                        default:
                            node.children = node.pointOption.children;
                    }
                }
                var c = node.children;
                
                node.parent = parent;
                node.depth = depth;
                node.height = 0;
                node.ancestor = ancestor;

                if (c && (n = c.length)) {
                    var chSum = 0, i = -1, n;
                    while (++i < n) {

                        // inner pies' ancestor is itself
                        if (depth === 0) {
                            ancestor = c[i];
                        }

                        // new Point data from depth 2
                        if (depth > 0 && !c[i].isPoint) {

                            c[i] = new Point(root.series, c[i], -1);

                            // since all points' series is root's series,
                            // set child's className manually
                            c[i].className = node.className + '-' + i;
                        }

                        dfsData(c[i], depth + 1, node, ancestor);

                        chSum += Math.abs(c[i].value);
                        node.height = Math.max(node.height, c[i].visible ? c[i].height + 1 : 0);
                    }

                    c.sort(function(a, b){
                        if (!a.value) {
                            return -1;
                        }
                        switch (orderType) {
                            case Constants.ASCENDING:
                                return Math.abs(a.value) - Math.abs(b.value);
                            case Constants.DESCENDING:
                                return Math.abs(b.value) - Math.abs(a.value);
                            default:
                                return a.index - b.index;
                        }
                    });

                    node.chSum = chSum;
                }

                var _value = node.pointOption.value;
                _value = isNaN(_value) ? 0 : _value;
                
                node.value = _value || node.chSum || 0;

                if (!node.visible) {
                    // set value to 0,
                    // so they can get position but no visible size
                    node.value = 0;
                }
            }

            dfsData(root, 0, null, null);
        },

        _calcData: function (root) {

            var height = root.height;
            
            var center = root.series.center;
            var innerRadius = root.series.innerRadius;
            var radius = root.series.radius;
            var gradual = root.series.gradual;
            var startAngle = root.series.startAngle;
            var endAngle = root.series.endAngle;

            var arc = endAngle - startAngle;

            this.center = center;
            this.innerRadius = innerRadius;
            this.radius = radius;
            this.startAngle = startAngle;
            this.endAngle = endAngle;

            var dRadius, innerPieR;

            if (innerRadius) {
                dRadius = height ? (radius - innerRadius) / height : 0;
                innerPieR = dRadius;
            } else {
                dRadius = (height > 1) ? radius * (1 - INNER_RADIUS_PCT) / (height - 1) : 0;
                innerPieR = (height > 1) ? radius * INNER_RADIUS_PCT : radius;
            }

            var self = this;

            function dfsData(node, x, dx, dy, ir, iPr) {
                var children = node.children;

                node.x = x;
                node.y = (node.depth - 2) * dy + ir + iPr;
                node.dx = dx;
                node.dy = dy;

                if (node.depth) {

                    if (node.depth === 1 && !ir) {
                        node.y = 0;
                        node.dy = iPr;
                    }

                    self._setColor(node, gradual, height);
                    self._mergeTooltipAttributes(node);

                    // outside label may be revised to inside,
                    // otherwise do nothing
                    if (node.dataLabels && node.dataLabels.enabled) {
                        // clone once only
                        if (!node.dataLabels._align && node.dataLabels.align === Constants.OUTSIDE) {
                            node.dataLabels = BaseUtils.clone(node.dataLabels);
                            node.dataLabels._align = node.dataLabels._align || node.dataLabels.align;
                        }
                        if (node.dataLabels._align === Constants.OUTSIDE) {
                            if (node.depth === height) {
                                node.dataLabels.align = Constants.OUTSIDE;
                            } else {
                                node.dataLabels.align = Constants.INSIDE;
                            }
                        }
                    }

                } else {
                    // -1 to avoid dy=0, thus invalidate drill down scale
                    node.y = -1;
                    node.dy = ir + 1;
                }
                
                node._x = node.x;
                node._dx = node.dx;
                node._y = node.y;
                node._dy = node.dy;

                if (children && (n = children.length)) {
                    var i = -1, n, c, d;
                    dx = node.chSum ? dx / node.chSum : 0;
                    while (++i < n) {
                        c = children[i];
                        d = Math.abs(c.value) * dx;
                        dfsData(c, x, d, dy, ir, iPr);
                        x += d;
                    }

                    self._calculatePercentage(children);
                }
            }

            dfsData(root, startAngle, arc, dRadius, innerRadius, innerPieR);
        },

        _setColor: function (node, gradual, height) {
            if (!(node && gradual && height)) {
                return;
            }
            if (!node.pointOption.color) {
                var rgba = ColorUtils.getRGBAColorArray(node.ancestor.color);
                var hsb = ColorUtils.rgb2hsb(rgba[0], rgba[1], rgba[2]);
                var detS, detB;

                var ratio = (node.depth - 1) / height;

                if (gradual === Constants.GRADUAL_LIGHTER) {
                    detS = -hsb[1] * ratio;
                    detB = (1 - hsb[2]) * ratio;
                } else {
                    detS = (1 - hsb[1]) * ratio;
                    detB = -hsb[2] * ratio;
                }

                node.color = ColorUtils.mixColorWithHSB(node.ancestor.color, 0, detS, detB);
            }

            if (!node.pointOption.mouseOverColor) {
                var detS, detB;
                if (gradual === Constants.GRADUAL_LIGHTER) {
                    detS = +0.1;
                    detB = -0.05
                } else {
                    detS = -0.1;
                    detB = +0.05;
                }
                
                node.mouseOverColor = ColorUtils.mixColorWithHSB(
                    (node.tooltip && node.tooltip.enabled && node.tooltip.shared) ?
                        node.ancestor.color :
                        node.color,
                    0, detS, detB);
            }
        },

        _mergeTooltipAttributes: function (node) {
            var tooltip = node.tooltip;

            if (tooltip && tooltip.enabled) {
                if (tooltip.shared) {
                    var p, d = node, points = [node];
                    while ((p = d.parent) && p.depth) {
                        d = p;
                        points.unshift(p);
                    }
                    node.tooltipText = this._calculateTooltipContent(tooltip, node.ancestor.parent, points);
                } else {
                    node.tooltipText = this._calculateTooltipContent(tooltip, node);
                }
            } else {
                node.tooltipText = null;
            }
        },

        // --- label calculation revised from Pie

        _getPossibleLabelBoundsByLocation:function(dim, location){
            var x , y;
            var width = dim.width;
            var height = dim.height;

            switch (location){
                case RIGHT_TOP:
                    x = 0;
                    y = -height;
                    break;
                case RIGHT_BOTTOM:
                    x = y = 0;
                    break;
                case LEFT_BOTTOM:
                    x = -width;
                    y = 0;
                    break;
                case LEFT_TOP:
                    x = -width;
                    y = -height;
                    break;
            }

            return {x:x, y:y, width:width, height:height};
        },

        _ignoreMinArcLabel:function(radius, arcs){

            var totalHeight = 0;

            for(var i = 0, len = arcs.length; i < len; i++){
                var labelDim = arcs[i].labelDim;
                totalHeight += labelDim.height;
            }

            //高度不够，需要省略一些标签
            if(radius * 1.2 < totalHeight){

                var det = totalHeight - radius;

                arcs.sort(function(a, b){
                    return a.value - b.value;
                });

                for(var i = 0, len = arcs.length; i < len; i++){
                    if(det < 0){
                        break;
                    }
                    var labelHeight = arcs[i].labelDim.height;
                    det -= labelHeight;
                }

                arcs = arcs.slice(i, arcs.length);
            }

            arcs.sort(function(a, b){
                return a.x - b.x;
            });

            return arcs;
        },

        _getStartAndEndAngle:function(location){
            switch (location){
                case RIGHT_TOP:
                    return {startAngle:0, endAngle:Math.PI/2};
                case RIGHT_BOTTOM:
                    return {startAngle:Math.PI/2, endAngle:Math.PI};
                case LEFT_BOTTOM:
                    return {startAngle:Math.PI, endAngle:3 * Math.PI / 2};
                case LEFT_TOP:
                    return {startAngle:3 * Math.PI / 2, endAngle: 2 * Math.PI};
            }
        },

        _getLocByArc: function (arc) {
            arc = arc % (2 * Math.PI);
            if(arc < Math.PI / 2){
                return RIGHT_TOP;
            }else if(arc < Math.PI){
                return RIGHT_BOTTOM;
            }else if(arc < 3 * Math.PI / 2){
                return LEFT_BOTTOM;
            }else{
                return LEFT_TOP;
            }
        },

        _getLabelBounds:function(location, centerX, centerY, hWidth, labelDim){
            var x,y;
            if(location == RIGHT_TOP || location == RIGHT_BOTTOM){
                x = centerX + hWidth + LINE_LABEL_GAP;
            }else{
                x = centerX - hWidth - LINE_LABEL_GAP - labelDim.width;
            }

            y = centerY - labelDim.height/2;

            return {x:x, y:y, width:labelDim.width, height:labelDim.height};
        },

        recalculateLabelPos:function(pieConfig, rotate){

            this.nodes.map(function (node) {
                node.labelPos = null;
                node.rotate = rotate;
            });

            this._calculateLabelPos();
        },

        _calculateLabelPos: function () {
            var root = this.root;
            var outPoints = [];
            var inPoints = [];

            this.nodes.map(function (node) {
                node.labelPos = null;
                if (node.dx < VIS_MIN) {
                    return;
                }

                if (node.depth &&
                    node.dx &&
                    node.dy &&
                    (this.drilldownNow ? node !== this.drilldownNow.parent : true) &&
                    node.dataLabels && node.dataLabels.enabled) {

                    if (node.dataLabels.align === Constants.OUTSIDE) {
                        outPoints.push(node);
                    } else {
                        inPoints.push(node);
                    }
                }
            }, this);

            this._calculateOutsideLabelBounds(outPoints, this.root.series, true);

            this._calculateLeadLineStartPos(outPoints);

            this._calculateInsideLabelBounds(inPoints);
        },

        _calculateInsideLabelBounds:function(nodes){
            nodes.map(function (a,i) {
                var node = nodes[i];
                var centerAngle = this.getCenterAngle(node);

                var tmpR = node.y + node.dy / 2;

                var center = this._getArcPoint(tmpR, centerAngle);

                var x = center[0] - node.labelDim.width/2;
                var y = center[1] - node.labelDim.height/2;

                node.labelPos = {x:x, y:y};
            }, this);
        },

        _calculateLeadLineStartPos:function(outPoints){

            var self = this;
            outPoints.forEach(function(arcPoint){

                var radius = arcPoint.y + arcPoint.dy;
                var centerAngle = self.getCenterAngle(arcPoint);

                if(arcPoint.labelPos){
                    arcPoint.labelPos.startPos = {
                        x:(radius + 1)*Math.sin(centerAngle),
                        y: (radius + 1) * Math.cos(centerAngle + Math.PI)
                    }
                }

            });
        },

        calcOutsideLabel: function (outPoints, fixedState, radius, center, plotBounds) {

            var pointsGroups = {};

            outPoints.map(function (p) {
                var center = this.getCenterAngle(p);
                var loc = this._getLocByArc(center);
                pointsGroups[loc] = pointsGroups[loc] || [];
                pointsGroups[loc].push(p);
            }, this);

            if (fixedState) {

                pointsGroups = this.ignoreMin(pointsGroups, radius);
                this.placeOutSideLabels(pointsGroups, radius);
                return radius;

            } else {

                for (var i = 0, len = DECREASE.length; i < len; i++) {
                    var usedR = radius * DECREASE[i];
                    var usedPointsG = this.ignoreMin(pointsGroups, radius);

                    this.placeOutSideLabels(usedPointsG, usedR);

                    if (this.testWithinBounds(usedPointsG, center, plotBounds)) {
                        break;
                    }
                }
                return usedR;
            }
        },

        ignoreMin: function (pointsGroups, radius) {
            var result = {};
            for (var i in pointsGroups) {
                pointsGroups[i].map(function (p) { p.labelPos = null; });
                result[i] = this._ignoreMinArcLabel(radius, pointsGroups[i]);
            }
            return result;
        },

        testWithinBounds: function (pointsGroups, center, wholeBounds) {
            for (var i in pointsGroups) {
                var bounds, x, y, width, height;
                x = y = 0;
                switch (i) {
                    case RIGHT_TOP:
                    case RIGHT_BOTTOM:
                        y = -center[1];
                        width = wholeBounds.width - center[0];
                        height = wholeBounds.height;
                        break;
                    case LEFT_BOTTOM:
                    case LEFT_TOP:
                        x = -center[0];
                        y = -center[1];
                        width = center[0];
                        height = wholeBounds.height;
                        break;
                }
                bounds = {x: x, y: y, width: width, height: height};

                for (var j = 0; j < pointsGroups[i].length; j++) {
                    var p = pointsGroups[i][j];
                    if (!p.labelPos) {
                        continue;
                    }
                    var pBounds = {
                        x: p.labelPos.x,
                        y: p.labelPos.y,
                        width: p.labelDim.width,
                        height: p.labelDim.height
                    };
                    if (!BaseUtils.containsRect(bounds, pBounds)) {
                        return false;
                    }
                }
            }
            return true;
        },

        placeOutSideLabels: function (pointsGroups, radius) {
            for (var i in pointsGroups) {
                if (!this.findNiceBounds(true, pointsGroups[i], radius, i)
                    && !this.findNiceBounds(false, pointsGroups[i], radius, i)
                ) {
                    // here MUST be true.
                    // for we have ignored min arcs, the problem is how to place them.
                    // return false;
                }
            }
            return true;
        },

        findNiceBounds:function(isAngleIncrease, arcPoints, usedR, location){

            var outerR = usedR * 1.2;
            var hWidth = usedR * 0.1;

            var angleRange = this._getStartAndEndAngle(location);

            var searchEnd = isAngleIncrease ? angleRange.endAngle : angleRange.startAngle;
            var step = isAngleIncrease ? STEP : -STEP;

            var preBounds;
            var preAngle;

            arcPoints.map(function (p) {
                p.labelPos = null;
            });

            for(var i = 0, len = arcPoints.length; i < len; i++){

                var pointIndex = isAngleIncrease ? i : len - i - 1;

                var compare = isAngleIncrease ? Math.max : Math.min;

                var point = arcPoints[pointIndex];

                var labelDim = point.labelDim;

                var centerAngle = this.getCenterAngle(point);

                centerAngle = preAngle ? compare(centerAngle, preAngle) : centerAngle;

                var found = false;
                for(var angle = centerAngle; (isAngleIncrease ? angle < searchEnd : angle > searchEnd); angle += step){

                    var centerX = outerR * Math.sin(angle);
                    var centerY = outerR * Math.cos(angle + Math.PI);

                    var bounds = this._getLabelBounds(location, centerX, centerY, hWidth, labelDim);

                    if ((preBounds ? !this._isOverlapOrShadow(preBounds, bounds) : true)
                    ) {
                        found = true;
                        preAngle = angle;
                        break;
                    }
                }

                if (!found) {
                    return false;
                }

                var midPos = {x:centerX, y:centerY};
                var endPos;
                if(location == RIGHT_TOP || location == RIGHT_BOTTOM){
                    endPos = {x:centerX + hWidth, y:centerY};
                }else{
                    endPos = {x:centerX - hWidth, y:centerY};
                }

                preBounds = bounds;
                point.labelPos = {
                    x:bounds.x,
                    y:bounds.y,

                    midPos:midPos,
                    endPos:endPos
                };
            }

            return true;
        },

        _calculateOutsideLabelBounds:function(outPoints, pieConfig, isRecalculate){

            var plotBounds = this.getPlotBounds();
            var center = [];
            center[0] = pieConfig.center[0] - plotBounds.x;
            center[1] = pieConfig.center[1] - plotBounds.y;

            var fixedState = pieConfig.fixedState || isRecalculate;

            pieConfig.radius = this.calcOutsideLabel(outPoints, fixedState, pieConfig.radius, center, plotBounds);

        },

        _isOverlapOrShadow: function (a, b) {
            var topHalfMinY = Math.max(a.y, b.y);
            var topHalfMaxY = Math.min(a.y + a.height / 2, b.y + b.height / 2);
            var bottomHalfMinY = Math.max(a.y + a.height / 2 , b.y + b.height / 2);
            var bottomHalfMaxY = Math.min(a.y + a.height, b.y + b.height);

            return BaseUtils.rectangleOverlapped(a, b) ||
                topHalfMinY <= topHalfMaxY || bottomHalfMinY <= bottomHalfMaxY;
        },

        getCenterAngle:function(node){
            var rotate = node.rotate || 0;
            var centerAngle = rotate + node.x + node.dx / 2 ;
            return BaseUtils.makeValueInRange(0, 2*Math.PI, centerAngle);
        },
        // --- label calc

        _getFixedPos:function(datum, divDim){

            var translateX = this.center[0];
            var translateY = this.center[1];

            var centerAngle = this.getCenterAngle(datum);
            var radius = datum.y + datum.dy;

            var centerX = radius * Math.sin(centerAngle) + translateX;
            var centerY = radius * Math.cos(centerAngle + Math.PI) + translateY;

            if(centerAngle < Math.PI / 2){
                centerY -= divDim.height;
            }else if(centerAngle >= Math.PI && centerAngle < 3 * Math.PI / 2){
                centerX -= divDim.width;
            }else if(centerAngle >= 3 * Math.PI / 2 && centerAngle < CIRCLE){
                centerY -= divDim.height;
                centerX -= divDim.width;
            }

            return [centerX, centerY];
        },
        
        drillDown: function (d) {
            if (this.drilldownNow === d) {
                return;
            }

            var p, node = d;
            while ((p = node.parent) && p.depth) {
                node = p;
                if (!p.name) {
                    return;
                }
            }

            this.drilldownNow = d;

            var radius = this.radius;
            var innerRadius = this.innerRadius;

            function deepest(node) {
                var children = node.children;
                var dc = node;
                if (children && (n = children.length)) {
                    var i = -1, n;
                    while (++i < n) {
                        var c = deepest(children[i]);
                        if (c.depth > dc.depth) {
                            dc = c;
                        }
                    }
                }
                return dc;
            }

            var yDomain, yRange;

            if (d.depth) {
                var rootHeight = d.ancestor.parent.height;

                if (d.height == 0) {
                    // outer ring
                    yDomain = [d.parent._y, d._y, d._y + d._dy];
                    yRange = [0, INNER_RING_RADIUS, radius];

                } else if (d.height + d.depth !== rootHeight) {
                    // deepest child is not outer ring
                    var dc = deepest(d);
                    yDomain = [d.parent._y, d._y, d._y + d._dy, dc._y + dc._dy, radius];
                    yRange = [0, INNER_RING_RADIUS, radius / 2, radius, radius];

                } else {
                    yDomain = [d.parent._y, d._y, d._y + d._dy, radius];
                    yRange = [0, INNER_RING_RADIUS, radius / 2, radius];
                }

            } else {
                yDomain = [0, innerRadius, radius];
                yRange = [0, innerRadius, radius];
            }

            var h = d.depth + d.height;

            this.sx.domain([d._x, d._x + d._dx]);
            this.sy.domain(yDomain).range(yRange);

            this.nodes.map(function (node) {
                if (node.depth &&
                    node.dataLabels &&
                    node.dataLabels.enabled &&
                    node.dataLabels._align === Constants.OUTSIDE) {
                    if (node.depth === h) {
                        node.dataLabels.align = Constants.OUTSIDE;
                    } else {
                        node.dataLabels.align = Constants.INSIDE;
                    }
                    QueryUtils.merge(node, node._calculateLabelInfo(node.dataLabels), true)
                }
                node.x = this.safeAngle(node._x);
                node.dx = this.safeAngle(node._x + node._dx) - node.x;
                node.y = this.safeRadius(node._y);
                node.dy = this.safeRadius(node._y + node._dy) - node.y;

            }, this);

            this._calculateLabelPos();
            
            this.render.drillDown(d);
        },

        onDrag:function(event){
            if(this._draggingSeries){
                this.render.onDrag(this._draggingSeries, event.containerPoint);
            }
        },

        dragEnd:function(event){
            if(this._draggingSeries){
                this.render.onDragEnd(this._draggingSeries, event.containerPoint);
                this._draggingSeries = null;
            }
        },

        findDraggingTarget:function(event){

            var pos = event.containerPoint;

            var plotBounds = this.getPlotBounds();

            var x = pos[0];
            var y = pos[1];

            var series = this.root.series;

            if(BaseUtils.containsPoint(series.bounds, [x,y]) && series.rotatable){
                this.render.onDragStart(this.root, pos);
                this._draggingSeries = series;
                return this;
            }

        },

        safeAngle: function (x) {
            return Math.max(this.startAngle, Math.min(this.endAngle, this.sx(x)));
        },

        safeRadius: function (y) {
            return Math.max(0, this.sy(y));
        },
        
        getChartNodes: function () {
            return this.nodes;
        },

        getCenter: function () {
            return this.center;
        },

        getInnerRadius: function () {
            return this.innerRadius;
        },

        getRadius: function () {
            return this.radius;
        },
        
        getStartAngle: function () {
            return this.startAngle;
        },
        
        getEndAngle: function () {
            return this.endAngle;
        },
        
        getDrilldown: function () {
            return this.drilldown;
        },
        
        getRotatable: function () {
            return this.rotatable;
        },

        getIsChanged: function () {
            return this.isChanged;
        }

    });
    
    require('../ChartLibrary').register(Constants.MULTIPIE_CHART, multiPie);
});
/**
 * Created by eason on 15/5/4.
 */
define('chart/Bar',['require','./BaseChart','../utils/BaseUtils','../Constants','../utils/QueryUtils','../utils/BoundsManager','../theme/options','../ChartLibrary','../ChartLibrary'],function(require){
    var BaseChart = require('./BaseChart');
    var BaseUtils = require('../utils/BaseUtils');
    var Constants = require('../Constants');
    var QueryUtils = require('../utils/QueryUtils');
    var BoundsManager = require('../utils/BoundsManager');
    var Options = require('../theme/options');
    
    var TOOLTIP_GAP = 1;
    var LABEL_GAP = 3;
    var MIN_BAR_SIZE = 2;

    var Bar = BaseChart.extend({

        doLayout:function(){

            //每个方向上的柱子
            var locations2Series = this._buildLocationMap();

            for(var location in locations2Series){

                var location2Series = locations2Series[location];

                for(var i = 0, count = location2Series.length; i < count; i++) {

                    var sameAxisSeries = location2Series[i];

                    if(sameAxisSeries && sameAxisSeries.length) {

                        this._buildBars(sameAxisSeries);

                    }

                }
            }

            this._calculateLabelPos();
        },

        getTrendLineXYValues:function(sery){

            var xValues = [];
            var yValues = [];

            var points = sery.points;
            var isHorizontal = sery.baseAxis.isHorizontal();
            var valueAxis = sery.valueAxis;

            var bars = [];

            for(var i = 0, len = points.length; i < len; i++){
                var barShape = points[i];
                if(!barShape.isNull){
                    bars.push(barShape);
                }
            }

            bars.sort(function(a, b){

                return isHorizontal ? a.x - b.x : a.y - b.y;

            });

            bars.forEach(function(barShape){
                var x, y;

                if(isHorizontal){
                    x = barShape.x + barShape.width / 2;
                    y = valueAxis.isAxisReversed() ? barShape.y + barShape.height : barShape.y;
                }else{
                    x = valueAxis.isAxisReversed() ? barShape.x : barShape.x + barShape.width;
                    y = barShape.y + barShape.height/2;
                }

                xValues.push(x);
                yValues.push(y);
            });

            return [xValues, yValues, sery.baseAxis.getPosition()];
        },

        //创建水平或者垂直方向上的柱子
        _buildBars:function(locationMap){

            var sery = locationMap[0][0];

            var valueBased = sery.isValueAxisBased();

            // valueBased ? this._calculateValueBasedPercentageAndTooltip(locationMap)
            //     : this._calculateCategoryBasedPercentageAndTooltip(locationMap);


            var barSize = valueBased ? this._getValueBasedBarSize(locationMap):this._getBarSize(locationMap);

            var centerPos = barSize.centerPos;
            var barWidth = barSize.barWidth;

            var categoryAxis = locationMap[0][0].baseAxis;
            var isHorizontal = categoryAxis.getPosition() == Constants.LEFT
                || categoryAxis.getPosition() == Constants.RIGHT;

            for(var i = 0, len = locationMap.length; i < len; i++){
                var stackedSeries = locationMap[i];

                for(var j = 0, count = stackedSeries.length; j < count; j++){

                    var sery = stackedSeries[j];

                    for(var dIndex = 0, dCount = sery.points.length; dIndex < dCount; dIndex++){

                        var point = sery.points[dIndex];

                        var pos = categoryAxis.scale(point.category) + centerPos[i] - barWidth[i][j] / 2;

                        var valueAxis = point.series.valueAxis;

                        var value = point.y;
                        var preSum = point.y0;

                        var prePos = valueAxis.scale(preSum);

                        if (preSum === Number.MIN_VALUE) {
                            prePos = valueAxis.scale.range()[0];
                        }

                        var currentPos = valueAxis.scale(value + preSum);
                        var barHeight = Math.abs(currentPos - prePos);

                        var strokeWidth = point.borderWidth;

                        var x = isHorizontal ? Math.min(prePos, currentPos) : pos;
                        var y = isHorizontal ? pos : Math.min(prePos, currentPos);
                        var width = isHorizontal ? barHeight : barWidth[i][j];
                        var height = isHorizontal ? barWidth[i][j] : barHeight;

                        width = Math.max(width, 0);
                        height = Math.max(height,0);

                        var tmpBar = BaseUtils.rectSubPixelOpt(x,y,width,height,strokeWidth);

                        QueryUtils.merge(point,
                            QueryUtils.merge(tmpBar,{
                                location:categoryAxis.getPosition(),
                                startPos:valueAxis.getStartPos(),
                                direction:this.getAnimationDirection(valueAxis, value)
                            },true),
                            true);
                    }
                }
            }
        },

        getAnimationDirection:function(valueAxis, value){

            var isPositive = value >= 0;

            if(valueAxis.isHorizontal()){
                return isPositive ^ valueAxis.isAxisReversed() ? Constants.LEFT_TO_RIGHT : Constants.RIGHT_TO_LEFT;
            }else{
                return isPositive ^ valueAxis.isAxisReversed() ? Constants.BOTTOM_TO_TOP : Constants.TOP_TO_BOTTOM;
            }
        },

        _getFixedPos:function(datum, divDim){

            var location = datum.location;

            var plotBounds = this.getPlotBounds();

            var x,y;
            if(location == Constants.TOP || location == Constants.BOTTOM){
                //柱形图
                x = plotBounds.x + datum.x + datum.width + TOOLTIP_GAP;
                y = plotBounds.y + datum.y;
            }else{
                //条形图
                x = plotBounds.x + datum.x + datum.width - divDim.width;
                y = plotBounds.y + datum.y + datum.height + TOOLTIP_GAP;
            }

            return [x, y];
        },

        mergeSeriesAttributes:function(sery){

            var queryList = [
                sery.seriesOption,
                this.option.plotOptions[this.componentType],
                this.option.plotOptions,
                Options[this.componentType].plotOptions
            ];

            QueryUtils.merge(sery, {
                width:QueryUtils.queryList(queryList, 'width')
            });

        },

        _getTotalDataPointCount:function(){

            var series = this.getVisibleChartData();
            var count = 0;
            for(var i = 0, len = series.length; i < len; i++){
                count += series[i].points.length;
            }

            return Math.max(count, 1);
        },

        _getValueBasedBarSize:function(locationMap){

            var baseAxis = locationMap[0][0].baseAxis;

            var count = this._getTotalDataPointCount();

            //处理柱子的大小
            var total = baseAxis.isHorizontal() ? baseAxis.bounds.width : baseAxis.bounds.height;
            var fixedBarWidth = this.fixedBarWidth ? this.fixedBarWidth : (total / count / 3);
            fixedBarWidth = Math.max(fixedBarWidth, MIN_BAR_SIZE);

            //缓存第一次计算的值
            this.fixedBarWidth = fixedBarWidth;

            var centerPos = [], barWidth = [];

            for(var i = 0, count = locationMap.length; i < count; i++){
                centerPos.push(0);

                for(var j = 0, len = locationMap[i].length; j < len; j++){

                    var sery = locationMap[i][j];

                    barWidth[i] = barWidth[i] || [];

                    barWidth[i].push(Math.max( BaseUtils.isNull(sery.width) ? fixedBarWidth : sery.width, MIN_BAR_SIZE));
                }
            }

            return {
                centerPos:centerPos,
                barWidth:barWidth
            }

        },

        _getBarSize:function(locationMap){

            var barCount = locationMap.length;

            var categoryAxis = locationMap[0][0].baseAxis;

            var tickLength = categoryAxis.getTickLength();

            var queryList = [
                this.option.plotOptions[this.componentType],
                this.option.plotOptions,
                Options[this.componentType].plotOptions
            ];
            var categoryGap = QueryUtils.queryList(queryList, 'categoryGap');
            var gap = QueryUtils.queryList(queryList, 'gap');

            categoryGap = this._getPercentValue(categoryGap, tickLength);

            var defaultWidth = (tickLength - categoryGap) / barCount;

            var start = categoryGap / 2;
            var centerPos = [];
            for(var i = 0; i < barCount; i++){
                centerPos.push(start + defaultWidth * (i + 0.5));
            }

            gap = this._getPercentValue(gap, defaultWidth);
            defaultWidth -= gap;

            var barWidth = [];
            for(var i = 0; i < barCount; i++){
                for(var j = 0, len = locationMap[i].length; j < len; j++){

                    var sery = locationMap[i][j];

                    barWidth[i] = barWidth[i] || [];

                    barWidth[i].push(Math.max( BaseUtils.isNull(sery.width) ? defaultWidth : sery.width, MIN_BAR_SIZE));
                }
            }

            return {
                centerPos:centerPos,
                barWidth:barWidth
            }
        },

        //计算标签的位置
        _calculateLabelPos:function(){
            var manager = new BoundsManager();
            var series = this.getVisibleChartData();
            var chart = this;

            series.forEach(function(sery){

                sery.points.forEach(function(point){

                    var dataLabels = point.dataLabels;
                    if(dataLabels && dataLabels.enabled){

                        if(dataLabels.align){
                            point.labelPos = chart._calculateAlignLabelPos(point, dataLabels.align);
                            manager.addBounds(BaseUtils.makeBounds(point.labelPos, point.labelDim));

                        }else{

                            var order = [Constants.CENTER, Constants.INSIDE, Constants.OUTSIDE];
                            for(var index = 0, len = order.length; index < len; index++){
                                var align = order[index];
                                var pos = chart._calculateAlignLabelPos(point, align);
                                if(!manager.isOverlapped(BaseUtils.makeBounds(pos, point.labelDim)) || align == Constants.OUTSIDE){
                                    point.labelPos = pos;
                                    manager.addBounds(BaseUtils.makeBounds(pos, point.labelDim));
                                    break;
                                }
                            }
                        }
                    }
                });

            });
        },

        _calculateAlignLabelPos:function(point, align){

            var labelDim = point.labelDim;

            var isVertical = point.location == Constants.TOP || point.location == Constants.BOTTOM;

            var isPositive = point.series.stackByPercent ? point.percentage >= 0 : point.value >= 0;

            var sery = point.series;
            var valueAxis = sery.valueAxis;

            isPositive = isPositive ^ valueAxis.isAxisReversed();

            var centerX = point.x + point.width/2;
            var centerY = point.y + point.height/2;

            var x,y;

            switch (align){
                case Constants.CENTER:

                    x = centerX - labelDim.width/2;
                    y = centerY - labelDim.height/2;

                    break;
                case Constants.INSIDE:

                    if(isVertical){
                        x = centerX - labelDim.width/2;

                        y = isPositive ?
                        point.y + LABEL_GAP : point.y + point.height - LABEL_GAP - labelDim.height;

                    }else{

                        y = centerY - labelDim.height/2;

                        x = isPositive ?
                        point.x + point.width - LABEL_GAP - labelDim.width : point.x + LABEL_GAP;

                    }

                    break;
                case Constants.OUTSIDE:

                    if(isVertical){
                        x = centerX - labelDim.width/2;
                        y = isPositive ?
                        point.y - LABEL_GAP - labelDim.height : point.y + point.height + LABEL_GAP;
                    }else{

                        y = centerY - labelDim.height/2;

                        x = isPositive ?
                        point.x + point.width + LABEL_GAP : point.x - LABEL_GAP - labelDim.width;
                    }

                    break;
            }

            return {
                x:x,
                y:y
            }
        },

        getInitBarAttribute:function(d){

            var direction = d.direction || Constants.BOTTOM_TO_TOP;

            var left2right = {x: d.startPos, y: d.y, width: 0, height: d.height};
            var left2rightEnd = {x: d.startPos, y: d.y, width:d.x + d.width - d.startPos, height: d.height};

            var right2left = {x: d.startPos, y: d.y, width: 0, height: d.height};
            var right2leftEnd = {x: d.x, y: d.y, width: d.startPos - d.x, height: d.height};

            var bottom2top = {x: d.x, y: d.startPos, width: d.width, height: 0};
            var bottom2topEnd = {x: d.x, y: d.y, width: d.width, height: d.startPos - d.y};

            var top2bottom = {x: d.x, y: d.startPos, width: d.width, height: 0};
            var top2bottomEnd = {x: d.x, y: d.startPos, width: d.width, height: d.y + d.height - d.startPos};

            switch (direction){

                case Constants.BOTTOM_TO_TOP:
                    return  {
                        init:bottom2top,
                        end:bottom2topEnd
                    };

                case Constants.TOP_TO_BOTTOM:
                    return {
                        init:top2bottom,
                        end:top2bottomEnd
                    };

                case Constants.LEFT_TO_RIGHT:
                    return {
                        init:left2right,
                        end:left2rightEnd
                    };

                case Constants.RIGHT_TO_LEFT:
                    return {
                        init:right2left,
                        end:right2leftEnd
                    };

            };
        }

    });

    require('../ChartLibrary').register(Constants.BAR_CHART, Bar);
    require('../ChartLibrary').register(Constants.COLUMN_CHART, Bar);

    return Bar;
});
/**
 * Created by eason on 15/7/17.
 */

define('chart/Line',['require','../Constants','../utils/BaseUtils','../utils/QueryUtils','./BaseChart','../theme/options','../ChartLibrary'],function(require){

    var Constants = require('../Constants');
    var BaseUtils = require('../utils/BaseUtils');
    var QueryUtils = require('../utils/QueryUtils');
    var BaseChart = require('./BaseChart');
    var Options = require('../theme/options');

    var DEFAULT_AREA_ALPHA = 0.35;

    var LABEL_GAP = 2;

    var Line = BaseChart.extend({

        type:Constants.LINE_CHART,

        doLayout:function(){

            var locations2Series = this._buildLocationMap();

            for(var location in locations2Series){

                var location2Series = locations2Series[location];

                for(var i = location2Series.length - 1; i >= 0; i--) {

                    var sameAxisSeries = location2Series[i];

                    if(sameAxisSeries && sameAxisSeries.length) {

                        this._buildLines(sameAxisSeries);

                    }
                }
            }

            this._calculateLabelPos();
        },

        _buildLines:function(locationMap) {

            var large = this.option.plotOptions.large;

            var sery = locationMap[0][0];

            // sery.isValueAxisBased() ? this._calculateValueBasedPercentageAndTooltip(locationMap)
            //     : this._calculateCategoryBasedPercentageAndTooltip(locationMap);

            var chart = this;
            for(var i = 0, count = locationMap.length; i < count; i++){
                var stackedSeries = locationMap[i];

                stackedSeries.forEach(function(series){

                    series.dataBands = chart._calculateDataBands(series);

                    var baseAxis = series.baseAxis;
                    var valueAxis = series.valueAxis;

                    var isHorizontal =
                        series.getLocation() == Constants.LEFT ||
                        series.getLocation() == Constants.RIGHT;
                    var originalPoints = series.originalPoints || series.points;
                    var points = [].concat(originalPoints);

                    points.forEach(function(point){
                        chart._positionFix(point, baseAxis, valueAxis, isHorizontal);
                    });

                    var key = chart.vanchart.isInverted() ? 'y' : 'x';
                    if(large){
                        var xMap = {};
                        var yMap = {};
                        var largePoints = [];

                        points.forEach(function(point){

                            if(!xMap[point.x] || !yMap[point.y]){

                                largePoints.push(point);

                                xMap[point.x] = true;
                                yMap[point.y] = true;
                            }
                        });

                        largePoints.sort(function(pointA, pointB){
                            return pointA[key] - pointB[key];
                        });
                        points = largePoints;
                    }else{
                        points.sort(function(pointA, pointB){
                            return pointA[key] - pointB[key];
                        });
                    }

                    if(series.connectNulls){

                        var newPoints = [];

                        points.forEach(function(point){

                            if(!point.isNull){
                                newPoints.push(point);
                            }

                        });
                        points = newPoints;
                    }

                    series.points = points;
                    series.originalPoints = originalPoints;
                });
            }
        },

        _positionFix:function(point, baseAxis, valueAxis, isHorizontal){

            var det = baseAxis.scale.rangeBand ? baseAxis.scale.rangeBand()/2 : 0;
            var t1 = Math.round(baseAxis.scale(point.category) + det);
            var t2 = valueAxis.scale(point.y + point.y0);
            var t3 = valueAxis.scale(point.y0);

            if(isHorizontal){
                point.y = t1;
                point.x = t2;
                point.x0 = t3;
            }else{
                point.x = t1;
                point.y = t2;
                point.y0 = t3;
            }
        },

        mergeDataPointAttributes:function(point){
            this._mergeMarkerAttributes(point);
        },

        mergeSeriesAttributes:function(lineSery){

            var seriesOption = lineSery.seriesOption;

            //系列的一些属性
            var queryList = [
                seriesOption,
                this.option.plotOptions[lineSery.type],
                this.option.plotOptions,
                Options[lineSery.type].plotOptions
            ];
            var connectNulls = BaseUtils.pick(QueryUtils.queryList(queryList, 'connectNulls'), true);
            var lineWidth = QueryUtils.queryList(queryList, 'lineWidth') || 0;
            var color = QueryUtils.queryList(queryList, 'color') || this._getDefaultSeriesColor(lineSery.name);

            var fillColor = QueryUtils.queryList(queryList, 'fillColor');
            fillColor = fillColor ? (fillColor === true ? color : fillColor) : (fillColor === false ? '' : color);

            var fillColorOpacity = BaseUtils.pick(QueryUtils.queryList(queryList, 'fillColorOpacity') , DEFAULT_AREA_ALPHA);
            var stack = QueryUtils.queryList(queryList, 'stack');

            var interpolate = this._getSeriesInterpolate(queryList);
            var lineSvg = this._getLineSvg(interpolate);
            var areaSvg = this._getAreaSvg(interpolate);
            var className = lineSery.className + (stack ? 'stacked' : 'unstacked') ;

            var points = [];

            BaseUtils.extend(lineSery,
                {
                    className:className,
                    lineWidth: lineWidth,
                    color: color,
                    fillColor:fillColor,
                    fillColorOpacity:fillColorOpacity,
                    connectNulls:connectNulls,
                    lineSvg: lineSvg,
                    areaSvg:areaSvg,
                    points: points,
                    isStack:!!stack
                }
            );
        },

        _calculateDataBands:function(lineSery){

            var plotBounds = this.getPlotBounds();

            var dColor = lineSery.color;
            var dFillColor = lineSery.fillColor;
            var dFillColorOpacity = lineSery.fillColorOpacity;

            var queryList = [
                lineSery.seriesOption,
                this.option.plotOptions[lineSery.type],
                this.option.plotOptions,
                Options[lineSery.type].plotOptions
            ];

            var bands = QueryUtils.queryList(queryList, 'bands');

            var clipID = this.vanchart.getIDPrefix() + lineSery.className;

            var valueAxis = lineSery.valueAxis;

            var resultRanges = [];
            resultRanges.push({
                x:0,
                y:0,
                width:plotBounds.width,
                height:plotBounds.height,
                color:dColor,
                fillColor:dFillColor,
                fillColorOpacity:dFillColorOpacity,
                lineData:lineSery,
                clipID:clipID + '-1'
            });

            if(!bands){
                return resultRanges;
            }

            if(!BaseUtils.isArray(bands)){
                bands = [bands];
            }

            for(var i = 0, len = bands.length; i < len; i++){

                var x = 0, y = 0;
                var width = plotBounds.width;
                var height = plotBounds.height;

                var domain = valueAxis.scale.domain();

                var from = Math.max(domain[0], bands[i].from);
                var to = Math.min(domain[1], bands[i].to);

                from = valueAxis.scale(from);
                to = valueAxis.scale(to);

                var color = bands[i].color || dColor;
                var fillColor = bands[i].fillColor || dFillColor;
                var fillColorOpacity = bands[i].fillColorOpacity || dFillColorOpacity;

                if(valueAxis.isHorizontal()){
                    x = Math.min(from, to);
                    width = Math.abs(from - to);
                }else{
                    y = Math.min(from, to);
                    height = Math.abs(from - to);
                }

                resultRanges.push({
                    x:x,
                    y:y,
                    height:height,
                    width:width,
                    color:color,
                    lineData:lineSery,
                    fillColor:fillColor,
                    fillColorOpacity:fillColorOpacity,
                    clipID:clipID + i
                });
            }

            return resultRanges;
        },

        _getFixedPos:function(datum){

            var radius = datum.marker.radius || this.getDefaultMarkerRadius();

            var plotBounds = this.getPlotBounds();

            var x = plotBounds.x + datum.x + radius;
            var y = plotBounds.y + datum.y + radius;

            return [x, y];
        },

        _calculateLabelPos:function(){

            var lineData = this.getVisibleChartData();

            lineData.forEach(function(lineData){

                lineData.points.forEach(function(point){
                    var dataLabels = point.dataLabels;
                    if(dataLabels && dataLabels.enabled){
                        point.labelPos = {
                            x: point.x - point.labelDim.width/2,
                            y:point.y  - LABEL_GAP - point.labelDim.height
                        };
                    }
                });

            });
        },

        getTrendLineXYValues:function(sery){
            return this.getNormalTrendLineXYValues(sery);
        },

        getClosestPoint:function(pos){
            var isInverted = this.vanchart.isInverted();
            var key = isInverted ? 'y' : 'x';

            var selectedPoint;
            var minDistance = Number.MAX_VALUE;

            var lineData = this.vanchart.hoverSeries;

            var plotBounds = this.getPlotBounds();

            var rePos = plotBounds[key] - (isInverted ? pos[1] : pos[0]);

            if(lineData && lineData.points){
                lineData.points.forEach(function(point){
                    var dis = Math.abs(point[key] + rePos);
                    if(dis < minDistance && !point.isNull){
                        selectedPoint = point;
                        minDistance = dis;
                    }
                });
            }else{

                var series = this.vanchart.series;

                series.forEach(function(sery){

                    if(sery.points){
                        sery.points.forEach(function(point){
                            var dis = Math.abs(point[key] + rePos);
                            if(dis < minDistance && !point.isNull){
                                selectedPoint = point;
                                minDistance = dis;
                            }
                        });
                    }
                });
            }
            return selectedPoint;
        }
    });
    
    require('../ChartLibrary').register(Constants.LINE_CHART, Line);

    return Line;
});
/**
 * Created by eason on 15/7/17.
 */

define('chart/Area',['require','../Constants','./Line','../ChartLibrary'],function(require){

    var Constants = require('../Constants');
    var Line = require('./Line');

    var Area = Line.extend({
        type:Constants.AREA_CHART
    });

    require('../ChartLibrary').register(Constants.AREA_CHART, Area);
    
    return Area;
});
/**
 * Created by eason on 15/12/2.
 */
define('chart/Gauge',['require','../Constants','../utils/BaseUtils','../utils/ColorUtils','./BaseChart','../utils/QueryUtils','../utils/BoundsManager','../theme/options','../ChartLibrary'],function(require){

    var Constants = require('../Constants');
    var BaseUtils = require('../utils/BaseUtils');
    var ColorUtils = require('../utils/ColorUtils');
    var BaseChart = require('./BaseChart');
    var QueryUtils = require('../utils/QueryUtils');
    var BoundsManager = require('../utils/BoundsManager');
    var Options = require('../theme/options');

    //默认半径大小
    var DEFAULT_RADIUS = 100;
    var DEFAULT_PADDING = 5;

    var TICK_SIZE = 6;
    var TICK_LABEL_GAP = 4;
    var THERMOMETER_R = 5;

    var HORIZONTAL_GAP = 0.8;
    var VERTICAL_GAP = 0.3;
    var LINE_GAP = 0.3;

    var Gauge = BaseChart.extend({

        doLayout:function(){

            var queryList = [
                this.option.plotOptions[Constants.GAUGE_CHART],
                this.option.plotOptions,
                Options[Constants.GAUGE_CHART].plotOptions
            ];

            var layout = QueryUtils.queryList(queryList, 'layout') || Constants.HORIZONTAL_LAYOUT;

            var series = this.getVisibleChartData();
            var self = this;
            series.forEach(function(sery){
                var optList = [sery.seriesOption].concat(queryList);
                //重置radius属性
                sery.radius = QueryUtils.queryList(optList, 'radius');

                var gaugeAxis = sery.gaugeAxis;
                var domain = gaugeAxis.scale.domain();
                var defaultBands = self._getDefaultBands([sery.seriesOption, optList], domain);

                sery.bands = BaseUtils.addArray(sery.bands, defaultBands);

                sery.points.forEach(function(point){
                    point.valueInDomain = BaseUtils.getValueInDomain(point.value, domain);

                    point.color = sery._getBandsColor(point) || point.color;

                    var queryList = [
                        point.pointOption,
                        sery.seriesOption,
                        sery.chart.option.plotOptions[sery.type],
                        sery.chart.option.plotOptions,
                        Options[sery.type].plotOptions
                    ];

                    point.mouseOverColor = QueryUtils.queryList(queryList, 'mouseOverColor') || ColorUtils.getHighLightColor(point.color);
                    point.clickColor = ColorUtils.getClickColor(point.color);
                });

                //过滤空值
                var points = sery.points;
                var result = [];
                for(var i = 0, len = points.length; i < len; i++){
                    if(!points[i].isNull){
                        result.push(points[i]);
                    }
                }
                sery.points = result;

                self._calculatePercentage(sery.points);
                self._mergeTooltipAttributes(sery.points);
                // self._dealStackedPoints(sery.points);
            });

            this._dealGaugeLabels();

            this._fixCenterAndSize(layout);
        },

        mergeSeriesAttributes:function(series){

            var queryList = [
                series.seriesOption,
                this.option.plotOptions[series.type],
                this.option.plotOptions,
                Options[series.type].plotOptions
            ];

            var style = QueryUtils.queryList(queryList, 'style') || Constants.GAUGE_POINTER;
            var themeConfig = this.vanchart.themeConfig;
            var styleConfig = themeConfig[style] || themeConfig[Constants.GAUGE_POINTER];
            var seriesLabel = QueryUtils.queryList(queryList, 'seriesLabel') || {};
            var valueLabel = QueryUtils.queryList(queryList, 'valueLabel') || {};
            var percentageLabel = QueryUtils.queryList(queryList, 'percentageLabel') || {};
            var needle = QueryUtils.queryList(queryList, 'needle');
            var hinge = QueryUtils.queryList(queryList, 'hinge');
            var clockwise = QueryUtils.queryList(queryList, 'clockwise');
            var hingeBackgroundColor = QueryUtils.queryList(queryList, 'hingeBackgroundColor');
            var paneBackgroundColor = QueryUtils.queryList(queryList, 'paneBackgroundColor');
            var slotBackgroundColor = QueryUtils.queryList(queryList, 'slotBackgroundColor');
            var innerPaneBackgroundColor = QueryUtils.queryList(queryList, 'innerPaneBackgroundColor');
            var thermometerLayout = QueryUtils.queryList(queryList, 'thermometerLayout') || Constants.HORIZONTAL_LAYOUT;

            var bands = QueryUtils.queryList(queryList, 'bands') || [];

            var className = series.className + style + thermometerLayout;

            BaseUtils.extend(series,
                {
                    className:className,
                    style : style,
                    bands:bands,
                    center : QueryUtils.queryList(queryList, 'center'),
                    radius : QueryUtils.queryList(queryList, 'radius'),
                    seriesLabel : QueryUtils.merge(seriesLabel, styleConfig.seriesLabel),
                    valueLabel : QueryUtils.merge(valueLabel, styleConfig.valueLabel),
                    percentageLabel : QueryUtils.merge(percentageLabel, styleConfig.percentageLabel),
                    needle : needle || styleConfig.needle,
                    hinge : hinge || styleConfig.hinge,
                    thermometerLayout:thermometerLayout || styleConfig.thermometerLayout,
                    clockwise:BaseUtils.pick(clockwise, styleConfig.clockwise),
                    hingeBackgroundColor : hingeBackgroundColor || styleConfig.hingeBackgroundColor,
                    paneBackgroundColor : paneBackgroundColor || styleConfig.paneBackgroundColor,
                    slotBackgroundColor: slotBackgroundColor || styleConfig.slotBackgroundColor,
                    innerPaneBackgroundColor: innerPaneBackgroundColor || styleConfig.innerPaneBackgroundColor
                }
            );
        },

        _getDefaultBands:function(queryList, domain){

            var color = QueryUtils.queryList(queryList, 'color');
            var bands = [];

            if(color){
                bands.push({
                    from:domain[0],
                    to:domain[1],
                    color:color
                });
            }else{
                var min = domain[0];
                var max = domain[1];
                var band = BaseUtils.accDiv((max - min), 3);
                var fStop = BaseUtils.accAdd(min, band);
                var sStop = BaseUtils.accAdd(fStop, band);
                var colors = this.option.colors;

                bands = [
                    {
                        from:min,
                        to:fStop,
                        color:colors[0]
                    },
                    {
                        from:fStop,
                        to:sStop,
                        color:colors[1]
                    },
                    {
                        from:sStop,
                        to:max,
                        color:colors[2]
                    }];
            }

            return bands;
        },

        _calculatePercentage:function(points){

            if(points.length){

                var gaugeAxis = points[0].series.gaugeAxis;

                var minMax = gaugeAxis.scale.domain();

                points.forEach(function(point){

                    point.percentage = (point.value - minMax[0]) / (minMax[1] - minMax[0]);

                });

            }

        },

        _dealGaugeLabels:function(){

            var self = this;

            var gaugeData = this.getVisibleChartData();

            gaugeData.forEach(function(singleGauge){

                var style = singleGauge.style;

                //分类标签
                if(style == Constants.GAUGE_POINTER || style == Constants.GAUGE_POINTER_SEMI){

                    singleGauge.seriesLabelContent = '';
                    singleGauge.seriesLabelDim = {width:0, height:0};

                    if(singleGauge.seriesLabel && singleGauge.seriesLabel.enabled && singleGauge.points[0]){

                        var style = singleGauge.seriesLabel.style;

                        var labelInfo = singleGauge.points[0]._calculateLabelInfo(singleGauge.seriesLabel);

                        var labelContent = labelInfo.labelContent;
                        var labelDim = labelInfo.labelDim;

                        singleGauge.seriesLabelContent = labelContent[0] ? labelContent[0].text : '';
                        singleGauge.seriesLabelStyle = style;
                        singleGauge.seriesLabelDim = labelDim;
                    }

                }else{
                    //百分比
                    singleGauge.percentageLabelContent = '';
                    singleGauge.percentageLabelDim = {width:0, height:0};

                    if(singleGauge.percentageLabel && singleGauge.percentageLabel.enabled && singleGauge.points[0]){

                        var labelStyle = BaseUtils.clone(singleGauge.percentageLabel.style);

                        if(!labelStyle.color){
                            labelStyle.color = singleGauge.points[0].color;
                        }

                        var labelInfo = singleGauge.points[0]._calculateLabelInfo(singleGauge.percentageLabel);
                        var labelContent = labelInfo.labelContent;
                        var labelDim = labelInfo.labelDim;

                        singleGauge.percentageLabelContent = labelContent[0] ? labelContent[0].text : '';
                        singleGauge.percentageLabelStyle = labelStyle;
                        singleGauge.percentageLabelDim = labelDim;
                    }

                }

                singleGauge.valueLabelContent = '';
                singleGauge.valueLabelDim = {width:0, height:0};

                if(singleGauge.valueLabel && singleGauge.valueLabel.enabled){
                    singleGauge.valueLabelContent = self._fixValueLabelContent(singleGauge);
                }

            });

        },

        _fixValueLabelContent:function(gauge){

            var valueLabel = gauge.valueLabel;
            var style = valueLabel.style;
            var useHtml = valueLabel.useHtml;
            var formatter = valueLabel.formatter;

            var valueLabelContent = [];

            if(gauge.style == Constants.GAUGE_POINTER
                || gauge.style == Constants.GAUGE_POINTER_SEMI
                || gauge.style == Constants.GAUGE_RING
                || gauge.style == Constants.GAUGE_THERMOMETER){
                for(var i = 0, len = gauge.points.length; i < len; i++){
                    var point = gauge.points[i];
                    var labelContent = this._calculateSingleLineLabelContent(formatter, point);
                    var labelDim = BaseUtils.getTextDimension(labelContent, style, useHtml);

                    valueLabelContent.push({
                        labelContent:labelContent,
                        labelDim:labelDim,
                        labelStyle:style
                    });
                }
            }else if(gauge.points[0]){
                var labelContent = this._createMultiLineLabelContent(formatter, gauge.points[0]);
                var labelStyle = valueLabel.style;
                for(var i = 0, len = labelContent.length; i < len; i++){
                    valueLabelContent.push({
                        labelContent:labelContent[i],
                        labelStyle:labelStyle,
                        labelDim:BaseUtils.getTextDimension(labelContent[i], labelStyle, useHtml)
                    });
                }
            }

            return valueLabelContent;
        },

        orderData:function(){

            var series = this.vanchart.series;

            var chart = this;

            series.sort(function(seryA, seryB){

                var totalA = seryA.getSeryTotalValue();

                var totalB = seryB.getSeryTotalValue();

                return chart.option.orderType == Constants.ASCENDING ? totalA - totalB : totalB - totalA;

            });
        },

        _getColorFromBands:function(value, bands){

            if(bands && bands.length){

                for(var i = 0, len = bands.length; i < len; i++){

                    var band = bands[i];

                    var min = Math.min(band.from, band.to);
                    var max = Math.max(band.from, band.to);

                    if(value >= min && value <= max){
                        return band.color;
                    }
                }
            }

        },

        _fixCenterAndSize:function(layout){

            var gaugeData = this.getVisibleChartData();

            //确定圆心位置的算作悬浮元素,给默认的大小
            for(var i = 0, len = gaugeData.length; i < len; i++){
                var singleGauge = gaugeData[i];

                if(singleGauge.center){
                    var plotBounds = this.vanchart.plotOriginalBounds;
                    var centerX = singleGauge.center[0];
                    var centerY = singleGauge.center[1];

                    if(centerX.indexOf('%') != -1){
                        centerX = this._getPercentValue(centerX, this.vanchart.chartWidth());
                    }

                    if(centerY.indexOf('%') != -1){
                        centerY = this._getPercentValue(centerY, this.vanchart.chartHeight());
                    }

                    centerX -= plotBounds.x;
                    centerY -= plotBounds.y;

                    singleGauge.centerX = centerX;
                    singleGauge.centerY = centerY;
                    singleGauge.radius = singleGauge.radius || DEFAULT_RADIUS;
                }
            }

            layout == Constants.HORIZONTAL_LAYOUT ?
                this._dealHorizontalLayout() : this._dealVerticalLayout();

            //确定边界以后确定圆心位置
            var self = this;
            gaugeData.forEach(function(singleGauge){

                var style = singleGauge.style;

                switch (style){
                    case Constants.GAUGE_POINTER:
                        self._fixPointerCenter(singleGauge);
                        break;

                    case Constants.GAUGE_POINTER_SEMI:
                        self._fixPointerSemiCenter(singleGauge);
                        break;

                    case Constants.GAUGE_SLOT:
                        self._fixSlotCenter(singleGauge);
                        break;

                    case Constants.GAUGE_THERMOMETER:
                        self._fixThermometerCenter(singleGauge);
                        break;

                    case Constants.GAUGE_RING:
                        self._fixRingCenter(singleGauge);
                        break;

                }
            });
        },

        _fixPointerCenter:function(gauge){

            var radius = gauge.radius;
            var align = gauge.seriesLabel.align || Constants.BOTTOM;
            if (!gauge.center) {
                var bounds = gauge.bounds;
                var labelHeight = 20 + gauge.seriesLabelDim.height;

                var usedHeight = bounds.height - labelHeight;

                var centerX = bounds.x + bounds.width / 2;
                var centerY = bounds.y + bounds.height / 2;
                radius = Math.min(bounds.width, usedHeight) / 2 - DEFAULT_PADDING;

                if (align == Constants.BOTTOM) {

                    if (centerY + radius + labelHeight > bounds.y + bounds.height) {

                        var gap = bounds.height - (radius * 2 + labelHeight);

                        if (gap >= 0) {
                            centerY = bounds.y + radius + gap / 2;
                        }
                    }

                } else {

                    if (centerY - radius - labelHeight < bounds.y) {

                        var gap = bounds.height - (radius * 2 + labelHeight);

                        if (gap >= 0) {
                            centerY = bounds.y + radius + labelHeight + gap / 2;
                        }

                    }
                }

                gauge.centerX = centerX;
                gauge.centerY = centerY;
                gauge.radius = radius;
            }


            if(gauge.seriesLabelContent){
                var dim = gauge.seriesLabelDim;

                gauge.seriesLabelPos = {
                    x: -dim.width/2,
                    y:align == Constants.BOTTOM ? (radius+20) : (-radius-20-dim.height)
                }
            }

            if(gauge.valueLabelContent){
                var gaugeAxis = gauge.gaugeAxis;
                var axisOption = gaugeAxis.componentOption;
                var domain = gaugeAxis.scale.domain();
                var scale = d3.scale.linear().domain(domain)
                    .range([BaseUtils.toRadian(-150), BaseUtils.toRadian(150)]);
                var tickHeight = BaseUtils.getTextHeight(axisOption.labelStyle);

                var startY = 0.16 * radius + tickHeight/2;
                var labelR = (1 - 0.05 - 0.1) * radius;
                var endY = labelR * Math.cos(Math.PI/6) - 2 * tickHeight;

                this._dealValueLabelContent(gauge, radius, scale, startY, endY);
            }


        },

        _getPointerTickBoundsManager:function(gaugeAxis, radius, scale, tickHeight){

            var manager = new BoundsManager();

            var labelR = (1 - 0.05 - 0.1 - 0.01) * radius;

            var tickData = gaugeAxis.getTickData();

            var gap = tickHeight * 0.5;

            var self = this;

            tickData.forEach(function(tick){

                var center = self._getPointerTickCenter(tick, labelR, scale);

                manager.addBounds({
                    x:center.x - tick.tickDim.width/2 - gap,
                    y:center.y - tick.tickDim.height/2 - gap,
                    width:tick.tickDim.width + gap,
                    height:tick.tickDim.height + gap
                })
            });

            var minorTickData = gaugeAxis.getMinorTickData();

            var minorTickR = (1 - 0.05 - 0.1) * radius;
            var minorTickSize = 0.1 * radius;

            minorTickData.forEach(function(minorTickValue){

                var radian = scale(minorTickValue);

                var point = self._getArcPoint(minorTickR, radian);

                var x, y;
                if(radian < Math.PI){
                    //右边
                    x = point[0];
                    y = point[1];

                }else{
                    //左边
                    x = point[0] - minorTickSize;
                    y = point[1];
                }

                manager.addBounds({
                    x:x,
                    y:y,
                    width:minorTickSize,
                    height:minorTickSize
                });
            });

            return manager;
        },

        //指针仪表盘刻度标签相对于圆心的标签中心的位置
        _getPointerTickCenter:function(tick, labelR, scale){

            var radian = scale(tick.tickValue);

            var joinPoint = this._getArcPoint(labelR, radian);
            var x = joinPoint[0];
            var y = joinPoint[1];

            var tickDim = tick.tickDim;

            var angle = Math.atan(tickDim.width / tickDim.height);

            var labelCenterX, labelCenterY;
            if(Math.abs(radian) < angle){

                var gap = tickDim.height/2;
                labelCenterX = x + gap * x / y;
                labelCenterY = y + gap;

            }else if(radian >= angle && radian <= (Math.PI - angle)){//右

                var gap = tickDim.width/2;
                labelCenterX = x - gap;
                labelCenterY = y - gap * y / x;

            }else if(radian >= angle - Math.PI && radian <= -angle){//左

                var gap = tickDim.width/2;
                labelCenterX = x + gap;
                labelCenterY = y + gap * y / x;

            }else{
                //下
                var gap = tickDim.height/2;
                labelCenterX = x - gap * x / y;
                labelCenterY = y - gap;
            }

            return {
                x:labelCenterX,
                y:labelCenterY
            }

        },

        _fixPointerSemiCenter:function(gauge){

            var radius = gauge.radius;
            var align = gauge.seriesLabel.align;
            if (!gauge.center) {
                var bounds = gauge.bounds;
                var labelHeight = 20 + gauge.seriesLabelDim.height;

                var usedHeight = bounds.height - labelHeight;
                radius = Math.min(bounds.width / 2, usedHeight / 1.14) - DEFAULT_PADDING;

                var centerX = bounds.x + bounds.width / 2;
                var centerY = bounds.y + bounds.height / 2 + radius / 2;

                if (align == Constants.BOTTOM) {

                    if (centerY + 0.14 * radius + labelHeight > bounds.y + bounds.height) {

                        var gap = bounds.height - (radius * 1.14 + labelHeight);

                        if (gap >= 0) {
                            centerY = bounds.y + radius + gap / 2;
                        }
                    }

                } else {

                    if (centerY - radius - labelHeight < bounds.y) {

                        var gap = bounds.height - (radius * 1.14 + labelHeight);

                        if (gap >= 0) {
                            centerY = bounds.y + radius + labelHeight + gap / 2;
                        }

                    }
                }

                gauge.centerX = centerX;
                gauge.centerY = centerY;
                gauge.radius = radius;
            }


            if(gauge.seriesLabelContent){
                var dim = gauge.seriesLabelDim;

                gauge.seriesLabelPos = {
                    x: -dim.width/2,
                    y:align == Constants.BOTTOM ? (radius * 0.14 + 20) : (-radius-20-dim.height)
                }
            }

            if(gauge.valueLabelContent){

                var gaugeAxis = gauge.gaugeAxis;
                var axisOption = gaugeAxis.componentOption;
                var domain = gaugeAxis.scale.domain();
                var scale = d3.scale.linear().domain(domain)
                    .range([BaseUtils.toRadian(-90), BaseUtils.toRadian(90)]);

                var tickHeight = BaseUtils.getTextHeight(axisOption.labelStyle);
                var labelR = (1 - 0.05 - 0.1) * radius;
                var startY = -(labelR  - 2 * tickHeight);
                var endY = -(0.11 * radius + tickHeight/2);

                this._dealValueLabelContent(gauge, radius, scale, startY, endY);
            }


        },

        _dealValueLabelContent:function(gauge, radius, scale, startY, endY){
            var gaugeAxis = gauge.gaugeAxis;
            var axisOption = gaugeAxis.componentOption;
            var tickHeight = BaseUtils.getTextHeight(axisOption.labelStyle);
            var valueLabelStyle = gauge.valueLabel.style;
            var useHtml = gauge.valueLabel.useHtml;
            var valueLabelHeight = BaseUtils.getTextHeight(valueLabelStyle);

            var boundsManager = this._getPointerTickBoundsManager(gaugeAxis, radius, scale, tickHeight);

            var count = gauge.valueLabelContent.length;

            var totalHeight = endY - startY;

            count = Math.min(Math.floor((totalHeight - valueLabelHeight/2)/(3 * valueLabelHeight/2)), count);
            count = Math.max(0, count);

            //只显示count个标签
            gauge.valueLabelContent.length = count;

            var totalHeight = valueLabelHeight * count + (count - 1) * valueLabelHeight/2;

            startY = (endY - startY - totalHeight)/2 + startY;

            var valueBackgroundY = startY - valueLabelHeight/2;
            var valueBackgroundX = Number.MAX_VALUE;

            for(var i = 0; i < count; i++){
                var singleLabel = gauge.valueLabelContent[i];

                var x = -singleLabel.labelDim.width/2;

                var tmpX = Math.min(x - valueLabelHeight/4, valueBackgroundX);

                var tmpBounds = {
                    x:tmpX,
                    y:valueBackgroundY,
                    width:2 * Math.abs(tmpX),
                    height:startY + valueLabelHeight * (1 + LINE_GAP) - valueBackgroundY
                };

                var singleLabelContent = singleLabel.labelContent;
                var hasClipped = false;
                while(boundsManager.isOverlapped(tmpBounds) && singleLabelContent.length){
                    singleLabelContent = singleLabelContent.substr(0, Math.floor(singleLabelContent.length * 0.9));
                    var tmpDim = BaseUtils.getTextDimension(singleLabelContent + '...', valueLabelStyle, useHtml);
                    x = -tmpDim.width/2;

                    tmpX = Math.min(x - valueLabelHeight/4, valueBackgroundX);

                    tmpBounds = {
                        x:tmpX,
                        y:valueBackgroundY,
                        width:2 * Math.abs(tmpX),
                        height:startY + valueLabelHeight * (1 + LINE_GAP) - valueBackgroundY
                    };

                    hasClipped = true;
                }

                if(hasClipped){
                    singleLabel.labelContent = singleLabelContent + '...';
                    singleLabel.labelDim = BaseUtils.getTextDimension(singleLabel.labelContent, valueLabelStyle, useHtml);
                    x = -singleLabel.labelDim.width/2;
                    tmpX = Math.min(x - valueLabelHeight/4, valueBackgroundX);
                }

                singleLabel.labelPos = {
                    x:x,
                    y:startY
                };

                startY += valueLabelHeight * (1 + LINE_GAP);

                valueBackgroundX = tmpX;
            }

            gauge.valueLabelBackground = {
                x:valueBackgroundX,
                y:valueBackgroundY,
                width:2 * Math.abs(valueBackgroundX),
                height:totalHeight + valueLabelHeight
            };
        },

        _fixSlotCenter:function(gauge){

            if (!gauge.center) {
                var bounds = gauge.bounds;

                var radius = Math.min(bounds.width / 2, bounds.height / 2);

                //刻度槽的宽度是0.16倍的半径
                radius = radius / 1.08 - DEFAULT_PADDING;

                var centerX = bounds.x + bounds.width / 2;
                var centerY = bounds.y + bounds.height / 2;

                gauge.centerX = centerX;
                gauge.centerY = centerY;
                gauge.radius = radius;
            }

            if(gauge.percentageLabelContent && gauge.valueLabelContent){

                gauge.percentageLabelPos = {
                    x:-gauge.percentageLabelDim.width/2,
                    y:-gauge.percentageLabelDim.height * (1 + LINE_GAP)
                };

                var startY = 0;
                for(var i = 0, count = gauge.valueLabelContent.length; i < count; i++){

                    var valueLabel = gauge.valueLabelContent[i];

                    valueLabel.labelPos = {
                        x:-valueLabel.labelDim.width/2,
                        y:startY
                    };

                    startY += (valueLabel.labelDim.height * (1 + LINE_GAP))
                }

            }else if(gauge.percentageLabelContent){

                gauge.percentageLabelPos = {
                    x:-gauge.percentageLabelDim.width/2,
                    y:-gauge.percentageLabelDim.height/2
                };

            }else if(gauge.valueLabelContent){

                var labelHeight = BaseUtils.getTextHeight(gauge.valueLabel.style);
                var labelCount = gauge.valueLabelContent.length;

                var totalHeight = labelHeight * labelCount + labelHeight * (labelCount - 1) / 2;

                var startY = - totalHeight / 2;

                for(var i = 0; i < labelCount; i++){

                    var valueLabel = gauge.valueLabelContent[i];

                    valueLabel.labelPos = {
                        x:-valueLabel.labelDim.width/2,
                        y:startY
                    };
                    startY += (labelHeight * (1 + LINE_GAP));
                }
            }

        },

        _fixThermometerCenter:function(gauge){

            var para = gauge.thermometerLayout == Constants.HORIZONTAL_LAYOUT ?
                this._fixHorizontalThermometerCenter(gauge) : this._fixVerticalThermometerCenter(gauge);

            var centerX = para.centerX;
            var centerY = para.centerY;
            var radius = para.radius;
            var showValueLabel = gauge.valueLabelContent ? gauge.valueLabelContent[0] : null;

            if(gauge.percentageLabelContent){
                gauge.percentageLabelPos.x -= centerX;
                gauge.percentageLabelPos.y -= centerY;

                //与底边对齐
                gauge.percentageLabelPos.y = Math.min(gauge.percentageLabelPos.y, radius - gauge.percentageLabelDim.height);
            }

            if(showValueLabel){
                showValueLabel.labelPos.x -= centerX;
                showValueLabel.labelPos.y -= centerY;

                var gap = (radius - showValueLabel.labelDim.height) - showValueLabel.labelPos.y;

                //与底边对齐
                if(gap < 0){
                    showValueLabel.labelPos.y += gap;

                    if(gauge.percentageLabelContent){
                        gauge.percentageLabelPos.y += gap;
                    }
                }
            }

            gauge.centerX = centerX;
            gauge.centerY = centerY;
            gauge.radius = radius;
        },

        _fixHorizontalThermometerCenter:function(gauge){

            var centerX, centerY, radius;
            var gaugeAxis = gauge.gaugeAxis;
            var percentageLabel = gauge.percentageLabel;
            var valueLabel = gauge.valueLabel;
            var showValueLabel = gauge.valueLabelContent ? gauge.valueLabelContent[0] : null;

            var totalHeight = this._getThermometerSize(gauge);
            var startY;

            if (gauge.center) {
                centerX = gauge.centerX;
                centerY = gauge.centerY;
                radius = gauge.radius;
                startY = centerY;

            } else {
                var bounds = gauge.bounds;
                startY = bounds.y + (bounds.height - totalHeight)/2;
                centerX = bounds.x + bounds.width/2;
                radius = bounds.width/2 - gaugeAxis.getMaxTickWidth() - DEFAULT_PADDING;
            }

            if(gauge.percentageLabelContent || showValueLabel){
                if(gauge.percentageLabelContent && showValueLabel
                    && percentageLabel.align == Constants.TOP && valueLabel.align == Constants.TOP){

                    if (gauge.center) {
                        startY -= (gauge.percentageLabelDim.height * (1 + LINE_GAP));
                        startY -= (showValueLabel.labelDim.height * (1 + HORIZONTAL_GAP));
                        startY -= (gaugeAxis.getTickHeight() + TICK_LABEL_GAP + TICK_SIZE + TICK_LABEL_GAP + THERMOMETER_R);
                    }

                    gauge.percentageLabelPos = {
                        x: -gauge.percentageLabelDim.width/2 + centerX,
                        y:startY
                    };

                    startY += (gauge.percentageLabelDim.height * (1 + LINE_GAP));

                    showValueLabel.labelPos = {
                        x: -showValueLabel.labelDim.width/2 + centerX,
                        y:startY
                    };

                    startY += (showValueLabel.labelDim.height * (1 + HORIZONTAL_GAP));


                }else{

                    if(gauge.percentageLabelContent && percentageLabel.align == Constants.TOP){

                        if (gauge.center) {
                            startY -= (gauge.percentageLabelDim.height * (1 + HORIZONTAL_GAP));
                            startY -= (gaugeAxis.getTickHeight() + TICK_LABEL_GAP + TICK_SIZE + TICK_LABEL_GAP + THERMOMETER_R);
                        }

                        gauge.percentageLabelPos = {
                            x: -gauge.percentageLabelDim.width/2 + centerX,
                            y:startY
                        };

                        startY += (gauge.percentageLabelDim.height * (1 + HORIZONTAL_GAP));
                    }

                    if(showValueLabel && valueLabel.align == Constants.TOP){

                        if (gauge.center) {
                            startY -= (showValueLabel.labelDim.height * (1 + HORIZONTAL_GAP));
                            startY -= (gaugeAxis.getTickHeight() + TICK_LABEL_GAP + TICK_SIZE + TICK_LABEL_GAP + THERMOMETER_R);
                        }

                        showValueLabel.labelPos = {
                            x: -showValueLabel.labelDim.width/2 + centerX,
                            y:startY
                        };

                        startY += (showValueLabel.labelDim.height * (1 + HORIZONTAL_GAP));
                    }
                }
            }

            if (gauge.center) {
                startY = centerY + 5;
            } else {
                startY += (gaugeAxis.getTickHeight() + TICK_LABEL_GAP + TICK_SIZE + TICK_LABEL_GAP + THERMOMETER_R * 2);
                centerY = startY - 5;
            }

            if(gauge.percentageLabelContent || showValueLabel){

                if(gauge.percentageLabelContent && showValueLabel
                    && percentageLabel.align == Constants.BOTTOM && valueLabel.align == Constants.BOTTOM){
                    startY += (gauge.percentageLabelDim.height * HORIZONTAL_GAP);

                    gauge.percentageLabelPos = {
                        x: -gauge.percentageLabelDim.width/2 + centerX,
                        y:startY
                    };

                    startY += (gauge.percentageLabelDim.height * (1 + LINE_GAP));

                    showValueLabel.labelPos = {
                        x: -showValueLabel.labelDim.width/2 + centerX,
                        y:startY
                    };

                }else{

                    if(gauge.percentageLabelContent && percentageLabel.align == Constants.BOTTOM){

                        startY += (gauge.percentageLabelDim.height * HORIZONTAL_GAP);

                        gauge.percentageLabelPos = {
                            x: -gauge.percentageLabelDim.width/2 + centerX,
                            y:startY
                        };

                    }

                    if(showValueLabel && valueLabel.align == Constants.BOTTOM){

                        startY += (showValueLabel.labelDim.height * HORIZONTAL_GAP);

                        showValueLabel.labelPos = {
                            x: -showValueLabel.labelDim.width/2 + centerX,
                            y:startY
                        };

                    }
                }

            }

            return {
                centerX:centerX,
                centerY:centerY,
                radius:radius
            }
        },

        _fixVerticalThermometerCenter:function(gauge){

            var centerX, centerY, radius;

            var percentageLabel = gauge.percentageLabel;
            var valueLabel = gauge.valueLabel;
            var gaugeAxis = gauge.gaugeAxis;

            var point = gauge.points[0] || {};
            var domain = gaugeAxis.scale.domain();
            var showValueLabel = gauge.valueLabelContent ? gauge.valueLabelContent[0] : null;

            //纵向布局
            var totalWidth = this._getThermometerSize(gauge);
            var startX;

            if (gauge.center) {
                centerX = gauge.centerX;
                centerY = gauge.centerY;
                radius = gauge.radius;
                startX = centerX - THERMOMETER_R * 2;

            } else {
                var bounds = gauge.bounds;
                startX = bounds.x + (bounds.width - totalWidth)/2;
                centerY = bounds.y + bounds.height/2;
                radius = bounds.height/2 - gaugeAxis.getTickHeight() - DEFAULT_PADDING;
            }

            var scale = d3.scale.linear().domain(domain).range([radius, -radius]);
            var labelY = centerY + scale(point.valueInDomain);

            if(gauge.percentageLabelDim){
                labelY -= gauge.percentageLabelDim.height/3;//差不多居中的位置
            }

            if(gauge.percentageLabelContent || showValueLabel){

                if(gauge.percentageLabelContent && showValueLabel
                    && percentageLabel.align == Constants.LEFT && valueLabel.align == Constants.LEFT){

                    if (!gauge.center) {
                        startX += Math.max(gauge.percentageLabelDim.width, showValueLabel.labelDim.width);
                        centerX = startX + THERMOMETER_R;
                    }

                    gauge.percentageLabelPos = {
                        x:startX - gauge.percentageLabelDim.width,
                        y:labelY
                    };

                    showValueLabel.labelPos = {
                        x:startX - showValueLabel.labelDim.width,
                        y:labelY + gauge.percentageLabelDim.height * (1 + LINE_GAP)
                    };

                    startX += LINE_GAP * Math.max(gauge.percentageLabelDim.height, showValueLabel.labelDim.height);

                }else{

                    if(gauge.percentageLabelContent && percentageLabel.align == Constants.LEFT){

                        if (gauge.center) {
                            startX -= (gauge.percentageLabelDim.width + LINE_GAP * gauge.percentageLabelDim.height);
                        }

                        gauge.percentageLabelPos = {
                            x:startX,
                            y:labelY
                        };

                        startX += (gauge.percentageLabelDim.width + LINE_GAP * gauge.percentageLabelDim.height);
                    }

                    if(showValueLabel && valueLabel.align == Constants.LEFT){

                        if (gauge.center) {
                            startX -= (showValueLabel.labelDim.width + LINE_GAP * showValueLabel.labelDim.height);
                        }

                        showValueLabel.labelPos = {
                            x:startX,
                            y:labelY
                        };

                        startX += (showValueLabel.labelDim.width + LINE_GAP * showValueLabel.labelDim.height);
                    }
                }
            }

            if (gauge.center) {
                startX = centerX - THERMOMETER_R;
            } else {
                centerX = startX + THERMOMETER_R;
            }

            startX += (THERMOMETER_R * 2 + TICK_LABEL_GAP + TICK_SIZE + TICK_LABEL_GAP + gaugeAxis.getMaxTickWidth());

            if(gauge.percentageLabelContent || showValueLabel){
                if(gauge.percentageLabelContent && showValueLabel
                    && percentageLabel.align == Constants.RIGHT && valueLabel.align == Constants.RIGHT){

                    startX += LINE_GAP * Math.max(gauge.percentageLabelDim.height, showValueLabel.labelDim.height);

                    gauge.percentageLabelPos = {
                        x:startX,
                        y:labelY
                    };

                    showValueLabel.labelPos = {
                        x:startX,
                        y:labelY + gauge.percentageLabelDim.height * (1 + LINE_GAP)
                    };

                }else{

                    if(gauge.percentageLabelContent && percentageLabel.align == Constants.RIGHT){
                        gauge.percentageLabelPos = {
                            x:startX + LINE_GAP * gauge.percentageLabelDim.height,
                            y:labelY
                        };
                    }

                    if(showValueLabel && valueLabel.align == Constants.RIGHT){

                        showValueLabel.labelPos = {
                            x:startX + LINE_GAP * showValueLabel.labelDim.height,
                            y:labelY
                        };

                    }
                }
            }

            return {
                centerX:centerX,
                centerY:centerY,
                radius:radius
            }
        },

        _fixRingCenter:function(gauge){

            if (!gauge.center) {
                var bounds = gauge.bounds;
                var radius = Math.min(bounds.width/2, bounds.height/2) - DEFAULT_PADDING;
                var centerX = bounds.x + bounds.width/2;
                var centerY = bounds.y + bounds.height/2;

                gauge.centerX = centerX;
                gauge.centerY = centerY;
                gauge.radius = radius;
            }

            var totalHeight = 0;
            var valueLabel = gauge.valueLabelContent ? gauge.valueLabelContent[0] : null;
            if(gauge.percentageLabelContent && valueLabel){
                totalHeight = gauge.percentageLabelDim.height * (1 + LINE_GAP) + valueLabel.labelDim.height;
            }else if(gauge.percentageLabelContent){
                totalHeight = gauge.percentageLabelDim.height;
            }else if(valueLabel){
                totalHeight = valueLabel.labelDim.height;
            }

            var startY = -totalHeight/2;

            if(gauge.percentageLabelContent){
                gauge.percentageLabelPos = {
                    x: -gauge.percentageLabelDim.width/2,
                    y:startY
                };

                startY += gauge.percentageLabelDim.height * (1 + LINE_GAP);
            }

            if(valueLabel){
                valueLabel.labelPos = {
                    x:-valueLabel.labelDim.width/2,
                    y:startY
                };
            }
        },

        _dealHorizontalLayout:function(){

            //先要判断是否都是纵向布局的试管,是的话平均分
            var isEqualThermometer = true;

            var usedSize = 0;
            var fixedSize = 0;

            var gaugeData = this.getVisibleChartData();

            gaugeData.forEach(function(singleGauge){
                if(!singleGauge.center){

                    if(singleGauge.style != Constants.GAUGE_THERMOMETER
                        || singleGauge.thermometerLayout == Constants.HORIZONTAL_LAYOUT){

                        if(singleGauge.radius){
                            usedSize += (singleGauge.radius * 2);
                            fixedSize++;
                        }else{
                            isEqualThermometer = false;
                        }

                    }

                }
            });

            if(!isEqualThermometer){
                var self = this;
                gaugeData.forEach(function(singleGauge){

                    if(!singleGauge.center
                        && singleGauge.style == Constants.GAUGE_THERMOMETER
                        && singleGauge.thermometerLayout == Constants.VERTICAL_LAYOUT){

                        usedSize += (self._getThermometerSize(singleGauge));
                        fixedSize ++;

                    }
                });
            }

            //平均半径
            var plotBounds = this.vanchart.getPlotBounds();
            var averageRadius = plotBounds.width / Math.max(1, gaugeData.length - fixedSize);
            averageRadius /= 2;

            var leftBounds = {
                x:0,
                y:0,
                width:plotBounds.width,
                height:plotBounds.height
            };

            for(var i = 0, len = gaugeData.length; i < len; i++){

                var singleGauge = gaugeData[i];

                if(!singleGauge.center){

                    var size = 0;

                    if(singleGauge.style == Constants.GAUGE_THERMOMETER){

                        if(singleGauge.thermometerLayout == Constants.HORIZONTAL_LAYOUT){

                            size = (singleGauge.radius || averageRadius) * 2;

                            singleGauge.bounds = {
                                x:leftBounds.x,
                                y:leftBounds.y,
                                width:size,
                                height:leftBounds.height
                            };

                            leftBounds.x += size;
                            leftBounds.width -= size;

                        }else{

                            if(isEqualThermometer){
                                size = averageRadius * 2;
                            }else{
                                size = this._getThermometerSize(singleGauge);
                            }

                            var height = singleGauge.radius ? singleGauge.radius * 2 : leftBounds.height;

                            height = Math.min(height, leftBounds.height);

                            singleGauge.bounds = {
                                x:leftBounds.x,
                                y:leftBounds.y,
                                width:size,
                                height:height
                            };

                            leftBounds.x += size;
                            leftBounds.width -= size;
                        }

                    }else{

                        size = (singleGauge.radius || averageRadius) * 2;

                        singleGauge.bounds = {
                            x:leftBounds.x,
                            y:leftBounds.y,
                            width:size,
                            height:leftBounds.height
                        };

                        leftBounds.x += size;
                        leftBounds.width -= size;
                    }
                }
            }
        },

        _dealVerticalLayout:function(){

            var isEqualThermometer = true;

            var usedSize = 0;
            var fixedSize = 0;

            var gaugeData = this.getVisibleChartData();

            gaugeData.forEach(function(singleGauge){
                if(!singleGauge.center){

                    if(singleGauge.style != Constants.GAUGE_THERMOMETER
                        || singleGauge.thermometerLayout == Constants.VERTICAL_LAYOUT){

                        if(singleGauge.radius){
                            usedSize += (singleGauge.radius * 2);
                            fixedSize++;
                        }else{
                            isEqualThermometer = false;
                        }

                    }

                }
            });

            if(!isEqualThermometer){
                var self = this;
                gaugeData.forEach(function(singleGauge){

                    if(!singleGauge.center
                        && singleGauge.style == Constants.GAUGE_THERMOMETER
                        && singleGauge.thermometerLayout == Constants.HORIZONTAL_LAYOUT){

                        usedSize += (self._getThermometerSize(singleGauge));
                        fixedSize ++;
                    }
                });
            }

            //平均半径
            var plotBounds = this.vanchart.getPlotBounds();
            var averageRadius = plotBounds.height / Math.max(1, gaugeData.length - fixedSize);
            averageRadius /= 2;

            var leftBounds = {
                x:0,
                y:0,
                width:plotBounds.width,
                height:plotBounds.height
            };

            for(var i = 0, len = gaugeData.length; i < len; i++){

                var singleGauge = gaugeData[i];

                if(!singleGauge.center){

                    var size = 0;

                    if(singleGauge.style == Constants.GAUGE_THERMOMETER){

                        if(singleGauge.thermometerLayout == Constants.VERTICAL_LAYOUT){

                            size = (singleGauge.radius || averageRadius) * 2;

                            singleGauge.bounds = {
                                x:leftBounds.x,
                                y:leftBounds.y,
                                width:leftBounds.width,
                                height:size
                            };

                            leftBounds.y += size;
                            leftBounds.height -= size;

                        }else{

                            if(isEqualThermometer){
                                size = averageRadius * 2;
                            }else{
                                size = this._getThermometerSize(singleGauge);
                            }

                            var width = singleGauge.radius ? singleGauge.radius * 2 : leftBounds.width;

                            width = Math.min(width, leftBounds.width);

                            singleGauge.bounds = {
                                x:leftBounds.x,
                                y:leftBounds.y,
                                width:width,
                                height:size
                            };

                            leftBounds.y += size;
                            leftBounds.height -= size;
                        }

                    }else{

                        size = (singleGauge.radius || averageRadius) * 2;

                        singleGauge.bounds = {
                            x:leftBounds.x,
                            y:leftBounds.y,
                            width:leftBounds.width,
                            height:size
                        };

                        leftBounds.y += size;
                        leftBounds.height -= size;
                    }
                }
            }

        },

        //试管仪表盘占据的大小,不算间隔
        _getThermometerSize:function(gauge){

            var showValueLabel = gauge.valueLabelContent ? gauge.valueLabelContent[0] : null;
            var percentageLabel = gauge.percentageLabel;
            var valueLabel = gauge.valueLabel;
            var gaugeAxis = gauge.gaugeAxis;

            if(gauge.thermometerLayout == Constants.HORIZONTAL_LAYOUT){

                var totalHeight = 0;

                if(gauge.percentageLabelContent && showValueLabel){
                    if(percentageLabel.align == valueLabel.align){
                        totalHeight += (gauge.percentageLabelDim.height + showValueLabel.labelDim.height);
                        totalHeight += LINE_GAP * gauge.percentageLabelDim.height;

                        totalHeight += HORIZONTAL_GAP * (valueLabel.align == Constants.TOP
                                ? showValueLabel.labelDim.height : gauge.percentageLabelDim.height);
                    }
                }else if(gauge.percentageLabelContent){
                    totalHeight += (1 + HORIZONTAL_GAP) * gauge.percentageLabelDim.height;
                }else if(showValueLabel){
                    totalHeight += (1 + HORIZONTAL_GAP) * showValueLabel.labelDim.height;
                }

                totalHeight += (THERMOMETER_R * 2 + TICK_LABEL_GAP + TICK_SIZE + TICK_LABEL_GAP + gaugeAxis.getTickHeight());

                return totalHeight;

            }else{

                var totalWidth = 0;
                if(gauge.percentageLabelContent && showValueLabel){
                    if(percentageLabel.align == valueLabel.align){
                        totalWidth += Math.max(gauge.percentageLabelDim.width, showValueLabel.labelDim.width);
                        totalWidth += VERTICAL_GAP * Math.max(gauge.percentageLabelDim.height, showValueLabel.labelDim.height);
                    }else{
                        totalWidth += (gauge.percentageLabelDim.width + showValueLabel.labelDim.width);
                        totalWidth += VERTICAL_GAP * (gauge.percentageLabelDim.height + showValueLabel.labelDim.height);
                    }
                }else if(gauge.percentageLabelContent){
                    totalWidth += (gauge.percentageLabelDim.width + VERTICAL_GAP * gauge.percentageLabelDim.height);
                }else if(showValueLabel){
                    totalWidth += (showValueLabel.labelDim.width + VERTICAL_GAP * showValueLabel.labelDim.height);
                }

                totalWidth += gaugeAxis.getMaxTickWidth();

                totalWidth += (THERMOMETER_R * 2 + TICK_LABEL_GAP + TICK_SIZE + TICK_LABEL_GAP);

                return totalWidth;
            }

            return DEFAULT_RADIUS;
        },

        _getFixedPos:function(datum, divDim){

            var gauge = datum.series || datum;

            var style = gauge.style;
            var thermometerLayout = gauge.thermometerLayout;

            var plotBounds = this.getPlotBounds();

            switch (style){
                case Constants.GAUGE_POINTER:
                case Constants.GAUGE_SLOT:
                case Constants.GAUGE_RING:

                    var x = plotBounds.x + gauge.centerX + gauge.radius + 10;
                    var y = plotBounds.y + gauge.centerY - divDim.height/2;

                    return [x, y];

                case Constants.GAUGE_POINTER_SEMI:
                    var x = plotBounds.x + gauge.centerX - divDim.width/2;
                    var y = plotBounds.y + gauge.centerY + 0.14 * gauge.radius + 10;

                    return [x, y];
                case Constants.GAUGE_THERMOMETER:

                    var x, y;

                    if(thermometerLayout == Constants.HORIZONTAL_LAYOUT){
                        x = plotBounds.x + gauge.centerX - divDim.width/2;
                        var baseY = plotBounds.y + gauge.centerY;
                        y = baseY + THERMOMETER_R + 10;

                        if(gauge.percentageLabelContent && gauge.percentageLabel.align == Constants.BOTTOM){
                            y = baseY + gauge.percentageLabelPos.y + gauge.percentageLabelDim.height + 10;
                        }

                        if(gauge.valueLabelContent && gauge.valueLabel.align == Constants.BOTTOM){
                            var valueLabel = gauge.valueLabelContent[0];
                            y = baseY + valueLabel.labelPos.y + valueLabel.labelDim.height + 10;
                        }

                    }else{

                        y = plotBounds.y + gauge.centerY - divDim.height/2;

                        var tickWidth = gauge.gaugeAxis.getMaxTickWidth();

                        var baseX = plotBounds.x + gauge.centerX;
                        x = baseX + THERMOMETER_R + TICK_LABEL_GAP + TICK_SIZE + TICK_LABEL_GAP + tickWidth + 10;

                        if(gauge.percentageLabelContent && gauge.percentageLabel.align == Constants.RIGHT){

                            x = baseX + gauge.percentageLabelPos.x + gauge.percentageLabelDim.width + 10;
                        }

                        if(gauge.valueLabelContent && gauge.valueLabel.align == Constants.RIGHT){
                            var valueLabel = gauge.valueLabelContent[0];
                            x = Math.max(x, baseX + valueLabel.labelPos.x + valueLabel.labelDim.width + 10)
                        }
                    }

                    return [x, y];
            }
        },

        getClosestPoint:function(){
            var hoverSeries = this.vanchart.hoverSeries;
            if(hoverSeries
                && hoverSeries.style != Constants.GAUGE_POINTER
                && hoverSeries.style != Constants.GAUGE_POINTER_SEMI){
                return hoverSeries.points[0];
            }

        }
    });

    require('../ChartLibrary').register(Constants.GAUGE_CHART, Gauge);
    return Gauge;
});
/**
 * Created by eason on 15/12/31.
 */
define('chart/Radar',['require','./BaseChart','../utils/BaseUtils','../Constants','../utils/QueryUtils','../utils/BoundsManager','../theme/options','../ChartLibrary'],function(require){

    var BaseChart = require('./BaseChart');
    var BaseUtils = require('../utils/BaseUtils');
    var Constants = require('../Constants');
    var QueryUtils = require('../utils/QueryUtils');
    var BoundsManager = require('../utils/BoundsManager');
    var Options = require('../theme/options');

    var DELAY = 200;
    var PADDING_GAP = 10;
    var LABEL_BORDER_GAP = 8;

    var TOP = 'radar-top';
    var BOTTOM = 'radar-bottom';
    var LEFT = 'radar-left';
    var RIGHT = 'radar-right';

    var Radar = BaseChart.extend({
        constructor:Radar,

        doLayout:function(){

            var locations2Series = this._buildLocationMap();

            for(var location in locations2Series){

                var location2Series = locations2Series[location];

                for(var i = location2Series.length - 1; i >= 0; i--) {

                    var sameAxisSeries = location2Series[i];

                    if(sameAxisSeries && sameAxisSeries.length) {

                        this._buildRadarSeries(sameAxisSeries);

                    }
                }
            }

        },

        mergeDataPointAttributes:function(point){
            this._mergeMarkerAttributes(point);
            point.columnType = this.isColumnType();
        },

        mergeSeriesAttributes:function(series){

            var queryList = [
                series.seriesOption,
                this.option.plotOptions[series.type],
                this.option.plotOptions,
                Options[series.type].plotOptions
            ];

            var columnType = QueryUtils.queryList(queryList, 'columnType');

            this.columnType = columnType;

            var connectNulls = BaseUtils.pick(QueryUtils.queryList(queryList, 'connectNulls'), true);

            var lineWidth = QueryUtils.queryList(queryList, 'lineWidth') || 0;

            var fillColor = QueryUtils.queryList(queryList, 'fillColor');
            var lineColor = QueryUtils.queryList(queryList, 'color') || this._getDefaultSeriesColor(series.name);

            fillColor = fillColor ? (fillColor === true ? lineColor : fillColor) : '';

            var fillColorOpacity = BaseUtils.pick(QueryUtils.queryList(queryList, 'fillColorOpacity'), (columnType ? 1 : 0.15)) ;

            var className = series.className + (columnType ? 'column' : 'polygon') ;

            if (columnType) {
                series.marker = null;
            }

            BaseUtils.extend(series,{
                className:className,
                lineWidth:lineWidth,
                lineColor:lineColor,
                columnType:columnType,
                connectNulls:connectNulls,
                fillColor:fillColor,
                fillColorOpacity:fillColorOpacity
            });
        },

        _buildRadarSeries:function(locationMap){

            // this._calculateCategoryBasedPercentageAndTooltip(locationMap);

            var tSery = locationMap[0][0];
            var radiusAxis = tSery.radiusAxis;
            var angleAxis = tSery.angleAxis;

            this.baseAxis = angleAxis;
            this.valueAxis = radiusAxis;
            this.cateScale = angleAxis.scale;
            this.valueScale = radiusAxis.scale;
            this.center = radiusAxis.polar.center;
            this.radius = radiusAxis.polar.radius;
            this.piece = angleAxis.piece;

            var self = this;

            for(var i = 0, count = locationMap.length; i < count; i++){
                var stackedSeries = locationMap[i];

                stackedSeries.forEach(function(series){

                    //先排序
                    series.points.sort(function(pointA, pointB){
                        return self.cateScale(pointA.category) - self.cateScale(pointB.category);
                    });

                    series.points.forEach(function(point){
                        var preSum = point.y0;

                        point.y0 = self.valueScale(preSum);

                        point.y = self.valueScale(point.y + preSum);

                        point.radian = self.cateScale(point.category) * self.piece;

                        point.pos = self._getArcPoint(point.y, point.radian);

                        if(point.dataLabels && point.dataLabels.enabled){
                            series.columnType ? self._calculateColumnTypeLabelPos(point) : self._calculatePolygonTypeLabelPos(point);
                        }
                    });

                    series.pathSegment = self._getPathSegment(series.points, series.connectNulls);
                });
            }
        },

        _calculateColumnTypeLabelPos:function(point){

            var position = this._getRadarPosition(point.category);
            var pos = this._getArcPoint(point.y - LABEL_BORDER_GAP, point.radian);
            var labelDim = point.labelDim;

            switch (position){
                case TOP:

                    point.labelPos = {
                        x:-labelDim.width/2,
                        y:pos[1]
                    };

                    break;

                case RIGHT:

                    point.labelPos = {
                        x:pos[0] - labelDim.width,
                        y:pos[1] - labelDim.height/2
                    };
                    break;

                case BOTTOM:

                    point.labelPos = {
                        x:-labelDim.width/2,
                        y:pos[1] - labelDim.height
                    };

                    break;

                case LEFT:

                    point.labelPos = {
                        x:pos[0],
                        y:pos[1] - labelDim.height/2
                    };

                    break
            }
        },

        _calculatePolygonTypeLabelPos:function(point){

            var position = this._getRadarPosition(point.category);
            var pos = this._getArcPoint(point.y + LABEL_BORDER_GAP, point.radian);
            var labelDim = point.labelDim;

            switch (position){
                case TOP:

                    point.labelPos = {
                        x:-labelDim.width/2,
                        y:pos[1] - labelDim.height
                    };

                    break;

                case RIGHT:

                    point.labelPos = {
                        x:pos[0],
                        y:pos[1] - labelDim.height/2
                    };
                    break;

                case BOTTOM:

                    point.labelPos = {
                        x:-labelDim.width/2,
                        y:pos[1]
                    };

                    break;

                case LEFT:

                    point.labelPos = {
                        x:pos[0] - labelDim.width,
                        y:pos[1] - labelDim.height/2
                    };

                    break
            }

        },

        _getRadarColumnPath:function(innerRadius, radius, radian){

            var halfSize = this.piece * 0.375;

            var startRadian = radian - halfSize;

            var endRadian = radian + halfSize;

            var arc = d3.svg.arc()
                .innerRadius(innerRadius).outerRadius(radius)
                .startAngle(startRadian).endAngle(endRadian);

            return arc();
        },

        _getPathSegment:function(dataPoints, connectNulls){

            var pathSeg = [];

            var tmp = [];

            if(connectNulls){

                pathSeg.push(tmp);

                dataPoints.forEach(function(dataPoint){

                    if(!dataPoint.isNull){
                        tmp.push(dataPoint.pos);
                    }

                });
            }else{

                var startIndex = 0;
                var count = dataPoints.length;

                for(var index = count - 1; index > 0; index--){

                    var current = dataPoints[index];
                    var pre = dataPoints[index - 1];

                    if(!current.isNull && pre.isNull){
                        startIndex = index;
                    }
                }

                for(var index = 0; index < count; index++){

                    var dataPoint = dataPoints[(index + startIndex) % count];

                    if(dataPoint.isNull && tmp.length){

                        if(tmp.length > 1){
                            pathSeg.push(tmp)
                        };

                        tmp = [];
                    }else{
                        tmp.push(dataPoint.pos);
                    }

                }

                if(tmp.length){
                    pathSeg.push(tmp);
                }
            }

            return pathSeg;
        },

        _getRadarSeriesFillPath:function(pathSeg, connectNulls){
            return this._getRadarSeriesPath(pathSeg, connectNulls, true);
        },

        _getRadarSeriesStrokePath:function(pathSeg, connectNulls){
            return this._getRadarSeriesPath(pathSeg, connectNulls, false);
        },

        _getRadarSeriesPath:function(pathSeg, connectNulls, toCenter){

            var path = '';
            var tmp = [];
            if(pathSeg.length == 1){

                tmp = pathSeg[0];

                var fullShape = tmp.length == this.baseAxis.getCategoryCount() || connectNulls;

                toCenter = (!fullShape && toCenter);

                path = toCenter ? 'M0,0' : '';

                for(var i = 0, count = tmp.length; i < count; i++){

                    var mOrl = (i || toCenter) ? 'L' : 'M';

                    path += (mOrl + BaseUtils.dealFloatPrecision(tmp[i][0]) + "," + BaseUtils.dealFloatPrecision(tmp[i][1]));
                }

                path += (fullShape || toCenter) ? 'Z' : '';

            }else{
                pathSeg.forEach(function(tmp){

                    path += toCenter ? 'M0,0' : '';

                    tmp.forEach(function(pos){
                        path += ('L' + BaseUtils.dealFloatPrecision(pos[0]) + "," + BaseUtils.dealFloatPrecision(pos[1]));
                    });

                    path += toCenter ? 'Z' : '';
                });
            }

            return path;
        },

        _getRadarPosition:function(category){

            var index = this.cateScale(category);
            var domain = this.cateScale.domain();
            var midIndex = domain.length / 2;

            if(index == 0){
                return TOP;
            }else if(index > 0 && index < midIndex){
                return RIGHT;
            }else if(index == midIndex){
                return BOTTOM;
            }else if(index > midIndex){
                return LEFT;
            }

        },

        getRadarCenter:function(){
            return this.center;
        },

        getBaseAxis:function(){
            return this.baseAxis;
        },

        getValueAxis:function(){
            return this.valueAxis;
        },

        isColumnType:function(){
            return this.columnType;
        },

        getInitRadius:function(){
            return this.valueScale(this.valueAxis.getStartPosValue());
        },

        _getInitPathSegment:function(pathSeg){
            var init = [];
            pathSeg.forEach(function(seg){
                var tmp = [];
                init.push(tmp);

                seg.forEach(function(){
                    tmp.push([0,0])
                })
            });

            return init;
        },

        _getFixedPos:function(datum, divDim){

            var x, y;

            if(datum.columnType){

                var radius = datum.y;
                var centerAngle = datum.radian;

                x = radius * Math.sin(centerAngle) + this.center[0];
                y = radius * Math.cos(centerAngle + Math.PI) + this.center[1];

                if(centerAngle < Math.PI / 2){
                    y -= divDim.height;
                }else if(centerAngle >= Math.PI && centerAngle < 3 * Math.PI / 2){
                    x -= divDim.width;
                }else if(centerAngle >= 3 * Math.PI / 2 && centerAngle < Math.PI * 2){
                    y -= divDim.height;
                    x -= divDim.width;
                }

            }else{
                var radius = datum.marker.radius || this.getDefaultMarkerRadius();
                x = this.center[0] + datum.pos[0] + radius;
                y = this.center[1] + datum.pos[1] + radius;
            }

            return [x, y];
        },

        getClosestPoint:function(pos){

            if(this.isColumnType()){
                return;
            }

            var selectedPoint;
            var minDistance = Number.MAX_VALUE;
            var lineData = this.vanchart.hoverSeries;
            var center = this.center;

            if(lineData){
                lineData.points.forEach(function(point){

                    var markerPos = point.pos;

                    var detX = markerPos[0] + center[0] - pos[0];
                    var detY = markerPos[1] + center[1] - pos[1];
                    var dis = Math.sqrt(detX * detX + detY * detY);

                    if(dis < minDistance && !point.isNull){
                        selectedPoint = point;
                        minDistance = dis;
                    }
                });
            }else{
                var series = this.vanchart.series;

                series.forEach(function(sery){

                    if(sery.points){
                        sery.points.forEach(function(point){

                            var markerPos = point.pos;

                            var detX = markerPos[0] + center[0] - pos[0];
                            var detY = markerPos[1] + center[1] - pos[1];
                            var dis = Math.sqrt(detX * detX + detY * detY);

                            if(dis < minDistance && !point.isNull){
                                selectedPoint = point;
                                minDistance = dis;
                            }
                        });
                    }
                });
            }

            return selectedPoint;
        }
    });

    require('../ChartLibrary').register(Constants.RADAR_CHART, Radar);
    
    return Radar;
});
/**
 * Created by Mitisky on 16/3/14.
 */
define('chart/Bubble',['require','./BaseChart','../utils/BaseUtils','../Constants','../utils/QueryUtils','../utils/ColorUtils','../theme/options','../ChartLibrary'],function(require){
    var BaseChart = require('./BaseChart');
    var BaseUtils = require('../utils/BaseUtils');
    var Constants = require('../Constants');
    var QueryUtils = require('../utils/QueryUtils');
    var ColorUtils = require('../utils/ColorUtils');
    var Options = require('../theme/options');

    var DEFAULT_BUBBLE_ALPHA = 0.7;
    var BUBBLES_SHOW_TIME = 800;
    var NEGATIVE_COLOR = 'rgb(138, 138, 138)';

    var Bubble = BaseChart.extend({
        type:Constants.BUBBLE_CHART,
        doLayout:function(){

            var series = this.getVisibleChartData();

            //力学气泡图的时候计算百分比和标签内容
            if(this.isForceBubble()){
                this.dealStackedSeries(series);
            }

            var allPoints = [];
            series.forEach(function(sery){
                allPoints = allPoints.concat(sery.points);
            });

            var self = this;
            this.calculateBubbleRadius();
            this._calculateBubblePosition(series, allPoints);
            allPoints.forEach(function(point){
                self._calculatePointLabelAndTooltip(point);
            });
        },

        calculateBubbleRadius:function(){
            var series = this.getVisibleChartData();
            var minSize = Number.MAX_VALUE;//所有数据的最大最小值
            var maxSize = -minSize;
            var minSizeArray = [];//每个系列数据的最大最小值
            var maxSizeArray = [];
            var self = this;
            series.forEach(function(sery, i) {
                if (sery.points.length > 0) {
                    var seriesMinSize = Number.MAX_VALUE;//当前系列数据的最大最小值
                    var seriesMaxSize = -seriesMinSize;
                    for(var index = 0, len = sery.points.length; index < len; index++){
                        var point = sery.points[index];
                        var pointS = point.size;
                        if(pointS < 0){
                            if(point.displayNegative){
                                pointS = Math.abs(pointS);
                                if(sery.chart.option.legend.enabled) {
                                    self._setNegativeColorAttr(point, sery);
                                }
                            } else {
                                continue;
                            }
                        }
                        seriesMaxSize = Math.max(seriesMaxSize, pointS);
                        seriesMinSize = Math.min(seriesMinSize, pointS);
                    }
                    minSize = Math.min(minSize, seriesMinSize);
                    maxSize = Math.max(maxSize, seriesMaxSize);
                    minSizeArray[i] = seriesMinSize;
                    maxSizeArray[i] = seriesMaxSize;
                }
            });

            var scale = BaseUtils.pick(this.vanchart.scale, 1);

            series.forEach(function(sery, i) {
                if (sery.points.length > 0) {
                    var seriesMaxDiameter = sery.maxSize;
                    var seriesMinDiameter = sery.minSize;
                    var sizeByArea = sery.sizeBy == Constants.SIZE_BY_AREA;
                    //系列条件属性设置最大最小半径，则气泡半径根据该系列最大最小size计算
                    var sizeBySeriesMinMax = BaseUtils.hasDefined(sery.seriesOption.minSize) && BaseUtils.hasDefined(sery.seriesOption.maxSize);
                    var seriesMaxSize = sizeBySeriesMinMax ? maxSizeArray[i] : maxSize;
                    var seriesMinSize = sizeBySeriesMinMax ? minSizeArray[i] : minSize;

                    var unit = 0;
                    if(seriesMaxSize != seriesMinSize){
                        unit = sizeByArea ? (seriesMaxDiameter * seriesMaxDiameter - seriesMinDiameter * seriesMinDiameter) / (seriesMaxSize - seriesMinSize)
                            : (seriesMaxDiameter - seriesMinDiameter ) / (seriesMaxSize - seriesMinSize);
                    }

                    sery.points.forEach(function(point) {
                        var temp = unit * (Math.abs(point.size) - seriesMinSize);
                        var diameter = sizeByArea ? Math.sqrt(seriesMinDiameter * seriesMinDiameter + temp)
                            : seriesMinSize + temp;
                        if(point.pointOption.minSize && point.pointOption.maxSize){
                            diameter = point.pointOption.minSize;
                        }
                        diameter = (point.size < 0 && !point.displayNegative) ? 0 : diameter;
                        point.radius = (diameter/2) * scale;
                    });
                }
            });
        },

        _calculateBubblePosition:function(series, allPoints){

            this.isForceBubble() ? this._calculateForceBubblePosition(series, allPoints)
                : this._calculateNormalBubblePosition(series, allPoints);
        },

        _calculateNormalBubblePosition:function(series, allPoints){
            var isInverted = this.vanchart.isInverted();

            series.forEach(function(sery){
                var baseAxis = sery.baseAxis;
                var valueAxis = sery.valueAxis;

                sery.points.forEach(function(point){

                    var det = baseAxis.scale.rangeBand ? baseAxis.scale.rangeBand()/2 : 0;
                    var t1 = Math.round(baseAxis.scale(point.category) + det);
                    var t2 = valueAxis.scale(point.value + point.y0);

                    var pos = {};
                    if (isInverted) {
                        pos.posX = t2;
                        pos.posY = t1;
                    } else {
                        pos.posX = t1;
                        pos.posY = t2;
                    }

                    QueryUtils.merge(point, pos, true);
                })
            });

            if(this.isSupportAnimation()) {

                allPoints.sort(function (pointA, pointB) {
                    return pointB.radius - pointA.radius;
                });

                var len = allPoints.length;
                if (len > 0) {
                    var unitTime = BUBBLES_SHOW_TIME / len;
                    allPoints.forEach(function (point, i) {

                        QueryUtils.merge(point, {
                            delayTime: unitTime * i
                        }, true);

                    });
                }
            }

        },

        _calculateForceBubblePosition:function(series, nodes){
            var maxRadius = 0;
            var plotBounds = this.getPlotBounds();
            var size = [plotBounds.width, plotBounds.height];

            series.forEach(function(sery){
                var cluster;
                sery.points.forEach(function(point){
                    cluster = cluster || point;
                    cluster = point.radius > cluster.radius ? point : cluster;
                    maxRadius = Math.max(maxRadius, point.radius);
                });

                sery.cluster = cluster;
            });

            //ie下需要模拟计算
            if(this.isUpdateWithForce()){
                return;
            }
            
            d3.layout.pack().sort(null)
                .size(size)
                .children(function(d) {
                    return d.values;
                })
                .value(function(d) {
                    return d.radius * d.radius;
                })
                .nodes({values: d3.nest()
                    .key(function(d) { return d.seriesName; })
                    .entries(nodes)});

            //这个layout会修改value的属性
            nodes.forEach(function(point){
                point.value = point.size;
            });

            //模拟集聚的过程
            var start = 0.1, end = 0.005;
            var padding = 2, clusterPadding = 2;
            var paddingAlpha = 0.5;
            var gravity = 0.02;
            var friction = 0.9;

            //set px,py
            nodes.forEach(function(point){
                point.px = point.x;
                point.py = point.y;
            });

            for(var alpha = start; alpha >= end; alpha -= (alpha > 0.07 ? 0.001 : 0.0005)){

                var n = nodes.length, i, o, k, x, y;

                if (k = alpha * gravity) {
                    x = size[0] / 2;
                    y = size[1] / 2;
                    i = -1;
                    if (k) while (++i < n) {
                        o = nodes[i];
                        o.x += (x - o.x) * k;
                        o.y += (y - o.y) * k;
                    }
                }
                i = -1;
                while (++i < n) {
                    o = nodes[i];
                    o.x -= (o.px - (o.px = o.x)) * friction;
                    o.y -= (o.py - (o.py = o.y)) * friction;
                }

                nodes.forEach(function(d){
                    //集聚
                    var cluster = d.series.cluster;

                    if (cluster && cluster != d){
                        var x = d.x - cluster.x,
                            y = d.y - cluster.y,
                            l = Math.sqrt(x * x + y * y),
                            r = d.radius + cluster.radius;
                        if (l != r) {
                            l = (l - r) / l * alpha;
                            d.x -= x *= l;
                            d.y -= y *= l;
                            cluster.x += x;
                            cluster.y += y;
                        }
                    }});

                for(var i = 0; i < n; i++){
                    var d = nodes[i];

                    for(var j = 0; j < n; j++){
                        var point = nodes[j];

                        if (point !== d) {
                            var x = d.x - point.x,
                                y = d.y - point.y,
                                l = Math.sqrt(x * x + y * y),
                                r = d.radius + point.radius + (d.series.cluster === point.series.cluster ? padding : clusterPadding);
                            if (l < r) {
                                l = (l - r) / l * paddingAlpha;
                                d.x -= x *= l;
                                d.y -= y *= l;
                                point.x += x;
                                point.y += y;
                            }
                        }
                    }
                }
            }

            nodes.forEach(function(point){
                point.posX = point.x;
                point.posY = point.y;
            })
        },

        _setNegativeColorAttr:function(point, sery){
            point.color = NEGATIVE_COLOR;
            point.clickColor = ColorUtils.getClickColor(NEGATIVE_COLOR);
            var queryList = [
                point.pointOption,
                sery.seriesOption,
                sery.chart.option.plotOptions[sery.type],
                sery.chart.option.plotOptions,
                Options[sery.type].plotOptions
            ];
            point.mouseOverColor = QueryUtils.queryList(queryList, 'mouseOverColor') || ColorUtils.getHighLightColor(NEGATIVE_COLOR);
        },

        _calculatePointLabelAndTooltip:function(point){

            var withForce = this.isUpdateWithForce();

            if(this.isForceBubble()){
                //力学气泡图
                if(point.labelContent && point.labelDim){

                    var radius = point.radius;
                    if((point.labelDim.width > 2 * radius) || (point.labelDim.height > 2 * radius)){
                        point.labelPos = null;
                    }else{

                        var posX = withForce ? 0 : point.posX;
                        var posY = withForce ? 0 : point.posY;

                        point.labelPos = {
                            x:-point.labelDim.width/2 + posX,
                            y:-point.labelDim.height/2 + posY
                        }
                    }

                }

            }else{
                var dataLabels = point.dataLabels;
                if(dataLabels && dataLabels.enabled) {

                    this._calculateBubbleLabelInfo(point, dataLabels, Constants.INSIDE);

                    this._calculateLabelPos(point);
                }
            }

            this.mergeSinglePointTooltipAttr(point);
        },

        _calculateLabelPos:function(point) {
            var labelDim = point.labelDim;
            var x = point.posX - labelDim.width/2;
            var y = point.posY - labelDim.height/2;
            var labelPos = {
                x: x,
                y: y
            };
            QueryUtils.merge(point, {
                labelPos: labelPos
            }, true);
        },

        getTrendLineXYValues:function(sery){
            return this.getBubbleTrendLineXYValues(sery);
        },

        _getFixedPos:function(datum){
            var radius = datum.radius || 0;

            var plotBounds = this.getPlotBounds();

            var x = this.isForceBubble() ? datum.x : datum.posX;
            var y = this.isForceBubble() ? datum.y : datum.posY;

            var x = plotBounds.x + x + radius;
            var y = plotBounds.y + y + radius;

            return [x, y];
        },

        mergeDataPointAttributes:function(point){
            var queryList = [
                point.pointOption,
                point.series.seriesOption,
                this.option.plotOptions[this.componentType],
                this.option.plotOptions,
                Options[this.componentType].plotOptions
            ];
            var isForceBubble = this.isForceBubble();
            var fillColorOpacity = BaseUtils.pick(QueryUtils.queryList(queryList, 'fillColorOpacity'), DEFAULT_BUBBLE_ALPHA);
            var size = BaseUtils.pick(QueryUtils.queryList(queryList, 'size'), 0);
            size = isForceBubble ? (point.isNull ? '-' : point.value) : size; //力学气泡图没有size的值
            var value = point.value, category = point.category;
            
            BaseUtils.extend(point, {
                fillColorOpacity: fillColorOpacity,
                x:category,
                y:value,
                size:size,
                shadow: QueryUtils.queryList(queryList, 'shadow'),
                displayNegative: QueryUtils.queryList(queryList, 'displayNegative'),
                delayTime:0
            });

            if(isForceBubble){
                point.x = undefined;
                point.y = undefined;
            }
        },

        mergeSeriesAttributes:function(sery) {

            var queryList = [
                sery.seriesOption,
                this.option.plotOptions[this.componentType],
                this.option.plotOptions,
                Options[this.componentType].plotOptions
            ];

            QueryUtils.merge(sery,{
                sizeBy: QueryUtils.queryList(queryList, 'sizeBy'),
                maxSize: QueryUtils.queryList(queryList, 'maxSize'),
                minSize: QueryUtils.queryList(queryList, 'minSize'),
                shadow: QueryUtils.queryList(queryList, 'shadow'),
                displayNegative: QueryUtils.queryList(queryList, 'displayNegative')
            });
        },

        getClosestPoint:function(pos){

            var series = this.getVisibleChartData();

            var plotBounds = this.getPlotBounds();

            for(var sIndex = series.length - 1; sIndex >= 0; sIndex--){
                var sery = series[sIndex];

                for(var pIndex = sery.points.length - 1; pIndex >= 0; pIndex--){

                    var point = sery.points[pIndex];

                    var detX = point.posX + plotBounds.x - pos[0];

                    var detY = point.posY + plotBounds.y - pos[1];

                    var len = Math.sqrt(detX * detX + detY * detY);

                    if(len <= point.radius){
                        return point;
                    }
                }
            }
        },

        getRender:function(){
            return !this.vanchart._leaflet && this.render;
        }
        
    });

    require('../ChartLibrary').register(Constants.BUBBLE_CHART, Bubble);

    return Bubble;
});

/**
 * Created by Mitisky on 16/3/24.
 */
define('chart/Scatter',['require','./BaseChart','../utils/BaseUtils','../utils/ColorUtils','../Constants','../utils/QueryUtils','../theme/options','../ChartLibrary'],function (require) {
    var BaseChart = require('./BaseChart');
    var BaseUtils = require('../utils/BaseUtils');
    var ColorUtils = require('../utils/ColorUtils');
    var Constants = require('../Constants');
    var QueryUtils = require('../utils/QueryUtils');
    var Options = require('../theme/options');

    var POINTS_SHOW_TIME = 800;
    var DEFAULT_SCATTER_ALPHA = 1;
    var LABEL_GAP = 2;

    var Scatter = BaseChart.extend({
        
        type:Constants.SCATTER_CHART,
        
        selfSeryIndex: 0,

        doLayout: function () {
            this.selfSeryIndex = 0;
            var self = this;
            var series = this.getVisibleChartData();
            var allPoints = [];
            var isInverted = this.vanchart.isInverted();

            series.forEach(function(sery) {
                if (sery.points.length > 0) {
                    var baseAxis = sery.baseAxis;
                    var valueAxis = sery.valueAxis;
                    sery.points.forEach(function(point) {
                        //这句是必要的，点击图例点原地消失
                        if(point.visible) {
                            var det = baseAxis.scale.rangeBand ? baseAxis.scale.rangeBand() / 2 : 0;
                            var x = Math.round(baseAxis.scale(point.category) + det);
                            var y = valueAxis.scale(point.value + point.y0);

                            var pos = {};
                            if (isInverted) {
                                pos.posX = y;
                                pos.posY = x;
                            } else {
                                pos.posX = x;
                                pos.posY = y;
                            }

                            QueryUtils.merge(point, pos, true);

                            self._calculatePointLabelAndTooltip(point);
                        }
                    });
                    allPoints = allPoints.concat(sery.points);

                    if (isInverted) {
                        sery.points.sort(function (pA, pB) {
                            return pA.posY - pB.posY;
                        });
                    } else {
                        sery.points.sort(function (pA, pB) {
                            return pA.posX - pB.posX;
                        });
                    }
                }
            });

            this._calculatePointDelayTime(allPoints);
        },

        _calculatePointDelayTime:function(allPoints) {
            if(this.isSupportAnimation()) {
                var len = allPoints.length;

                if (len > 0) {
                    allPoints.forEach(function (point, i) {
                        var delayTime = d3.ease('exp-in-out')(i/len) * POINTS_SHOW_TIME;
                        QueryUtils.merge(point, {
                            delayTime: delayTime
                        }, true);

                    });
                }
            }
        },

        _calculatePointLabelAndTooltip:function(point){

            var dataLabels = point.dataLabels;
            if(dataLabels && dataLabels.enabled) {
                this._calculateBubbleLabelInfo(point, dataLabels, Constants.OUTSIDE);

                this._calculateLabelPos(point);
            }

            this.mergeSinglePointTooltipAttr(point);

        },

        _calculateLabelPos:function(point) {
            var labelDim = point.labelDim;
            var labelPos = {
                x: point.posX - labelDim.width/2,
                y: point.posY  - LABEL_GAP - labelDim.height
            };
            QueryUtils.merge(point, {
                labelPos: labelPos
            }, true);
        },

        getTrendLineXYValues:function(sery){
            return this.getBubbleTrendLineXYValues(sery);
        },

        _createCategoryLine:function(data, label, style, formatter){
            return this._createBubbleTooltipSeriesLine(data, label, style, formatter);
        },

        _createSeriesLine:function(data, label, style, formatter){
            return this._createBubbleTooltipXYSizeLine(data, label, style, formatter);
        },

        _getFixedPos:function(datum){
            var radius = datum.marker.radius || this.getDefaultMarkerRadius();

            var plotBounds = this.getPlotBounds();

            var x = plotBounds.x + datum.posX + radius;
            var y = plotBounds.y + datum.posY + radius;

            return [x, y];
        },

        mergeDataPointAttributes:function(point){
            var queryList = [
                point.pointOption,
                point.series.seriesOption,
                this.option.plotOptions[point.series.type],
                this.option.plotOptions,
                Options[point.series.type].plotOptions
            ];
            var fillColorOpacity = BaseUtils.pick(QueryUtils.queryList(queryList, 'fillColorOpacity'), DEFAULT_SCATTER_ALPHA);

            if(point.color){
                fillColorOpacity = BaseUtils.pick(ColorUtils.getColorOpacityWithoutDefault(point.color), fillColorOpacity);
            }

            var size = BaseUtils.pick(QueryUtils.queryList(queryList, 'size'), 0);
            var value = point.value, category = point.category;

            BaseUtils.extend(point, {
                fillColorOpacity: fillColorOpacity,
                x:category,
                y:value,
                size: size
            });

            //放在最后原因：会用到size
            this._mergeMarkerAttributes(point);
            if(BaseUtils.isNullMarker(point.marker)){
                point.marker.symbol = point.series.marker.symbol;
            }

            point.marker.fillColor = ColorUtils.colorToHex(point.marker.fillColor);
        },

        mergeSeriesAttributes:function(sery){
            if(BaseUtils.isNullMarker(sery.marker)){
                sery.marker.symbol = BaseUtils.getDefaultMarkerSymbol(this.selfSeryIndex);
                this.selfSeryIndex++;
            }

            var seriesOption = sery.seriesOption;
            var queryList = [
                seriesOption,
                this.option.plotOptions[sery.type],
                this.option.plotOptions,
                Options[sery.type].plotOptions
            ];

            var lineWidth = QueryUtils.queryList(queryList, 'lineWidth') || 0;
            var interpolate = this._getSeriesInterpolate(queryList);
            var lineSvg = d3.svg.line()
                .interpolate(interpolate)
                .x(function (d) {
                    return d.posX;
                })
                .y(function (d) {
                    return d.posY;
                })
                .defined(function (d) {
                    return !d.isNull;
                });

            QueryUtils.merge(sery,
                {
                    lineWidth: lineWidth,
                    lineSvg: lineSvg,
                    interpolate:interpolate
                }
            );
        },

        getClosestPoint:function(pos){

            var series = this.getVisibleChartData();

            var plotBounds = this.getPlotBounds();

            for(var sIndex = series.length - 1; sIndex >= 0; sIndex--){
                var sery = series[sIndex];

                for(var pIndex = sery.points.length - 1; pIndex >= 0; pIndex--){

                    var point = sery.points[pIndex];

                    var detX = point.posX + plotBounds.x - pos[0];

                    var detY = point.posY + plotBounds.y - pos[1];

                    var len = Math.sqrt(detX * detX + detY * detY);

                    var radius =  point.marker.radius || 4.5;

                    if(len <= radius){
                        return point;
                    }
                }
            }
        },

        getRender:function(){
            return !this.vanchart._leaflet && this.render;
        }

    });

    require('../ChartLibrary').register(Constants.SCATTER_CHART, Scatter);
    
    return Scatter;
});

/**
 * Created by eason on 16/5/9.
 */
define('chart/Map',['require','../Constants','../utils/BaseUtils','../utils/QueryUtils','./BaseChart','../component/Geo','../ChartLibrary','../component/Series','../theme/options','../utils/Formatter','../ChartLibrary'],function(require){

    var NAME = 'NAME';
    var SERIES = 'SERIES';
    var VALUE = 'VALUE';
    var PERCENT = 'PERCENT';

    var Constants = require('../Constants');
    var BaseUtils = require('../utils/BaseUtils');
    var QueryUtils = require('../utils/QueryUtils');
    var BaseChart = require('./BaseChart');
    var Geo = require('../component/Geo');
    var ChartLibrary = require('../ChartLibrary');
    
    var Series = require('../component/Series');
    var Options = require('../theme/options');
    var Formatter = require('../utils/Formatter');

    var Map = BaseChart.extend({
        type:Constants.MAP_CHART,
        layerIndex:0,
        doLayout:function(){
            var bubble = this.vanchart.getChart(Constants.BUBBLE_CHART);
            bubble && bubble.calculateBubbleRadius();

            //百分比,标签,数据提示
            this._calculateTextRelated(this.getVisibleChartData(Constants.AREA_MAP));

            var bubbleSeries = this.getVisibleChartData(Constants.BUBBLE_CHART);
            var scatterSeries = this.getVisibleChartData(Constants.SCATTER_CHART);
            var pointMap = this.getVisibleChartData(Constants.POINT_MAP);
            var pointSeries = bubbleSeries.concat(scatterSeries, pointMap);

            //对于点地图,像气泡和散点图只有size,而没有value,而这里应该统一算成value
            for(var i = pointSeries.length - 1; i >= 0; i--){
                var points = pointSeries[i].points;
                points.forEach(function(point){
                    point.value = BaseUtils.hasDefined(point.size) ? point.size : point.value;
                });
            }

            this._calculateTextRelated(pointSeries);
        },

        //重新计算标签
        viewreset:function(){
            //缩放以后重叠的标签重新计算
            var map = this;
            clearTimeout(this.labelRelaoutTimeOut);
            this.labelRelaoutTimeOut = setTimeout(function(){
                map.render && map.render.updateLabel();
            }, 200);//避免过快的操作
        },

        _calculateTextRelated:function(series){

            var nameMap = {};
            var geo = this.vanchart.getComponent(Constants.GEO_COMPONENT);

            //计算百分比
            for(var i = 0, count = series.length; i < count; i++){
                var total = 0;
                var points = series[i].points.filter(function(p){return !p.isNull;});
                var isAreaMap = series[i].type == Constants.AREA_MAP;

                points.forEach(function(point){
                    total = BaseUtils.accAdd(total, Math.abs(point.value));
                });

                points.forEach(function(point){
                    point.percentage = Math.abs(BaseUtils.accDiv(point.value, total));
                    point.percentage  = isNaN(point.percentage) ? 0 : point.percentage;

                    var key = isAreaMap ? point.name : geo.getDataPointLatLng(point).join('-');

                    nameMap[key] = nameMap[key] || [];
                    nameMap[key].push(point);
                });
            }

            var map = this;
            for(var name in nameMap){
                var points = nameMap[name];
                points.forEach(function(point){

                    point.points = points;
                    //标签
                    if(point.dataLabels && point.dataLabels.enabled){
                        BaseUtils.extend(point, map.calculateMapLabel(point, point.dataLabels, point.series.type));
                    }

                    //数据点提示
                    if(point.tooltip && point.tooltip.enabled){
                        point.tooltipText = map._calculateTooltipContent(point.tooltip, point, points);
                    }
                });
            }
        },

        calculateMapLabel:function(point, labelInfo, chartType){

            var dataLabels = labelInfo || {};
            var formatter =  dataLabels.formatter;
            var useHtml = dataLabels.useHtml;

            var labelPosition = (chartType == Constants.SCATTER_CHART || chartType == Constants.POINT_MAP) ? Constants.OUTSIDE : Constants.INSIDE;

            var content = [];

            if(typeof formatter == 'object'){

                var label = formatter.identifier;

                if(label.indexOf(NAME) != -1){
                    var text = Formatter.format(point.name, formatter.nameFormat);
                    var style = point.getCategorySeriesStyle(dataLabels, labelPosition);
                    var dim = BaseUtils.getTextDimension(text, style, useHtml);
                    content.push({text:text, style:style, dim:dim});
                }

                var line = '';
                var hasSeries = label.indexOf(SERIES) != -1, hasValue = label.indexOf(VALUE) != -1, hasPercent = label.indexOf(PERCENT) != -1;
                var seriesLabel = Formatter.format(point.seriesName, formatter.seriesFormat);
                var valueLabel = Formatter.format(point.value, formatter.valueFormat);
                var percentLabel = Formatter.format(point.percentage, formatter.percentFormat);
                if(hasSeries){
                    line += seriesLabel;
                    if(hasValue || hasPercent){
                        line += ':'
                    }
                }

                if(hasValue){
                    line += valueLabel;
                    if(hasPercent){
                        line += ' '
                    }
                }

                if(hasPercent){
                    line += percentLabel;
                }

                if(line){
                    var style = point.getValuePercentageStyle(dataLabels, labelPosition);
                    var dim = BaseUtils.getTextDimension(line, style, useHtml);
                    content.push({text:line, style:style, dim:dim});
                }

            }else{
                point.pushCustomLabelContent(formatter, dataLabels, useHtml, content, labelPosition);
            }

            var labelDim = point.calculateTextDim(content);

            return {
                labelContent:content,
                labelDim:labelDim
            };

        },

        initLayerInfo:function(){
            this.layerMap = [];
            this.initMapData();
            var drillTools = this.vanchart.getComponent(Constants.DRILL_TOOLS);
            var rangeLegend = this.vanchart.getComponent(Constants.RANGE_LEGEND_COMPONENT);

            var geo = this.layerMap[0][0].geo;
            var seriesOptions = this.vanchart.restoreOption.series;
            var series = this.vanchart.series;

            if(drillTools){
                drillTools.addIconData(this.layerMap[0][0]);

                if(this.option.initDrillPath){
                    var path = this.option.initDrillPath;
                    var series = this.vanchart.series;

                    for(var i = 1; i < path.length; i++){
                        var name = path[i];

                        var point = null;
                        for(var j = 0; j < series.length; j++){
                            var points = series[j].points;

                            for(var k = 0; k < points.length; k++){
                                if(points[k].drill && points[k].drill.geo.name == name){
                                    point = points[k];
                                    break;
                                }
                            }

                            if(point){
                                break;
                            }
                        }

                        if(point){
                            var iconData = this.iconDataOfMap(point.drillSeries);
                            if(drillTools && iconData){
                                drillTools.addIconData(iconData);
                            }
                        }
                    }

                    series = point.drillSeries;
                    seriesOptions = point.drillSeries.originSeries;
                    geo = point.geo;
                }
            }

            this.vanchart.series = series;
            this.vanchart.currentOption.series = seriesOptions
            this.vanchart.components.geo = geo;

            if(rangeLegend){
                rangeLegend.refresh();
            }

            geo.fitMapBounds();
        },

        //地图因为更具geoJson的数据,不需要布局,但是需要计算标签的位置等信息
        initMapData:function(series, geo, layerIndex){
            series = series || this.vanchart.series;
            geo = geo || this.vanchart.getComponent(Constants.GEO_COMPONENT);
            var vanchart = this.vanchart;

            var rangeLegend = this.vanchart.getComponent(Constants.RANGE_LEGEND_COMPONENT);

            layerIndex = layerIndex || 0;
            var isLeafSeries = true, map = this, vanchart = this.vanchart;
            for(var i = series.length - 1; i >= 0; i--){
                var sery = series[i];
                for(var j = sery.points.length - 1; j >= 0; j--){
                    var point = sery.points[j];
                    if(point.drill){
                        var drill = point.drill, drillSeries = [], drillGeo;

                        map.option.geo = drill.geo;
                        drillGeo = new Geo(this.vanchart, this.option, Constants.GEO_COMPONENT);
                        vanchart.components.geo = drillGeo;

                        if(rangeLegend){
                            map.option.series = drill.series;
                            rangeLegend.refresh();
                        }

                        drill.series.forEach(function(sery){
                            sery.type = sery.type || map.option.chartType;
                            var classType = sery.type.toLowerCase().indexOf(Constants.MAP_CHART) != -1 ? Constants.MAP_CHART : sery.type;

                            var classTypeObj = vanchart.getChart(classType);

                            if(!classTypeObj){
                                var ChartClass = ChartLibrary.get(classType);
                                classTypeObj = new ChartClass(vanchart, vanchart.currentOption, classType);
                                vanchart.charts[classType] = classTypeObj;
                            }

                            drillSeries.push(new Series(classTypeObj, sery));
                        });

                        drillSeries.originSeries = drill.series;

                        point.drillSeries = drillSeries;
                        point.geo = drillGeo;

                        isLeafSeries = false;
                        this.layerMap[layerIndex] = this.layerMap[layerIndex] || [];
                        this.layerMap[layerIndex].push({geo:geo, series:series, layerIndex:layerIndex});
                        this.initMapData(point.drillSeries, point.geo, layerIndex + 1);
                    }
                }
            }

            if(isLeafSeries){
                for(var i = series.length - 1; i >= 0; i--){
                    this.layerMap[layerIndex] = this.layerMap[layerIndex] || [];
                    this.layerMap[layerIndex].push({geo:geo, series:series, layerIndex:layerIndex});
                }
            }
        },

        _getComputedMapStyle:function(queryList){
            var style =  {
                fillColor:QueryUtils.queryList(queryList, 'fillColor'),
                fillColorOpacity:QueryUtils.queryList(queryList, 'fillColorOpacity'),
                borderWidth:QueryUtils.queryList(queryList, 'borderWidth'),
                borderColor:QueryUtils.queryList(queryList, 'borderColor'),
                borderOpacity:QueryUtils.queryList(queryList, 'borderOpacity')
            };

            return style;
        },

        mergeSeriesAttributes:function(series){

            var queryList = [
                series.seriesOption,
                this.option.plotOptions[series.type],
                this.option.plotOptions,
                Options[series.type].plotOptions
            ];

            series.mapStyle = this._getComputedMapStyle(queryList);
            series.icon = QueryUtils.queryList(queryList, 'icon');
        },

        mergeDataPointAttributes:function(point){
            var pointOption = point.pointOption;
            var queryList = [
                pointOption,
                point.series.seriesOption,
                this.option.plotOptions[point.series.type],
                this.option.plotOptions,
                Options[point.series.type].plotOptions
            ];

            //todo 如何指定其他的值
            var value = BaseUtils.pick(pointOption.value, pointOption[1]);

            var style = this._getComputedMapStyle(queryList);
            style.fillColor = point.color;//todo fillColor,color属性重复

            BaseUtils.extend(point, {
                mapStyle:style,
                value:value,
                isNull:BaseUtils.hasNotDefined(value)
            });
        },

        iconDataOfMap:function(series){
            for(var i = this.layerMap.length - 1; i >= 0; i--){
                var layerArray = this.layerMap[i];

                for(var j = layerArray.length - 1; j >= 0; j--){
                    if(layerArray[j].series == series){
                        return layerArray[j];
                    }
                }
            }
        },

        drillDown:function(dataPoint){
            if(dataPoint.drillSeries){

                var vanchart = this.vanchart;

                vanchart.lastIconData = vanchart.lastIconData || [];
                vanchart.lastIconData[this.layerIndex] = {
                    zoomListener:dataPoint.geo.getZoomListener(),
                    series:vanchart.series,
                    geo:vanchart.getComponent(Constants.GEO_COMPONENT)
                };

                this.vanchart.series = dataPoint.drillSeries;
                this.vanchart.currentOption.series = dataPoint.drillSeries.originSeries;
                this.vanchart.components.geo = dataPoint.geo;

                this.vanchart.series.forEach(function(sery){
                    var points = sery.points;
                    sery.visible = true;
                    for(var i = 0, len = points.length; i <len; i++){
                        points[i].visible = true;
                    }
                });

                this.vanchart.hoverPoint = null;
                dataPoint.geo.fitMapBounds();

                var drillTools = this.vanchart.getComponent(Constants.DRILL_TOOLS);
                var iconData = this.iconDataOfMap(dataPoint.drillSeries);
                if(drillTools && iconData){
                    drillTools.addIconData(iconData);
                }

                var rangeLegend = this.vanchart.getComponent(Constants.RANGE_LEGEND_COMPONENT);
                if(rangeLegend){
                    rangeLegend.refresh();
                }

                this.vanchart.refreshComponentsAndSeries();

                this.layerIndex++;
            }
        },

        drillUp:function(iconData){
            this.vanchart.series = iconData.series;
            this.vanchart.components.geo = iconData.geo;
            this.vanchart.currentOption.series = iconData.series.originSeries;

            this.vanchart.series.forEach(function(sery){
                var points = sery.points;
                sery.visible = true;
                for(var i = 0, len = points.length; i <len; i++){
                    points[i].visible = true;
                }
            });

            this.vanchart.hoverPoint = null;
            iconData.geo.fitMapBounds();

            var drillTools = this.vanchart.getComponent(Constants.DRILL_TOOLS);
            if(drillTools){
                drillTools.deleteIconData(iconData.series);
            }

            var rangeLegend = this.vanchart.getComponent(Constants.RANGE_LEGEND_COMPONENT);
            if(rangeLegend){
                rangeLegend.refresh();
            }

            this.vanchart.refreshComponentsAndSeries();

            this.layerIndex--;
        },

        _getFixedPos:function(point){
            var map = point.series.chart, leaflet = map.vanchart._leaflet;
            var geo = map.vanchart.getComponent(Constants.GEO_COMPONENT);
            var type = point.series.type;

            var latlng = geo.getDataPointLatLng(point);
            var pos = leaflet.latLngToContainerPoint(latlng);

            if(type == Constants.AREA_MAP){
                var detX = 0, detY = 0;
                if(point.dataLabels && point.labelDim && point.labelPos){
                    detX = point.labelDim.width/2;
                    detY = point.labelDim.height/2;
                }
                return [pos.x + detX, pos.y + detY];
            }else{
                //散点和气泡有半径的时候
                if(point.radius || point.marker && !BaseUtils.isImageMarker(point.marker.symbol)){
                    var radius = point.radius || (point.marker && point.marker.radius) || this.getDefaultMarkerRadius();
                    radius = (radius + 1)/1.414;
                    return [pos.x + radius, pos.y + radius];
                }
            }

            return [pos.x, pos.y];
        }
    });

    require('../ChartLibrary').register(Constants.MAP_CHART, Map);

    return Map;
});
/**
 * Created by eason on 15/8/13.
 */

define('render/PieSvgRender',['require','./BaseRender','../utils/BaseUtils','../utils/ColorUtils','../Constants','../utils/BezierEasing','./RenderLibrary'],function(require){

    var PATH_G = 'path-g';
    var LABEL_G = 'label-g';
    var PIE_G = 'pie-g';

    var BaseRender = require('./BaseRender');
    var BaseUtils = require('../utils/BaseUtils');
    var ColorUtils = require('../utils/ColorUtils');
    var Constants = require('../Constants');
    var Bezier = require('../utils/BezierEasing');

    var HOVER_PERCENT = 1.1;

    var ANIMATION_TIME = 1000;
    var EASE = 'bounce';

    var SORT_EASE = Bezier.css.swing;
    var SORT_TIME = 400;

    var START_STOP = 'start-gradual-stop';
    var END_STOP = 'end-gradual-stop';

    var PieSvgRender = BaseRender.extend({
        
        render:function(){

            var plotBounds = this.component.getPlotBounds();
            var svgRoot = this.component.getVanchartRender().getRenderRoot();

            if(!this._bodyG){
                this._bodyG = svgRoot.append('g');
            }

            this._bodyG.attr('transform', BaseUtils.makeTranslate(plotBounds));

            var self = this;

            var pieData = this.component.getVisibleChartData();

            var pieUpdate = this._bodyG.selectAll('g.' + PIE_G)
                .data(pieData, function(d){return d.className;});

            pieUpdate
                .attr('transform', function(d){return BaseUtils.makeTranslate([d.centerX, d.centerY])})
                .each(function(d){

                    var pieG = d3.select(this);

                    self._updateDefs(pieG.select('defs'), d);

                    self._updateSlices(pieG.select('g.' + PATH_G), d);

                    self._drawLabel(pieG.select('g.' + LABEL_G), d, ANIMATION_TIME);
                });

            var newPie = pieUpdate.enter()
                .append('g')
                .attr('class', function(d){
                    return PIE_G + ' ' + d.className;
                });

            pieUpdate.exit().remove();

            newPie.each(function(d){

                var pieG = d3.select(this)
                    .attr('transform', BaseUtils.makeTranslate([d.centerX, d.centerY]));

                pieG.append('defs');

                pieG.append('g').attr('class', PATH_G);

                pieG.append('g').attr('class', LABEL_G);

                self._updateDefs(pieG.select('defs'), d);

                self._updateSlices(pieG.select('g.' + PATH_G), d, true);

                self._drawLabel(pieG.select('g.' + LABEL_G), d, ANIMATION_TIME);
            });

        },

        _updateDefs:function(defs, config){

            if(!config.style){
                return;
            }

            if(config.style == Constants.STYLE_GRADUAL){

                var self = this;
                var points = config.visiblePoints;
                var grads = defs.selectAll("radialGradient").data(points, function(d){
                    return d.className;
                });

                var newSlice = grads.enter().append('radialGradient');
                newSlice.append('stop').attr('class', START_STOP);
                newSlice.append('stop').attr('class', END_STOP);

                grads
                    .attr("gradientUnits", "userSpaceOnUse")
                    .attr("cx", "0%")
                    .attr("cy", "0%")
                    .attr("r", function(d){
                        return Math.max(d.radius, 0) + 'px';
                    })
                    .attr("id", function(d){
                        return  self._getGradualID(d);
                    });

                grads.select("stop." + START_STOP)
                    .attr("offset", function(d){
                        return (d.series.innerRadius / Math.max(d.radius, 1)) * 100 + '%';
                    })
                    .style("stop-color", function(d){
                        return ColorUtils.getColorWithDivider(d.color, 0.8);
                    });

                grads.select("stop." + END_STOP)
                    .attr("offset", "100%")
                    .style("stop-color", function(d){
                        return d.color;
                    });
            }
        },

        _updateSlices:function(pathG, config, initPie){
            var arc = d3.svg.arc().innerRadius(config.innerRadius);
            var points = config.visiblePoints;

            var initStartAngel = Math.PI * config.startAngle / 180;
            var initEndAngle = Math.PI * config.endAngle / 180;

            var self = this;

            var slices;

            if(this.component.groupDataByClassName()){
                slices = pathG.selectAll('path').data(points, function(d){return d.className});
            }else{
                slices = pathG.selectAll('path').data(points);
            }

            var rotate = d3.transform(pathG.attr('transform')).rotate;
            this.component.recalculateLabelPos(config, BaseUtils.toRadian(rotate));

            var exitSlice = slices.exit();
            var supportAnimation = this.component.isSupportAnimation();

            var emptyExitS = exitSlice.empty() && slices.enter().empty();

            if(supportAnimation){
                exitSlice
                    .transition()
                    .ease(EASE)
                    .duration(ANIMATION_TIME)
                    .attrTween("d", function (d) {

                        //需要消失的系列
                        var dataIndex = this._dataIndex_;
                        var radius = this._current_.radius;

                        var currentArc;
                        if(dataIndex == 0){
                            currentArc = {startAngle: initStartAngel, endAngle: initStartAngel, radius: radius};
                        }else if(dataIndex >= points.length){
                            currentArc = {startAngle: initEndAngle, endAngle: initEndAngle, radius: radius};
                        }else{

                            var preArc = points[dataIndex - 1];
                            if(preArc.lastShape){
                                var preGap = Math.abs(preArc.lastShape.endAngle - preArc.endAngle);
                                var startAngle = d.startAngle + preGap;
                                currentArc = {startAngle: startAngle, endAngle: startAngle, radius: radius};
                            }else{
                                //没有前一个arc的话直接创建
                                currentArc = {startAngle: d.startAngle, endAngle: d.startAngle, radius: d.radius}
                            }
                        }

                        var interpolate = d3.interpolate(this._current_ , currentArc);

                        return function (t) {
                            return arc.outerRadius(d.radius)(interpolate(t));
                        };
                    })
                    .remove();
            }else{
                exitSlice.remove();
            }

            slices.enter().append("path");
            self.addShapeEventHandler(slices);

            var animationTime = (emptyExitS && !initPie) ? SORT_TIME : ANIMATION_TIME;
            var easeFunc = (emptyExitS && !initPie) ? SORT_EASE : EASE;

            slices.each(function(d){

                this._dataIndex_ = self._indexInVisiblePoints(d);
                var index = this._dataIndex_;

                var slice = d3.select(this)
                    .attr('class', d.className)
                    .style("fill", self._getFill(d))
                    .style('stroke', d.borderColor)
                    .style('stroke-width', d.borderWidth);

                if(supportAnimation){
                    slice
                        .transition()
                        .ease(easeFunc)
                        .duration(animationTime)
                        .attrTween("d", function (d) {

                            var currentArc = this._current_;

                            if(initPie){
                                currentArc = {startAngle: initStartAngel, endAngle: initStartAngel, radius:d.radius};
                            }else if(!currentArc){
                                if(index == 0){
                                    currentArc = {startAngle: initStartAngel, endAngle: initStartAngel, radius:d.radius};
                                }else if(index >= points.length - 1){
                                    currentArc = {startAngle: initEndAngle, endAngle: initEndAngle, radius:d.radius};
                                }else{
                                    var preArc = points[index - 1];

                                    if(preArc.lastShape){
                                        var preGap = Math.abs(preArc.lastShape.endAngle - preArc.endAngle);
                                        var startAngle = d.startAngle + preGap;
                                        currentArc = {startAngle: startAngle, endAngle: startAngle, radius: d.radius};
                                    }else{
                                        //没有前一个arc的话直接创建
                                        currentArc = {startAngle: d.startAngle, endAngle: d.startAngle, radius: d.radius}
                                    }

                                }

                            }

                            var interpolate = d3.interpolate(currentArc, self._getArcData(d));

                            this._current_ = interpolate(1);

                            return function (t) {
                                var tmp = interpolate(t);
                                return arc.outerRadius(tmp.radius)(tmp);
                            };
                        });
                }else{

                    slice.attr('d', function(d){
                        this._current_ = self._getArcData(d);
                        return arc.outerRadius(d.radius)(this._current_);
                    })

                }

            });
        },

        _drawLabel:function(labelG, config, delay){

            delay = delay || 0;
            delay = this.component.isSupportAnimation() ? delay : 0;

            var plotBounds = this.component.getPlotBounds();
            var transX = config.centerX + plotBounds.x;
            var transY = config.centerY + plotBounds.y;

            this._drawSvgDataLabels(labelG, config.visiblePoints, transX, transY, delay, config.name);
        },

        onDragStart:function(target, initPos){

            var pieG = this._bodyG.select('g.' + target.className);

            var labelG = pieG.select('g.' + LABEL_G);
            var pathG = pieG.select('g.' + PATH_G);

            //旋转的时候把标签和牵引线隐藏
            this._removeSvgDataLabels(labelG, target.category);

            this.initPos = initPos;
            this.initRotate = d3.transform(pathG.attr('transform')).rotate;
        },

        _getPositionInPie:function(absPos, target){

            var plotBounds = this.component.getPlotBounds();

            var x = absPos[0] - plotBounds.x - target.centerX;

            var y = absPos[1] - plotBounds.y - target.centerY;

            return [x, y];
        },

        onDrag:function(target, currentPos){

            var pieG = this._bodyG.select('g.' + target.className);

            var pathG = pieG.select('g.' + PATH_G);

            var startAngle = this._getAngle(this._getPositionInPie(this.initPos, target), [0,0]);

            var newAngle = this._getAngle(this._getPositionInPie(currentPos, target), [0,0]);

            var rotate = newAngle - startAngle + this.initRotate;

            pathG.attr("transform", "rotate(" + rotate + "," + 0 + "," + 0 + ")");

        },

        onDragEnd:function(target){

            var pieG = this._bodyG.select('g.' + target.className);

            var labelG = pieG.select('g.' + LABEL_G);
            var pathG = pieG.select('g.' + PATH_G);

            var rotate = d3.transform(pathG.attr('transform')).rotate;

            this.component.recalculateLabelPos(target, BaseUtils.toRadian(rotate));

            this._drawLabel(labelG, target);
        },

        _getFill:function(d){

            var gradient = this._bodyG.select('#' + this._getGradualID(d));

            gradient.select("stop." + START_STOP)
                .style("stop-color", ColorUtils.getColorWithDivider(d.color, 0.9));

            gradient.select("stop." + END_STOP).style("stop-color", d.color);

            return d.style == Constants.STYLE_GRADUAL ? "url(#" + this._getGradualID(d) + ")": d.color;
        },

        _getClickedFill:function(d){

            var gradient = this._bodyG.select('#' + this._getGradualID(d));

            gradient.select("stop." + START_STOP)
                .style("stop-color", ColorUtils.getColorWithDivider(d.clickColor, 0.9));

            gradient.select("stop." + END_STOP).style("stop-color", d.clickColor);

            return d.style == Constants.STYLE_GRADUAL ? "url(#" + this._getGradualID(d) + ")": d.clickColor;
        },

        _getMouseOverFill:function(d){
            var gradient = this._bodyG.select('#' + this._getGradualID(d));

            gradient.select("stop." + START_STOP)
                .style("stop-color", ColorUtils.getColorWithDivider(d.mouseOverColor, 0.9));

            gradient.select("stop." + END_STOP).style("stop-color", d.mouseOverColor);

            return d.style == Constants.STYLE_GRADUAL ? "url(#" + this._getGradualID(d) + ")": d.mouseOverColor;
        },

        _getGradualID:function(d){
            return d.className + this.component.vanchart.getIDPrefix();
        },

        _getArcData:function(d){
            return {
                startAngle: d.startAngle,
                endAngle: d.endAngle,
                radius: d.radius
            };
        },

        _indexInVisiblePoints:function(point){
            var points = point.series.visiblePoints;
            for(var i = 0, len = points.length; i < len; i++){
                if(points[i] == point){
                    return i;
                }
            }
            return 0;
        },

        _getAngle:function(current, center){
            return Math.atan2(current[1] - center[1], current[0] - center[0]) / (Math.PI / 180);
        },

        mouseOver:function(event){
            if(event && event.target){
                var d = event.target.datum();

                var self = this;

                var pathNode = event.target.node();
                clearTimeout(pathNode.cancelChosenTimeout);

                var arc = d3.svg.arc().innerRadius(d.series.innerRadius);

                if(pathNode && !pathNode.isChosen){
                    event.target
                        .style('fill', function(d){
                            return self._getMouseOverFill(d);
                        })
                        .transition().ease("elastic").duration(800)
                        .attrTween("d", function (d) {
                            var outerRadius = d.radius;
                            var interpolate = d3.interpolate(outerRadius, outerRadius * 1.1);
                            var arcData = self._getArcData(d);

                            return function (t) {
                                return arc.outerRadius(interpolate(t))(arcData);
                            };

                        });

                    pathNode.isChosen = true;
                }
            }
        },

        mouseOut:function(event){
            if(event && event.target){
                var d = event.target.datum();

                var arc = d3.svg.arc().innerRadius(d.series.innerRadius);

                var self = this;
                var pathNode = event.target.node();

                if(!pathNode || !pathNode.isChosen){
                    return;
                }

                clearTimeout(pathNode.cancelChosenTimeout);

                pathNode.cancelChosenTimeout = setTimeout(function(){
                    if(pathNode.isChosen){
                        event.target
                            .style('fill', function(d){
                                return self._getFill(d);
                            })
                            .transition()
                            .ease("elastic").duration(600)
                            .attrTween("d", function (d) {
                                var outerRadius = d.radius;
                                var interpolate = d3.interpolate(outerRadius * HOVER_PERCENT, outerRadius);
                                var arcData = self._getArcData(d);
                                return function (t) {
                                    return arc.outerRadius(interpolate(t))(arcData);
                                };
                            });

                        pathNode.isChosen = false;
                    }
                },50);
            }
        },

        mouseDown:function(event){
            if(event && event.target){
                var d = event.target.datum();
                event.target.style('fill', this._getClickedFill(d));
            }
        },

        mouseUp:function(event){
            if(event && event.target){
                var d = event.target.datum();
                if (event.target.node().isChosen) {
                    event.target.style('fill', this._getMouseOverFill(d));
                }
            }
        }
    });

    require('./RenderLibrary').register(Constants.PIE_SVG, PieSvgRender);

    return PieSvgRender;
});
/**
 * Created by Yuqian on 16/6/15.
 */

define('render/MultiPieSvgRender',['require','./BaseRender','../utils/BaseUtils','../utils/ColorUtils','../Constants','../utils/BezierEasing','./RenderLibrary'],function(require){

    var WRAP = 'multipie-wrap';
    var MULTIPIE_G = 'multipie-g';
    var LABEL_G = 'label-g';
    var LABEL_KEY = 'multipie-label';
    var DRILLDOWN_RING = 'drilldown-ring';

    var BaseRender = require('./BaseRender');
    var BaseUtils = require('../utils/BaseUtils');
    var ColorUtils = require('../utils/ColorUtils');
    var Constants = require('../Constants');
    var Bezier = require('../utils/BezierEasing');

    var ANIMATION_TIME = 1000;
    var INNER_HOVER_TIME = 300;
    var SORT_TIME = 400;

    var EASE = 'bounce';
    var INNER_HOVER_EASE = Bezier.css.swing;
    var SORT_EASE = Bezier.css.swing;

    var INNER_RING_RADIUS = 15;
    var INNER_RING_STROKE_WIDTH = 5;


    var MultiPieSvgRender = BaseRender.extend({

        _bodyG: null,

        arc: null,

        render: function () {
            
            var plotBounds = this.component.getPlotBounds();
            var svgRoot = this.component.getVanchartRender().getRenderRoot();
            var center = this.component.getCenter();
            var multiPieData = this.component.getChartNodes();
            var supportAnimation = this.component.isSupportAnimation();

            if(!this._bodyG){
                this._bodyG = svgRoot.append('g').datum(multiPieData);
                var wrap = this._bodyG.append('g').attr('class', WRAP);
                var multiPieG = wrap.append('g').attr('class', MULTIPIE_G);
                this._bodyG.append('g').attr('class', LABEL_G);

                // initial animation
                if (supportAnimation) {
                    wrap
                        .transition()
                        .duration(550)
                        .ease('linear')
                        .attrTween('transform', function () {
                            var i = d3.interpolate(-180, 0);
                            return function (t) {
                                var inter = i(t);
                                return 'rotate(' + inter + ')';
                            };
                        });

                    multiPieG
                        .transition()
                        .duration(400)
                        .ease('linear')
                        .attrTween('transform', function () {
                            var i = d3.interpolate(0, 0.9);
                            return function (t) {
                                var inter = i(t);
                                return 'scale(' + inter + ')';
                            };
                        })
                        .transition()
                        .duration(1000)
                        .ease('elastic', 1.1, 0.3)
                        .attrTween('transform', function () {
                            var i = d3.interpolate(0.9, 1);
                            return function (t) {
                                var inter = i(t);
                                return 'scale(' + inter + ')';
                            };
                        });
                }

                this._bodyG
                    .append('path')
                    .attr('class', DRILLDOWN_RING)
                    .attr('d', d3.svg.arc()
                        .startAngle(0)
                        .endAngle(Math.PI * 2)
                        .innerRadius(INNER_RING_RADIUS)
                        .outerRadius(INNER_RING_RADIUS + INNER_RING_STROKE_WIDTH))
                    .style('fill', 'rgba(0,0,0,0.1)')

            } else {
                this._bodyG.datum(multiPieData);
            }

            this._bodyG.attr('transform', BaseUtils.makeTranslate(center));

            this._bodyG.select('.' + DRILLDOWN_RING).attr('display', 'none');

            this._drawSeries(this._bodyG);

            this._drawLabel(this._bodyG, ANIMATION_TIME);

        },

        _drawSeries: function (bodyG) {
            var multiPieG = bodyG.select('.' + MULTIPIE_G);

            var updatePath = multiPieG
                .selectAll('path')
                .data(function (d) { return d; }/*, function (d) { return d.className; }*/);

            this._updateSeries(updatePath);

        },

        _updateSeries: function (updatePath) {
            var multiPie = this.component;
            var ease = multiPie.getIsChanged() ? SORT_EASE : EASE;
            var aTime = multiPie.getIsChanged() ? SORT_TIME : ANIMATION_TIME;
            var supportAnimation = this.component.isSupportAnimation();

            var arc = d3.svg.arc()
                .startAngle(function (d) { return d.x; })
                .endAngle(function (d) { return d.x + d.dx; })
                .innerRadius(function(d) { return d.y;})
                .outerRadius(function(d) { return d.y + d.dy;});

            this.arc = arc;

            updatePath.exit().remove();

            // update
            updatePath
                .attr("display", function (d) { return (d.name || !d.depth) ? null : 'none';})
                .attr("opacity", function (d) {
                    return d.depth ? 1 : 0;
                })// hide inner ring
                .style("stroke", function (d) {
                    return d.borderColor;
                })
                .style("stroke-width", function (d) {
                    return d.borderWidth;
                })
                .style("fill", function (d) {
                    return d.color;
                })
                .transition()
                .ease(ease)
                .duration(supportAnimation ? aTime : 0)
                .attrTween("d", function (a) {
                    var self = this;
                    var i = d3.interpolate(
                        {
                            x: self.x1,
                            y: self.y1,
                            dx: self.dx1,
                            dy: self.dy1
                        }, a);
                    return function (t) {
                        var b = i(t);
                        self.x1 = b.x;
                        self.y1 = b.y;
                        self.dx1 = b.dx;
                        self.dy1 = b.dy;
                        return arc(b);
                    };
                });


            // enter

            // stash old values
            function stash(d) {
                this.x1 = d.x;
                this.y1 = d.y;
                this.dx1 = d.dx;
                this.dy1 = d.dy;
            }

            updatePath.enter()
                .append("path")
                .attr("display", function (d) { return (d.name || !d.depth) ? null : 'none';})
                .attr("opacity", function(d) { return d.depth ? 1 : 0;})// hide inner ring
                .attr("d", arc)
                .style("stroke", function (d) { return d.borderColor; })
                .style("stroke-width", function (d) { return d.borderWidth; })
                .style("fill", function(d) { return d.color; })
                .each(stash);

            this.addShapeEventHandler(updatePath);
        },


        _drawLabel:function(bodyG, delay){
            var labelG = bodyG.select('.' + LABEL_G);

            delay = delay || 0;
            delay = this.component.isSupportAnimation() ? delay : 0;

            var multiPieData = bodyG.datum();

            var center = this.component.getCenter();
            var transX = center[0];
            var transY = center[1];

            this._drawSvgDataLabels(labelG, multiPieData, transX, transY, delay, LABEL_KEY);
        },

        drillDown: function (d) {
            var multiPieG = this._bodyG.select('.' + MULTIPIE_G);
            var labelG = multiPieG.select('g.' + LABEL_G);
            var supportAnimation = this.component.isSupportAnimation();

            this._removeSvgDataLabels(labelG, '');

            var arc = this.arc;
            if (supportAnimation) {
                multiPieG.transition()
                    .duration(ANIMATION_TIME)
                    .selectAll("path")
                    .style('fill', function(d){
                        return d.color;
                    })
                    .attrTween("d", function (a) {
                        var self = this;
                        var i = d3.interpolate(
                            {
                                x: self.x1,
                                y: self.y1,
                                dx: self.dx1,
                                dy: self.dy1
                            }, a);
                        return function (t) {
                            var b = i(t);
                            self.x1 = b.x;
                            self.y1 = b.y;
                            self.dx1 = b.dx;
                            self.dy1 = b.dy;
                            return arc(b);
                        };
                    })
                    // following handle the small edge things,
                    // doesn't matter to the main animation...
                    .attrTween('opacity', function (d) {
                        var self = this;
                        return function (t) {
                            return (d.depth && (self.y1 + self.dy1) >= INNER_RING_RADIUS) ? 1 : 0
                        }
                    })
                    .each('end', function (d) {
                        this.isChosen = false;
                        d3.select(this).attr('opacity', (d.depth && d.dx && (d.y + d.dy) > INNER_RING_RADIUS) ? 1 : 0)
                    });
            } else {
                multiPieG
                    .selectAll("path")
                    .attr("d", arc)
                    .each(function (d) {
                        this.isChosen = false;
                        d3.select(this).attr('opacity', (d.depth && d.dx && (d.y + d.dy) > INNER_RING_RADIUS) ? 1 : 0)
                    });
            }

            this._drawLabel(this._bodyG);

            if (d.depth) {
                this._bodyG
                    .select('.' + DRILLDOWN_RING)
                    .transition()
                    .delay(ANIMATION_TIME)
                    .attr('display', null);
            } else {
                this._bodyG
                    .select('.' + DRILLDOWN_RING)
                    .transition()
                    .attr('display', 'none');
            }
        },

        mouseOver: function (event) {
            if(event && event.target){

                var pathNode = event.target.node();

                if(pathNode && !pathNode.isChosen){
                    var d = event.target.datum();

                    if (d.depth && pathNode.y1+pathNode.dy1 === INNER_RING_RADIUS) {
                        event.target
                            .transition()
                            .duration(INNER_HOVER_TIME)
                            .ease(INNER_HOVER_EASE)
                            .attr('opacity', 1)
                    } else {
                        event.target
                            .style('fill', function(d){
                                return d.mouseOverColor;
                            });

                        if (d.tooltip && d.tooltip.shared) {
                            var handler = this.component.vanchart.handler;
                            var p, node = d;
                            while ((p = node.parent) && p.depth && p.y+p.dy !== INNER_RING_RADIUS) {
                                node = p;
                                handler.fireEventByData(p, 'cover', event);
                            }
                        }
                    }

                    pathNode.isChosen = true;
                }
            }
        },

        mouseOut: function (event) {
            if(event && event.target){

                var pathNode = event.target.node();

                if(pathNode && pathNode.isChosen){
                    var d = event.target.datum();

                    if (d.depth && pathNode.y1+pathNode.dy1 === INNER_RING_RADIUS) {
                        event.target
                            .transition()
                            .duration(INNER_HOVER_TIME)
                            .ease(INNER_HOVER_EASE)
                            .attr('opacity', 0);
                    } else {
                        event.target
                            .style('fill', function(d){
                                return d.color;
                            });

                        if (d.tooltip && d.tooltip.shared) {
                            var handler = this.component.vanchart.handler;
                            var p, node = d;
                            while ((p = node.parent) && p.depth && p.y+p.dy !== INNER_RING_RADIUS) {
                                node = p;
                                handler.fireEventByData(p, 'leave', event);
                            }
                        }
                    }

                    pathNode.isChosen = false;
                }
            }
        },

        mouseDown:function(event){
            if(event && event.target){
                var d = event.target.datum();
                this.down = d;
            }
        },

        mouseUp: function (event) {

            if(event && event.target){
                var d = event.target.datum();
                
                if (this.component.getDrilldown() && this.down === d) {
                    this.component.drillDown(d);
                }
            }

        },

        onDragStart:function(target, initPos){

            var labelG = this._bodyG.select('g.' + LABEL_G);
            var pathG = this._bodyG.select('g.' + MULTIPIE_G);

            //旋转的时候把标签和牵引线隐藏
            this._removeSvgDataLabels(labelG, target.category);

            this.initPos = initPos;
            this.initRotate = d3.transform(pathG.attr('transform')).rotate;
        },

        _getPositionInPie:function(absPos, target){

            var plotBounds = this.component.getPlotBounds();

            var x = absPos[0] - target.centerX;

            var y = absPos[1] - target.centerY;

            return [x, y];
        },

        onDrag:function(target, currentPos){
            this.down = null;

            var pathG = this._bodyG.select('g.' + MULTIPIE_G);

            var startAngle = this._getAngle(this._getPositionInPie(this.initPos, target), [0,0]);

            var newAngle = this._getAngle(this._getPositionInPie(currentPos, target), [0,0]);

            var rotate = newAngle - startAngle + this.initRotate;

            pathG.attr("transform", "rotate(" + rotate + "," + 0 + "," + 0 + ")");

        },

        onDragEnd:function(target){

            var labelG = this._bodyG.select('g.' + LABEL_G);
            var pathG = this._bodyG.select('g.' + MULTIPIE_G);

            var rotate = d3.transform(pathG.attr('transform')).rotate;

            this.component.recalculateLabelPos(target, BaseUtils.toRadian(rotate));

            this._drawLabel(this._bodyG, target);
        },

        _getAngle:function(current, center){
            return Math.atan2(current[1] - center[1], current[0] - center[0]) / (Math.PI / 180);
        }
    });

    require('./RenderLibrary').register(Constants.MULTIPIE_SVG, MultiPieSvgRender);

    return MultiPieSvgRender;
});
/**
 * Created by eason on 15/9/24.
 */

define('render/BarSvgRender',['require','./BaseRender','../utils/BaseUtils','../Constants','../utils/ColorUtils','../utils/BezierEasing','./RenderLibrary'],function(require){

    var BaseRender = require('./BaseRender');
    var BaseUtils = require('../utils/BaseUtils');
    var Constants = require('../Constants');
    var ColorUtils = require('../utils/ColorUtils');
    var BezierEasing = require('../utils/BezierEasing');

    var INIT_ANIMATION_TIME = 400;
    var EXIT_ANIMATION_TIME = 150;
    var UPDATE_ANIMATION_TIME = 250;

    var CHOSEN_STROKE_WIDTH = 6;

    var START_GRADUAL_CLASS = 'start-gradual-class';
    var END_GRADUAL_CLASS = 'end-gradual-class';

    var BAR_SERIES_GROUP = 'bar-seires-group';

    var BarSvgRender = BaseRender.extend({

        render:function(){
            var svgRoot = this.component.getVanchartRender().getRenderRoot();

            if(!this._bodyG){
                this._bodyG = svgRoot.append('g');
                this._labelG = svgRoot.append('g');
                this._updateChartBodyTranslate([this._bodyG, this._labelG]);
            } else {
                this._updateChartBodyTranslate([this._bodyG, this._labelG], this.component.isSupportAnimation(), UPDATE_ANIMATION_TIME);
            }

            var barData = this.component.getVisibleChartData();

            var barSeriesS = this._bodyG.selectAll('g.' + BAR_SERIES_GROUP).data(barData, function(d){return d.className});

            this._dropSeries(barSeriesS);

            this._updateSeries(barSeriesS);

            this._createSeries(barSeriesS);

            this._drawNormalChartLabels(this._labelG);
        },

        _dropSeries:function(seriesS){

            var exitSeries = seriesS.exit();

            var supportAnimation = this.component.isSupportAnimation();

            exitSeries.each(function(){

                d3.select(this)
                    .selectAll('rect')
                    .transition()
                    .duration(supportAnimation ? EXIT_ANIMATION_TIME : 0)
                    .ease('linear')
                    .attrTween('y', function(d){

                        var y = d.y;
                        var height = d.height;
                        var bottomY = y + height;

                        return function(t){
                            var currentH = height * (1 - d3.ease('back')(t));
                            return bottomY - currentH + 'px';
                        }

                    })
                    .attrTween('height', function(d){
                        var height = d.height;

                        return function(t){
                            return height * (1 - d3.ease('back')(t)) + 'px';
                        }
                    })
                    .remove();
            });
        },

        _updateSeries:function(seriesS){

            var lastEmptySize = BaseUtils.pick(this.emptySeries, 0);
            this.emptySeries = seriesS.exit().size();

            var chart = this;

            seriesS.each(function(d){

                var barG = d3.select(this);

                chart._updateDefs(d.points, barG.select('defs'), d.getLocation());

                var barS = barG.selectAll('rect').data(d.points, function(d){return d.className;});

                var updateDelay = lastEmptySize < chart.emptySeries ? EXIT_ANIMATION_TIME : 0;
                var createDelay = lastEmptySize > chart.emptySeries ? UPDATE_ANIMATION_TIME : 0;

                barS.empty() ? chart._crateInitialBarElement(barS, createDelay) : chart._updateBarTransition(barS, updateDelay);

                //这两步是自动刷新的时候可能出现的
                if(!barS.enter().empty()){
                    chart._crateInitialBarElement(barS, updateDelay + UPDATE_ANIMATION_TIME);
                }

                chart.addShapeEventHandler(barS);

                barS.exit().remove();
            });
        },

        _createSeries:function(seriesS){

            var newSeriesG = seriesS.enter().append('g').attr('class', BAR_SERIES_GROUP);

            var chart = this;

            newSeriesG.each(function(d){

                var barG = d3.select(this);

                chart._updateDefs(d.points, barG.append('defs'), d.getLocation());

                var barS = barG.selectAll('rect').data(d.points, function(d){return d.className;});

                barS.call(chart._crateInitialBarElement.bind(chart));
            });

        },

        _updateDefs:function(points, defs, location){

            var self = this;

            if(this.component.option.style){
                var grads = defs.selectAll("linearGradient")
                    .data(points, function(d){
                        return d.className;
                    });

                var x1, y1, x2, y2;
                x1 = y1 = x2 = y2 = '0%';
                switch (location){
                    case Constants.TOP:
                        y1 = '100%';
                        break;
                    case Constants.BOTTOM:
                        y2 = '100%';
                        break;
                    case Constants.LEFT:
                        x1 = '100%';
                        break;
                    case Constants.RIGHT:
                        x2 = '100%';
                        break;
                }

                grads.enter()
                    .append('linearGradient')
                    .attr("x1", x1)
                    .attr("y1", y1)
                    .attr('x2', x2)
                    .attr('y2', y2)
                    .attr("id", function(d){
                        return self._getGradualID(d);
                    });

                grads.append("stop")
                    .attr("offset", '0%')
                    .attr('class', START_GRADUAL_CLASS)
                    .style("stop-color", function(d){
                        return ColorUtils.getColorWithDivider(d.color, 0.9);
                    });

                grads.append("stop")
                    .attr("offset", "100%")
                    .attr('class', END_GRADUAL_CLASS)
                    .style("stop-color", function(d){
                        return d.color;
                    });
            }

            var imagePoints = [];
            points.forEach(function(point){
                if(point.image){
                    imagePoints.push(point);

                    if(point.image){
                        imagePoints.push(point);

                        switch (point.location){
                            case Constants.BOTTOM:
                                point.imageX = point.x;
                                point.imageY = point.y + point.height % point.imageHeight;
                                break;

                            case Constants.TOP:
                            case Constants.LEFT:
                                point.imageX = point.x;
                                point.imageY = point.y;
                                break;

                            case Constants.RIGHT:
                                point.imageX = point.x + point.width % point.imageWidth;
                                point.imageY = point.y;
                                break;
                        }
                    }

                }
            });

            var patterns = defs
                .selectAll('pattern')
                .data(imagePoints, function(d){
                    return d.className;
                });

            var enter = patterns
                .enter()
                .append('pattern');

            enter.append('image');

            patterns
                .attr('x', function(d){return d.imageX})
                .attr('y', function(d){return d.imageY})
                .attr('width', function(d){return d.imageWidth})
                .attr('height', function(d){return d.imageHeight})
                .attr('patternUnits', 'userSpaceOnUse')
                .attr('id', function(d){return self._getImageID(d)})
                .select('image')
                .attr('x', 0)
                .attr('y', 0)
                .attr('width', function(d){return d.imageWidth})
                .attr('height', function(d){return d.imageHeight})
                .attr('xlink:href', function(d){return d.image});

        },

        _getGradualID:function(d){
            var IDPrefix = this.component.vanchart.getIDPrefix();
            return 'gradual' + d.className + IDPrefix;
        },

        _getImageID:function(d){
            var IDPrefix = this.component.vanchart.getIDPrefix();
            return 'image' + d.className + IDPrefix;
        },

        _getFillWidthColor:function(d, color){

            var gradient = this._bodyG.select('#' + this._getGradualID(d));
            gradient.select("stop." + START_GRADUAL_CLASS)
                .style("stop-color", ColorUtils.getColorWithDivider(color, 0.9));

            gradient.select("stop." + END_GRADUAL_CLASS)
                .style("stop-color", color);

            var style = this.component.option.style;
            var gradualID = "url(#" + this._getGradualID(d) + ")";
            var imageID = "url(#" + this._getImageID(d) + ")";

            return d.image ? imageID : (style == Constants.STYLE_GRADUAL ? gradualID : color);
        },

        _getMouseOverFill:function(d){
            return this._getFillWidthColor(d, d.mouseOverColor);
        },

        _getFill:function(d){
            return this._getFillWidthColor(d, d.color);
        },

        _getClickedFill:function(d){
            return this._getFillWidthColor(d, d.clickColor);
        },

        _crateInitialBarElement:function(selection, delay){

            delay = delay || 0;

            var self = this;

            var enterSelection = selection.enter().append('rect');

            //创建的时候加监听
            this.addShapeEventHandler(enterSelection);

            var supportAnimation = this.component.isSupportAnimation();

            enterSelection
                .each(function(d){

                    var barChangeInfo = self.component.getInitBarAttribute(d);

                    var initBar = supportAnimation ? barChangeInfo.init : d;
                    var endBar = barChangeInfo.end;

                    var bar = d3.select(this);

                    self._setInitBarAttributes(bar, d, initBar);

                    if(supportAnimation && d.width > 0 && d.height > 0){

                        bar
                            .transition()
                            .ease(BezierEasing.css.swing)
                            .duration(INIT_ANIMATION_TIME)
                            .delay(delay)
                            .attr('x', endBar.x)
                            .attr('y', endBar.y)
                            .attr('width', Math.max(endBar.width, 0))
                            .attr('height', Math.max(endBar.height, 0))
                            .each('end', function(){
                                bar
                                    .attr('x', d.x)
                                    .attr('y', d.y)
                                    .attr('width', Math.max(d.width, 0))
                                    .attr('height', Math.max(d.height, 0));
                            });

                    }else{

                        bar
                            .attr('x', d.x)
                            .attr('y', d.y)
                            .attr('width', Math.max(d.width, 0))
                            .attr('height', Math.max(d.height, 0));

                    }
                });
        },

        _setInitBarAttributes:function(barSelection, d, initBar){

            barSelection
                .attr('class', d.className)
                .attr('x', initBar.x)
                .attr('y', initBar.y)
                .attr('width', Math.max(initBar.width, 0))
                .attr('height', Math.max(initBar.height, 0))
                .attr('rx', d.borderRadius)
                .attr('ry', d.borderRadius)
                .style({
                    'fill': this._getFill(d),
                    'stroke': d.borderColor,
                    'stroke-width': d.borderWidth
                })
                .each(function(){
                    this._current_ = {x: d.x, y: d.y, width: d.width, height: d.height};
                });
        },

        //已经显示的系列的动画
        _updateBarTransition:function(barS, delay){

            var supportAnimation = this.component.isSupportAnimation();
            var self = this;
            var delay = delay || 0;

            if(supportAnimation){
                barS
                    .each(function(d){
                        var lastBar = this._current_ || {x: d.x, y: d.y, width: d.width, height: d.height};
                        this._current_ = {x: d.x, y: d.y, width: d.width, height: d.height};

                        d3.select(this)
                            .style({
                                'fill': self._getFill(d),
                                'stroke': d.borderColor,
                                'stroke-width': d.borderWidth
                            })
                            .transition()
                            .duration(UPDATE_ANIMATION_TIME)
                            .delay(delay)
                            .ease('linear')
                            .attrTween('x',function(){
                                return function(t){
                                    return lastBar.x + (d.x - lastBar.x)*BezierEasing.css.swing(t) + 'px';
                                }
                            })
                            .attrTween('y',function(){
                                return function(t){
                                    return lastBar.y + (d.y - lastBar.y)*BezierEasing.css.swing(t) + 'px';
                                }
                            })
                            .attrTween('width',function(){
                                return function(t){
                                    return lastBar.width + (d.width - lastBar.width)*BezierEasing.css.swing(t) + 'px';
                                }
                            })
                            .attrTween('height',function(){
                                return function(t){
                                    return lastBar.height + (d.height - lastBar.height)*BezierEasing.css.swing(t) + 'px';
                                }
                            });
                    });
            }else{
                barS.each(function(d){
                    self._setInitBarAttributes(d3.select(this), d, d);
                });
            }

        },

        mouseOver:function(event){
            if(event && event.target){
                var d = event.target.datum();
                event.target
                    .style({
                        'stroke':d.mouseOverColor,
                        'fill':this._getMouseOverFill(d),
                        'stroke-width':d.borderWidth,
                        'stroke-opacity':0.35
                    })
                    .interrupt(Constants.SELECT_ANIMATION)
                    .transition(Constants.SELECT_ANIMATION)
                    .duration(100)
                    .ease('ease-out-in')
                    .style('stroke-width', CHOSEN_STROKE_WIDTH);
            }
        },

        mouseOut:function(event){
            if(event && event.target){
                var d = event.target.datum();

                event.target
                    .interrupt(Constants.SELECT_ANIMATION)
                    .transition(Constants.SELECT_ANIMATION);

                event.target
                    .style('fill', this._getFill(d))
                    .style('stroke', d.borderColor)
                    .style('stroke-opacity', 1)
                    .style('stroke-width', d.borderWidth);
            }
        },

        mouseDown:function(event){
            if(event && event.target){
                var d = event.target.datum();
                event.target.style('fill', this._getClickedFill(d));
            }
        },

        mouseUp:function(event){
            if(event && event.target){
                var d = event.target.datum();
                event.target.style('fill', this._getMouseOverFill(d));
            }
        }
        
    });

    require('./RenderLibrary').register(Constants.BAR_SVG, BarSvgRender);
});
/**
 * Created by eason on 15/11/6.
 */
define('render/LineSvgRender',['require','./BaseRender','../utils/BaseUtils','../utils/ColorUtils','../Constants','../utils/QueryUtils','../utils/BezierEasing','./RenderLibrary'],function(require){

    var BaseRender = require('./BaseRender');
    var BaseUtils = require('../utils/BaseUtils');
    var ColorUtils = require('../utils/ColorUtils');
    var Constants = require('../Constants');

    var QueryUtils = require('../utils/QueryUtils');
    var Bezier = require('../utils/BezierEasing');

    var LINE_G_CLASS = 'lineGroupG';
    var AREA_G_CLASS = 'areaGroupG';

    var MARKER_G_CLASS = 'markerGroupG';
    var PATH_G = 'pathG';
    var AREA_G = 'areaG';

    var CLASS = 'class';

    var LINE_SHOW_TIME = 800;
    var LINE_MONITOR_TIME = 500;
    var LINE_UPDATE_TIME = 250;

    var CHOSEN_AREA_ALPHA = 0.65;


    var LineSvgRender = BaseRender.extend({
        render:function(){

            var svgRoot = this.component.getVanchartRender().getRenderRoot();

            if(!this._bodyG){
                this._bodyG = svgRoot.append('g');
                this._defsG = this._bodyG.append('g');
                this._areaG = this._bodyG.append('g');
                this._lineG = this._bodyG.append('g');
                this._labelG = this._bodyG.append('g');
                this._updateChartBodyTranslate([this._bodyG]);
            } else {
                this._updateChartBodyTranslate([this._bodyG], this.component.isSupportAnimation(), LINE_UPDATE_TIME);
            }

            this._updateLineSeries();

            this._drawNormalChartLabels(this._labelG, this.component.isSupportAnimation() ? LINE_SHOW_TIME : 0);
        },

        //animationTime, easeFunc是对update状态的线组
        _updateLineSeries:function(animationTime, easeFunc){

            var g = this._updateDataBinding();
            var defsG = g.defsG;
            var areaG = g.areaG;
            var lineG = g.lineG;

            animationTime = this.component.isSupportAnimation() ? (animationTime || LINE_UPDATE_TIME) : 0;

            easeFunc = easeFunc || Bezier.css.swing;

            //退场的折线删除
            defsG.exit().remove();
            lineG.exit().remove();
            areaG.exit().remove();

            defsG
                .selectAll('clipPath')
                .select('rect')
                .transition()
                .ease(easeFunc)
                .duration(animationTime)
                .attr('x', function(d){
                    return d.x;
                })
                .attr('y', function(d){
                    return d.y;
                })
                .attr('width', function(d){
                    return d.width;
                })
                .attr('height', function(d){
                    return d.height;
                });

            areaG
                .selectAll('path')
                .filter(function(d){
                    return d.lineData.isStack;
                })
                .style('fill', function(d){
                    return d.fillColor;
                })
                .style('fill-opacity', function(d){
                    return d.fillColorOpacity;
                })
                .style('stroke', 'none')
                .transition()
                .ease(easeFunc)
                .duration(animationTime)
                .attr('d', function(d){
                    var lineData = d.lineData;
                    return lineData.areaSvg(lineData.points);
                })
                .each('end', function(){
                    d3.select(this)
                        .attr('d', function(d){
                            var lineData = d.lineData;
                            return lineData.areaSvg(lineData.points);
                        });
                });

            lineG
                .select('g.' + PATH_G)
                .selectAll('path')
                .style('fill', 'none')
                .style('stroke', function(d){
                    return d.color;
                })
                .style('stroke-width', function(d){
                    return d.lineData.lineWidth;
                })
                .transition()
                .ease(easeFunc)
                .duration(animationTime)
                .attr('d', function(d){
                    var lineData = d.lineData;
                    return lineData.lineSvg(lineData.points);
                })
                .each('end', function(){
                    d3.select(this)
                        .attr('d', function(d){
                            var lineData = d.lineData;
                            return lineData.lineSvg(lineData.points);
                        });
                });

            lineG
                .select('g.' + AREA_G)
                .selectAll('path')
                .filter(function(d){
                    return !d.lineData.isStack;
                })
                .style('fill', function(d){
                    return d.fillColor;
                })
                .style('fill-opacity', function(d){
                    return d.fillColorOpacity;
                })
                .style('stroke', 'none')
                .transition()
                .ease(easeFunc)
                .duration(animationTime)
                .attr('d', function(d){
                    var lineData = d.lineData;
                    return lineData.areaSvg(lineData.points);
                })
                .each('end', function(){
                    d3.select(this)
                        .attr('d', function(d){
                            var lineData = d.lineData;
                            return lineData.areaSvg(lineData.points);
                        });
                });


            var self = this;
            lineG.each(function(d){

                var markers = d3.select(this)
                    .select('g.' + MARKER_G_CLASS)
                    .selectAll('g').data(function(d){ return d.points.filter(function(d){return !d.isNull}); });

                self.addShapeEventHandler(markers);

                markers
                    .each(function(d){
                        self._updateMarkerStyle(d3.select(this), d);
                    })
                    .transition()
                    .ease(easeFunc)
                    .duration(animationTime)
                    .attr('transform', function(d){
                        return 'translate(' + d.x + ',' + d.y + ')';
                    });

                markers.exit().remove();

                d3.select(this)
                    .transition()
                    .delay(animationTime)
                    .each('end', function(){

                        markers.call(self._createSvgMarker.bind(self))
                            .attr('transform', function(d) {
                                return 'translate(' + d.x + ',' + d.y + ')';
                            });

                    });

            });

            this.addSeriesEventHandler(areaG);
            this.addSeriesEventHandler(lineG);

            //新建折线
            this._createNewLineSeries(g);
        },

        _updateDataBinding:function(){

            var lines = this.component.getVisibleChartData();

            var lineG = this._lineG
                .selectAll('g.' + LINE_G_CLASS)
                .data(lines, function(d){return d.className});

            var areaG = this._areaG
                .selectAll('g.' + AREA_G_CLASS)
                .data(lines, function(d){return d.className});

            var defsG = this._defsG
                .selectAll('defs')
                .data(lines, function(d){
                    return d.className;
                });

            defsG
                .selectAll('clipPath')
                .data(function(d){
                    return d.dataBands;
                });

            areaG
                .selectAll('path')
                .data(function(d){
                    return d.dataBands;
                });

            lineG.select('g.' + PATH_G)
                .selectAll('path')
                .data(function(d){
                    return d.dataBands;
                });

            lineG.select('g.' + AREA_G)
                .selectAll('path')
                .data(function(d){
                    return d.dataBands;
                });

            return {
                defsG:defsG,
                areaG:areaG,
                lineG:lineG
            };
        },

        _createNewLineSeries:function(g){

            var g = this._updateDataBinding();
            var defsG = g.defsG;
            var areaG = g.areaG;
            var lineG = g.lineG;
            var self = this;

            var animationTime = this.component.isSupportAnimation() ? LINE_SHOW_TIME : 0;

            defsG
                .enter()
                .append('defs')
                .selectAll('clipPath')
                .data(function(d){
                    return d.dataBands;
                })
                .enter()
                .append('clipPath')
                .attr('id', function(d){
                    return d.clipID;
                })
                .append('rect')
                .attr('x', function(d){
                    return d.x;
                })
                .attr('y', function(d){
                    return d.y;
                })
                .attr('width', 0)
                .attr('height', function(d){
                    return d.height;
                })
                .transition()
                .ease('quad-in-out')
                .duration(animationTime)
                .attr('width', function(d){
                    return d.width;
                });

            if(this.component.componentType == Constants.AREA_CHART){

                var enterArea = areaG.enter()
                    .append('g')
                    .attr('class', function(d){
                        return AREA_G_CLASS + ' ' + (d.className);
                    });

                enterArea
                    .selectAll('path')
                    .data(function(d){
                        return d.dataBands;
                    })
                    .enter()
                    .append('path')
                    .filter(function(d){
                        return d.lineData.isStack;
                    })
                    .style('fill', function(d){
                        return d.fillColor;
                    })
                    .style('fill-opacity', function(d){
                        return d.fillColorOpacity;
                    })
                    .style('stroke', 'none')
                    .attr('d', function(d){
                        var lineData = d.lineData;
                        return lineData.areaSvg(lineData.points);
                    })
                    .attr('clip-path', function(d){
                        return "url(#"  + d.clipID +")";
                    });

                this.addSeriesEventHandler(enterArea);
            }

            var enterG = lineG.enter()
                .append('g')
                .attr('class', function(d){
                    return LINE_G_CLASS + ' ' + (d.className);
                });

            enterG.append('g')
                .attr('class', PATH_G)
                .selectAll('path')
                .data(function(d){
                    return d.dataBands;
                })
                .enter()
                .append('path')
                .style('fill', 'none')
                .style('stroke', function(d){
                    return d.color;
                })
                .style('stroke-width', function(d){
                    return d.lineData.lineWidth;
                })
                .attr('d', function(d){
                    var lineData = d.lineData;
                    return lineData.lineSvg(lineData.points);
                })
                .attr('clip-path', function(d){
                    return "url(#"  + d.clipID +")";
                });

            this.addSeriesEventHandler(enterG);

            if(this.component.componentType == Constants.AREA_CHART){
                enterG.append('g')
                    .attr('class', AREA_G)
                    .selectAll('path')
                    .data(function(d){
                        return d.dataBands;
                    })
                    .enter()
                    .append('path')
                    .filter(function(d){
                        return !d.lineData.isStack;
                    })
                    .style('fill', function(d){
                        return d.fillColor;
                    })
                    .style('fill-opacity', function(d){
                        return d.fillColorOpacity;
                    })
                    .style('stroke', 'none')
                    .attr('d', function(d){
                        var lineData = d.lineData;
                        return lineData.areaSvg(lineData.points);
                    })
                    .attr('clip-path', function(d){
                        return "url(#"  + d.clipID +")";
                    });
            }

            if(this.component.isSupportAnimation()){
                enterG
                    .append('g')
                    .attr('class', MARKER_G_CLASS)
                    .selectAll('g')
                    .data(function(d){ return d.points.filter(function(d){return !d.isNull}); })
                    .call(this._createSvgMarker.bind(this))
                    .attr('transform', function(d){
                        return 'translate('+ d.x +','+ d.y +') scale(0.01)';
                    })
                    .transition()
                    .delay(function(d){return d.delay})
                    .duration(150)
                    .ease('ease-out-in')
                    .attr('transform', function(d){
                        return 'translate('+ d.x +','+ d.y +') scale(1.5)';
                    })
                    .transition()
                    .duration(150)
                    .ease('ease-out-in')
                    .attr('transform', function(d){
                        return 'translate('+ d.x +','+ d.y +') scale(1)';
                    });
            }else{
                enterG
                    .append('g')
                    .attr('class', MARKER_G_CLASS)
                    .selectAll('g')
                    .data(function(d){return d.points;})
                    .call(this._createSvgMarker.bind(this))
                    .attr('transform', function(d){
                        return 'translate('+ d.x +','+ d.y +')';
                    });
            }
        },

        _createImageMarker:function(src, callBack){
            var img = new Image();
            img.onload = function() {
                callBack(this.width, this.height);
            };
            img.src = src;
        },

        seriesMouseOver:function(event){

            if(event && event.target){

                var d = event.target.datum();

                var seriesClass = d.className;

                this._lineG.select('g.' + seriesClass).select('g.' + AREA_G)
                    .selectAll('path').transition(Constants.SELECT_ANIMATION).duration(100).ease('swing')
                    .style('fill', function(d){
                        return ColorUtils.getHighLightColor(d.fillColor);
                    })
                    .style('fill-opacity', CHOSEN_AREA_ALPHA);

                this._lineG.select('g.' + seriesClass).select('g.' + PATH_G)
                    .selectAll('path').transition(Constants.SELECT_ANIMATION).duration(100).ease('swing')
                    .style('stroke', function(d){
                        return ColorUtils.getHighLightColor(d.color);
                    })
                    .style('stroke-width', function(d){
                        return d.lineData.lineWidth + 1;
                    });

                BaseUtils.toFront(this._lineG.select('g.' + seriesClass).node());

                this._areaG.select('g.' + seriesClass)
                    .selectAll('path').transition(Constants.SELECT_ANIMATION).duration(100).ease('swing')
                    .style('fill', function(d){
                        return ColorUtils.getHighLightColor(d.fillColor);
                    })
                    .style('fill-opacity', CHOSEN_AREA_ALPHA);
            }
        },

        seriesMouseOut:function(event){

            if(event && event.target){

                var d = event.target.datum();

                var seriesClass = d.className;

                this._lineG.select('g.' + seriesClass).select('g.' + AREA_G)
                    .selectAll('path').transition(Constants.SELECT_ANIMATION).duration(100).ease('swing')
                    .style('fill', function(d){
                        return d.fillColor;
                    })
                    .style('fill-opacity', function(d){
                        return d.fillColorOpacity;
                    });

                this._lineG.select('g.' + seriesClass).select('g.' + PATH_G)
                    .selectAll('path').transition(Constants.SELECT_ANIMATION).duration(100).ease('swing')
                    .style('stroke', function(d){
                        return d.color;
                    })
                    .style('stroke-width', function(d){
                        return d.lineData.lineWidth;
                    });

                this._areaG.select('g.' + seriesClass)
                    .selectAll('path').transition(Constants.SELECT_ANIMATION).duration(100).ease('swing')
                    .style('fill', function(d){
                        return d.fillColor;
                    })
                    .style('fill-opacity', function(d){
                        return d.fillColorOpacity;
                    });
            }
        },

        mouseOver:function(event){
            if(event && event.target){
                var d = event.target.datum();
                this._makeMarkerChosenState(event.target, d);
            }
        },

        mouseOut:function(event){
            if(event && event.target){
                var d = event.target.datum();
                this._cancelMarkerChosenState(event.target, d);
            }
        },

        mouseDown:function(event){
            if(event && event.target){
                var d = event.target.datum();
                this._makeMarkerClickedState(event.target, d);
            }
        },

        mouseUp:function(event){
            if(event && event.target){
                var d = event.target.datum();
                this._cancelMarkerClickedState(event.target, d);
            }
        }
    });

    require('./RenderLibrary').register(Constants.LINE_SVG, LineSvgRender);

    return LineSvgRender;

});
/**
 * Created by eason on 15/11/6.
 */
define('render/AreaSvgRender',['require','../Constants','./LineSvgRender','./RenderLibrary'],function(require){

    var Constants = require('../Constants');
    var LineSvgRender = require('./LineSvgRender');

    var AreaSvgRender = LineSvgRender.extend({});

    require('./RenderLibrary').register(Constants.AREA_SVG, AreaSvgRender);
});
/**
 * Created by eason on 15/12/2.
 */

define('render/GaugeSvgRender',['require','../utils/BaseUtils','../utils/ColorUtils','../Constants','./BaseRender','../utils/BoundsManager','./RenderLibrary'],function(require){

    var BaseUtils = require('../utils/BaseUtils');
    var ColorUtils = require('../utils/ColorUtils');
    var Constants = require('../Constants');
    var BaseRender = require('./BaseRender');
    var BoundsManager = require('../utils/BoundsManager');

    var ANIMATION_TIME = 1000;
    var THERMOMETER_R = 5;
    var MAGIC_DET = 0.001;
    var EASE_TYPE = 'quad-out';

    var GAUGE = 'gauge-class';

    var POINTER_HINGE_BACKGROUND = 'pointer-hinge-background';
    var POINTER_HINGE = 'pointer-hinge';
    var SLOT_BACKGROUND = 'slot-background';
    var THERMOMETER_BACKGROUND = 'thermometer-background';
    var RING_INNER_BACKGROUND = 'ring-inner-background';
    var RING_INNER_STROKE = 'ring-inner-stroke';
    var RING_OUTER_STROKE = 'ring-outer-stroke';
    var RING_ARC_PATH = 'ring-arc-path';

    var NEEDLE = 'gauge-needle';
    var BACKGROUND = 'gauge-background';
    var GAUGE_LABEL = 'gauge-label';
    var GAUGE_AXIS = 'gauge-axis';

    var GaugeSvgRender = BaseRender.extend({
        render:function(){

            var plotBounds = this.component.vanchart.plotOriginalBounds;
            var svgRoot = this.component.getVanchartRender().getRenderRoot();

            this._bodyG = this._bodyG || svgRoot.append('g');
            this._bodyG.attr('transform', 'translate('+plotBounds.x+','+plotBounds.y+')');
            this._bodyG.select('defs').remove();
            this._createDefs();

            this.labelDivManager.clearAllLabels();

            var data = this.component.getVisibleChartData();

            var gaugeS = this._bodyG
                .selectAll('g.' + GAUGE).data(data, function(d){
                    return GAUGE + ' ' + d.className;
                });

            gaugeS.exit().remove();

            gaugeS
                .attr('class', function(d){
                    return GAUGE + ' ' + d.className;
                })
                .call(this._updateGauge.bind(this))
                .transition()
                .duration(ANIMATION_TIME)
                .ease(EASE_TYPE)
                .attr('transform', function(d){
                    return 'translate(' + d.centerX + ',' + d.centerY + ')';
                });

            this.addSeriesEventHandler(gaugeS);

            gaugeS
                .enter()
                .append('g')
                .attr('class', function(d){
                    return GAUGE + ' ' + d.className;
                })
                .attr('transform', function(d){

                    return 'translate(' + Math.round(d.centerX) + ',' + Math.round(d.centerY) + ')';
                })
                .call(this._createGauge.bind(this));
        },

        _createDefs:function(){
            var defs= this._bodyG.append('defs');

            this._createVerticalLinearGradient(defs, this._getRingGradualID(), '#ffffff', '#dddddd');
            this._createVerticalLinearGradient(defs, this._getRingClickedGradualID(), '#dddddd', '#ffffff');

            var self = this;
            var gaugeData = this.component.getVisibleChartData();
            gaugeData.forEach(function(gauge){

                var point = gauge.points[0];

                if(!point){
                    return;
                }

                if(gauge.style == Constants.GAUGE_THERMOMETER){
                    var endColor = point.color;
                    var startColor = ColorUtils.mixColorWithHSB(endColor, 0, -0.1, 0.1);

                    var endColorClicked = ColorUtils.getColorWithDivider(endColor, 1/0.95);
                    var startColorClicked = ColorUtils.mixColorWithHSB(endColor, 0, -0.1, 0.1);

                    var endColorMouseOver = ColorUtils.getColorWithDivider(point.mouseOverColor, 1/0.95);
                    var startColorMouseOver = ColorUtils.mixColorWithHSB(point.mouseOverColor, 0, -0.1, 0.1);

                    if(gauge.thermometerLayout == Constants.HORIZONTAL_LAYOUT){

                        self._createHorizontalLinearGradient(defs, self._getThermometerGradualID(gauge), startColor, endColor);
                        self._createHorizontalLinearGradient(defs, self._getThermometerClickedGradualID(gauge), startColorClicked, endColorClicked);
                        self._createHorizontalLinearGradient(defs,  self._getThermometerMouseOverGradualID(gauge), startColorMouseOver, endColorMouseOver)

                    }else{

                        self._createVerticalLinearGradient(defs, self._getThermometerGradualID(gauge), endColor, startColor);
                        self._createVerticalLinearGradient(defs, self._getThermometerClickedGradualID(gauge), endColorClicked, startColorClicked);
                        self._createVerticalLinearGradient(defs,  self._getThermometerMouseOverGradualID(gauge), endColorMouseOver, startColorMouseOver)

                    }
                }else if(gauge.style == Constants.GAUGE_POINTER || gauge.style == Constants.GAUGE_POINTER_SEMI){

                    self._createDropShadowFilter(defs, self._getPointerDropShadowID(), 0, 2, 0.1, 2);
                    self._createInnerShadowFilter(defs, self._getPointerInnerShadowID(), 0, 2, 0.1, 2);

                }else if(gauge.style == Constants.GAUGE_SLOT){
                    self._createDropShadowFilter(defs, self._getSlotDropShadowID(), 0, 2, 0.05, 0);
                    self._createInnerShadowFilter(defs, self._getSlotInnerShadowID(), 0, 2, 0.05, 0);
                }

            });
        },

        _removeGaugeLabels:function(gaugeG){
            var labelG = gaugeG.select('g.' + GAUGE_LABEL);

            labelG.selectAll('text').remove();
            labelG.selectAll('rect').remove();
        },

        _createGauge:function(gaugeG){

            var self = this;

            gaugeG.each(function(d){

                var style = d.style;
                var gSelection = d3.select(this);

                self.addSeriesEventHandler(gSelection);

                switch (style){
                    case Constants.GAUGE_POINTER:
                        gSelection.append('path').attr('class', BACKGROUND);
                        gSelection.append('path').attr('class', POINTER_HINGE_BACKGROUND);
                        gSelection.append('g').attr('class', GAUGE_LABEL);
                        gSelection.append('g').attr('class', GAUGE_AXIS);
                        gSelection.append('g').attr('class', NEEDLE);
                        gSelection.append('path').attr('class', POINTER_HINGE);

                        self._createPointerCircle(gSelection, d);
                        break;

                    case Constants.GAUGE_POINTER_SEMI:
                        gSelection.append('path').attr('class', BACKGROUND);
                        gSelection.append('path').attr('class', POINTER_HINGE_BACKGROUND);
                        gSelection.append('g').attr('class', GAUGE_LABEL);
                        gSelection.append('g').attr('class', GAUGE_AXIS);
                        gSelection.append('g').attr('class', NEEDLE);
                        gSelection.append('path').attr('class', POINTER_HINGE);
                        self._createPointerSemi(gSelection, d);
                        break;

                    case Constants.GAUGE_SLOT:
                        gSelection.append('path').attr('class', BACKGROUND);
                        gSelection.append('path').attr('class', SLOT_BACKGROUND);
                        gSelection.append('circle').attr('class', NEEDLE);
                        gSelection.append('g').attr('class', GAUGE_LABEL);

                        self._createSlot(gSelection, d);
                        break;

                    case Constants.GAUGE_THERMOMETER:

                        gSelection.append('line').attr('class', BACKGROUND);
                        gSelection.append('line').attr('class', THERMOMETER_BACKGROUND);
                        gSelection.append('circle').attr('class', NEEDLE);
                        gSelection.append('g').attr('class', GAUGE_AXIS);
                        gSelection.append('g').attr('class', GAUGE_LABEL);

                        self._createThermometer(gSelection, d);
                        break;

                    case Constants.GAUGE_RING:
                        gSelection.append('path').attr('class', BACKGROUND);
                        gSelection.append('path').attr('class', RING_ARC_PATH);
                        gSelection.append('path').attr('class', RING_INNER_BACKGROUND);
                        gSelection.append('path').attr('class', RING_INNER_STROKE);
                        gSelection.append('path').attr('class', RING_OUTER_STROKE);
                        gSelection.append('g').attr('class', GAUGE_LABEL);

                        self._createRing(gSelection, d);
                        break;
                }

            });
        },

        _updateGauge:function(gaugeG){
            var self = this;

            gaugeG.each(function(d){

                var style = d.style;
                var gSelection = d3.select(this);

                self._removeGaugeLabels(gSelection);

                switch (style){
                    case Constants.GAUGE_POINTER:
                        self._createPointerCircle(gSelection, d);
                        break;

                    case Constants.GAUGE_POINTER_SEMI:
                        self._createPointerSemi(gSelection, d);
                        break;

                    case Constants.GAUGE_SLOT:
                        self._createSlot(gSelection, d);
                        break;

                    case Constants.GAUGE_THERMOMETER:
                        self._createThermometer(gSelection, d);
                        break;

                    case Constants.GAUGE_RING:
                        self._createRing(gSelection, d);
                        break;
                }

            });

        },

        _createPointerCircle:function(gaugeG, d){
            this._createPointer(gaugeG, d, 180, 150, 0.16, 0.07);
        },

        _createPointerSemi:function(gaugeG, d){
            this._createPointer(gaugeG, d, 98, 90, 0.11, 0.055);
        },

        _createPointer:function(gaugeG, d, baseAngle, scaleAngle, hBackground, hinge){

            var circle = d3.svg.arc().startAngle(0).endAngle(2 * Math.PI).innerRadius(0);

            var arc = d3.svg.arc().startAngle(BaseUtils.toRadian(-baseAngle))
                .endAngle(BaseUtils.toRadian(baseAngle))
                .innerRadius(0).outerRadius(d.radius).toCenter(false);

            var domain = d.gaugeAxis.scale.domain();
            var scale = d3.scale.linear().domain(domain)
                .range([BaseUtils.toRadian(-scaleAngle), BaseUtils.toRadian(scaleAngle)]);

            gaugeG
                .select('path.' + BACKGROUND)
                .attr('d', arc())
                .style('fill', d.paneBackgroundColor)
                .style('fill-opacity', ColorUtils.getColorOpacity(d.paneBackgroundColor))

            this._addFilter(gaugeG.select('path.' + BACKGROUND), this._getPointerDropShadowID());

            //枢纽背景
            circle.outerRadius(hBackground * d.radius);
            gaugeG
                .select('path.' + POINTER_HINGE_BACKGROUND)
                .attr('d', circle())
                .style('fill', d.hingeBackgroundColor)
                .style('fill-opacity', ColorUtils.getColorOpacity(d.hingeBackgroundColor));

            this._addFilter(gaugeG.select('path.' + POINTER_HINGE_BACKGROUND), this._getPointerInnerShadowID());

            this._drawGaugeLabels(gaugeG, d);

            this._drawPointerTicks(gaugeG, d, scale);

            this._drawPointerArrow(gaugeG, d, scale);

            //枢纽
            circle.outerRadius(hinge * d.radius);
            gaugeG
                .select('path.' + POINTER_HINGE)
                .attr('d', circle())
                .style('fill', d.hinge)
                .style('fill-opacity', ColorUtils.getColorOpacity(d.hinge));

            this._addFilter(gaugeG.select('path.' + POINTER_HINGE), this._getPointerDropShadowID());
        },

        _drawPointerArrow:function(gaugeG, d, scale){

            var pointerG = gaugeG.select('g.' + NEEDLE);

            var self = this;
            var domain = scale.domain();

            var arrows = pointerG
                .selectAll('path').data(d.points);

            arrows.enter().append('path');

            arrows.exit().remove();

            this.addShapeEventHandler(arrows);

            arrows.each(function(point){

                var pointer = d3.select(this);

                var rotate = self._getRotate(pointer);

                var initRadian = self.component.isSupportAnimation() ? scale(domain[0]) : scale(point.valueInDomain);

                var endRadian = scale(point.valueInDomain);

                var endDegree = BaseUtils.toDegree(endRadian - initRadian);

                pointer
                    .attr('d', self._getArrowPath(d.radius, initRadian))
                    .style('cursor', 'pointer')
                    .style('fill', d.needle)
                    .style('fill-opacity', ColorUtils.getColorOpacity(d.needle))
                    .transition()
                    .duration(ANIMATION_TIME)
                    .ease(EASE_TYPE)
                    .attrTween('transform', function(){

                        var interpolate = d3.interpolate(rotate, endDegree);

                        return function(t){
                            return "rotate(" + interpolate(t) + ")";
                        }
                    });

                self._addFilter(pointer, self._getPointerDropShadowID(), ANIMATION_TIME)
            });
        },


        //todo iie10直接加阴影会导致指针不显示
        _addFilter:function(selection, filterID, delay){
            delay = delay || 0;
            delay += 100;
            setTimeout(function(){
                if(selection){
                    selection.style("filter", 'url(#'+ filterID +')')
                }
            }, delay)
        },

        _getRotate:function(selectionG){

            var transform = selectionG.attr('transform');

            if(transform){
                var startIndex = transform.indexOf('(');
                if(startIndex != -1){
                    return parseFloat(transform.substr(startIndex + 1));
                }
            }

            return 0;

        },

        _getArrowPath:function(radius, initRadian){

            var p0 = this._getArcPoint(0.9 * radius, initRadian);

            var p1 = this._getArcPoint(0.02 * radius, initRadian + Math.PI/2);

            var p2 = this._getArcPoint(0.02 * radius, initRadian - Math.PI/2);

            return 'M' + p0[0] + ',' + p0[1] + 'L' + p1[0] + ',' + p1[1] + 'L' + p2[0] + ',' + p2[1] + 'Z';

        },

        _drawPointerTicks:function(gaugeG, d, scale){

            var axisG = gaugeG.select('g.' + GAUGE_AXIS);

            var tickData = d.gaugeAxis.getTickData();

            var axisOption = d.gaugeAxis.componentOption;
            var labelStyle = axisOption.labelStyle;
            var useHtml = axisOption.useHtml;

            var minorTickData = d.gaugeAxis.getMinorTickData();

            var self = this;

            var tickR = (1 - 0.05) * d.radius;
            var labelR = (1 - 0.05 - 0.1 - 0.01) * d.radius;

            var bands = d.bands;
            var plotBounds = this.component.getPlotBounds();
            var transX = plotBounds.x + d.centerX;
            var transY = plotBounds.y + d.centerY;

            var tick = axisG.selectAll("g.tick").data(tickData, function(d){
                return scale(d.tickValue);
            });

            tick.exit().remove();

            var enterTick = tick.enter().append('g').attr('class', 'tick');
            enterTick.append('text');
            enterTick.append('line');

            tick.each(function(tickD){

                var tickG = d3.select(this);

                var radian = scale(tickD.tickValue);
                var start = self._getArcPoint(tickR, radian);
                var end = self._getArcPoint(tickR - 0.1 * d.radius, radian);

                var color = self.component._getColorFromBands(tickD.tickValue, bands);

                tickG
                    .select('line')
                    .attr('x1', start[0])
                    .attr('y1', start[1])
                    .attr('x2', end[0])
                    .attr('y2', end[1])
                    .attr('stroke', color);

                var center = self.component._getPointerTickCenter(tickD, labelR, scale);

                if(useHtml){

                    var labelPos = {
                        x:transX + center.x - tickD.tickDim.width/2,
                        y:transY + center.y - tickD.tickDim.height/2
                    };
                    self.labelDivManager.addLabel(tickD.tickContent, labelPos, labelStyle);

                }else{
                    tickG
                        .select('text')
                        .attr('x', center.x)
                        .attr('y', center.y)
                        .attr('dy', '.35em')
                        .attr("text-anchor", "middle")
                        .text(tickD.tickContent)
                        .call(BaseUtils.setTextStyle, labelStyle);
                }

            });

            var minorTick = axisG.selectAll("line.minorTick")
                .data(minorTickData, function(d){return scale(d);});

            minorTick.enter().append('line').attr('class', 'minorTick');

            minorTick.exit().remove();

            minorTick.each(function(value){

                var radian = scale(value);
                var start = self._getArcPoint(tickR, radian);
                var end = self._getArcPoint(tickR - 0.05 * d.radius, radian);

                var color = self.component._getColorFromBands(value, bands);

                d3.select(this)
                    .attr('x1', start[0])
                    .attr('y1', start[1])
                    .attr('x2', end[0])
                    .attr('y2', end[1])
                    .attr('stroke', color);
            });

        },

        _getArcPoint:function(r, radian){
            return [r * Math.sin(radian), -r * Math.cos(radian)]
        },

        _createSlot:function(gaugeG, d){

            var arc = d3.svg.arc().startAngle(BaseUtils.toRadian(-135))
                .endAngle(BaseUtils.toRadian(135))
                .innerRadius(0).outerRadius(d.radius)
                .toCenter(false).closePath(false);

            var circle = d3.svg.arc().startAngle(BaseUtils.toRadian(-135))
                .endAngle(BaseUtils.toRadian(135))
                .innerRadius(0).outerRadius(d.radius)
                .toCenter(false).closePath(false);

            var domain = d.gaugeAxis.scale.domain();
            var scale = d3.scale.linear().domain(domain)
                .range([BaseUtils.toRadian(-135), BaseUtils.toRadian(135)]);

            var point = d.points[0];

            if(!point){
                return;
            }

            var initRadian = scale(domain[0]);
            var endRadian = scale(point.valueInDomain);
            var startStroke = this.component._getColorFromBands(domain[0], d.bands);
            var endStroke = point.color;

            var lastRotate = this._getRotate(gaugeG.select('circle.' + NEEDLE));

            var lastStroke = gaugeG.select('path.' + SLOT_BACKGROUND).attr('lastStroke');
            startStroke = BaseUtils.isEmpty(lastStroke) ? startStroke : lastStroke;

            if(!this.component.isSupportAnimation()){
                initRadian = endRadian;
                startStroke = endStroke;
            }

            gaugeG
                .select('path.' + BACKGROUND)
                .attr('d', circle())
                .style({
                    'fill':'none',
                    'stroke': d.slotBackgroundColor,
                    'stroke-linecap':'round',
                    'stroke-width': d.radius * 0.16
                });

            this._addFilter(gaugeG.select('path.' + BACKGROUND), this._getSlotInnerShadowID());

            gaugeG
                .select('path.' + SLOT_BACKGROUND)
                .attr('lastStroke', endStroke)
                .style({
                    'fill':'none',
                    'stroke': ColorUtils.colorToHex(startStroke),
                    'stroke-linecap':'round',
                    'stroke-width': d.radius * 0.16
                })
                .transition()
                .duration(ANIMATION_TIME)
                .ease(EASE_TYPE)
                .attrTween('d', function(){

                    var interpolate = d3.interpolate(initRadian + BaseUtils.toRadian(lastRotate), endRadian);

                    return function(t){
                        return arc.endAngle(interpolate(t))();
                    }
                })
                .style('stroke', ColorUtils.colorToHex(endStroke));

            //白色指针
            var cP = this._getArcPoint(d.radius, initRadian);
            gaugeG
                .select('circle.' + NEEDLE)
                .attr('cx', cP[0])
                .attr('cy', cP[1])
                .attr('r', 0.048 * d.radius)
                .style('fill', d.needle)
                .style('fill-opacity', ColorUtils.getColorOpacity(d.needle))
                .transition()
                .duration(ANIMATION_TIME)
                .ease(EASE_TYPE)
                .attrTween('transform', function(){

                    var interpolate = d3.interpolate(lastRotate, BaseUtils.toDegree(endRadian - initRadian));

                    return function(t){
                        return "rotate(" + interpolate(t) + ")";
                    }
                });

            this._addFilter(gaugeG.select('circle.' + NEEDLE), this._getSlotDropShadowID(), ANIMATION_TIME);

            this._drawGaugeLabels(gaugeG, d);
        },

        _createThermometer:function(gaugeG, d){

            var domain = d.gaugeAxis.scale.domain();
            var point = d.points[0];

            if(!point){
                return;
            }

            var valueInDomain = point.valueInDomain;
            var color = point.color;
            var radius = d.radius;
            var scale = d3.scale.linear()
                .domain(domain).range([-radius, radius]);

            var x1 = 'x1', y1 = 'y1', x2 = 'x2', y2 = 'y2';
            var cx = 'cx', cy = 'cy';

            var endX = scale(valueInDomain);
            var initX = -radius;

            if(d.thermometerLayout == Constants.VERTICAL_LAYOUT){
                x1 = 'y1'; y1 = 'x1'; x2 = 'y2'; y2 = 'x2';
                cx = 'cy'; cy = 'cx';
                initX = radius;
                endX = scale.range([radius, -radius])(valueInDomain);
            }

            gaugeG.select('line.' + BACKGROUND)
                .attr(x1, -radius)
                .attr(y1, 0)
                .attr(x2, radius)
                .attr(y2, 0)
                .style({
                    'fill':'none',
                    'stroke': d.slotBackgroundColor,
                    'stroke-width':THERMOMETER_R * 2,
                    'stroke-linecap':'round'
                });

            if(this.component.isSupportAnimation()){

                var lastX = gaugeG.select('line.' + THERMOMETER_BACKGROUND).attr(x2) || initX;
                lastX = parseFloat(lastX);

                gaugeG
                    .select('line.' + THERMOMETER_BACKGROUND)
                    .attr(x1, initX)
                    .attr(y1, 0)
                    .attr(x2, lastX)
                    .attr(y2, MAGIC_DET)
                    .style({
                        stroke:"url(#" + this._getThermometerGradualID(d) + ")",
                        'stroke-width':THERMOMETER_R * 2,
                        'stroke-linecap':'round'
                    })
                    .transition()
                    .duration(ANIMATION_TIME)
                    .ease(EASE_TYPE)
                    .attr(x2, endX);

                gaugeG
                    .select('circle.' + NEEDLE)
                    .attr(cx, lastX)
                    .attr(cy, 0)
                    .attr('r', THERMOMETER_R * 0.9)
                    .style({
                        'fill': d.needle,
                        'fill-opacity':ColorUtils.getColorOpacity(d.needle),
                        'stroke-width': THERMOMETER_R * 0.6,
                        'stroke':ColorUtils.mixColorWithHSB(color, 0, 0.1, -0.1)
                    })
                    .transition()
                    .duration(ANIMATION_TIME)
                    .ease(EASE_TYPE)
                    .attr(cx, endX);
            }else{
                gaugeG
                    .select('line.' + THERMOMETER_BACKGROUND)
                    .attr(x1, initX)
                    .attr(y1, 0)
                    .attr(x2, endX)
                    .attr(y2, MAGIC_DET)
                    .style({
                        stroke:"url(#" + this._getThermometerGradualID(d) + ")",
                        'stroke-width':THERMOMETER_R * 2,
                        'stroke-linecap':'round'
                    });

                gaugeG
                    .select('circle.' + NEEDLE)
                    .attr(cx, endX)
                    .attr(cy, 0)
                    .attr('r', THERMOMETER_R * 0.9)
                    .style({
                        'fill': d.needle,
                        'fill-opacity':ColorUtils.getColorOpacity(d.needle),
                        'stroke-width': THERMOMETER_R * 0.6,
                        'stroke':ColorUtils.mixColorWithHSB(color, 0, 0.1, -0.1)
                    });
            }

            this._drawGaugeLabels(gaugeG, d);
            this._drawThermometerTicks(gaugeG, d, scale);
        },

        _drawThermometerTicks:function(gaugeG, d, scale){

            var axisG = gaugeG.select('g.' + GAUGE_AXIS);

            var tickData = d.gaugeAxis.getTickData();

            var axisOption = d.gaugeAxis.componentOption;
            var labelStyle = axisOption.labelStyle;
            var useHtml = axisOption.useHtml;

            var plotBounds = this.component.getPlotBounds();
            var transX = plotBounds.x + d.centerX;
            var transY = plotBounds.y + d.centerY;

            var minorTickData = d.gaugeAxis.getMinorTickData();

            var x1 = 'x1', y1 = 'y1', x2 = 'x2', y2 = 'y2';
            var dx = 'dx';
            var x = 'x', y = 'y';

            var startY = -9, endY = -15, endMinorY = -13;
            var textAnchor = 'middle', textY = -19;
            var detX = '0em';

            if(d.thermometerLayout == Constants.VERTICAL_LAYOUT){
                x1 = 'y1'; y1 = 'x1'; x2 = 'y2'; y2 = 'x2';
                dx = 'dy';
                x = 'y'; y = 'x';
                startY = 9; endY = 15; endMinorY = 13;
                textAnchor = 'start'; textY = 19;
                detX = '.35em';
            }

            var tickS = axisG.selectAll("g.tick").data(tickData, function(d){
                return scale(d.tickValue);
            });

            tickS.exit().remove();

            var enterTick = tickS.enter().append('g').attr('class', 'tick');
            enterTick.append('text');
            enterTick.append('line');

            var self = this;

            tickS.each(function(tick) {

                var tickG = d3.select(this);
                var posX = scale(tick.tickValue);


                posX = BaseUtils.lineSubPixelOpt(posX,1);

                tickG
                    .select('line')
                    .attr(x1, posX)
                    .attr(y1, startY)
                    .attr(x2, posX)
                    .attr(y2, endY)
                    .style('stroke', axisOption.tickColor)
                    .style('stork-width', axisOption.tickWidth);

                if (useHtml) {
                    var labelPos;
                    if (d.thermometerLayout == Constants.HORIZONTAL_LAYOUT) {

                        labelPos = {
                            x: transX + posX - tick.tickDim.width / 2,
                            y: transY + textY - tick.tickDim.height
                        }

                    } else {

                        labelPos = {
                            x: transX + textY,
                            y: transY + posX - tick.tickDim.height / 2
                        }

                    }

                    self.labelDivManager.addLabel(tick.tickContent, labelPos, labelStyle);
                }else{
                    tickG
                        .select('text')
                        .attr(x, posX)
                        .attr(y, textY)
                        .attr("text-anchor", textAnchor)
                        .attr(dx, detX)
                        .text(tick.tickContent)
                        .call(BaseUtils.setTextStyle, labelStyle);
                }


            });

            var minorTick = axisG.selectAll("line.minorTick")
                .data(minorTickData, function(d){return scale(d);});

            minorTick.enter().append('line').attr('class', 'minorTick');

            minorTick.exit().remove();

            minorTick.each(function(value){

                var posX = scale(value);

                posX = BaseUtils.lineSubPixelOpt(posX,1);

                d3.select(this)
                    .attr(x1, posX)
                    .attr(y1, startY)
                    .attr(x2, posX)
                    .attr(y2, endMinorY)
                    .style('stroke', axisOption.minorTickColor)
                    .style('stork-width', axisOption.minorTickWidth);
            });
        },

        _createRing:function(gaugeG, d){

            var circle = d3.svg.arc()
                .startAngle(0).endAngle(2 * Math.PI)
                .innerRadius(0).outerRadius(d.radius);

            var arc = d3.svg.arc().startAngle(0)
                .innerRadius(0).outerRadius(d.radius);

            var domain = d.gaugeAxis.scale.domain();
            var point = d.points[0];

            if(!point){
                return;
            }

            var arcPercentage = Math.max(point.percentage, 0);
            var endRadian = 2 * Math.PI * arcPercentage * (d.clockwise ? 1 : -1);
            var startFill = this.component._getColorFromBands(domain[0], d.bands);
            var endFill = point.color;
            var innerR = d.radius * 0.8;
            var outerStrokeR = innerR + 2;
            var innerStrokeR = innerR - 1.5;

            gaugeG
                .select('path.' + BACKGROUND)
                .attr('d', circle())
                .style({
                    'fill':d.paneBackgroundColor,
                    'fill-opacity':ColorUtils.getColorOpacity(d.paneBackgroundColor)
                });

            if(this.component.isSupportAnimation()){

                var arcPath = gaugeG.select('path.' + RING_ARC_PATH);
                var lastRadian = arcPath.attr('lastRadian');
                if(BaseUtils.isEmpty(lastRadian)){
                    lastRadian = 0;
                }else{
                    startFill = arcPath.style('fill');
                    lastRadian = parseFloat(lastRadian);
                }

                arcPath
                    .style('fill', ColorUtils.colorToHex(startFill))
                    .style('fill-opacity', ColorUtils.getColorOpacity(startFill))
                    .transition()
                    .duration(ANIMATION_TIME)
                    .ease(EASE_TYPE)
                    .style('fill', ColorUtils.colorToHex(endFill))
                    .style('fill-opacity', ColorUtils.getColorOpacity(endFill))
                    .attrTween('d', function(){

                        var interpolate = d3.interpolate(lastRadian, endRadian);

                        return function(t){
                            return arc.endAngle(interpolate(t))();
                        }
                    })
                    .attr('lastRadian', endRadian);
            }else{
                gaugeG
                    .select('path.' + RING_ARC_PATH)
                    .style('fill', endFill)
                    .style('fill-opacity', ColorUtils.getColorOpacity(endFill))
                    .attr('d', arc.endAngle(endRadian)());
            }

            gaugeG
                .select('path.' + RING_INNER_BACKGROUND)
                .attr('d', circle.outerRadius(innerR)())
                .style('fill', d.innerPaneBackgroundColor)
                .style('fill-opacity', ColorUtils.getColorOpacity(d.innerPaneBackgroundColor));

            gaugeG
                .select('path.' + RING_OUTER_STROKE)
                .attr('d', circle.outerRadius(outerStrokeR))
                .style({
                    'fill': 'none',
                    'stroke':'#000000',
                    'stroke-opacity':0.05,
                    'stroke-width':4
                });

            gaugeG
                .select('path.' + RING_INNER_STROKE)
                .attr('d', circle.outerRadius(innerStrokeR))
                .style({
                    'fill': 'none',
                    'stroke':"url(#" + this._getRingGradualID() + ")",
                    'stroke-width':3
                });


            this._drawGaugeLabels(gaugeG, d);
        },

        _drawGaugeLabels:function(gaugeG, d){
            var labelG = gaugeG.select('g.' + GAUGE_LABEL);

            if(d.seriesLabelContent){
                this._drawLabel(labelG, d.seriesLabelContent, d.seriesLabelPos, d.seriesLabelDim,
                    d.seriesLabelStyle, d, d.seriesLabel.useHtml);
            }

            if(d.percentageLabelContent){
                this._drawLabel(labelG, d.percentageLabelContent, d.percentageLabelPos, d.percentageLabelDim,
                    d.percentageLabelStyle, d, d.percentageLabel.useHtml);
            }

            if(d.valueLabelContent && d.valueLabelContent.length){

                //指针类型的仪表盘值标签后面有背景
                if(d.valueLabelBackground){
                    labelG
                        .append('rect')
                        .attr('x', d.valueLabelBackground.x)
                        .attr('y', d.valueLabelBackground.y)
                        .attr('width', d.valueLabelBackground.width)
                        .attr('height', d.valueLabelBackground.height)
                        .attr('rx', d.radius * 0.02)
                        .attr('ry', d.radius * 0.02)
                        .style({
                            fill: d.valueLabel.backgroundColor,
                            'fill-opacity': ColorUtils.getColorOpacity(d.valueLabel.backgroundColor)
                        });

                    this._addFilter(labelG, this._getPointerInnerShadowID());
                }

                for(var i = 0, len = d.valueLabelContent.length; i < len; i++){
                    var valueLabel = d.valueLabelContent[i];
                    this._drawLabel(labelG, valueLabel.labelContent, valueLabel.labelPos, valueLabel.labelDim,
                        valueLabel.labelStyle, d, d.valueLabel.useHtml);
                }

            }

        },

        _drawLabel:function(pSelection, labelContent, labelPos, labelDim, labelStyle, gauge, useHtml){

            if(!labelPos){
                return;
            }

            if(useHtml){
                var plotBounds = this.component.getPlotBounds();
                var centerX = gauge.centerX;
                var centerY = gauge.centerY;

                labelPos = {
                    x:labelPos.x + centerX + plotBounds.x,
                    y:labelPos.y + centerY + plotBounds.y
                };

                this.labelDivManager.addLabel(labelContent, labelPos, labelStyle);

            }else{
                pSelection
                    .append('text')
                    .attr('text-anchor', 'middle')
                    .attr('dy', '0.85em')
                    .attr('x', labelPos.x + labelDim.width/2)
                    .attr('y', labelPos.y)
                    .text(labelContent)
                    .call(BaseUtils.setTextStyle, labelStyle);
            }
        },

        _getPointerInnerShadowID:function(){
            return this.component.vanchart.getIDPrefix() + Constants.GAUGE_POINTER + 'innerShadow';
        },

        _getPointerDropShadowID:function(){
            return this.component.vanchart.getIDPrefix() + Constants.GAUGE_POINTER + 'dropShadow';
        },

        _getSlotDropShadowID:function(){
            return this.component.vanchart.getIDPrefix() + Constants.GAUGE_SLOT + 'dropShadow';
        },

        _getSlotInnerShadowID:function(){
            return this.component.vanchart.getIDPrefix() + Constants.GAUGE_SLOT + 'innerShadow';
        },

        _getRingGradualID:function(){
            return this.component.vanchart.getIDPrefix() + Constants.GAUGE_RING;
        },

        _getRingClickedGradualID:function(){
            return this.component.vanchart.getIDPrefix() + Constants.GAUGE_RING + 'clicked';
        },

        _getThermometerGradualID:function(d){
            return this.component.vanchart.getIDPrefix() + d.className;
        },

        _getThermometerClickedGradualID:function(d){
            return this.component.vanchart.getIDPrefix() + d.className + 'clicked';
        },

        _getThermometerMouseOverGradualID:function(d){
            return this.component.vanchart.getIDPrefix() + d.className + 'mouseover';
        },

        seriesMouseOver:function(event){

            if(event && event.target){
                var gauge = event.target.datum();
                var d = gauge.points[0];
                var style = gauge.style;
                switch (style){
                    case Constants.GAUGE_POINTER:
                    case Constants.GAUGE_POINTER_SEMI:

                        break;
                    case Constants.GAUGE_RING:

                        event.target
                            .select('path.' + RING_ARC_PATH)
                            .style('fill', d.mouseOverColor);

                        break;
                    case Constants.GAUGE_SLOT:

                        var backgroundColor = ColorUtils.getHighLightColor(d.color);
                        var needleColor = ColorUtils.getHighLightColor(gauge.needle);

                        event.target
                            .select('path.' + SLOT_BACKGROUND)
                            .style('stroke', ColorUtils.colorToHex(backgroundColor));

                        event.target
                            .select('circle.' + NEEDLE).style('fill', needleColor);

                        break;
                    case Constants.GAUGE_THERMOMETER:

                        event.target
                            .select('line.' + THERMOMETER_BACKGROUND)
                            .style('stroke', "url(#" + this._getThermometerMouseOverGradualID(gauge) + ")");

                        event.target
                            .select('circle.' + NEEDLE)
                            .style('stroke', ColorUtils.getHighLightColor(d.color))
                            .style('fill', ColorUtils.getHighLightColor(gauge.needle));

                        break;
                }
            }
        },

        seriesMouseOut:function(event){
            if(event && event.target){
                var gauge = event.target.datum();
                var d = gauge.points[0];
                var style = gauge.style;

                switch (style){
                    case Constants.GAUGE_POINTER:
                    case Constants.GAUGE_POINTER_SEMI:

                        break;
                    case Constants.GAUGE_RING:

                        event.target
                            .select('path.' + RING_ARC_PATH)
                            .style('fill', d.color);

                        break;
                    case Constants.GAUGE_SLOT:

                        event.target
                            .select('path.' + SLOT_BACKGROUND)
                            .style('stroke', ColorUtils.colorToHex(d.color));

                        event.target
                            .select('circle.' + NEEDLE).style('fill', gauge.needle);

                        break;
                    case Constants.GAUGE_THERMOMETER:

                        event.target
                            .select('line.' + THERMOMETER_BACKGROUND)
                            .style('stroke', "url(#" + this._getThermometerGradualID(gauge) + ")");

                        event.target
                            .select('circle.' + NEEDLE)
                            .style('stroke', d.color)
                            .style('fill', gauge.needle);

                        break;
                }
            }
        },

        seriesMouseDown:function(event){
            if(event && event.target){
                var gauge = event.target.datum();
                var d = gauge.points[0];
                var style = gauge.style;
                var circle = d3.svg.arc().startAngle(0).endAngle(2 * Math.PI).innerRadius(0);

                switch (style){
                    case Constants.GAUGE_POINTER:
                    case Constants.GAUGE_POINTER_SEMI:

                        var hBackground = style == Constants.GAUGE_POINTER ? 0.16 : 0.11;
                        var hinge = style == Constants.GAUGE_POINTER ? 0.07 : 0.055;

                        circle.outerRadius(hBackground * d.series.radius * 1.25);
                        event.target.select('path.' + POINTER_HINGE_BACKGROUND).attr('d', circle());

                        //枢纽
                        circle.outerRadius(hinge * d.series.radius * 1.25);
                        event.target.select('path.' + POINTER_HINGE).attr('d', circle());

                        break;
                    case Constants.GAUGE_RING:

                        event.target
                            .select('path.' + RING_INNER_STROKE)
                            .style('stroke', "url(#" + this._getRingClickedGradualID() + ")");

                        event.target.select('path.' + RING_ARC_PATH).style('fill', d.clickColor);

                        break;
                    case Constants.GAUGE_SLOT:

                        var backgroundColor = ColorUtils.getColorWithDivider(d.color, 1/0.95);
                        var needleColor = ColorUtils.getColorWithDivider(gauge.needle, 1/0.95);

                        event.target
                            .select('path.' + SLOT_BACKGROUND)
                            .style('stroke', ColorUtils.colorToHex(backgroundColor));

                        event.target.select('circle.' + NEEDLE).style('fill', needleColor);

                        break;
                    case Constants.GAUGE_THERMOMETER:

                        event.target
                            .select('line.' + THERMOMETER_BACKGROUND)
                            .style('stroke', "url(#" + this._getThermometerClickedGradualID(gauge) + ")");

                        event.target
                            .select('circle.' + NEEDLE)
                            .style('stroke', ColorUtils.getClickColor(d.color))
                            .style('fill', ColorUtils.getClickColor(gauge.needle));

                        break;
                }
            }
        },

        seriesMouseUp:function(event){
            if(event && event.target){
                var gauge = event.target.datum();
                var d = gauge.points[0];
                var style = gauge.style;
                var circle = d3.svg.arc().startAngle(0).endAngle(2 * Math.PI).innerRadius(0);

                switch (style){
                    case Constants.GAUGE_POINTER:
                    case Constants.GAUGE_POINTER_SEMI:

                        var hBackground = style == Constants.GAUGE_POINTER ? 0.16 : 0.11;
                        var hinge = style == Constants.GAUGE_POINTER ? 0.07 : 0.055;

                        circle.outerRadius(hBackground * d.series.radius);
                        event.target.select('path.' + POINTER_HINGE_BACKGROUND).attr('d', circle());

                        //枢纽
                        circle.outerRadius(hinge * d.series.radius);
                        event.target.select('path.' + POINTER_HINGE).attr('d', circle());

                        break;
                    case Constants.GAUGE_RING:

                        event.target.select('path.' + RING_INNER_STROKE)
                            .style('stroke', "url(#" + this._getRingGradualID() + ")");

                        event.target.select('path.' + RING_ARC_PATH)
                            .style('fill', d.mouseOverColor);

                        break;
                    case Constants.GAUGE_SLOT:

                        var backgroundColor = ColorUtils.getHighLightColor(d.color);
                        var needleColor = ColorUtils.getHighLightColor(gauge.needle);

                        event.target
                            .select('path.' + SLOT_BACKGROUND)
                            .style('stroke', ColorUtils.colorToHex(backgroundColor));

                        event.target.select('circle.' + NEEDLE).style('fill', needleColor);

                        break;
                    case Constants.GAUGE_THERMOMETER:

                        event.target
                            .select('line.' + THERMOMETER_BACKGROUND)
                            .style('stroke', "url(#" + this._getThermometerMouseOverGradualID(gauge) + ")");

                        event.target
                            .select('circle.' + NEEDLE)
                            .style('stroke', ColorUtils.getHighLightColor(d.color))
                            .style('fill', ColorUtils.getHighLightColor(gauge.needle));

                        break;
                }
            }
        },

        _getSeriesTypes:function(){
            return BaseUtils.hasTouch() ? {
                'touchstart':this._seriesTouchStart,
                'forceTouchEnd':this._seriesTouchEnd
            } : {
                'mouseover':this._seriesMouseOver,
                'forceMouseOut':this._seriesMouseOut,
                'mousedown':this.seriesMouseDown,
                'mouseup':this.seriesMouseUp
            }
        }
    });

    require('./RenderLibrary').register(Constants.GAUGE_SVG, GaugeSvgRender);
});
/**
 * Created by eason on 15/12/31.
 */
define('render/RadarSvgRender',['require','./BaseRender','../utils/BaseUtils','../utils/LabelDivManager','../utils/ColorUtils','../Constants','./RenderLibrary'],function(require){

    var BaseRender = require('./BaseRender');
    var BaseUtils = require('../utils/BaseUtils');
    var LabelDivManager = require('../utils/LabelDivManager');
    var ColorUtils = require('../utils/ColorUtils');
    var Constants = require('../Constants');

    var CATEGORY_TEXT = 'category-axis-tick-text';
    var VALUE_TEXT = 'value-axis-tick-text';
    var GRID_LINE = 'axis-grid-line';
    var PLOT_BANDS = 'plot-bands';
    var PLOT_LINES = 'plot-lines';
    var VALUE_LINE = 'value-axis-line';
    var CATEGORY_LINE = 'category-axis-line';

    var RADAR_SERIES = 'radar-series';

    var SERIES_STROKE = 'series-stroke';
    var SERIES_FILL = 'series-fill';

    var COLUMN = 'radar-column';

    var ANIMATION_TIME = 500;
    var EASE = 'back-out';

    var EXIT_TIME = 500;
    var EXIT_EASE = 'exp-out';

    var AXIS_TIME = 300;

    var VALUE_TICK_GAP = 2;

    var RadarSvgRender = BaseRender.extend({
        render:function(){

            var svgRoot = this.component.getVanchartRender().getRenderRoot();

            if(!this._bodyG){
                this._bodyG = svgRoot.append('g');
                this._bodyG.append('defs').append('clipPath').attr('id', this._getRadarClipID());
            }

            this._updateTransform();

            this._drawRadarSeries();
        },

        _updateTransform:function(){

            var radarCenter = this.component.getRadarCenter();

            var maxValue = this.component.valueScale.domain()[1];

            var clipPath = this._bodyG.select('#' + this._getRadarClipID());

            clipPath.select('path').remove();

            clipPath.append('path').attr('d', this.component.valueAxis._getClipSeriesPath(maxValue));

            this._bodyG.attr('transform', BaseUtils.makeTranslate(radarCenter));
        },

        _drawRadarSeries:function(){

            var radarData = this.component.getVisibleChartData();

            var updateS = this._bodyG.selectAll('.' + RADAR_SERIES)
                .data(radarData, function(d){return d.className});

            this._deleteRadarSeries(updateS);

            this._updateRadarSeries(updateS);

            this._createRadarSeries(updateS);

            this._drawLabel(this.component.isSupportAnimation() ? ANIMATION_TIME : 0);
        },

        _deleteRadarSeries:function(updateS){

            var exitS = updateS.exit();

            this.component.isColumnType() ? this._deleteColumnTypeSeries(exitS)
                : this._deletePolygonTypeSeries(exitS);
        },

        _deleteColumnTypeSeries:function(exitS){

            var exitTime = this.component.isSupportAnimation() ? EXIT_TIME : 0;

            var self = this;
            exitS.each(function(d){
                var seriesG = d3.select(this);
                seriesG
                    .selectAll('path.' + COLUMN)
                    .transition()
                    .duration(exitTime)
                    .ease(EXIT_EASE)
                    .attrTween('d', function(d){

                        var interpolate = d3.interpolate(d.y, d.y0);

                        return function(t){
                            return self.component._getRadarColumnPath(d.y0, interpolate(t), d.radian);
                        }

                    })
                    .each('end', function(){
                        d3.select(this).remove();
                    });
            });

        },

        _deletePolygonTypeSeries:function(exitS){

            var self = this;

            var markerClass = this._getMarkerClass();

            var exitTime = this.component.isSupportAnimation() ? EXIT_TIME : 0;

            exitS.each(function(){

                var seriesG = d3.select(this);

                seriesG
                    .select('path.' + SERIES_STROKE)
                    .transition()
                    .duration(exitTime)
                    .ease(EXIT_EASE)
                    .attrTween('d', function(d){

                        var initPathSeg = self.component._getInitPathSegment(d.pathSegment);
                        var interpolate  = d3.interpolateArray(d.pathSegment, initPathSeg);

                        return function(t){
                            return self.component._getRadarSeriesStrokePath(interpolate(t), d.connectNulls);
                        };

                    })
                    .each('end', function(){
                        d3.select(this).remove();
                    });

                seriesG
                    .select('path.' + SERIES_FILL)
                    .transition()
                    .duration(exitTime)
                    .ease(EXIT_EASE)
                    .attrTween('d', function(d){

                        var initPathSeg = self.component._getInitPathSegment(d.pathSegment);
                        var interpolate  = d3.interpolateArray(d.pathSegment, initPathSeg);

                        return function(t){
                            return self.component._getRadarSeriesFillPath(interpolate(t), d.connectNulls);
                        };

                    })
                    .each('end', function(){
                        d3.select(this).remove();
                    });

                seriesG
                    .selectAll('g.' + markerClass)
                    .transition()
                    .duration(exitTime)
                    .ease(EXIT_EASE)
                    .attr('transform', function(){
                        return BaseUtils.makeTranslate([0,0]) + 'scale(0)';
                    })
                    .each('end', function(){
                        d3.select(this).remove();
                    });
            });

        },

        _updateRadarSeries:function(updateS){
            this.component.isColumnType() ? this._updateColumnTypeSeries(updateS)
                : this._updatePolygonTypeSeries(updateS);
        },

        _updateColumnTypeSeries:function(updateS){

            var self = this;

            updateS.each(function(d){

                var columnS = d3.select(this).selectAll('path.' + COLUMN).data(d.points);

                self.addShapeEventHandler(columnS);

                columnS.exit().remove();

                columnS.call(self._createColumn.bind(self));

                columnS.each(function(d){
                    d3.select(this)
                        .style('fill', function (d) {
                            return d.color;
                        })
                        .style('fill-opacity', function(d){
                            return d.fillColorOpacity;
                        })
                        .style('stroke', function(d){
                            return d.borderColor;
                        })
                        .style('stroke-width', function(d){
                            return d.borderWidth;
                        })
                        .transition()
                        .duration(EXIT_TIME)
                        .ease(EXIT_EASE)
                        .attrTween('d', function(d){

                            var innerRadius = BaseUtils.pick(this._innerRadius_, d.y0);
                            var outerRadius = BaseUtils.pick(this._outerRadius_, d.y);

                            var innerInterpolate = d3.interpolate(innerRadius, d.y0);
                            var outerInterpolate = d3.interpolate(outerRadius, d.y);

                            this._innerRadius_ = d.y0;
                            this._outerRadius_ = d.y;

                            return function(t){

                                var iR = innerInterpolate(t);
                                var oR = outerInterpolate(t);
                                return self.component._getRadarColumnPath(iR, oR, d.radian);

                            }
                        });
                });

            });

        },

        _updatePolygonTypeSeries:function(updateS){

            var self = this;

            var markerClass = this._getMarkerClass();

            var animationTime = this.component.isSupportAnimation() ? ANIMATION_TIME : 0;

            updateS.each(function(d){

                var seriesG = d3.select(this);

                if(seriesG.select('path.' + SERIES_STROKE).empty()){
                    self._createPolygonStroke(seriesG, d);
                }else{
                    var strokePath = seriesG.select('path.' + SERIES_STROKE);
                    self.addSeriesEventHandler(strokePath);
                    strokePath
                        .style({
                            'fill':'none',
                            'stroke': d.lineColor,
                            'stroke-width': d.lineWidth
                        })
                        .transition()
                        .duration(animationTime)
                        .ease(EASE)
                        .attrTween('d', function(d){

                            var useLastPathSeg = !!this._pathSegment_;

                            if(useLastPathSeg && this._pathSegment_.length == d.pathSegment.length){
                                var last = this._pathSegment_;
                                for(var i = 0, count = last.length; i < count && useLastPathSeg; i++){
                                    if(last[i].length != d.pathSegment[i].length){
                                        useLastPathSeg = false;
                                    }
                                }
                            }

                            var initPathSeg = useLastPathSeg ? this._pathSegment_ : self.component._getInitPathSegment(d.pathSegment);

                            var interpolate  = d3.interpolateArray(initPathSeg, d.pathSegment);

                            this._pathSegment_ = d.pathSegment;

                            return function(t){
                                return self.component._getRadarSeriesStrokePath(interpolate(t), d.connectNulls);
                            };

                        });
                }

                if(seriesG.select('path.' + SERIES_FILL).empty()){
                    self._createPolygonFill(seriesG, d);
                }else{
                    var fillPath = seriesG.select('path.' + SERIES_FILL);
                    self.addSeriesEventHandler(strokePath);
                    fillPath
                        .style({
                            'fill': d.fillColor,
                            'fill-opacity': d.fillColor ? d.fillColorOpacity : 0
                        })
                        .transition()
                        .duration(animationTime)
                        .ease(EASE)
                        .attrTween('d', function(d){

                            var initPathSeg = this._pathSegment_ ?
                                this._pathSegment_ : self.component._getInitPathSegment(d.pathSegment);

                            var interpolate  = d3.interpolateArray(initPathSeg, d.pathSegment);

                            this._pathSegment_ = d.pathSegment;

                            return function(t){
                                return self.component._getRadarSeriesFillPath(interpolate(t), d.connectNulls);
                            };

                        });
                }


                var markers = seriesG.selectAll('g.' + markerClass)
                    .data(function(d){ return d.points.filter(function(d){return !d.isNull}); });

                self.addShapeEventHandler(markers);

                markers.exit().remove();

                markers.call(self._createSvgMarker.bind(self));

                markers
                    .each(function(d){
                        self._updateMarkerStyle(d3.select(this), d);
                    })
                    .transition()
                    .duration(animationTime)
                    .ease(EASE)
                    .attr('transform', function(d){return BaseUtils.makeTranslate(d.pos)});
            });

        },

        _createRadarSeries:function(updateS){

            var enterS = updateS.enter().append('g')
                .attr('class', function(d){return d.className + ' ' + RADAR_SERIES})
                .attr('clip-path', "url(#" + this._getRadarClipID() +")");

            this.component.isColumnType() ? this._createColumnTypeSeries(enterS) : this._createPolygonTypeSeries(enterS);
        },

        _createColumnTypeSeries:function(enterS){

            var self = this;

            enterS.each(function(d){

                d3.select(this)
                    .selectAll('path.' + COLUMN)
                    .data(d.points)
                    .call(self._createColumn.bind(self))
                    .transition()
                    .duration(self.component.isSupportAnimation() ? ANIMATION_TIME : 0)
                    .ease(EASE)
                    .attrTween('d', function(d){

                        var initR = self.component.getInitRadius();
                        var interpolate = d3.interpolate(initR, d.y);

                        this._innerRadius_ = d.y0;
                        this._outerRadius_ = d.y;

                        return function(t){
                            return self.component._getRadarColumnPath(initR, interpolate(t), d.radian);
                        }

                    })
                    .each('end', function(d){
                        d3.select(this)
                            .attr('d', self.component._getRadarColumnPath(d.y0, d.y, d.radian))
                    });

            });

        },

        _createPolygonStroke:function(gElement, d){

            var self = this;
            var supportAnimation = this.component.isSupportAnimation();
            var para = supportAnimation ? 1 : 0;

            var strokePath = gElement.selectAll('path.' + SERIES_STROKE).data([d]);

            strokePath.enter()
                .append('path')
                .attr('class', SERIES_STROKE)
                .style({
                    'fill':'none',
                    'stroke': d.lineColor,
                    'stroke-width': d.lineWidth
                })
                .transition()
                .duration(ANIMATION_TIME * para)
                .ease(EASE)
                .attrTween('d', function(d){
                    var initSeg = self.component._getInitPathSegment(d.pathSegment);
                    var interpolate  = d3.interpolateArray(initSeg, d.pathSegment);

                    this._pathSegment_ = d.pathSegment;

                    return function(t){
                        return self.component._getRadarSeriesStrokePath(interpolate(t), d.connectNulls);
                    };
                });

            this.addSeriesEventHandler(strokePath);
        },

        _createPolygonFill:function(gElement, d){

            var self = this;
            var supportAnimation = this.component.isSupportAnimation();
            var para = supportAnimation ? 1 : 0;

            if(d.fillColor && d.fillColorOpacity){

                var fillPath = gElement.selectAll('path.' + SERIES_FILL).data([d]);

                fillPath.enter()
                    .append('path')
                    .attr('class', SERIES_FILL)
                    .style({
                        'fill': d.fillColor,
                        'fill-opacity': d.fillColor ? d.fillColorOpacity : 0
                    })
                    .transition()
                    .duration(ANIMATION_TIME * para)
                    .ease(EASE)
                    .attrTween('d', function(d){
                        var initSeg = self.component._getInitPathSegment(d.pathSegment);
                        var interpolate  = d3.interpolateArray(initSeg, d.pathSegment);

                        this._pathSegment_ = d.pathSegment;

                        return function(t){
                            return self.component._getRadarSeriesFillPath(interpolate(t), d.connectNulls);
                        };
                    });

                this.addSeriesEventHandler(fillPath);
            }

        },

        _createPolygonTypeSeries:function(enterS){

            var self = this;

            var markerClass = this._getMarkerClass();

            var supportAnimation = this.component.isSupportAnimation();
            var para = supportAnimation ? 1 : 0;

            enterS.each(function(d){

                var gElement = d3.select(this);

                self._createPolygonStroke(gElement, d);

                self._createPolygonFill(gElement, d);

                gElement
                    .selectAll('g.' + markerClass)
                    .data(d.points.filter(function(d){return !d.isNull}))
                    .call(self._createSvgMarker.bind(self))
                    .attr('transform', function(){
                        return BaseUtils.makeTranslate([0,0]) + 'scale(0.01)'
                    })
                    .transition()
                    .duration(ANIMATION_TIME * para)
                    .ease(EASE)
                    .attr('transform', function(d){
                        return BaseUtils.makeTranslate(d.pos) + 'scale(1)';
                    })

            });
        },

        _createColumn:function(updateS){

            var newColumn = updateS.enter();

            newColumn
                .append('path')
                .attr('class', function(d){
                    return COLUMN + ' ' + d.className;
                })
                .style('fill', function (d) {
                    return d.color;
                })
                .style('fill-opacity', function(d){
                    return d.fillColorOpacity;
                })
                .style('stroke', function(d){
                    return d.borderColor;
                })
                .style('stroke-width', function(d){
                    return d.borderWidth;
                })
                .call(this.addShapeEventHandler.bind(this));
        },

        _drawLabel:function(delay){

            var radarData = this.component.getVisibleChartData();

            var center = this.component.getRadarCenter();
            var r = this.component.radius;

            var allPoints = [];
            radarData.forEach(function(data){
                allPoints = allPoints.concat(data.points);
            });

            allPoints = allPoints.filter(function(point){
                if(point.labelPos && point.labelDim){

                    var x = point.labelPos.x;
                    var y = point.labelPos.y;

                    x += x > 0 ? 0 : point.labelDim.width;
                    y += y > 0 ? 0 : point.labelDim.height;

                    if((x*x + y*y) < r*r){
                        return true;
                    }
                }
            });

            if(!this._labelG){
                this._labelG = this._bodyG.append('g');
            }

            this._drawSvgDataLabels(this._labelG, allPoints, center[0], center[1], delay);
        },

        _getRadarClipID:function(){
            return 'radarClip' + this.component.vanchart.getIDPrefix();
        },

        mouseOver:function(event){
            if(event && event.target){
                var d = event.target.datum();
                if(d.columnType){
                    event.target
                        .style('stroke', d.mouseOverColor)
                        .style('fill', d.mouseOverColor)
                        .style('stroke-width', d.borderWidth)
                        .style('stroke-opacity', 0.35)
                        .interrupt()
                        .transition()
                        .duration(100)
                        .ease('ease-out-in')
                        .style('stroke-width', 6);
                }else{
                    this._makeMarkerChosenState(event.target, d);
                }
            }
        },

        mouseOut:function(event){
            if(event && event.target){
                var d = event.target.datum();

                if(d.columnType){
                    event.target.interrupt().transition()
                        .style('fill', d.color)
                        .style('stroke', d.borderColor)
                        .style('stroke-opacity', 1)
                        .style('stroke-width', d.borderWidth);
                }else{
                    this._cancelMarkerChosenState(event.target, d);
                }

            }
        },

        mouseDown:function(event){
            if(event && event.target){
                var d = event.target.datum();
                if(d.columnType){
                    event.target.style('fill', d.clickColor);
                }else{
                    this._makeMarkerClickedState(event.target, d);
                }
            }
        },

        mouseUp:function(event){
            if(event && event.target){
                var d = event.target.datum();
                
                if(d.columnType){
                    event.target.style('fill', d.mouseOverColor);
                }else{
                    this._cancelMarkerClickedState(event.target, d);
                }
            }
        }
    });

    require('./RenderLibrary').register(Constants.RADAR_SVG, RadarSvgRender);
});
/**
 * Created by Mitisky on 16/3/14.
 */
define('render/BubbleSvgRender',['require','./BaseRender','../utils/BaseUtils','../Constants','./RenderLibrary'],function(require){
    var BaseRender = require('./BaseRender');
    var BaseUtils = require('../utils/BaseUtils');
    var Constants = require('../Constants');

    var BUBBLE_INIT_TIME = 500;
    var BUBBLE_UPDATE_TIME = 500;
    var BUBBLE_EXIT_TIME = 300;
    var BUBBLE_CHOSEN_TIME = 200;
    var BUBBLES_SHOW_TIME = 800;

    var CHOSEN_STROKE_WIDTH = 6;

    var BUBBLE_SERIES_GROUP = 'bubble-series-group';
    var BUBBLE_SHADOW_ID = 'bubble-shadow-id';
    var FORCE_BUBBLE_GROUP = 'force-bubble-group';

    var BubbleSvgRender = BaseRender.extend({

        render:function(){
            this.component.isLargeMode() ? this._canvasRender() : this._svgRender();
        },

        _svgRender:function() {
            this.component.isUpdateWithForce() ? this._renderForceBubbles() : this._renderNormalBubbles();
        },

        _createForceBubbleDivLabel:function(visiblePoints){

            var self = this;

            var plotBounds = self.component.getPlotBounds();

            var validPoints = [];

            visiblePoints.forEach(function(point){
                if(point.labelPos && point.dataLabels.useHtml){
                    point.labelPos = {
                        x:-point.labelDim.width/2 + point.x,
                        y:-point.labelDim.height/2 + point.y
                    };
                    validPoints.push(point)
                }

            });

            self._renderDivLabels(visiblePoints, plotBounds.x, plotBounds.y);
        },

        _renderForceBubbles:function(){

            //准备node数据
            var bubbleData = this.component.getVisibleChartData();
            var nodes = [];
            var maxRadius = 0, padding = 2, clusterPadding = 2;

            bubbleData.forEach(function(sery){
                sery.points.forEach(function(point){
                    if(point.visible){
                        nodes.push(point);
                        point.px = undefined;
                        point.py = undefined;
                        maxRadius = Math.max(maxRadius, point.radius);
                    }
                })
            });

            var svgRoot = this.component.getVanchartRender().getRenderRoot();
            var clipID = this.component.vanchart.getBodyClipID();
            var plotBounds = this.component.getPlotBounds();
            var self = this;

            if(!this._bodyG) {
                this._bodyG = svgRoot.append('g');
                this._createDefs();
            }

            this._bodyG
                .attr('transform', 'translate('+plotBounds.x+','+plotBounds.y+')')
                .attr('clip-path', "url(#" + clipID +")");

            var bubbleS = this._bodyG
                .selectAll('g.' + FORCE_BUBBLE_GROUP)
                .data(nodes, function(d){return d.className;});

            bubbleS.each(function(d){

                var circle = d3.transform(d3.select(this)
                    .attr('transform')).translate;

                d.x = circle[0];
                d.y = circle[1];
            });

            if(this.force){
                this.force.stop();
            }

            var force = d3.layout.force()
                .nodes(nodes)
                .size([plotBounds.width, plotBounds.height])
                .gravity(.05)
                .charge(0)
                .on("tick", tick)
                .on('start', function(){
                    self.labelDivManager.clearAllLabels();
                })
                .on('end', function(){
                    self._createForceBubbleDivLabel(nodes);
                })
                .start();

            this.force = force;

            var exitBubbles = bubbleS.exit();
            exitBubbles.each(function(){

                d3.select(this)
                    .transition()
                    .duration(BUBBLE_EXIT_TIME)
                    .ease('back-in')
                    .each(function(){

                        d3.transition(d3.select(this).select('circle'))
                            .attrTween("r", function(d) {
                                var i = d3.interpolate(d.radius, 0);
                                return function(t) { return i(t); };
                            });

                    })
                    .remove();

            });

            bubbleS
                .call(this.force.drag)
                .each(function(d){

                    var g = d3.select(this);

                    g.select('circle')
                        .style('fill', function(d){
                            return d.color;
                        })
                        .style('fill-opacity', function(d){
                            return d.fillColorOpacity
                        })
                        .transition()
                        .duration(750)
                        .attrTween("r", function(d) {
                            var currentR = d3.select(this).attr('r');
                            var i = d3.interpolate(currentR, d.radius);
                            return function(t) { return d.radius = i(t); };
                        })
                        .each('end', function(d){
                            self._createForceLabel(d, d3.select(this.parentNode));
                        });

                    g.select('text').remove();
                });

            this.addShapeEventHandler(bubbleS.select('circle'));

            this._createNewForceBubble(bubbleS, true);

            function tick(e) {

                bubbleS
                    .each(cluster(10 * e.alpha * e.alpha))
                    .each(collide(.5));

                bubbleS.each(function(){
                    var g = d3.select(this);
                    var scale = BaseUtils.pick(d3.transform(g.attr("transform")).scale, 1);
                    g
                        .attr('transform', function(d){
                            return 'translate(' + d.x + ',' + d.y + ')' + 'scale(' + scale + ')';
                        })
                });
            }

            // Move d to be adjacent to the cluster node.
            function cluster(alpha) {
                return function(d) {
                    var cluster = d.series.cluster;
                    if (!cluster || cluster === d) return;
                    var x = d.x - cluster.x,
                        y = d.y - cluster.y,
                        l = Math.sqrt(x * x + y * y),
                        r = d.radius + cluster.radius;
                    if (l != r) {
                        l = (l - r) / l * alpha;
                        d.x -= x *= l;
                        d.y -= y *= l;
                        cluster.x += x;
                        cluster.y += y;
                    }
                };
            }

            // Resolves collisions between d and all other circles.
            function collide(alpha) {
                var quadtree = d3.geom.quadtree(nodes);
                return function(d) {
                    var r = d.radius + maxRadius + Math.max(padding, clusterPadding),
                        nx1 = d.x - r,
                        nx2 = d.x + r,
                        ny1 = d.y - r,
                        ny2 = d.y + r;
                    quadtree.visit(function(quad, x1, y1, x2, y2) {
                        if (quad.point && (quad.point !== d)) {
                            var x = d.x - quad.point.x,
                                y = d.y - quad.point.y,
                                l = Math.sqrt(x * x + y * y),
                                r = d.radius + quad.point.radius + (d.series.cluster === quad.point.series.cluster ? padding : clusterPadding);
                            if (l < r) {
                                l = (l - r) / l * alpha;
                                d.x -= x *= l;
                                d.y -= y *= l;
                                quad.point.x += x;
                                quad.point.y += y;
                            }
                        }
                        return x1 > nx2 || x2 < nx1 || y1 > ny2 || y2 < ny1;
                    });
                };
            }
        },

        _createNewForceBubble:function(bubbleS, animation){

            var self = this;

            var plotBounds = this.component.getPlotBounds();
            var cX = plotBounds.width/2;
            var cY = plotBounds.height/2;

            var newForceGroup = bubbleS.enter().append('g').attr('class', function(d){
                return FORCE_BUBBLE_GROUP + ' ' + d.className;
            });

            newForceGroup
                .attr('transform', function(d){
                    var x = BaseUtils.isEmpty(d.x) ? cX : d.x;
                    var y = BaseUtils.isEmpty(d.y) ? cY : d.y;
                    return 'translate(' + x + ',' + y + ')'
                })
                .call(this.force.drag)
                .append('circle')
                .style('fill', function(d){
                    return d.color;
                })
                .style('fill-opacity', function(d){
                    return d.fillColorOpacity
                })
                .each(function(d){
                    self._addFilter(d, d3.select(this), 0);
                });

            this.addShapeEventHandler(newForceGroup.select('circle'));

            newForceGroup
                .select('circle')
                .transition().duration(animation ? 750 : 0)
                .delay(function(d, i) { return i * 5; })
                .attrTween("r", function(d) {
                    var i = d3.interpolate(0, d.radius);
                    return function(t) { return d.radius = i(t); };
                })
                .each('end', function(d){
                    self._createForceLabel(d, d3.select(this.parentNode));
                });
        },

        _createForceLabel:function(d, gElement){

            if(d.labelPos && d.labelDim && !d.dataLabels.useHtml){

                var labelContent = d.labelContent;

                var centerX = d.labelPos.x + d.labelDim.width/2;

                var startY = d.labelPos.y;

                var text = gElement.append('text').style('opacity', 0);

                for(var i = 0, count = labelContent.length; i < count; i++){
                    var label = labelContent[i];

                    var labelDim = label.dim;
                    var labelText = label.text;
                    var labelStyle = label.style;

                    text
                        .append('tspan')
                        .attr('x', centerX)
                        .attr('y', startY + labelDim.height/2)
                        .attr('dy', '.32em')
                        .attr("text-anchor", "middle")
                        .text(labelText)
                        .call(BaseUtils.setTextStyle, labelStyle);
                    startY += (labelDim.height + this.component.getLabelGap());
                }

                text.transition('linear')
                    .duration(400)
                    .style('opacity', 1)

            }
        },

        _renderNormalBubbles:function(){
            var svgRoot = this.component.getVanchartRender().getRenderRoot();
            var supportAnimation = this.component.isSupportAnimation();

            if(!this._bodyG) {
                this._bodyG = svgRoot.append('g');
                this._createDefs();
                this._updateChartBodyTranslate([this._bodyG]);
            } else {
                this._updateChartBodyTranslate([this._bodyG], supportAnimation, BUBBLE_UPDATE_TIME);
            }

            if(this._animationTimeOut){
                for(var timeOut in this._animationTimeOut){
                    clearTimeout(this._animationTimeOut[timeOut]);
                }
            }
            this._animationTimeOut = {};

            var bubbleData = this.component.getVisibleChartData();

            var bubbleSeriesS = this._bodyG
                .selectAll('g.' + BUBBLE_SERIES_GROUP)
                .data(bubbleData, function(d){return d.className});

            this._animationTimeOut = {};

            this._dropSeries(bubbleSeriesS.exit(), supportAnimation);

            this._updateSeries(bubbleSeriesS, supportAnimation);

            this._createSeries(bubbleSeriesS, supportAnimation);
        },

        scaleRender:function(){
            if(this.component.isUpdateWithForce()){
                var bubbleData = this.component.getVisibleChartData();
                var nodes = [];
                bubbleData.forEach(function(sery){
                    sery.points.forEach(function(point){
                        if(point.visible){
                            nodes.push(point);
                        }
                    })
                });

                var self = this;

                var bubbleS = this._bodyG
                    .selectAll('g.' + FORCE_BUBBLE_GROUP)
                    .data(nodes, function(d){return d.className;});

                bubbleS
                    .transition()
                    .duration(BUBBLE_UPDATE_TIME)
                    .ease('back-out')
                    .attr('transform', function(d){
                        return 'translate('+ d.x + ',' + d.y +')';
                    })
                    .each('start', function(){
                        self.labelDivManager.clearAllLabels();
                    })
                    .each('end', function(){
                        self._createForceBubbleDivLabel(nodes);
                    });


                bubbleS.each(function(d){

                    var g = d3.select(this);

                    g.select('circle').attr('r', d.radius);

                    if(d.labelPos && g.select('text').empty()){
                        self._createForceLabel(d, g);
                    }

                });
            }else{
                this.render();
            }
        },

        filterRender: function () {
            if(this.component.isLargeMode()){
                this._canvasRender();
            }else if(this.component.isUpdateWithForce()){

                var bubbleData = this.component.getVisibleChartData();
                var nodes = [];
                bubbleData.forEach(function(sery){
                    sery.points.forEach(function(point){
                        if(point.visible){
                            nodes.push(point);
                        }
                    })
                });

                this.labelDivManager.clearAllLabels();
                this._createForceBubbleDivLabel(nodes);

                var bubbleS = this._bodyG
                    .selectAll('g.' + FORCE_BUBBLE_GROUP)
                    .data(nodes, function(d){return d.className;});

                bubbleS.each(function(){
                    var g = d3.select(this);

                    var translate = d3.transform(g.attr('transform')).translate;

                    g.attr('transform', BaseUtils.makeTranslate(translate) + 'scale(1)');
                });


                bubbleS.exit().each(function(){

                    var g = d3.select(this);

                    var translate = d3.transform(g.attr('transform')).translate;

                    g.attr('transform', BaseUtils.makeTranslate(translate) + 'scale(0)');
                });

            }else{
                var self = this;
                this._bodyG.selectAll('text')
                    .filter(function(d){return d.visible})
                    .style('opacity', 1);

                this._bodyG.selectAll('text')
                    .filter(function(d){return !d.visible})
                    .style('opacity', 0);

                this._bodyG.selectAll('path')
                    .filter(function(d){return d.visible})
                    .attr('transform', function (d) {
                        return 'translate('+d.posX+','+ d.posY+')';
                    })
                    .attr('d', function(d){
                        return d3.svg.arc().outerRadius(d.radius)({startAngle:0, endAngle:2 * Math.PI})})
                    .each(function (p) {
                        self.labelDivManager.setLabelOpacity(p.className, 1);
                    });

                this._bodyG.selectAll('path')
                    .filter(function(d){return !d.visible})
                    .attr('transform', function (d) {
                        return 'translate('+d.posX+','+ d.posY+')';
                    })
                    .attr('d', d3.svg.arc().outerRadius(0)({startAngle:0, endAngle:2 * Math.PI}))
                    .each(function (p) {
                        self.labelDivManager.setLabelOpacity(p.className, 0);
                    })
            }

        },

        _createDefs:function(){

            var defs = this._bodyG.append('defs');

            this._createDropShadowFilter(defs, this._getFilterID(), 0, 0, 0.2, 2);
        },

        _getFilterID:function(){

            return this.component.vanchart.getIDPrefix() + BUBBLE_SHADOW_ID;;

        },

        _addFilter:function(d, bubble, delay){
            var self = this;
            if(d.shadow) {
                delay = delay || 0;
                delay += 200;
                setTimeout(function () {
                    if (bubble) {
                        bubble.style("filter", 'url(#' + self._getFilterID() + ')')
                    }
                }, delay)
            }
        },

        //系列消失动画
        _dropSeries:function(exitSeries, supportAnimation){
            var self = this;
            exitSeries.each(function(d){
                d3.select(this)
                    .selectAll('path')
                    .transition()
                    .duration(supportAnimation ? BUBBLE_EXIT_TIME : 0)
                    .ease('back-in')
                    .attr('d', d3.svg.arc().outerRadius(0)({startAngle:0, endAngle:2 * Math.PI}))
                    .remove();

                d3.select(this)
                    .selectAll('text')
                    .remove();

                d.points.forEach(function (p) {
                    self.labelDivManager.clearLabels(p.className);
                })
            });
        },

        _updateSeries:function(bubbleSeries, supportAnimation){

            var isChangeData = this.component.vanchart.isChangeDataState();

            var self = this;
            if(isChangeData){
                this._dropSeries(bubbleSeries, supportAnimation);

                clearTimeout(self._animationTimeOut['changeData']);
                self._animationTimeOut['changeData'] = setTimeout(function () {
                    bubbleSeries.each(function(d){
                        d3.select(this)
                            .selectAll('path')
                            .remove();

                        var bubbles = d3.select(this)
                            .selectAll('path')
                            .data(d.points, function(d){return d.className;});

                        self._createBubbles(bubbles, supportAnimation);

                        var labels = d3.select(this)
                            .selectAll('text')
                            .data(d.points)
                            .enter()
                            .append('text')
                            .style('opacity', function(d){
                                return d.visible ? 1 : 0;
                            })
                            .each(function (d) {
                                self._createSingleDataLabel(d, d3.select(this));
                            });

                        labels.style('pointer-events', 'none');
                    })
                }, supportAnimation ? BUBBLE_EXIT_TIME + 100 : 0)
            } else {
                bubbleSeries.each(function(d){

                    var bubbles = d3.select(this)
                        .selectAll('path')
                        .data(d.points, function(d){return d.className;});

                    var parentG = d3.select(this);

                    var delayTime = supportAnimation ? (bubbles.empty() ? BUBBLE_EXIT_TIME : BUBBLE_UPDATE_TIME) + 100 : 0;
                    if(bubbles.empty()){
                        self._createBubbles(bubbles, supportAnimation);
                    } else {
                        d3.select(this)
                            .selectAll('text')
                            .remove();

                        d.points.forEach(function (p) {
                            self.labelDivManager.clearLabels(p.className);
                        });

                        self._updateBubbles(bubbles, supportAnimation);
                    }

                    clearTimeout(self._animationTimeOut[d.className]);
                    self._animationTimeOut[d.className] = setTimeout(function () {
                        var labels = parentG
                            .selectAll('text')
                            .data(d.points)
                            .enter()
                            .append('text')
                            .style('opacity', function(d){
                                return d.visible ? 1 : 0;
                            })
                            .each(function (d) {
                                self._createSingleDataLabel(d, d3.select(this));
                            });
                        labels.style('pointer-events', 'none');
                    }, delayTime)

                });
            }
        },

        //系列重现动画
        _createBubbles:function(bubbles, supportAnimation) {
            var bubbleG = bubbles.enter().append('path');
            var self = this;
            bubbleG.each(function(d){

                var bubble = d3.select(this);

                bubble
                    .attr('class', d.className)
                    .attr('transform', 'translate('+d.posX+','+ d.posY+')')
                    .attr('d', d3.svg.arc().outerRadius(0)({startAngle:0, endAngle:2 * Math.PI}))
                    .style('fill', d.color)
                    .style('fill-opacity', d.fillColorOpacity)
                    .transition()
                    .ease('back-out')
                    .duration(supportAnimation ? BUBBLE_EXIT_TIME : 0)
                    .attr('d', d3.svg.arc().outerRadius(d.radius)({startAngle:0, endAngle:2 * Math.PI}));

                self._addFilter(d, bubble, supportAnimation ? BUBBLE_EXIT_TIME : 0);
            });

            self.addShapeEventHandler(bubbles);
        },

        //系列消失或重现时，其他系列位置、大小动画.
        _updateBubbles:function(bubbles, supportAnimation) {
            this.addShapeEventHandler(bubbles);

            bubbles
                .filter(function(d){return d.visible})
                .each(function(d){

                    d3.select(this)
                        .style('fill', d.color)
                        .style('fill-opacity', d.fillColorOpacity)
                        .transition()
                        .duration(supportAnimation ? BUBBLE_UPDATE_TIME : 0)
                        .ease('back-out')
                        .attr('d', function(d){
                            return d3.svg.arc().outerRadius(d.radius)({startAngle:0, endAngle:2 * Math.PI});
                        })
                        .attr('transform', 'translate('+ d.posX+','+ d.posY+')');
                });
        },

        //初始化
        _createSeries:function(bubbleSeries, supportAnimation) {
            var newSeriesG = bubbleSeries.enter().append('g').attr('class', BUBBLE_SERIES_GROUP);

            var self = this;
            newSeriesG.each(function(d){

                var bubbles = d3.select(this)
                    .selectAll('path')
                    .data(d.points, function(d){return d.className;});

                var bubbleG = bubbles.enter().append('path');

                bubbleG
                    .filter(function(d){return d.visible})
                    .each(function(d){

                        var bubble = d3.select(this);

                        bubble
                            .attr('class', d.className)
                            .attr('transform', 'translate('+d.posX+','+ d.posY+')')
                            .attr('d', d3.svg.arc().outerRadius(0)({startAngle:0, endAngle:2 * Math.PI}))
                            .style('fill', d.color)
                            .style('fill-opacity', d.fillColorOpacity)
                            .transition()
                            .delay(supportAnimation ? d.delayTime : 0)
                            .ease('bounce')
                            .duration(supportAnimation ? BUBBLE_INIT_TIME : 0)
                            .attr('d', d3.svg.arc().outerRadius(d.radius)({startAngle:0, endAngle:2 * Math.PI}));

                        self._addFilter(d, bubble, supportAnimation ? (BUBBLE_INIT_TIME + d.delayTime) : 0);
                    });

                self.addShapeEventHandler(bubbles);

                var labels = d3.select(this)
                    .selectAll('text')
                    .data(d.points);

                clearTimeout(self._animationTimeOut[d.className + 'init']);
                self._animationTimeOut[d.className + 'init'] = setTimeout(function () {
                    labels
                        .enter()
                        .append('text')
                        .filter(function(d){return d.visible})
                        .each(function (d) {
                            self._createSingleDataLabel(d, d3.select(this))
                        });

                    labels.style('pointer-events', 'none');

                }, supportAnimation ? BUBBLE_INIT_TIME + BUBBLES_SHOW_TIME : 0)

            });
        },

        mouseOver:function(event){
            if(this.component.isLargeMode()){
                return;
            }

            if(event && event.target){
                var d = event.target.datum();
                event.target
                    .style({
                        'stroke':d.mouseOverColor,
                        'stroke-width':0,
                        'stroke-opacity':0.35,
                        'fill':d.mouseOverColor
                    })
                    .interrupt(Constants.SELECT_ANIMATION)
                    .transition(Constants.SELECT_ANIMATION)
                    .duration(BUBBLE_CHOSEN_TIME)
                    .ease('back-out')
                    .style('stroke-width', CHOSEN_STROKE_WIDTH)
            }
        },

        mouseOut:function(event){

            if(this.component.isLargeMode()){
                return;
            }

            if(event && event.target){
                var d = event.target.datum();

                event.target
                    .style('fill', d.color)
                    .style('fill-opacity', d.fillColorOpacity)
                    .interrupt(Constants.SELECT_ANIMATION)
                    .transition(Constants.SELECT_ANIMATION);

                event.target
                    .style('stroke-width', 0);
            }
        },

        mouseDown:function(event){

            if(this.component.isLargeMode()){
                return;
            }

            if(event && event.target){
                var d = event.target.datum();
                event.target.style('fill', d.clickColor);
            }
        },

        mouseUp:function(event){
            if(event && event.target){
                var d = event.target.datum();
                event.target.style('fill', d.mouseOverColor);
            }
        }
    });

    require('./RenderLibrary').register(Constants.BUBBLE_SVG, BubbleSvgRender);

    return BubbleSvgRender;
});
/**
 * Created by Mitisky on 16/3/24.
 */
define('render/ScatterSvgRender',['require','./BaseRender','../utils/BaseUtils','../utils/ColorUtils','../Constants','./RenderLibrary'],function (require) {
    var BaseRender = require('./BaseRender');
    var BaseUtils = require('../utils/BaseUtils');
    var ColorUtils = require('../utils/ColorUtils');
    var Constants = require('../Constants');

    var SCATTER_SHOW_TIME = 800;
    var SCATTER_INIT_TIME = 300;
    var SCATTER_UPDATE_TIME = 500;

    var SCATTER_SERIES_GROUP = 'scatter-series-group';
    var SCATTER_SERIES_LINE_CLASS = 'scatter-series-line-class';

    var ScatterSvgRender = BaseRender.extend({
        render:function(){
            this.component.isLargeMode() ? this._canvasRender() : this._svgRender();
        },

        _svgRender:function(){

            var svgRoot = this.component.getVanchartRender().getRenderRoot();
            var supportAnimation = this.component.isSupportAnimation();

            if(!this._bodyG) {
                this._bodyG = svgRoot.append('g');
                this._updateChartBodyTranslate([this._bodyG]);
            } else {
                this._updateChartBodyTranslate([this._bodyG], supportAnimation, SCATTER_UPDATE_TIME);
            }

            var scatterData = this.component.getVisibleChartData();

            var scatterSeriesS = this._bodyG
                .selectAll('g.' + SCATTER_SERIES_GROUP)
                .data(scatterData, function(d){return d.className});

            this._animationTimeOut = {};

            this._dropSeries(scatterSeriesS.exit(), supportAnimation);

            this._updateSeries(scatterSeriesS, supportAnimation);

            this._createSeries(scatterSeriesS, supportAnimation);
        },

        filterRender: function () {
            if(this.component.isLargeMode()){
                this._canvasRender();
            }else{
                var self = this;
                this._bodyG.selectAll('g.' + SCATTER_SERIES_GROUP)
                    .each(function () {
                        d3.select(this)
                            .selectAll('g')
                            .filter(function(d){return d.visible})
                            .attr('transform', function(d){
                                return 'translate('+ d.posX +','+ d.posY +') scale(1)';
                            })
                            .each(function (p) {
                                self.labelDivManager.setLabelOpacity(p.className, 1);
                            });

                        d3.select(this)
                            .selectAll('g')
                            .filter(function(d){return !d.visible})
                            .attr('transform', function(d){
                                return 'translate('+ d.posX +','+ d.posY +') scale(0)';
                            })
                            .each(function (p) {
                                self.labelDivManager.setLabelOpacity(p.className, 0);
                            });
                    });
            }
        },

        //系列消失动画
        _dropSeries:function(exitSeries, supportAnimation){
            var self = this;

            exitSeries.each(function(d){
                d3.select(this)
                    .selectAll('g')
                    .transition()
                    .duration(supportAnimation ? SCATTER_INIT_TIME : 0)
                    .ease('back-in')
                    .attr('transform', function(d){
                        return 'translate('+ d.posX +','+ d.posY +') scale(0)';
                    })
                    .remove();

                d.points.forEach(function (p) {
                    self.labelDivManager.clearLabels(p.className);
                });

                d3.select(this)
                    .selectAll('path.' + SCATTER_SERIES_LINE_CLASS)
                    .remove();
            });
        },

        _updateSeries:function(scatterSeriesS, supportAnimation){

            var isChangeData = this.component.vanchart.isChangeDataState();

            var self = this;
            scatterSeriesS.each(function(d){
                var parentG = d3.select(this);

                var points = parentG
                    .selectAll('g')
                    .data(d.points, function(d){return d.className;});

                self.addShapeEventHandler(points);

                if(isChangeData){
                    //自动刷新动画
                    parentG.selectAll('path.' + SCATTER_SERIES_LINE_CLASS).remove();

                    points
                        .transition()
                        .duration(supportAnimation ? SCATTER_INIT_TIME : 0)
                        .ease('back-in')
                        .attr('transform', function(d){
                            return 'translate('+ d.posX +','+ d.posY +') scale(0)';
                        })
                        .remove();

                    clearTimeout(self._animationTimeOut[d.className]);
                    self._animationTimeOut[d.className] = setTimeout(function () {
                        self._createSeriesLine(parentG, d, supportAnimation ? SCATTER_INIT_TIME : 0);

                        parentG
                            .selectAll('g')
                            .data(d.points, function(d){return d.className;})
                            .call(self._createSvgMarker.bind(self))
                            .filter(function(d){return d.visible})
                            .attr('transform', function(d){
                                return 'translate('+ d.posX +','+ d.posY +') scale(0.01)';
                            })
                            .transition()
                            .duration(supportAnimation ? SCATTER_INIT_TIME : 0)
                            .ease('back-out')
                            .attr('transform', function(d){
                                return 'translate('+ d.posX +','+ d.posY +') scale(1)';
                            })
                            .each('end', function () {
                                var labelG = d3.select(this)
                                    .append('text')
                                    .attr('transform', function(d){
                                        return 'translate('+ (-d.posX) +','+ (-d.posY) +') scale(1)';
                                    });

                                labelG
                                    .each(function (p) {
                                        self._createSingleDataLabel(p, labelG);
                                    })
                            });
                    }, supportAnimation ? SCATTER_INIT_TIME * 2 : SCATTER_INIT_TIME);
                }else{
                    if(points.empty()){
                        //点击图例系列重现
                        self._createSeriesLine(parentG, d, supportAnimation ? SCATTER_INIT_TIME : 0);

                        points
                            .call(self._createSvgMarker.bind(self))
                            .filter(function(d){return d.visible})
                            .attr('transform', function(d){
                                return 'translate('+ d.posX +','+ d.posY +') scale(0.01)';
                            })
                            .transition()
                            .duration(supportAnimation ? SCATTER_INIT_TIME : 0)
                            .ease('back-out')
                            .attr('transform', function(d){
                                return 'translate('+ d.posX +','+ d.posY +') scale(1)';
                            })
                            .each('end', function () {
                                var labelG = d3.select(this)
                                    .append('text')
                                    .attr('transform', function(d){
                                        return 'translate('+ (-d.posX) +','+ (-d.posY) +') scale(1)';
                                    });

                                labelG
                                    .each(function (p) {
                                        self._createSingleDataLabel(p, labelG);
                                    })
                            });
                    } else {
                        //点击图例其他系列移动
                        d.points.forEach(function (p) {
                            self.labelDivManager.clearLabels(p.className);
                        });

                        points
                            .filter(function(d){return d.visible})
                            .each(function(d){
                                self._updateMarkerStyle(d3.select(this), d);
                            })
                            .transition()
                            .duration(supportAnimation ? SCATTER_UPDATE_TIME : 0)
                            .ease('back-out')
                            .attr('transform', function(d){
                                return 'translate('+ d.posX +','+ d.posY +') scale(1)';
                            })
                            .each('end', function () {
                                d3.select(this)
                                    .append('text')
                                    .attr('transform', function(d){
                                        return 'translate('+ (-d.posX) +','+ (-d.posY) +') scale(1)';
                                    })
                                    .each(function (p) {
                                        self._createSingleDivDataLabel(p);
                                    })
                            });
                        parentG.select('path.' + SCATTER_SERIES_LINE_CLASS)
                            .transition()
                            .duration(supportAnimation ? SCATTER_UPDATE_TIME : 0)
                            .ease('back-out')
                            .attr('d',  d.lineSvg(d.points));
                    }
                }
            });
        },

        //初始化
        _createSeries:function(scatterSeriesS, supportAnimation) {
            var newSeriesG = scatterSeriesS.enter().append('g').attr('class', SCATTER_SERIES_GROUP);

            var self = this;
            newSeriesG
                .each(function (d) {
                    self._createSeriesLine(d3.select(this), d, supportAnimation ? SCATTER_SHOW_TIME : 0);
                });

            var markerS = newSeriesG.selectAll('g.' + SCATTER_SERIES_GROUP)
                .data(function(d){ return d.points; });

            this._createMarkers(markerS, supportAnimation)
        },

        _createMarkers:function(markerS, supportAnimation){
            var self = this;

            markerS
                .call(this._createSvgMarker.bind(this))
                .filter(function(d){return d.visible})
                .attr('transform', function(d){
                    return 'translate('+ d.posX +','+ d.posY +') scale(0.01)';
                })
                .transition()
                .delay(function(d){return supportAnimation ? d.delayTime : 0})
                .duration(supportAnimation ? SCATTER_INIT_TIME : 0)
                .ease('back-out')
                .attr('transform', function(d){
                    return 'translate('+ d.posX +','+ d.posY +') scale(1)';
                })
                .each('end', function () {
                    var labelG = d3.select(this)
                        .append('text')
                        .attr('transform', function(d){
                            return 'translate('+ (-d.posX) +','+ (-d.posY) +') scale(1)';
                        });

                    labelG
                        .each(function (p) {
                            self._createSingleDataLabel(p, labelG);
                        })
                });

        },

        _createSeriesLine: function (parentG, d, delayTime) {
            parentG
                .append('path')
                .attr('class', SCATTER_SERIES_LINE_CLASS)
                .attr('d',  d.lineSvg(d.points))
                .style('fill', 'none')
                .style('stroke', ColorUtils.colorToHex(d.color))
                .style('stroke-width', 0)
                .style("pointer-events", "none");

            parentG
                .select('path.' + SCATTER_SERIES_LINE_CLASS)
                .transition()
                .delay(delayTime)
                .style('stroke-width', d.lineWidth);
        },

        mouseOver:function(event){
            if(event && event.target){
                var d = event.target.datum();
                this._makeMarkerChosenState(event.target, d);
            }
        },

        mouseOut:function(event){
            if(event && event.target){
                var d = event.target.datum();
                this._cancelMarkerChosenState(event.target, d);
            }
        },

        mouseDown:function(event){
            if(event && event.target){
                var d = event.target.datum();
                this._makeMarkerClickedState(event.target, d);
            }
        },

        mouseUp:function(event){
            if(event && event.target){
                var d = event.target.datum();
                this._cancelMarkerClickedState(event.target, d);
            }
        }
    });

    require('./RenderLibrary').register(Constants.SCATTER_SVG, ScatterSvgRender);

    return ScatterSvgRender;
});

/**
 * Created by eason on 16/5/9.
 */
define('render/MapSvgRender',['require','../utils/BaseUtils','../utils/ColorUtils','../Constants','./BaseRender','../utils/BoundsManager','./RenderLibrary'],function(require){

    var BaseUtils = require('../utils/BaseUtils');
    var ColorUtils = require('../utils/ColorUtils');
    var Constants = require('../Constants');
    var BaseRender = require('./BaseRender');
    var BoundsManager = require('../utils/BoundsManager');

    function labelFilter(point){
        return point && point.dataLabels && point.labelContent && point.labelPos;
    }

    function validLabelFilter(point){
        return point && point.dataLabels && point.labelContent;
    }

    function areaKeyFunc(point){
        return point.properties.id;
    }

    function pointKeyFunc(point){
        return point.className;
    }

    var MapSvgRender = BaseRender.extend({
        render:function(){
            var map = this.component, geo = map.vanchart.getComponent(Constants.GEO_COMPONENT);
            var featureMap = geo.getFeatureMap(map.vanchart.series);
            this._updateShape(featureMap);
            this.updateLabel(featureMap);
        },

        _updateShape:function(featureMap){
            var area = featureMap.areaFeatures, bubble = featureMap.bubbleFeatures, scatter = featureMap.scatterFeatures, image = featureMap.imageFeatures;
            var leaflet = this.component.vanchart._leaflet;
            this._updateAreaMap(area, leaflet);
            this._updateBubbleMap(bubble, leaflet);
            this._updateScatterMap(scatter, leaflet);
            this._updateImageMap(image, leaflet);
            this._createDropShadow(leaflet);
        },

        updateLabel:function(featureMap){
            var map = this.component, geo = map.vanchart.getComponent(Constants.GEO_COMPONENT);
            var leaflet = map.vanchart._leaflet;

            featureMap = featureMap || geo.getFeatureMap(map.vanchart.series);
            var area = featureMap.areaFeatures, bubble = featureMap.bubbleFeatures, scatter = featureMap.scatterFeatures, image = featureMap.imageFeatures;

            this._fixConflictLabel(area, bubble, scatter, image);

            var areaText = area.filter(labelFilter), bubbleText = bubble.filter(labelFilter), scatterText = scatter.filter(labelFilter), imageText = image.filter(labelFilter);

            this._areaLabelLayer = this._areaLabelLayer || L.layerGroup().addTo(leaflet);
            this._updatePointLayerGroup(this._areaLabelLayer, L.text, areaText, null, pointKeyFunc);

            this._bubbleLabelLayer = this._bubbleLabelLayer || L.layerGroup().addTo(leaflet);
            this._updatePointLayerGroup(this._bubbleLabelLayer, L.text, bubbleText, null, pointKeyFunc);

            this._scatterLabelLayer = this._scatterLabelLayer || L.layerGroup().addTo(leaflet);
            this._updatePointLayerGroup(this._scatterLabelLayer, L.text, scatterText, null, pointKeyFunc);

            this._imageLabelLayer = this._imageLabelLayer || L.layerGroup().addTo(leaflet);
            this._updatePointLayerGroup(this._imageLabelLayer, L.text, imageText, null, pointKeyFunc);
        },

        //重新计算每个标签的位置
        _fixConflictLabel:function(areaText, bubbleText, scatterText, imageText){

            var pointsText = areaText.concat(bubbleText, scatterText, imageText);

            pointsText = pointsText.filter(validLabelFilter);

            var manager = new BoundsManager();

            var geo = this.component.vanchart.getComponent(Constants.GEO_COMPONENT);
            var leaflet = this.component.vanchart._leaflet;

            pointsText.forEach(function(point){
                if(point.dataLabels && point.feature && point.feature.properties.center){
                    var latlng = geo.getDataPointLatLng(point);
                    var pixels = leaflet.latLngToContainerPoint(latlng);
                    var labelBounds = BaseUtils.makeBounds(pixels, point.labelDim);
                    point.labelPos = labelBounds;
                    manager.addBounds(labelBounds);
                }
            });

            pointsText.forEach(function(point){
                if(point.dataLabels && ((point.feature && !point.feature.properties.center) || point.lnglat)){
                    var latlng = geo.getDataPointLatLng(point);
                    var pixels = leaflet.latLngToContainerPoint(latlng);
                    var labelBounds = BaseUtils.makeBounds(pixels, point.labelDim);
                    if(!manager.isOverlapped(labelBounds)){
                        point.labelPos = labelBounds;
                        manager.addBounds(labelBounds);
                    }else{
                        point.labelPos = null;
                    }
                }
            });
        },

        _updateAreaMap:function(area, leaflet){
            var renderer = this;
            var areaOptions = {
                style:function(feature){
                    return {
                        fillColor:feature.fillColor,
                        fillOpacity:feature.fillColorOpacity,
                        color:feature.borderColor,
                        weight:feature.borderWidth,
                        opacity:feature.borderOpacity
                    }
                },
                onEachFeature:function(feature, layer){
                    layer.on(renderer._areaMapHandler(layer))
                }
            };
            this._areaLayer = this._areaLayer || L.geoJson([], areaOptions).addTo(leaflet);
            this._updateAreaLayerGroup(this._areaLayer, area);
        },

        _updateBubbleMap:function(bubble, leaflet){
            //气泡地图
            var renderer = this;
            var bubbleOptions = {
                style:function(data){
                    return {
                        radius:data.radius,
                        fillColor:data.color,
                        fillOpacity:data.fillColorOpacity,
                        weight:0,
                        stroke:false
                    }
                },
                onEachLayer:function(layer){
                    layer.on(renderer._bubbleMapHandler(layer))
                }
            };
            this._bubbleLayer = this._bubbleLayer || L.layerGroup().addTo(leaflet);
            this._updatePointLayerGroup(this._bubbleLayer, L.circleMarker, bubble, bubbleOptions);
        },

        _updateScatterMap:function(scatter, leaflet){
            //散点地图
            var renderer = this;
            var scatterOptions = {
                style:function(feature){
                    var isHollow = renderer._isHollowMarker(feature.marker.symbol);

                    return isHollow ? {
                        fill:false,
                        stroke:true,
                        color:feature.marker.fillColor,
                        weight:2,
                        opacity:feature.fillColorOpacity,
                        markerType:feature.marker.symbol,
                        radius:feature.marker.radius
                    }:
                    {
                        fill:true,
                        stroke:false,
                        fillColor:feature.marker.fillColor,
                        fillOpacity:feature.fillColorOpacity,
                        markerType:feature.marker.symbol,
                        radius:feature.marker.radius
                    }
                },

                onEachLayer:function(layer){
                    layer.on(renderer._scatterMapHandler(layer))
                }
            };
            this._scatterLayer = this._scatterLayer || L.layerGroup().addTo(leaflet);
            this._updatePointLayerGroup(this._scatterLayer, L.scatterMarker, scatter, scatterOptions);
        },

        _updateImageMap:function(image, leaflet){
            //图片类型的标记点
            var renderer = this;
            var imageOptions = {
                style:function(feature){
                    return {icon:L.icon(feature.icon)}
                },

                onEachLayer:function(layer){
                    layer.on(renderer._imageMapHandler(layer))
                }
            };

            this._imageLayer = this._imageLayer || L.layerGroup().addTo(leaflet);
            this._updatePointLayerGroup(this._imageLayer, L.marker, image, imageOptions);
        },

        _updatePointLayerGroup:function(layerGroup, layerFunc, features, options){

            var layers = layerGroup.getLayers();
            var selection = this._rebindLayers(layers, features, pointKeyFunc);
            var geo = this.component.vanchart.getComponent(Constants.GEO_COMPONENT);

            for(var i = selection.enter.length - 1; i >= 0; i--){
                var point = selection.enter[i];
                var latlng = geo.getDataPointLatLng(point);

                var layer = layerFunc(latlng, options && options.style.call(null, point), point, this);
                options && options.onEachLayer.call(null, layer);
                layerGroup.addLayer(layer);
            }

            selection.exit.forEach(function(layer){layerGroup.removeLayer(layer);});

            layerGroup.getLayers().forEach(function(layer){
                layer.updateWithData && layer.updateWithData();
                var style = options && options.style.call(null, layer._data);
                layer.setStyle && layer.setStyle(style || {});
            });

        },

        _updateAreaLayerGroup:function(layerGroup, features){

            var layers = layerGroup.getLayers();
            var selection = this._rebindLayers(layers, features, areaKeyFunc);

            layerGroup.addData(selection.enter);
            selection.exit.forEach(function(layer){layerGroup.removeLayer(layer);});
            layers.forEach(function(layer){layerGroup.resetStyle(layer);});
        },

        //参考d3的selection的实现
        _rebindLayers:function(layers, dataArray, keyFunction){
            var i, n = layers.length, m = dataArray.length, enterFeatures = [], exitLayers = [];
            var nodeByKeyValue = {}, keyValues = new Array(n), keyValue, layer, data;
            for (i = -1; ++i < n; ) {
                layer = layers[i];
                keyValue = keyFunction(layer._data);
                nodeByKeyValue[keyValue] = layer;
                keyValues[i] = keyValue;
            }
            for (i = -1; ++i < m; ) {
                data = dataArray[i];
                keyValue = keyFunction(data);
                layer = nodeByKeyValue[keyValue];
                if (!layer) {
                    enterFeatures.push(data);
                }else if(layer !== true){
                    layer._data = data;
                    layer.feature = data;//兼容
                }
                nodeByKeyValue[keyValue] = true;
            }

            for (i = -1; ++i < n; ) {
                if (nodeByKeyValue[keyValues[i]] !== true) {
                    exitLayers[i] = layers[i];
                }
            }

            return {
                enter:enterFeatures,
                exit:exitLayers
            }
        },

        _createDropShadow:function(leaflet){
            if(!this._defs && leaflet){
                this._defs = d3.select(leaflet._renderer._container).append('defs');
                this._createDropShadowFilter(this._defs, this._getDropShadowID(), 0, 1, 0.5, 2);
            }
        },

        _areaMapHandler:function(layer){
            var map = this.component, renderer = this;
            var tooltip = map.vanchart.getComponent(Constants.TOOLTIP_COMPONENT);
            return {
                click:function(e){
                    var feature = layer._data;
                    map.drillDown(feature);
                    feature.onClick && feature.onClick(e.originalEvent);
                },

                mouseover:function(){
                    if(!layer._data.name){
                        return;
                    }

                    map.vanchart.hoverPoint = layer._data;

                    var areaLayers = renderer._areaLayer.getLayers(), feature = layer._data;
                    for(var i = 0, len = areaLayers.length; i < len; i++){
                        if(areaLayers[i]._data.name == layer._data.name){
                            areaLayers[i].setStyle({
                                fillColor:feature.mouseOverColor,
                                weight:2,
                                'filter':'url(#' + renderer._getDropShadowID() + ')'
                            });
                        }
                    }
                },
                mouseout:function(){
                    tooltip.hide();
                    var areaLayers = renderer._areaLayer.getLayers();
                    for(var i = 0, len = areaLayers.length; i < len; i++){
                        if(areaLayers[i]._data.name == layer._data.name){
                            var feature = areaLayers[i]._data;
                            areaLayers[i].setStyle({
                                fillColor:feature.fillColor,
                                weight: feature.borderWidth,
                                'filter':''
                            });
                        }
                    }
                },

                mousemove:function(){
                    var feature = layer._data;
                    tooltip.showWithPoint(feature);
                }
            }
        },

        _bubbleMapHandler:function(layer){
            var map = this.component, renderer = this;
            var tooltip = map.vanchart.getComponent(Constants.TOOLTIP_COMPONENT);
            return {
                click:function(e){
                    var feature = layer._data;
                    map.drillDown(feature);
                    feature.onClick && feature.onClick(e.originalEvent);
                },

                mouseover:function(){
                    var feature = layer._data;
                    var areaLayers = renderer._bubbleLayer.getLayers();
                    for(var i = 0, len = areaLayers.length; i < len; i++){
                        if(areaLayers[i]._data.name == layer._data.name){
                            d3.select(areaLayers[i]._path)
                                .style({
                                    'stroke':feature.mouseOverColor,
                                    'stroke-width':0,
                                    'stroke-opacity':0.35,
                                    'fill':feature.mouseOverColor
                                })
                                .interrupt(Constants.SELECT_ANIMATION).transition(Constants.SELECT_ANIMATION)
                                .duration(200).ease('back-out').style('stroke-width', 6)
                        }
                    }
                },

                mouseout:function(){
                    tooltip.hide();

                    var areaLayers = renderer._bubbleLayer.getLayers();
                    var feature = layer._data;
                    for(var i = 0, len = areaLayers.length; i < len; i++){
                        if(areaLayers[i]._data.name == layer._data.name){
                            d3.select(areaLayers[i]._path)
                                .style('fill', feature.color)
                                .style('fill-opacity', feature.fillColorOpacity)
                                .interrupt(Constants.SELECT_ANIMATION)
                                .transition(Constants.SELECT_ANIMATION);
                            d3.select(areaLayers[i]._path)
                                .style('stroke-width', 0);
                        }
                    }
                },

                mousemove:function(){
                    var feature = layer._data;
                    tooltip.showWithPoint(feature);
                }
            }
        },

        _scatterMapHandler:function(layer){
            var map = this.component, renderer = this;
            var tooltip = map.vanchart.getComponent(Constants.TOOLTIP_COMPONENT);

            return {
                click:function(e){
                    var feature = layer._data;
                    map.drillDown(feature);
                    feature.onClick && feature.onClick(e.originalEvent);
                },

                mouseover:function(){
                    var feature = layer._data;
                    var markerType = feature.marker.symbol;
                    var radius =  feature.marker.radius || map.getDefaultMarkerRadius();
                    var markerHighlightColor = feature.mouseOverColor || ColorUtils.getHighLightColor(feature.marker.fillColor);
                    var isHollow = renderer._isHollowMarker(feature.marker.symbol);

                    var areaLayers = renderer._scatterLayer.getLayers();
                    for(var i = 0, len = areaLayers.length; i < len; i++){
                        if(areaLayers[i]._data.name == layer._data.name){
                            d3.select(areaLayers[i]._path)
                                .style(isHollow ? 'stroke':'fill', markerHighlightColor)
                                .interrupt(Constants.SELECT_ANIMATION)
                                .transition(Constants.SELECT_ANIMATION)
                                .ease('ease-out-expo')
                                .attr('d', renderer._getMarkerPath(markerType, radius + 2))
                        }
                    }

                },

                mouseout:function(){
                    tooltip.hide();

                    var feature = layer._data;
                    var markerType = feature.marker.symbol;
                    var radius =  feature.marker.radius || map.getDefaultMarkerRadius();
                    var areaLayers = renderer._scatterLayer.getLayers();
                    var isHollow = renderer._isHollowMarker(feature.marker.symbol);
                    for(var i = 0, len = areaLayers.length; i < len; i++){
                        if(areaLayers[i]._data.name == layer._data.name){
                            d3.select(areaLayers[i]._path)
                                .interrupt(Constants.SELECT_ANIMATION)
                                .style(isHollow ? 'stroke':'fill', feature.marker.fillColor)
                                .attr('d', renderer._getMarkerPath(markerType, radius));
                        }
                    }
                },

                mousemove:function(){
                    var feature = layer._data;
                    tooltip.showWithPoint(feature);
                }
            }
        },

        _imageMapHandler:function(layer){
            var map = this.component, renderer = this;
            var tooltip = map.vanchart.getComponent(Constants.TOOLTIP_COMPONENT);
            return {
                click:function(e){
                    var feature = layer._data;
                    map.drillDown(feature);
                    feature.onClick && feature.onClick(e.originalEvent);
                },

                mouseover:function(){

                },

                mouseout:function(){
                    tooltip.hide();
                },

                mousemove:function(){
                    var feature = layer._data;
                    tooltip.showWithPoint(feature);
                }
            }
        },

        _getDropShadowID:function(){
            return this.component.vanchart.getIDPrefix() + Constants.MAP_CHART;
        },

        filterRender:function(){
            this.render();
        }
    });
    
    require('./RenderLibrary').register(Constants.MAP_SVG, MapSvgRender);

    return MapSvgRender;
});
/**
 * Created by eason on 16/5/17.
 */
define('render/DrillToolsSvgRender',['require','./BaseRender','../utils/BaseUtils','../Constants','./RenderLibrary'],function(require){

    var BaseRender = require('./BaseRender');
    var BaseUtils = require('../utils/BaseUtils');
    var Constants = require('../Constants');

    var DrillToolsSvgRender = BaseRender.extend({
        render:function(){
            var cfg = this.component.componentOption;
            var b = this.component.bounds;
            var svgRoot = this.component.getVanchartRender().getRenderRoot();
            this._bodyG = this._bodyG || svgRoot.append('g').style("pointer-events", "all");

            var shadowID = this.component.vanchart.getIDPrefix() + Constants.DRILL_TOOLS + "shadow";
            var clipID = this.component.vanchart.getIDPrefix() + Constants.DRILL_TOOLS + 'clip';
            if(!this._defs){
                this._defs = this._bodyG.append('defs');
                this._createDropShadowFilter(this._defs, shadowID, 0, 0, 0.15, 1);
                this._defs.append('clipPath').attr('id', clipID).append('rect').attr('width', b.width).attr('height', b.height);
            }

            this._bodyG.attr('transform', BaseUtils.makeTranslate(b)).attr('clip-path', "url(#" + clipID +")");

            var dTools = this.component;
            var map = dTools.vanchart.getChart(Constants.MAP_CHART);
            var iconS = this._bodyG.selectAll('g').data(this.component.getIconData(), function(d){return d.layerIndex});

            //update状态的标签注意改文字颜色
            iconS.select('text').style('fill', function(d){return dTools.textColor(d);});

            var exitData = [];
            var exit = iconS.exit().each(function(d){exitData.push(d)});
            dTools.calculateExitAnimation(exitData);
            exit.transition()
                .duration(function(d){return d.time;}).delay(function(d){return d.delay;})
                .ease('quad-in').attr('transform', function(d){return BaseUtils.makeTranslate([d.aniStart, 0])})
                .style('opacity', 0)
                .remove();

            iconS.enter().insert('g', ':first-child').each(function(d){
                var label = d.geo.geoName;
                var g = d3.select(this).style('cursor', 'pointer');
                g.append('path').attr('d', dTools.getBookMarkPath(d)).style('fill', cfg.backgroundColor).style("filter", 'url(#'+ shadowID +')');
                g.append('text').text(label).attr('x', dTools.leftPadding(d) + 'em').attr('y', (dTools.topPadding() + .85) + 'em')
                    .call(BaseUtils.setTextStyle, cfg.style).style('fill', cfg.currentColor);
                g.attr('transform', BaseUtils.makeTranslate([d.aniStart, 0]))
                    .transition().duration(500).ease('cubic-out')
                    .attr('transform', BaseUtils.makeTranslate([d.aniEnd, 0]));
                g
                    .on('click', function(d){
                        
                        var dataPoint = dTools.findDataPointByName(d.geo.geoName);
                        cfg.click && cfg.click(dataPoint);

                        map.drillUp(d);
                    })
                    .on('mouseenter', function(d){
                        d3.select(this).select('text').style('fill', dTools.mouseOverColor(d));
                    })
                    .on('mouseleave', function(d){
                        d3.select(this).select('text').style('fill', dTools.textColor(d));
                    })
            })
        }
    });
    
    require('./RenderLibrary').register(Constants.DRILL_TOOLS_SVG, DrillToolsSvgRender);

    return DrillToolsSvgRender;
});
/**
 * Created by eason on 15/8/14.
 */

define('render/TitleSvgRender',['require','./BaseRender','../utils/BaseUtils','../Constants','../utils/BezierEasing','./RenderLibrary'],function(require){

    var BaseRender = require('./BaseRender');
    var BaseUtils = require('../utils/BaseUtils');
    var Constants = require('../Constants');
    var BezierEasing = require('../utils/BezierEasing');

    var TITLE_GRADUAL = 'title-gradual-background';

    var TitleSvgRender = BaseRender.extend({
        render:function(){

            if(this._titleG){
                return;
            }

            var cfg = this.component.componentOption;
            var bounds = this.component.bounds;
            var svgRoot = this.component.getVanchartRender().getRenderRoot();

            var IDPrefix = this.component.vanchart.getIDPrefix();
            var gradualID = TITLE_GRADUAL + IDPrefix;

            if(!this._titleG){
                this._backgroundG = svgRoot.append('g')
                    .attr('transform', 'translate(' + bounds.x + ',' + bounds.y + ')');

                this._titleG = svgRoot.append('g');
            }

            //背景
            if(cfg.backgroundColor){

                this._createGradualDefs(this._titleG, cfg.backgroundColor, gradualID);

                this._backgroundG
                    .append('rect')
                    .attr('x', 0)
                    .attr('y', 0)
                    .attr('width', bounds.width)
                    .attr('height', bounds.height)
                    .attr('rx', cfg.borderRadius)
                    .attr('ry', cfg.borderRadius)
                    .style('fill', function(){
                        return typeof cfg.backgroundColor == 'string' ?
                            cfg.backgroundColor : "url(#" + gradualID + ")";
                    });
            }

            var textDim = this.component.textDim;
            var padding = this.component.getPadding();
            var textBounds = {
                x: bounds.x + padding,
                y: bounds.y + padding,
                width: textDim.width,
                height: textDim.height
            };

            if (!this.component.isFloat && cfg.align === 'center') {
                textBounds.x = bounds.x + bounds.width / 2 - textDim.width / 2;
            }

            this.textBounds = textBounds;

            if (cfg.useHtml) {
                this._drawTitle(cfg, textBounds);
            } else {

                var result = BaseUtils.splitText(cfg.text, cfg.style, textBounds.width);

                var lineHeight = textDim.height / result.length;

                var x, textAnchor;
                var align = cfg.align || 'left';
                switch (align) {
                    case 'left':
                        textAnchor = 'start';
                        x = textBounds.x;
                        break;
                    case 'center':
                        textAnchor = 'middle';
                        x = textBounds.x + textDim.width / 2;
                        break;
                    case 'right':
                        textAnchor = 'end';
                        x = textBounds.x + textDim.width;
                        break;
                }

                for (var index = 0, len = result.length; index < len; index++) {
                    this._titleG
                        .append('text')
                        .attr('x', x)
                        .attr('y', textBounds.y + lineHeight * index + lineHeight / 2)
                        .attr("dy", ".32em")
                        .attr('class', Constants.CHART_HIDE)
                        .style("text-anchor", textAnchor)
                        .text(result[index])
                        .call(BaseUtils.setTextStyle, cfg.style);
                }
            }
        },

        translateX:function(width){
            if (!width) {
                return;
            }

            var translate = d3.transform(this._titleG.attr('transform')).translate;

            var newX = translate[0] + width;

            this._titleG.transition().ease(BezierEasing.css.swing).duration(300)
                .attr('transform', 'translate(' + newX + ',' + translate[1] + ')');

        },

        changeTextRightSpace: function (changes) {

            if (this.component.isFloat) {
                return;
            }

            switch (this.component.componentOption.align) {
                case 'center':
                    var bounds = this.component.bounds;
                    var initTextDim = this.component.textDim;
                    var initTextX = bounds.x + bounds.width / 2 - initTextDim.width / 2;
                    var textBounds = this.textBounds;
                    var padding = this.component.getPadding();
                    var barWidth = this.component.vanchart.getToolbarWidth();
                    var initBarWidth = this.component.initBarWidth;

                    var gap = bounds.width / 2 - initTextDim.width / 2 - initBarWidth - padding;

                    var changesToInit = barWidth - initBarWidth;

                    var x = textBounds.x;
                    var width = textBounds.width;

                    if (gap <= 0 && changesToInit) {
                        x = bounds.x;
                        width = bounds.width - barWidth;
                    } else if (gap < changesToInit) {
                        x = initTextX - (changesToInit - gap);
                    } else {
                        x = initTextX;
                        width = initTextDim.width;
                    }

                    this.labelDivManager.changeLabelDim({
                        left: x - textBounds.x,
                        width: width - textBounds.width
                    });

                    this.translateX(width - textBounds.width + x - textBounds.x);

                    this.textBounds.x = x;
                    this.textBounds.width = width;

                    break;
                default:
                    // adjust width
                    this.labelDivManager.changeLabelDim({
                        width: -changes
                    });

                    this.translateX(-changes);

            }
        },

        remove:function(){
            if(this._titleG){
                this._titleG.remove();
                this._titleG = null;
            }
            this.removeDivLabels();
        }
    });

    require('./RenderLibrary').register(Constants.TITLE_SVG, TitleSvgRender);
    return TitleSvgRender;
});
/**
 * Created by eason on 15/9/25.
 */

define('render/BaseAxisSvgRender',['require','./BaseRender','../utils/BaseUtils','../utils/BezierEasing','../Constants'],function(require){

    var BaseRender = require('./BaseRender');
    var BaseUtils = require('../utils/BaseUtils');
    var BezierEasing = require('../utils/BezierEasing');
    var Constants = require('../Constants');


    var TIME = 400;
    var EASE = BezierEasing.css.swing;

    var MONITOR_EASE = 'linear';
    var MONITOR_TIME = 500;

    var TICK_TEXT = 'axis-tick-text';
    var TICK_LINE = 'axis-tick-line';
    var MINOR_TICK_LINE = 'axis-minor-tick-line';
    var GRID_LINE = 'axis-grid-line';
    var PLOT_BANDS = 'plot-bands';
    var PLOT_LINES = 'plot-lines';
    var AXIS_LINE = 'axis-line';
    var HIGHLIGHT_BAND = 'highlight-band';

    var BaseAxisSvgRender = BaseRender.extend({

        render:function(){

            var svgRoot = this.component.getVanchartRender().getRenderRoot().select('g.' + Constants.AXIS_GROUP);

            this.labelDivManager.clearAllLabels();

            if(this._axisG){
                if(this.component.option.plotOptions.large){
                    this._axisG.call(this._drawAxis.bind(this));
                }else{
                    this._axisG.transition().ease(EASE).duration(TIME).call(this._drawAxis.bind(this));
                }

                clearTimeout(this._animation_);
                var self = this;
                this._animation_ = setTimeout(function(){
                    self._axisG.call(self._drawAxis.bind(self));
                }, TIME + 100)

            }else{
                this._axisG =  svgRoot.append('g');
                this._axisG.call(this._drawAxis.bind(this));
            }

            this._axisTitleG = this._axisTitleG || svgRoot.append('g');

            var titleBounds = this.component.getAxisTitleBounds();

            this._axisTitleG.attr('transform', 'translate(' + titleBounds.x + ',' + titleBounds.y + ')');

            this._drawAxisTitle(titleBounds);
        },

        drawHighlightBand: function (pos) {

            var axis = this.component;
            if (!axis._getBandByPosition) {
                return;
            }

            var drawBand = axis._getBandByPosition(pos);
            var highlightType = axis.getHighlightType();

            this.removeHighlightBand();

            switch (highlightType) {
                case 'band':
                    this._axisG
                        .append('rect')
                        .attr('class', HIGHLIGHT_BAND)
                        .attr('x', drawBand.x)
                        .attr('y', drawBand.y)
                        .attr('width', drawBand.width)
                        .attr('height', drawBand.height)
                        .style('fill', 'rgba(98,179,240,0.2)');

                    break;
                case 'line':
                default:
                    this._axisG
                        .append('line')
                        .attr('class', HIGHLIGHT_BAND)
                        .attr('x1', drawBand.x)
                        .attr('y1', drawBand.y)
                        .attr('x2', drawBand.x + drawBand.width)
                        .attr('y2', drawBand.y + drawBand.height)
                        .attr('stroke', 'rgb(140,140,140)')
                        .attr('stroke-width', '1');
            }

        },

        removeHighlightBand: function () {
            this._axisG.select('.' + HIGHLIGHT_BAND).remove();
        },
        
        _drawPlotBands:function(g){

            var plotBands = this.component._preCalculatePlotBands();
            var plotBounds = this.component.getPlotBounds();

            g.each(function(){

                var bands = d3.select(this)
                    .selectAll('.' + PLOT_BANDS).data(plotBands);

                bands.exit().remove();

                bands.enter().append('rect').attr('class', PLOT_BANDS);

                bands
                    .attr('transform', BaseUtils.makeTranslate(plotBounds))
                    .style('fill', function(d){return d.color});

                d3.transition(bands)
                    .attr('x', function(d){return d.x})
                    .attr('y', function(d){return d.y})
                    .attr('width', function(d){return d.width})
                    .attr('height', function(d){return d.height});
            });
        },

        _drawPlotLines:function(g){

            var plotLines = this.component._preCalculatePlotLines();
            var plotBounds = this.component.getPlotBounds();

            g.each(function(){

                var lines = d3.select(this)
                    .selectAll('.' + PLOT_LINES).data(plotLines);

                lines.exit().remove();

                var lineEnter = lines.enter().append('g').attr('class', PLOT_LINES);
                lineEnter.append('line');
                lineEnter.append('text');

                d3.transition(lines).attr('transform', BaseUtils.makeTranslate(plotBounds));

                d3.transition(lines.select('line'))
                    .attr('x1', function(d){return d.startPos.x})
                    .attr('y1', function(d){return d.startPos.y})
                    .attr('x2', function(d){return d.endPos.x})
                    .attr('y2', function(d){return d.endPos.y})
                    .style('stroke', function(d){
                        return d.color;
                    })
                    .style('stroke-width', function(d){
                        return d.width;
                    })
                    .style('stroke-dasharray', function(d){
                        return d.dataArray;
                    });

                d3.transition(lines.select('text'))
                    .text(function(d){
                        return d.text;
                    })
                    .attr('x', function(d){
                        return d.textX;
                    })
                    .attr('y', function(d){
                        return d.textY;
                    })
                    .attr('dy', '0.85em')
                    .each(function(d){
                        d3.select(this)
                            .call(BaseUtils.setTextStyle, d.style);
                    });
            });
        },

        _drawGridLine:function(g){
            var cfg = this.component.componentOption;
            var plotBounds = this.component.getPlotBounds();
            var gridLineWidth = cfg.gridLineWidth;
            var ticks = this.component.getTickData();
            var scale = this.component.scale;
            var lastScale = this.component.lastScale || scale;

            var x1 = 'x1', y1 = 'y1', x2 = 'x2', y2 = 'y2';
            var lineSize = plotBounds.height;
            var endPos = plotBounds.width;

            if(!this.component.isHorizontal()){
                x1 = 'y1'; y1 = 'x1'; x2 = 'y2'; y2 = 'x2';
                lineSize = plotBounds.width;
                endPos = 0;
            }

            var gridLineColor = cfg.gridLineColor;
            var det = BaseUtils.lineSubPixelOpt(0, gridLineWidth);

            g.each(function(){

                d3.select(this).selectAll('.' + GRID_LINE).data([0]).enter().append('g').attr('class', GRID_LINE);

                var gridLines = d3.select(this).select('g.' + GRID_LINE)
                                        .selectAll('line').data(ticks, function(d){return d.tickValue});

                if(gridLineWidth){

                    d3.transition(gridLines.exit())
                        .style("opacity", 0)
                        .attr(x1, function(d){
                            return scale(d.tickValue);
                        })
                        .attr(y1, 0)
                        .attr(x2, function(d){
                            return scale(d.tickValue);
                        })
                        .attr(y2, lineSize)
                        .remove();

                    var enter = gridLines.enter();

                    enter.append('line')
                        .attr('class', GRID_LINE)
                        .attr('transform', BaseUtils.makeTranslate(plotBounds))
                        .attr(x1, function(d){
                            return lastScale(d.tickValue) + det}
                        )
                        .attr(y1, 0)
                        .attr(x2, function(d){return lastScale(d.tickValue) + det})
                        .attr(y2, lineSize)
                        .style({
                            'stroke':gridLineColor,
                            'stroke-width':gridLineWidth,
                            'opacity':0
                        });

                    d3.transition(gridLines)
                        .attr('transform', BaseUtils.makeTranslate(plotBounds))
                        .attr(x1, function(d){return d.tickPos + det})
                        .attr(y1, 0)
                        .attr(x2, function(d){return d.tickPos + det})
                        .attr(y2, lineSize)
                        .style('opacity', 1);
                }else{
                    gridLines.remove();
                }

            });
        },

        _drawTickLine:function(g){

            var cfg = this.component.componentOption;

            var ticks = this.component.getMainTickData();
            var tickLength = cfg.enableTick ? cfg.tickLength : 0;
            var tickWidth = cfg.tickWidth;
            var tickColor = cfg.tickColor;
            var axisOrigin = this.component._getAxisOriginPoint();
            var orient = this.component.getPosition();

            var x1 = 'x1', y1 = 'y1', x2 = 'x2', y2 = 'y2';
            if(!this.component.isHorizontal()){
                x1 = 'y1'; y1 = 'x1'; x2 = 'y2'; y2 = 'x2';
            }

            var sign = (orient == Constants.TOP || orient == Constants.LEFT) ? -1 : 1;
            var det = BaseUtils.lineSubPixelOpt(0, tickWidth);

            g.each(function(){

                var tickLines = d3.select(this).selectAll('.' + TICK_LINE).data(ticks);

                if(tickLength && tickWidth){

                    tickLines.enter()
                        .append('line').attr('class', TICK_LINE)
                        .attr('transform', BaseUtils.makeTranslate(axisOrigin))
                        .style({
                            'stroke':tickColor,
                            'stroke-width':tickWidth
                        });

                    tickLines.exit().remove();

                    d3.transition(tickLines)
                        .attr('transform', BaseUtils.makeTranslate(axisOrigin))
                        .attr(x1, function(d){
                            return d.tickPos + det;
                        })
                        .attr(y1, 0)
                        .attr(x2, function(d){
                            return d.tickPos + det;
                        })
                        .attr(y2, sign * tickLength);
                }else{
                    tickLines.remove();
                }
            });

        },

        _drawTickLabel:function(g){

            var cfg = this.component.componentOption;
            var plotBounds = this.component.getPlotBounds();

            var scale = this.component.scale;
            var lastScale = this.component.lastScale || scale;

            var ticks = this.component.getTickData();
            var tickLength = cfg.enableTick ? cfg.tickLength : 0;
            var labelRotation = cfg.labelRotation || 0;
            var axisOrigin = this.component._getAxisOriginPoint();
            var useHtml = cfg.useHtml && !cfg.labelRotation;
            var labelStyle = cfg.labelStyle;
            var labelHeight = BaseUtils.getTextHeight(labelStyle);
            var tickPadding = cfg.tickPadding + tickLength || 0;

            var orient = this.component.getPosition();
            var sign = (orient == Constants.TOP || orient == Constants.LEFT) ? -1 : 1;

            var isHorizontal = this.component.isHorizontal();

            var x = 'x', y = 'y';
            if(!isHorizontal){
                x = 'y'; y = 'x';
            }

            var self = this;

            g.each(function(){

                var tickLabels = d3.select(this)
                    .selectAll('.' + TICK_TEXT)
                    .data(ticks, function(d){return d.tickValue});

                if(cfg.showLabel && !useHtml){

                    tickLabels.enter()
                        .append('text')
                        .attr('class', TICK_TEXT)
                        .attr('transform', function(d){
                            return self._getLabelTransform(lastScale, d, sign, tickPadding, axisOrigin, labelRotation);
                        })
                        .attr(x, function(d){return lastScale(d.tickValue);})
                        .style('text-anchor', 'middle')
                        .style('opacity', 0)
                        .call(BaseUtils.setTextStyle, labelStyle);

                    d3.transition(tickLabels.exit())
                        .attr(x, function(d){
                            return scale(d.tickValue);
                        })
                        .style('opacity', 0)
                        .remove();


                    d3.transition(tickLabels)
                        .attr('transform', function(d){
                            return self._getLabelTransform(scale, d, sign, tickPadding, axisOrigin, labelRotation);
                        })
                        .text(function(d){return d.tickContent;})
                        .attr(x, function(d){return d.tickLabelPos;})
                        .attr(y, function(d){
                            if(isHorizontal){
                                var tmp = orient == Constants.TOP ? (tickPadding + d.tickDim.height/2 - labelHeight/2) : (tickPadding + d.tickDim.height/2 + labelHeight/2);
                                return sign * tmp;
                            }else{
                                return sign * (tickPadding + d.tickDim.width/2)
                            }
                        })
                        .attr('dy', isHorizontal ? 0 : '.32em')
                        .style('opacity', 1);

                }else{
                    tickLabels.remove();
                }
            });
        },

        _getLabelTransform:function(scale, d, sign, tickPadding, axisOrigin, labelRotation){

            var det = scale.rangeBand ? -scale.rangeBand()/2 : 0;
            var tickLabelPos = Math.round(scale(d.tickValue)) - det;

            var rx, ry;
            if(this.component.isHorizontal()){
                rx = tickLabelPos;
                ry = sign * (tickPadding + d.tickDim.height/2);
            }else{
                rx = sign * (tickPadding + d.tickDim.width/2);
                ry = tickLabelPos;
            }
            return BaseUtils.makeTranslate(axisOrigin) + 'rotate(' + labelRotation + ' ' + rx + ',' + ry + ')';
        },

        _drawAxisLine:function(g){
            var cfg = this.component.componentOption;
            var plotBounds = this.component.getPlotBounds();
            var axisOrigin = this.component._getAxisOriginPoint();
            var lineWidth = cfg.lineWidth;
            var lineColor = cfg.lineColor;

            var x1 = 'x1', y1 = 'y1', x2 = 'x2', y2 = 'y2';
            var size = plotBounds.width;

            if(!this.component.isHorizontal()){
                x1 = 'y1'; y1 = 'x1'; x2 = 'y2'; y2 = 'x2';
                size = plotBounds.height;
            }

            var det = BaseUtils.lineSubPixelOpt(0, lineWidth);

            g.each(function(){

                var path = d3.select(this).selectAll("line." + AXIS_LINE).data([ 0 ]);

                if(lineWidth){

                    path.exit().remove();

                    path.enter().append('line').attr('class', AXIS_LINE);

                    d3.transition(path)
                        .attr('transform', BaseUtils.makeTranslate(axisOrigin))
                        .attr(x1, 0)
                        .attr(y1, det)
                        .attr(x2, size)
                        .attr(y2, det)
                        .style({
                            'stroke':lineColor,
                            'stroke-width':lineWidth
                        });
                }else{
                    path.remove();
                }

            });

        },

        _drawMinorTickLine:function(g){

            var cfg = this.component.componentOption;
            var minorTickLength = cfg.enableMinorTick ? cfg.minorTickLength : 0;
            var minorTickWidth = cfg.minorTickWidth;
            var minorTickColor = cfg.minorTickColor;
            var minorTickData = this.component.getMinorTickData();

            var axisOrigin = this.component._getAxisOriginPoint();
            var orient = this.component.getPosition();

            var x1 = 'x1', y1 = 'y1', x2 = 'x2', y2 = 'y2';
            if(!this.component.isHorizontal()){
                x1 = 'y1'; y1 = 'x1'; x2 = 'y2'; y2 = 'x2';
            }

            var sign = (orient == Constants.TOP || orient == Constants.LEFT) ? -1 : 1;
            var det = BaseUtils.lineSubPixelOpt(0, minorTickWidth);

            var isCategory = this.component.type == Constants.CATEGORY_AXIS_COMPONENT;
            var scale = this.component.scale;

            g.each(function(){

                var minorTicks = d3.select(this)
                    .selectAll('.' + MINOR_TICK_LINE)
                    .data(minorTickData);

                if(minorTickLength && minorTickWidth){

                    minorTicks.enter()
                        .append('line').attr('class', MINOR_TICK_LINE)
                        .attr('transform', BaseUtils.makeTranslate(axisOrigin))
                        .style({
                            'stroke':minorTickColor,
                            'stroke-width':minorTickWidth
                        });

                    minorTicks.exit().remove();

                    d3.transition(minorTicks)
                        .attr('transform', BaseUtils.makeTranslate(axisOrigin))
                        .attr(x1, function(d){
                            return (isCategory ? d : scale(d)) + det;
                        })
                        .attr(y1, 0)
                        .attr(x2, function(d){
                            return (isCategory ? d : scale(d)) + det;
                        })
                        .attr(y2, sign * minorTickLength);
                }else{
                    minorTicks.remove();
                }
            });
        },

        _drawDivLabels:function(){

            var labelDivManager = this.labelDivManager;
            var cfg = this.component.componentOption;

            if(!cfg.useHtml || cfg.labelRotation){
                return;
            }

            var origin = this.component._getAxisOriginPoint();

            var transX = origin.x;
            var transY = origin.y;

            var orient = this.component.getPosition();
            var isHorizontal = this.component.isHorizontal();
            var scale = this.component.getTickScale();
            var ticks = this.component.getTickData();

            var tickLength = cfg.enableTick ? cfg.tickLength : 0;
            var tickSpacing = (scale.rangeBand ? 0 : tickLength) + cfg.tickPadding;

            var labelStyle = cfg.labelStyle;
            var labelHeight = BaseUtils.getTextHeight(labelStyle);

            var x,y;
            if(cfg.useHtml && !cfg.labelRotation){

                if(isHorizontal){

                    y = orient == Constants.TOP ? -(tickSpacing + labelHeight) : tickSpacing;

                    ticks.forEach(function(tick){

                        x = tick.tickLabelPos - tick.tickDim.width/2;

                        labelDivManager.addLabel(tick.tickContent, {x:x + transX, y:y + transY}, labelStyle);

                    });

                }else{

                    ticks.forEach(function(tick){

                        x = orient == Constants.LEFT ? -(tickSpacing + tick.tickDim.width) : tickSpacing;
                        y = tick.tickLabelPos - labelHeight/2;

                        labelDivManager.addLabel(tick.tickContent, {x:x + transX, y:y + transY}, labelStyle);
                    });
                }
            }

        },

        /**
         * 坐标轴的刻度线，同区域背景什么的要分开画
         * @param selection
         * @private
         */
        _drawAxis:function(g) {

            this._drawPlotBands(g);

            this._drawAxisLine(g);

            this._drawGridLine(g);

            this._drawArrow(g);

            this._drawTickLine(g);

            this._drawTickLabel(g);

            this._drawDivLabels();

            this._drawMinorTickLine(g);

            this._drawPlotLines(g);
        },

        _drawArrow:function(g){

            if(!this.component.showArrow()){
                return;
            }

            var plotBounds = this.component.getPlotBounds();
            var cfg = this.component.componentOption;
            var lineWidth = cfg.lineWidth;
            var lineColor = cfg.lineColor;
            var pathDet = BaseUtils.lineSubPixelOpt(0, lineWidth);
            var axisOrigin = this.component._getAxisOriginPoint();

            this._axisG.select('g.arrow').remove();

            var transform;
            if (this.component.isHorizontal()) {
                if (this.component.isAxisReversed()) {
                    transform = BaseUtils.makeTranslate([axisOrigin.x, axisOrigin.y])
                        + ' rotate(180)';
                    pathDet = -pathDet;
                } else {
                    transform = BaseUtils.makeTranslate([axisOrigin.x + plotBounds.width, axisOrigin.y]);
                }
            } else {
                if (this.component.isAxisReversed()) {
                    transform = BaseUtils.makeTranslate([axisOrigin.x, axisOrigin.y + plotBounds.height])
                        + ' rotate(90)';
                    pathDet= -pathDet;
                } else {
                    transform = BaseUtils.makeTranslate([axisOrigin.x, axisOrigin.y])
                        + ' rotate(-90)';
                }
            }

            var arrowG = this._axisG.append('g')
                .attr('class', 'arrow')
                .attr('transform', transform);
            arrowG.append('line');
            arrowG.append('path');

            arrowG
                .select('line')
                .attr('x1', 0)
                .attr('y1', pathDet)
                .attr('x2', 6)
                .attr('y2', pathDet)
                .style({
                    'stroke':lineColor,
                    'stroke-width':lineWidth
                });

            arrowG
                .select('path')
                .attr("d", "M2,2 L10,6 L2,10 L6,6 L2,2")
                .attr('transform', 'translate(0,' + (pathDet-6) + ')')
                .style('fill', lineColor);

        },

        _drawAxisTitle:function(titleBounds){
            this.component.isHorizontal() ? this._drawHorizontalTitle(titleBounds)
                : this._drawVerticalTitle(titleBounds);
        },

        _drawHorizontalTitle:function(titleBounds){
            var cfg = this.component.componentOption;

            if(cfg.title){

                var title = cfg.title;

                if(title.useHtml){
                    this._drawHorizontalAxisTitleWithHtml(title, titleBounds);
                }else{
                    var rotation = title.rotation || 0;

                    var textDim = BaseUtils.getTextDimension(title.text, title.style, title.useHtml);

                    var x, textAnchor, rx;
                    var align = this.component.getTitleAlign();
                    switch(align){
                        case 'left':
                            x = 0;
                            rx = x + textDim.width/2;
                            textAnchor = 'start';
                            break;
                        case 'center':
                            x = titleBounds.width/2;
                            rx = x;
                            textAnchor = 'middle';
                            break;
                        case 'right':
                            x = titleBounds.width;
                            rx = x - textDim.width/2;
                            textAnchor = 'end';
                            break;
                    }

                    var gap = this.component.getTitleLabelGap();
                    var ry = titleBounds.height/2;
                    var y = textDim.height * 0.85 + (this.component.getPosition() == Constants.BOTTOM ? gap : -gap);

                    this._axisTitleG.select('text').remove();

                    this._axisTitleG
                        .append('text')
                        .attr('x', x)
                        .attr('y', y)
                        .text(title.text)
                        .style('text-anchor', textAnchor)
                        .attr('transform', 'rotate(' + rotation + ' ' + rx + ',' + ry + ')')
                        .call(BaseUtils.setTextStyle, title.style);
                }
            }
        },

        _drawVerticalTitle:function(titleBounds){

            var cfg = this.component.componentOption;

            if(cfg.title) {
                var title = cfg.title;
                if(title.useHtml){
                    this._drawVerticalAxisTitleWithHtml(title, titleBounds);
                }else{
                    var rotation = title.rotation || 0;

                    var textDim = BaseUtils.getTextDimension(title.text, title.style, title.useHtml);
                    var rotatedDim = BaseUtils.getTextDimensionWithRotation(title.text, title.style, title.useHtml, rotation);

                    var x = titleBounds.width / 2;
                    var rx = x;

                    var align = this.component.getTitleAlign();
                    var y, ry;
                    switch(align){
                        case 'top':
                            y = textDim.height + rotatedDim.height/2;
                            break;
                        case 'center':
                            y = textDim.height + (titleBounds.height - textDim.height)/2;
                            break;
                        case 'bottom':
                            y = titleBounds.height - rotatedDim.height/2;
                            break;
                    }

                    ry = y;

                    this._axisTitleG.select('text').remove();

                    this._axisTitleG
                        .append('text')
                        .attr('x', x)
                        .attr('y', y)
                        .text(title.text)
                        .style('text-anchor', 'middle')
                        .attr('transform', 'rotate(' + rotation + ' ' + rx + ',' + ry + ')')
                        .call(BaseUtils.setTextStyle, title.style);
                }
            }
        },

        remove:function(){
            this.removeDivLabels();
            this._axisG.remove();
            this._axisTitleG.remove();
        }
    });

    return BaseAxisSvgRender;
});
/**
 * Created by eason on 15/9/25.
 */

define('render/CategoryAxisSvgRender',['require','./BaseAxisSvgRender','../Constants','./RenderLibrary'],function(require){

    var BaseAxisRender = require('./BaseAxisSvgRender');
    
    var Constants = require('../Constants');

    var CategoryAxisSvgRender = BaseAxisRender.extend({});

    require('./RenderLibrary').register(Constants.CATEGORY_AXIS_SVG, CategoryAxisSvgRender);
});
/**
 * Created by eason on 15/9/25.
 */

define('render/ValueAxisSvgRender',['require','./BaseAxisSvgRender','../Constants','./RenderLibrary'],function(require){

    var BaseAxisRender = require('./BaseAxisSvgRender');
    var Constants = require('../Constants');

    var ValueAxisSvgRender = BaseAxisRender.extend({});
    
    require('./RenderLibrary').register(Constants.VALUE_AXIS_SVG, ValueAxisSvgRender);
});
/**
 * Created by Jeffrey on 16/4/22.
 */

define('render/RadiusAxisSvgRender',['require','./BaseRender','../utils/BaseUtils','../utils/BezierEasing','../Constants','./RenderLibrary'],function(require){

    var BaseRender = require('./BaseRender');
    var BaseUtils = require('../utils/BaseUtils');
    var BezierEasing = require('../utils/BezierEasing');
    var Constants = require('../Constants');


    var TIME = 400;
    var EASE = BezierEasing.css.swing;

    var MONITOR_EASE = 'linear';
    var MONITOR_TIME = 500;
    var ANIMATION_TIME = 500;

    var TICK_TEXT = 'axis-tick-text';
    var TICK_LINE = 'axis-tick-line';
    var MINOR_TICK_LINE = 'axis-minor-tick-line';
    var RADIUS_AXIS_GRID_LINE = 'radius-axis-grid-line';
    var PLOT_BANDS = 'plot-bands';
    var PLOT_LINES = 'plot-lines';
    var AXIS_LINE = 'axis-line';
    var CATEGORY_LINE = 'category-axis-line';
    var VALUE_LINE = 'value-axis-line';
    var VALUE_TICK_GAP = 2;
    var VALUE_TEXT = 'value-axis-tick-text';


    var RadiusAxisSvgRender = BaseRender.extend({
        render:function(){

            var svgRoot = this.component.getVanchartRender().getRenderRoot().select('g.' + Constants.AXIS_GROUP);

            this.labelDivManager.clearAllLabels();

            var clipID = 'polarClip' + this.component.vanchart.getIDPrefix();

            if (this._axisG) {
                this._axisG.transition().ease('linear').duration(TIME).call(this._drawAxis.bind(this));
            } else{
                this._axisG = svgRoot.append('g');

                this._axisG.call(this._drawAxis.bind(this));
            }

            var radiusAxis = this.component;
            var clipPath = this._axisG.select('#' + clipID);
            clipPath.select('path').remove();
            clipPath.append('path').attr('d', function () {
                return radiusAxis._getRadiusGridPath(radiusAxis.scale.domain()[1]);
            });

            this._axisG.attr('transform', BaseUtils.makeTranslate(this.component.polar.center));

        },

        _drawAxis: function (g) {

            // in angleAxis grid lines
            // this._drawAxisLine(g);

            this._drawGridLine(g);

            this._drawPlotBands(g);

            this._drawPlotLines(g);

            this._drawTickLabel(g);
        },

        _drawAxisLine: function (g) {
            var cfg = this.component.componentOption;
            var lineWidth = cfg.lineWidth;
            var lineColor = cfg.lineColor;

            var axisLineData = this.component.getPolarInitPoint();

            g.each(function(){

                var axisLine = d3.select(this)
                    .selectAll('line.' + VALUE_LINE)
                    .data([axisLineData]);

                if(lineWidth){
                    axisLine.exit().remove();
                    axisLine.enter().append('line').attr('class', VALUE_LINE);

                    d3.transition(axisLine)
                        .attr('x2', function(d){
                            return d[0];
                        })
                        .attr('y2', function(d){
                            return d[1];
                        })
                        .style({
                            'stroke':lineColor,
                            'stroke-width':lineWidth
                        });
                }else{
                    axisLine.remove();
                }

            });

        },

        _drawGridLine: function (g) {

            var radiusAxis = this.component;
            var lastScale = radiusAxis.lastScale || radiusAxis.valueScale;
            var cfg = radiusAxis.componentOption;
            var ticks = radiusAxis.getTickData();
            var gridLineColor = cfg.gridLineColor;
            var gridLineWidth = cfg.gridLineWidth;

            g.each(function(){

                // prepare ticks data
                var gridLines = d3.select(this)
                    .selectAll('path.' + RADIUS_AXIS_GRID_LINE)
                    .data(ticks, function(d){return d.tickValue;});

                if (!gridLineWidth) {

                    gridLines.remove();

                } else {
                    // enter
                    gridLines.enter()
                        .append('path')
                        .attr('class', RADIUS_AXIS_GRID_LINE)
                        .attr('d', function(d) {
                            this._currentPos_ = radiusAxis._getRadiusGridData(d.tickValue, false, lastScale);
                            return radiusAxis._getRadiusGridPathByData(this._currentPos_);
                        })
                        .style({
                            fill:'none',
                            'stroke':gridLineColor,
                            'stroke-width':gridLineWidth,
                            'opacity': 1
                        });

                    // transition
                    var transition = d3.transition(gridLines)
                        .style('opacity', 1);

                    // add attrTween fun
                    if (!transition.attrTween) {
                        transition
                            .attr('d', function(d) {
                                this._currentPos_ = radiusAxis._getRadiusGridData(d.tickValue);
                                return radiusAxis._getRadiusGridPathByData(this._currentPos_);
                            });
                    } else {
                        transition
                            .attrTween('d', function(d) {
                                var prePos = this._currentPos_;
                                this._currentPos_ = radiusAxis._getRadiusGridData(d.tickValue);

                                prePos = prePos.length != this._currentPos_.length ? this._currentPos_ : prePos;

                                var interpolate = d3.interpolate(prePos, this._currentPos_);

                                return function (t) {
                                    return radiusAxis._getRadiusGridPathByData(interpolate(t));
                                };
                            })
                    }

                    // exit
                    var gridExit = d3.transition(gridLines.exit())
                        .style('opacity', 0)
                        .remove();

                    if (gridExit.attrTween) {
                        gridExit
                            .attrTween('d', function(d) {
                                var prePos = this._currentPos_;
                                this._currentPos_ = radiusAxis._getRadiusGridData(d.tickValue);
                                var interpolate = d3.interpolate(prePos, this._currentPos_);

                                return function(t) {
                                    return radiusAxis._getRadiusGridPathByData(interpolate(t));
                                };
                            })
                    }
                }
            });

        },

        _drawPlotBands: function (g) {

            var plotBands = this.component.getRadiusPlotBands();

            g.each(function(){

                var bands = d3.select(this)
                    .selectAll('path.' + PLOT_BANDS).data(plotBands);

                bands.exit().remove();

                bands.enter().append('path').attr('class', PLOT_BANDS);

                d3.transition(bands)
                    .attr('d', function(d){
                        return d.path;
                    })
                    .style('fill', function(d){
                        return d.color;
                    })

            });

        },

        _drawPlotLines:function(g){

            var plotLines = this.component.getPlotLines();
            var self = this;

            g.each(function(){

                var lines = d3.select(this)
                    .selectAll('.' + PLOT_LINES).data(plotLines);

                lines.exit().remove();

                var lineEnter = lines.enter().append('g').attr('class', PLOT_LINES);
                lineEnter.append('path');
                lineEnter.append('text');

                d3.transition(lines.select('path'))
                    .attr('d', function(d){
                        return  self.component._getRadiusGridPath(d.value);
                    })
                    .style('fill', 'none')
                    .style('stroke', function(d){
                        return d.color;
                    })
                    .style('stroke-width', function(d){
                        return d.width;
                    })
                    .style('stroke-dasharray', function(d){
                        return d.dataArray;
                    });

                d3.transition(lines.select('text'))
                    .text(function(d){
                        return d.text;
                    })
                    .attr('y', function(d){
                        return d.baseY;
                    })
                    .attr('text-anchor', function(d){
                        return d.textAnchor;
                    })
                    .each(function(d){
                        d3.select(this)
                            .call(BaseUtils.setTextStyle, d.style);
                    });
            });

        },

        _drawTickLabel:function(g){

            var radiusAxis = this.component;
            var scale = radiusAxis.scale;
            var lastScale = radiusAxis.lastScale || radiusAxis.scale;
            var cfg = radiusAxis.componentOption;
            var ticks = radiusAxis.getTickData();

            //最大值标签不显示
            ticks.length = Math.max(ticks.length - 1, 0);

            var labelStyle = cfg.labelStyle;
            var labelRotation = cfg.labelRotation;
            var useHtml = cfg.useHtml;

            if(useHtml && !labelRotation){

                var center = radiusAxis.polar.center;

                for(var i = 0, len = ticks.length; i < len; i++){

                    var tick = ticks[i];

                    var x = -tick.tickDim.width - VALUE_TICK_GAP + center[0];
                    var y = -scale(tick.tickValue)-tick.tickDim.height + center[1];

                    this.labelDivManager.addLabel(tick.tickContent, {x:x, y:y}, labelStyle);
                }

            }else{

                g.each(function(){

                    var valueText = d3.select(this)
                        .selectAll('text.' + VALUE_TEXT)
                        .data(ticks, function(d){return d.tickValue;});

                    if(cfg.showLabel){
                        valueText.exit().remove();
                        valueText.enter().append('text').attr('class', VALUE_TEXT)
                            .attr('x', -VALUE_TICK_GAP)
                            .attr('y', function(d){
                                return -lastScale(d.tickValue);
                            })
                            .attr('transform', function(d){
                                return 'rotate(' + labelRotation + ' 0 0)';
                            });

                        valueText.call(BaseUtils.setTextStyle, labelStyle);

                        d3.transition(valueText)
                            .text(function(d){return d.tickContent;})
                            .attr('y', function(d){
                                return -scale(d.tickValue);
                            })
                            .style('text-anchor', 'end')
                    }else{
                        valueText.remove();
                    }

                });
            }
        },

        remove:function(){
            this.removeDivLabels();
            this._axisG.remove();
        }

    });
    
    require('./RenderLibrary').register(Constants.RADIUS_AXIS_SVG, RadiusAxisSvgRender);

});
/**
 * Created by Jeffrey on 16/4/22.
 */

define('render/AngleAxisSvgRender',['require','./BaseRender','../utils/BaseUtils','../utils/BezierEasing','../Constants','./RenderLibrary'],function(require){

    var BaseRender = require('./BaseRender');
    var BaseUtils = require('../utils/BaseUtils');
    var BezierEasing = require('../utils/BezierEasing');
    var Constants = require('../Constants');

    var TIME = 400;

    var ANGLE_AXIS_LINE = 'angle-axis-line';
    var ANGLE_AXIS_GRID_LINE = 'angle-axis-grid-line';
    var CATEGORY_TEXT = 'category-axis-tick-text';
    var HIGHLIGHT_BAND = 'highlight-band';

    var AngleAxisSvgRender = BaseRender.extend({

        render:function(){

            var svgRoot = this.component.getVanchartRender().getRenderRoot().select('g.' + Constants.AXIS_GROUP);

            this.labelDivManager.clearAllLabels();

            if (this._axisG) {
                this._axisG.transition().ease('linear').duration(TIME).call(this._drawAxis.bind(this));
            } else{
                this._axisG = svgRoot.append('g');
                this._axisG.call(this._drawAxis.bind(this));
            }

            this._axisG.attr('transform', BaseUtils.makeTranslate(this.component.polar.center));
        },

        _drawAxis: function (g) {

            this._drawAxisLine(g);

            this._drawGridLine(g);

            this._drawTickLabel(g);
        },

        drawHighlightBand: function (pos) {

            var axis = this.component;
            if (!axis._getBandByPosition) {
                return;
            }

            var drawBand = axis._getBandByPosition(pos);
            var highlightType = axis.getHighlightType();

            this.removeHighlightBand();

            switch (highlightType) {
                case 'band':
                    this._axisG
                        .append('path')
                        .attr('class', HIGHLIGHT_BAND)
                        .attr('d', drawBand.d)
                        .style('fill', 'rgba(98,179,240,0.2)');

                    break;
                case 'line':
                default:
                    
                    this._axisG
                        .append('line')
                        .attr('class', HIGHLIGHT_BAND)
                        .attr('x2', drawBand.x)
                        .attr('y2', drawBand.y)
                        .attr('stroke', 'rgb(140,140,140)')
                        .attr('stroke-width', '1');
            }

        },

        removeHighlightBand: function () {
            this._axisG.select('.' + HIGHLIGHT_BAND).remove();
        },

        _drawAxisLine:function(g){
            var radiusAxis = this.component.polar.radiusAxis;

            var angleAxis = this.component;
            var lineWidth = angleAxis.componentOption.lineWidth;
            var lineColor = angleAxis.componentOption.lineColor;
            var maxValue = radiusAxis.scale.domain()[1];

            g.each(function(){

                var angleAxisLine = d3.select(this)
                    .selectAll('path.' + ANGLE_AXIS_LINE)
                    .data([0]);

                if(lineWidth){

                    angleAxisLine.enter().append('path').attr('class', ANGLE_AXIS_LINE);

                    d3.transition(angleAxisLine)
                        .attr('d', function(){
                            return radiusAxis._getRadiusGridPath(maxValue);
                        })
                        .style({
                            fill:'none',
                            'stroke':lineColor,
                            'stroke-width':lineWidth
                        });

                }else{
                    angleAxisLine.remove();
                }

            });

        },

        _drawGridLine:function(g){

            // for multiple radiusAxes feature (later)
            // angleAxis should not have grid line
            var cfg = this.component.polar.radiusAxis.componentOption;
            var lineWidth = cfg.lineWidth;
            var lineColor = cfg.lineColor;

            var axisLineData = this.component.getAngleGridLineData();

            g.each(function(){

                var axisLine = d3.select(this)
                    .selectAll('line.' + ANGLE_AXIS_GRID_LINE)
                    .data(axisLineData);

                if(lineWidth){
                    axisLine.exit().remove();
                    axisLine.enter()
                        .append('line')
                        .attr('class', ANGLE_AXIS_GRID_LINE);

                    d3.transition(axisLine)
                        .attr('x2', function(d){
                            return d[0];
                        })
                        .attr('y2', function(d){
                            return d[1];
                        })
                        .style({
                            'stroke':lineColor,
                            'stroke-width':lineWidth
                        });
                }else{
                    axisLine.remove();
                }

            });

        },

        _drawTickLabel:function(g){
            var angleAxis = this.component;
            var cfg = angleAxis.componentOption;

            var labelStyle = cfg.labelStyle;
            var labelRotation = cfg.labelRotation || 0;
            var useHtml = cfg.useHtml;

            var ticks = angleAxis.tickData;
            var lineHeight = BaseUtils.getTextHeight(labelStyle);

            if(useHtml && !labelRotation){

                var center = angleAxis.polar.center;

                for(var i = 0, len = ticks.length; i < len; i++){

                    var tick = ticks[i];

                    var x = tick.tickPos.x + center[0];
                    var y = tick.tickPos.y + center[1];

                    this.labelDivManager.addLabel(tick.tickContent, {x:x, y:y}, labelStyle);
                }

            }else{
                g.each(function(){
                    d3.select(this).selectAll('text.' + CATEGORY_TEXT).remove();

                    var cateText = d3.select(this).selectAll('text.' + CATEGORY_TEXT).data(ticks);

                    if(cfg.showLabel){

                        cateText.enter().append('text')
                            .attr('class', CATEGORY_TEXT)
                            .call(BaseUtils.setTextStyle, labelStyle);

                        cateText.each(function(d){

                            var tickContent = d.tickContent;

                            if(BaseUtils.isArray(tickContent)){

                                var dx = d.tickPos.x < 0 ? d.tickDim.width : 0;
                                var textAnchor = d.tickPos.x < 0 ? 'end' : 'start';

                                for(var i = 0, len = tickContent.length; i < len; i++){

                                    if(i == 0){

                                        d3.select(this)
                                            .append('tspan')
                                            .text(tickContent[i])
                                            .attr('x', dx + d.tickPos.x)
                                            .attr('y', 0.85 * lineHeight + d.tickPos.y)
                                            .attr('text-anchor', textAnchor);

                                    }else{

                                        d3.select(this)
                                            .append('tspan')
                                            .text(tickContent[i])
                                            .attr('x', dx + d.tickPos.x)
                                            .attr('y', 0.85 * lineHeight + i * (1.3 * lineHeight) + d.tickPos.y)
                                            .attr('text-anchor', textAnchor);

                                    }
                                }

                                if(labelRotation){

                                    var rx = d.tickPos.x + d.tickDim.width/2;
                                    var ry = d.tickPos.y + d.tickDim.height/2;

                                    d3.select(this)
                                        .attr('transform', 'rotate(' + labelRotation + ' ' + rx + ',' + ry + ')');
                                }

                            }else{

                                var rx = d.tickPos.x + d.tickDim.width/2;

                                var ry = d.tickPos.y + d.tickDim.height/2;

                                var normalDim = BaseUtils.getTextDimension(tickContent, labelStyle, useHtml);

                                d3.select(this)
                                    .text(tickContent)
                                    .attr('x', rx - normalDim.width/2)
                                    .attr('y', ry - normalDim.height/2)
                                    .attr('text-anchor', 'start')
                                    .attr('dy', '.85em')
                                    .attr('transform', 'rotate(' + labelRotation + ' ' + rx + ',' + ry + ')');

                            }

                        });
                    }
                });
            }
        },

        remove:function(){
            this.removeDivLabels();
            this._axisG.remove();
        }
    });

    require('./RenderLibrary').register(Constants.ANGLE_AXIS_SVG, AngleAxisSvgRender);
});
/**
 * Created by eason on 15/11/2.
 */
define('render/DateAxisSvgRender',['require','./BaseAxisSvgRender','../Constants','./RenderLibrary'],function(require){

    var BaseAxisRender = require('./BaseAxisSvgRender');
    var Constants = require('../Constants');

    var DateAxisSvgRender = BaseAxisRender.extend({});

    require('./RenderLibrary').register(Constants.DATE_AXIS_SVG, DateAxisSvgRender);
});
/**
 * Created by eason on 15/8/14.
 */
define('render/LegendSvgRender',['require','./BaseRender','../utils/BaseUtils','../utils/BezierEasing','../Constants','./LegendIconFactory','../dom/DomEvent','./RenderLibrary'],function(require){

    var BaseRender = require('./BaseRender');
    var BaseUtils = require('../utils/BaseUtils');
    var BezierEasing = require('../utils/BezierEasing');
    var Constants = require('../Constants');
    var LegendIconFactory = require('./LegendIconFactory');
    var DomEvent = require('../dom/DomEvent');

    var LEGEND_ITEM = 'legend-item';
    var LEGEND_MARKER = 'legend-marker';
    var LEGEND_LABEL = 'legend-label';

    var LEGEND_GRADUAL = 'legend-gradual-background';
    var LEGEND_PAGES = 'legend-pages';

    var ENABLED_COLOR = 'rgb(67,67,72)';
    var DISABLED_COLOR = 'rgb(204,204,204)';

    var LegendSvgRender = BaseRender.extend({
        render:function(){

            if(!this.component.componentOption.visible){
                this.remove();
                return;
            }
            
            var svgRoot = this.component.getVanchartRender().getRenderRoot();
            var bounds = this.component.bounds;

            this._legendG = this._legendG ||  svgRoot.append('g').on('mousedown', function(){DomEvent.stopPropagation(d3.event);});

            this._legendG
                .attr('transform', 'translate('+ bounds.x +','+ bounds.y +')')
                .style("pointer-events", 'all');

            this._updateBackground();

            this.component.isHorizontal() ? this._updateHorizontal() : this._updateVertical();
        },

        _updateBackground:function(){

            var option = this.component.componentOption;
            var bounds = this.component.bounds;
            var IDPrefix = this.component.vanchart.getIDPrefix();
            var gradualID = LEGEND_GRADUAL + IDPrefix;

            this._renderSvgBackground(this._legendG, option, bounds, gradualID);
        },

        _renderVerticalWithPages:function(verticalG){

            var width = this.component.bounds.width;
            var height = this.component.bounds.height;

            height -= this.component.getButtonHeight();

            var clipID = this.component.vanchart.getIDPrefix() + LEGEND_PAGES;

            var defs = verticalG.selectAll('defs').data([0]);
            defs.enter().append('defs');
            var clip = defs.selectAll('#' + clipID).data([0]);
            clip.enter().append('clipPath').attr('id', clipID).append('rect');
            clip.select('rect').attr('width', width).attr('height', height);

            var clippedG = verticalG.selectAll('g.clip').data([0]);
            clippedG.enter().append('g').attr('class', 'clip');
            clippedG = verticalG.select('g.clip').attr('clip-path', "url(#" + clipID +")");

            var pageG = clippedG.selectAll('g.pageG').data([0]);
            pageG.enter().append('g').attr('class', 'pageG');
            pageG = clippedG.select('g.pageG');

            this._renderVerticalWithoutPages(pageG);

            var buttonWidth = 40;

            var buttonG = verticalG.selectAll('g.button').data([0]);
            buttonG.enter().append('g').attr('class', 'button');
            buttonG = verticalG.select('g.button').attr('transform', 'translate(' + 0 + ',' + height + ')');

            var leftButtonTopX = (width - buttonWidth) / 2;
            var rightButtonTopX = (width + buttonWidth) / 2;

            var translateDet = height - this.component.getPadding();

            var totalHeight = this.component.getPreHeight();

            this.pageIndex = BaseUtils.pick(this.pageIndex, 0);
            var pageCount = Math.ceil((totalHeight - height) / translateDet) + 1;

            var labelX = width/2;

            var text = buttonG.selectAll('text').data([0]);
            text.enter().append('text');

            text
                .attr('x', labelX)
                .attr('y', 0)
                .attr('dy', '.71em')
                .attr("text-anchor", "middle")
                .text((this.pageIndex + 1) + '/' + pageCount)
                .style('font-Family', 'Verdana')
                .style('font-Size', '14px');

            var self = this;
            var leftButton = buttonG.selectAll('path.left').data([0]);

            leftButton.enter()
                .append('path').attr('class', 'left')
                .attr('d', this._prePageButtonPath(leftButtonTopX))
                .style('cursor', 'pointer')
                .style('fill', DISABLED_COLOR)
                .on('click', function(){

                    if(self.pageIndex <= 0){
                        return;
                    }

                    var translate = d3.transform(pageG.attr('transform')).translate;

                    var translateX = translate[0];
                    var translateY = self.pageIndex == 1 ? 0 : (translate[1] + translateDet);

                    pageG
                        .transition()
                        .duration(500)
                        .ease(BezierEasing.css.swing)
                        .attr('transform', 'translate(' + translateX + ',' + translateY + ')');

                    self.pageIndex--;
                    var showIndex = self.pageIndex + 1;
                    text.text(showIndex + "/" + pageCount);

                    rightButton.style('fill', self.pageIndex == pageCount - 1 ? DISABLED_COLOR : ENABLED_COLOR);
                    d3.select(this).style('fill', self.pageIndex <= 0 ? DISABLED_COLOR : ENABLED_COLOR);
                });


            var rightButton = buttonG.selectAll('path.right').data([0]);
            rightButton.enter()
                .append('path')
                .attr('class', 'right')
                .attr('d', this._nextPageButtonPath(rightButtonTopX))
                .style('cursor', 'pointer')
                .style('fill', ENABLED_COLOR)
                .on('click', function(){

                    if(self.pageIndex == pageCount - 1){
                        return;
                    }

                    var translate = d3.transform(pageG.attr('transform')).translate;

                    var translateX = translate[0];
                    var translateY = translate[1] - translateDet;

                    pageG
                        .transition()
                        .duration(800)
                        .ease(BezierEasing.css.swing)
                        .attr('transform', 'translate(' + translateX + ',' + translateY + ')');

                    self.pageIndex++;
                    var showIndex = self.pageIndex + 1;
                    text.text(showIndex + "/" + pageCount);

                    d3.select(this).style('fill', self.pageIndex == pageCount - 1 ? DISABLED_COLOR : ENABLED_COLOR);
                    leftButton.style('fill', self.pageIndex <= 0 ? DISABLED_COLOR : ENABLED_COLOR)
                });
        },

        _prePageButtonPath:function(topX){
            var edge = 12;
            var topY = 0;

            var leftBottomX = topX - edge / 2;
            var leftBottomY = (edge / 2) * Math.sqrt(3);

            var rightBottomX = topX + edge / 2;
            var rightBottomY = leftBottomY;

            return 'M' + topX + ',' + topY + 'L' + leftBottomX + ',' + leftBottomY + 'L' + rightBottomX + ',' + rightBottomY + 'Z';
        },

        _nextPageButtonPath:function(topX){
            var edge = 12;
            var topY = 0;

            var topLeftX = topX - edge/2;
            var topLeftY = topY;

            var topRightX = topX + edge/2;
            var topRightY = topY;

            var bottomX = topX;
            var bottomY = (edge / 2) * Math.sqrt(3);

            return 'M' + topLeftX + ',' + topLeftY + 'L' + topRightX + ',' + topRightY + 'L' + bottomX + ',' + bottomY + 'Z';
        },

        _renderVerticalWithoutPages:function(gElement){
            var items = this.component.getLegendItems();
            var self = this;
            var legend = this.component;
            var cfg = this.component.componentOption;

            var PADDING = this.component.getPadding() + this.component.verticalAlign;
            var GAP = this.component.getGap();

            var updateS = gElement.selectAll('g.' + LEGEND_ITEM).data(items);

            updateS.exit().remove();

            updateS
                .enter()
                .append('g')
                .attr('class', LEGEND_ITEM)
                .each(function(d){

                    var rowSelection = d3.select(this);

                    var marker = LegendIconFactory.hasIcon(d.legendIconType) ? 'path' : 'image';

                    rowSelection.append(marker).attr('class', LEGEND_MARKER);
                    rowSelection.append('text').attr('class', LEGEND_LABEL);

                    rowSelection.call(self._bindMouseEvent.bind(self));
                });

            gElement
                .selectAll('g.' + LEGEND_ITEM)
                .each(function(d, i){

                    var rowSelection = d3.select(this);

                    var iconSize = LegendIconFactory.getLegendIconSize(d.legendIconType);
                    var labelDim = BaseUtils.getTextDimension(d.itemName, cfg.style, true);
                    var detY = Math.max(iconSize.height, labelDim.height)/2;

                    var preHeight = legend.getPreHeight(i);

                    var markerS = rowSelection.select('.' + LEGEND_MARKER)
                        .attr('transform', 'translate(' + PADDING + ',' + (preHeight + detY - iconSize.height/2) + ')');

                    self._updateLegendMarker(markerS, d);

                    rowSelection
                        .select('text.' + LEGEND_LABEL)
                        .text(function(d){return d.itemName})
                        .attr('x', PADDING + iconSize.width + GAP)
                        .attr('y', preHeight + detY)
                        .attr("dy", ".35em")
                        .call(BaseUtils.setTextStyle, cfg.style)
                        .style('fill', function(d){
                            return d.visible ? cfg.style.color : d.hiddenColor;
                        });

                })
        },

        _updateVertical:function(){

            var verticalG = this._legendG.selectAll('g.vertical').data([0]);
            verticalG.enter().append('g').attr('class', 'vertical');
            verticalG = this._legendG.select('g.vertical');

            var lastState = BaseUtils.pick(this.hasEnoughSpace, this.component.hasEnoughVerticalSpace());

            var currentState = this.component.hasEnoughVerticalSpace();

            if(currentState != lastState){
                verticalG.remove();
                verticalG = this._legendG.append('g').attr('class', 'vertical');
                this.hasEnoughSpace = currentState;
            }

            this.component.hasEnoughVerticalSpace() ? this._renderVerticalWithoutPages(verticalG) : this._renderVerticalWithPages(verticalG);
        },

        _updateHorizontal:function(){

            var PADDING = this.component.getPadding();
            var HORIZONTAL_GAP = this.component.getHorizontalGap();
            var GAP = this.component.getGap();

            var lineItems = this.component.getHorizontalLineItems();
            var lineHeight = this.component.getLineHeight();
            var lineStartX = [];
            var lineStartY = [];

            var cfg = this.component.componentOption;
            var boundsWidth = this.component.bounds.width;
            var y = PADDING;
            for(var lineIndex = 0, len = lineItems.length; lineIndex < len; lineIndex++){

                var items = lineItems[lineIndex];

                var itemsWidth = this.component.getHorizontalItemsWidth(items);

                var x = Math.round((boundsWidth - itemsWidth) / 2);
                var startX = [x];

                for(var i = 1; i < items.length; i++){
                    var preItem = items[i - 1];
                    var iconSize = LegendIconFactory.getLegendIconSize(preItem.legendIconType);
                    var labelDim = BaseUtils.getTextDimension(preItem.itemName, cfg.style, true);
                    x += iconSize.width + GAP + labelDim.width + HORIZONTAL_GAP;
                    startX.push(x);
                }

                lineStartX.push(startX);
                lineStartY.push(y);

                y += lineHeight[lineIndex] + PADDING
            }

            function indexInLine(d, j){
                var preCount = 0;
                for(var i = 0; i < d.lineIndex; i++){
                    preCount += lineItems[i].length;
                }
                return j - preCount;
            }

            var self = this;
            var items = this.component.getLegendItems();

            var itemS = this._legendG.selectAll('g.' + LEGEND_ITEM).data(items);
            itemS.exit().remove();

            var newItems = itemS.enter();
            newItems
                .append('g')
                .attr('class', LEGEND_ITEM)
                .each(function(d){
                    var newItem = d3.select(this);

                    var marker = LegendIconFactory.hasIcon(d.legendIconType) ? 'path' : 'image';

                    newItem.append(marker).attr('class', LEGEND_MARKER);

                    newItem.append('text').attr('class', LEGEND_LABEL);
                    newItem.call(self._bindMouseEvent.bind(self));
                });

            itemS.each(function(d, i){

                var rowSelection = d3.select(this);

                var iconSize = LegendIconFactory.getLegendIconSize(d.legendIconType);
                var labelDim = BaseUtils.getTextDimension(d.itemName, cfg.style, true);

                var detY = Math.max(iconSize.height, labelDim.height)/2;

                i = indexInLine(d, i);
                var x = lineStartX[d.lineIndex][i];
                var y = lineStartY[d.lineIndex];

                var textColor = d.visible ? cfg.style.color : d.hiddenColor;

                var markerS = rowSelection.select('.' + LEGEND_MARKER)
                    .attr('transform', 'translate(' + x + ',' + (y + detY - iconSize.height/2) + ')');

                self._updateLegendMarker(markerS, d);

                rowSelection.select('text')
                    .text(function(d){return d.itemName})
                    .attr('x', x + iconSize.width + GAP)
                    .attr('y', y + detY)
                    .attr("dy", ".35em")
                    .call(BaseUtils.setTextStyle, cfg.style)
                    .style('fill', textColor);
            });
        },

        _updateLegendMarker:function(markerS, d){
            var markerColor = d.visible ? d.color : d.hiddenColor;
            if(LegendIconFactory.hasIcon(d.legendIconType)){
                markerS
                    .attr('d', function(){
                        return LegendIconFactory.getLegendIconPath(d.legendIconType);
                    })
                    .style('fill', markerColor)
                    .style('fill-opacity', d.fillColorOpacity);

                if(d.series.type == Constants.BUBBLE_CHART){
                    markerS
                        .style('stroke', function(d){
                            return d.visible ? d.color : d.hiddenColor
                        })
                        .style('stroke-width',1);
                }
            }else{
                markerS
                    .attr('preserveAspectRatio', 'none')
                    .attr('xlink:href', d.legendIconType)
                    .attr('width', 12).attr('height', 12);
            }

        },

        _bindMouseEvent:function(rowSelection){

            var vanchart = this.component.vanchart;
            var cfg = this.component.componentOption;

            rowSelection
                .style('cursor', 'pointer')
                .on('mouseenter', function(d){
                    d3.select(this).select('.' + LEGEND_LABEL).style('fill', d.hoverColor);
                })
                .on('mouseleave', function(d){
                    var textColor = d.visible ? cfg.style.color : d.hiddenColor;
                    d3.select(this).select('.' + LEGEND_LABEL).style('fill', textColor);
                })
                .on('click', function(d){
                    var name = d.itemName;
                    vanchart.series.map(function(sery){

                        if(sery.type == Constants.PIE_CHART || sery.type === Constants.MULTIPIE_CHART){

                            var key = sery.type == Constants.PIE_CHART ? 'seriesName': 'name';
                            sery.points.map(function(point){
                                if(point[key] == name){
                                    point.visible = !point.visible;
                                }
                            });

                            sery.updateVisiblePoints();

                        } else {
                            if (sery.name === name) {
                                sery.visible = !sery.visible;
                            }
                        }
                    });

                    vanchart.currentOption.byClassName = true;
                    vanchart.refreshComponentsAndSeries();
                });
        },

        remove:function(){
            this._legendG && this._legendG.remove();
            this._legendG = null;
        }
    });

    require('./RenderLibrary').register(Constants.LEGEND_SVG, LegendSvgRender);
    return LegendSvgRender;
});
/**
 * Created by eason on 15/8/24.
 */


define('render/ToolbarSvgRender',['require','./BaseRender','../utils/BaseUtils','../Constants','./RenderLibrary'],function(require){

    var BaseRender = require('./BaseRender');
    var BaseUtils = require('../utils/BaseUtils');
    var Constants = require('../Constants');

    var ToolbarSvgRender = BaseRender.extend({
        render:function(){
            var cfg = this.component.componentOption;

            if(!cfg.enabled || this._bodyG){
                return;
            }

            var svgRoot = this.component.getVanchartRender().getRenderRoot();

            var pos = this.component.getToolbarPos();

            if(!this._bodyG){
                this._bodyG = svgRoot.append('g')
                    .style("pointer-events", 'all')
                    .attr('transform', 'translate('+ pos.x +','+ pos.y +')');
            }

            if(this.component.menuIcon){
                this.component.menuIcon.render(this._bodyG);
            }

            this.component.refreshIcon.render(this._bodyG);

            var toolbarIcons = this.component.getToolbarIcons();

            for(var i = 0, len = toolbarIcons.length; i < len; i++){
                toolbarIcons[i].render(this._bodyG);
            }
        },

        hide:function(){

            var toolbarIcons = this.component.getToolbarIcons();

            var iconSize = toolbarIcons.length;

            var delay = [];

            for(var i = 0; i < iconSize; i++){
                delay.push(100 + 80 * i);
            }

            for(var i = 0; i < iconSize; i++){
                var moveIndex = iconSize - i;
                toolbarIcons[i].hideIcon(moveIndex, delay[i]);
            }

            var refreshIcon = this.component.getRefreshIcon();

            var left = 4 * (iconSize + 1) ;
            var right = 4 * (iconSize + 1) + 33 * iconSize;

            if(refreshIcon.visible){
                refreshIcon.refreshMove(left, right);
            }

        },

        show:function(){
            var delay = [0];

            var toolbarIcons = this.component.getToolbarIcons();

            var iconSize = toolbarIcons.length;

            for(var i = 0; i < iconSize - 1; i++){
                delay.push(100 + 80 * i);
            }

            for(var i = 0; i < iconSize; i++){
                var moveIndex = iconSize - i;
                toolbarIcons[i].showIcon(moveIndex, delay[i]);
            }

            var refreshIcon = this.component.getRefreshIcon();

            var left = 4 * (iconSize + 1) + 33 * iconSize;
            var right = 4 * (iconSize + 1);

            if(refreshIcon.visible){
                refreshIcon.refreshMove(left, right);
            }

        },

        toFront: function () {
            this._bodyG && BaseUtils.toFrontOfAll(this._bodyG.node());
        }
    });

    require('./RenderLibrary').register(Constants.TOOLBAR_SVG, ToolbarSvgRender);
    
    return ToolbarSvgRender;
});
/**
 * Created by eason on 15/10/12.
 */

define('render/DataSheetSvgRender',['require','./BaseRender','../utils/BaseUtils','../Constants','./LegendIconFactory','./RenderLibrary'],function(require){

    var BaseRender = require('./BaseRender');
    var BaseUtils = require('../utils/BaseUtils');
    var Constants = require('../Constants');
    var LegendIconFactory = require('./LegendIconFactory');

    var DataSheetSvgRender = BaseRender.extend({

        render:function(){

            var svgRoot = this.component.getVanchartRender().getRenderRoot();

            if(this._tableG){
                this._tableG.remove();
            }

            var axis = this.component.vanchart.xAxis();
            var categories = axis.getCategories();
            var unitLength = this.component.getPlotBounds().width / categories.length;

            var seriesWidth = this.component.getMaxSeriesWidth();
            var categoryHeight = this.component.getCategoryHeight();

            var transX = this.component.bounds.x;
            var transY = this.component.bounds.y;

            this._tableG = svgRoot
                .append('g')
                .attr('transform', 'translate(' + transX + ',' + transY + ')');

            this._drawLines(seriesWidth, categoryHeight, unitLength);

            this._drawCategory(seriesWidth, categoryHeight, unitLength);

            this._drawSeries(seriesWidth, categoryHeight);

            this._drawValues(seriesWidth, categoryHeight, unitLength);
        },

        _drawLines:function(seriesWidth, categoryHeight, unitLength){

            var lineG = this._tableG.append('g');
            var cfg = this.component.componentOption;

            var endX = this.component.bounds.width;
            var endY = this.component.bounds.height;

            lineG.append('path')
                .attr('d', 'M' + seriesWidth + ',0' + 'L' + endX + ',0' + 'L' + endX + ' ' + endY + 'L0' + ',' + endY + 'L0' + ',' + categoryHeight)
                .style({
                    fill:'none',
                    stroke:cfg.borderColor,
                    'stroke-width':cfg.borderWidth
                });

            var cateCount = this.component.categoryNames.length;

            var startX = seriesWidth;

            for(var i = 0; i < cateCount; i++){
                lineG.append('line')
                    .attr('x1', startX)
                    .attr('y1', 0)
                    .attr('x2', startX)
                    .attr('y2', endY);

                startX += unitLength;
            }

            var seriesCount = this.component.seriesNames.length;
            var height = categoryHeight;

            for(var i = 0; i < seriesCount; i++){

                lineG.append('line')
                    .attr('x1', 0)
                    .attr('y1', height)
                    .attr('x2', endX)
                    .attr('y2', height);

                height += this.component.getSeriesHeight(i);
            }

            lineG.selectAll('line')
                .style({
                    fill:'none',
                    stroke:cfg.borderColor,
                    'stroke-width':cfg.borderWidth
                });

        },

        _drawValues:function(seriesWidth, categoryHeight, unitLength){

            var valueG = this._tableG.append('g');

            var values = this.component.values;

            var valueStyle = this.component._valueStyle();
            var valueLineHeight = BaseUtils.getTextHeight(valueStyle);
            var textPadding = this.component.getTextPadding();
            var startX = seriesWidth;
            var startY = categoryHeight;

            for(var lineIndex = 0; lineIndex < values.length; lineIndex++){
                var singleLine = values[lineIndex];

                var valueHeight = this.component.getSeriesHeight(lineIndex);

                for(var valueIndex = 0; valueIndex < singleLine.length; valueIndex++){

                    var singleName = singleLine[valueIndex];

                    if (!singleName) {
                        continue;
                    }

                    var firstY = startY + this._getStartY(singleName, valueStyle, valueHeight) + valueLineHeight * 0.85;

                    for(var i = 0; i < singleName.length; i++){

                        valueG
                            .append('text')
                            .text(singleName[i])
                            .attr('x', startX + unitLength/2 + unitLength * valueIndex)
                            .attr('y', firstY + (valueLineHeight + textPadding) * i)

                    }
                }

                startY += valueHeight;
            }

            valueG.selectAll('text')
                .style({
                    'text-anchor':'middle'
                })
                .call(BaseUtils.setTextStyle, valueStyle);

        },

        _drawCategory:function(seriesWidth, categoryHeight, unitLength){

            var categoryG = this._tableG.append('g');

            var categoryNames = this.component.categoryNames;

            var startX = seriesWidth;

            var categoryStyle = this.component._categoryStyle();

            var categoryLineHeight = BaseUtils.getTextHeight(categoryStyle);
            var textPadding = this.component.getTextPadding();

            for(var index = 0, cCount = categoryNames.length; index < cCount; index++){

                var singleName = categoryNames[index];

                var startY = this._getStartY(singleName, categoryStyle, categoryHeight) + categoryLineHeight * 0.85;

                for(var i = 0; i < singleName.length; i++){

                    categoryG
                        .append('text')
                        .text(singleName[i])
                        .attr('x', startX + unitLength/2 + unitLength * index)
                        .attr('y', startY + (categoryLineHeight + textPadding) * i)

                }

            }

            categoryG.selectAll('text')
                .style({
                    'text-anchor':'middle'
                })
                .call(BaseUtils.setTextStyle, categoryStyle);

        },

        _drawSeries:function(seriesWidth, categoryHeight){

            var seriesG = this._tableG.append('g');

            var seriesNames = this.component.seriesNames;

            var startX = 16 + (seriesWidth - 16) / 2;
            var startY = categoryHeight;

            var seriesStyle = this.component._seriesStyle();
            var seriesLineHeight = BaseUtils.getTextHeight(seriesStyle);
            var textPadding = this.component.getTextPadding();
            var series = this.component.vanchart.series;

            for(var index = 0, sCount = seriesNames.length; index < sCount; index++){

                var singleName = seriesNames[index];
                var seriesHeight = this.component.getSeriesHeight(index);

                var firstY = startY + this._getStartY(singleName, seriesStyle, seriesHeight) + seriesLineHeight * 0.85;

                for(var i = 0; i < singleName.length; i++){

                    seriesG
                        .append('text')
                        .text(singleName[i])
                        .attr('x', startX)
                        .attr('y', firstY + (seriesLineHeight + textPadding) * i)

                }

                //画前面的色块
                var iconType = this.component.getLegendIconTypeWithSeriesIndex(index);
                var iconHeight = LegendIconFactory.getLegendIconSize(iconType).height;

                if(LegendIconFactory.hasIcon(iconType)){
                    seriesG
                        .append('path')
                        .attr('d', LegendIconFactory.getLegendIconPath(iconType))
                        .attr('transform', 'translate(2,' + ((seriesHeight - iconHeight)/2 + startY) + ')')
                        .style('fill', this.component._getDefaultSeriesColor(singleName[0]));
                }else{
                    seriesG.append('image')
                        .attr('preserveAspectRatio', 'none')
                        .attr('xlink:href', iconType)
                        .attr('width', 12).attr('height', 12)
                        .attr('transform', 'translate(2,' + ((seriesHeight - iconHeight)/2 + startY) + ')');
                }

                startY += seriesHeight;
            }

            seriesG.selectAll('text')
                .style({
                    'text-anchor':'middle'
                })
                .call(BaseUtils.setTextStyle, seriesStyle);

        },

        _getStartY:function(textArray, style, boxHeight){

            var textPadding = this.component.getTextPadding();

            var textCount = textArray.length;

            var textHeight = BaseUtils.getTextHeight(style) * textCount + (textCount - 1) * textPadding;

            return (boxHeight - textHeight) / 2;
        },

        remove:function(){
            this._tableG && this._tableG.remove();
        }

    });
    
    require('./RenderLibrary').register(Constants.DATA_SHEET_SVG, DataSheetSvgRender);

});
/**
 * Created by Mitisky on 16/3/21.
 */
define('render/RangeLegendSvgRender',['require','./BaseRender','../utils/BaseUtils','../Constants','../dom/DomEvent','./RenderLibrary'],function(require){
    var BaseRender = require('./BaseRender');
    var BaseUtils = require('../utils/BaseUtils');
    var Constants = require('../Constants');
    var DomEvent = require('../dom/DomEvent');

    var PADDING = 10;

    var WIDTH = 15;
    var HEIGHT = 100;
    var BAR_WIDTH = 15;
    var BAR_HEIGHT = 10;
    var BAR_TEXT_GAP = 5;
    var ITEM_WIDTH = 25;
    var ITEM_GAP = 2;

    var CLIP_ID = 'linear-color-clip-path-id';
    var MIN_BAR_CLASS_NAME = 'min-bar-class-name';
    var MAX_BAR_CLASS_NAME = 'max-bar-class-name';

    var RANGE_ITEM = 'range-item';

    var RangeLegendSvgRender = BaseRender.extend({
        render:function() {

            if(!this.component.componentOption.visible){
                this.remove();
                return;
            }

            var svgRoot = this.component.getVanchartRender().getRenderRoot();
            var bounds = this.component.bounds;

            this.isHorizontal = this.component.isHorizontal();

            if(!this._legendG){
                this._legendG = svgRoot.append('g')
                    .on('mousedown', function(){
                        DomEvent.stopPropagation(d3.event);
                    })
                    .style("pointer-events", 'all');
                this.minPos = 0;
                this.maxPos = HEIGHT;
            }

            if(!this.component.vanchart.isZoomRefreshState()){
                this.minPos = 0;
                this.maxPos = HEIGHT;
            }

            this._legendG.attr('transform', 'translate('+ this._getIntPos(bounds.x) +','+ this._getIntPos(bounds.y) +')');

            this._updateBackground();

            this.component.isIntervalLegend ? this._renderInterval() : this._renderGradient();
        },

        _updateBackground: function () {
            var option = this.component.componentOption;
            var bounds = this.component.bounds;
            var IDPrefix = this.component.vanchart.getIDPrefix();
            var gradualID = 'range-legend-background' + IDPrefix;

            this._renderSvgBackground(this._legendG, option, bounds, gradualID);
        },

        _renderGradient:function() {
            var linearGradient = this._createDefs();
            var startPos = ((this.isHorizontal ? this.component.bounds.width : this.component.bounds.height)- HEIGHT)/2;
            startPos = this._getIntPos(startPos);

            var barBackgroundG = this._legendG.selectAll('rect.' + 'gradient-bar-background').data([0]);
            barBackgroundG.enter().append('rect').attr('class', 'gradient-bar-background');
            barBackgroundG
                .attr('rx', 2)
                .attr('ry', 2)
                .attr('x', this.isHorizontal ? startPos : PADDING)
                .attr('y', this.isHorizontal ? PADDING : startPos)
                .attr('width',this.isHorizontal ? HEIGHT : WIDTH)
                .attr('height',this.isHorizontal ? WIDTH : HEIGHT)
                .style('fill', '#eaeaea');

            var IDPrefix = this.component.vanchart.getIDPrefix();
            var barGradientG = this._legendG.selectAll('rect.' + 'gradient-bar').data([0]);
            barGradientG.enter().append('rect').attr('class', 'gradient-bar');
            barGradientG
                .attr('clip-path', "url(#" + CLIP_ID + IDPrefix +")")
                .attr('rx', 2)
                .attr('ry', 2)
                .attr('x', this.isHorizontal ? startPos : PADDING)
                .attr('y', this.isHorizontal ? PADDING : startPos)
                .attr('width',this.isHorizontal ? HEIGHT : WIDTH)
                .attr('height',this.isHorizontal ? WIDTH : HEIGHT)
                .style('fill','url(#' + linearGradient.attr('id') + ')');

            var self = this;
            var minDrag = d3.behavior.drag()
                .on("dragstart", function() {
                    // silence other listeners
                    d3.event.sourceEvent.stopPropagation();
                })
                .on('drag', function () {
                    var change = 0;
                    if(self.isHorizontal){
                        var temp = self.minPos;
                        self.minPos += Math.round(d3.event.dx);
                        self.minPos = Math.max(self.minPos, 0);
                        self.minPos = Math.min(self.minPos, self.maxPos);
                        change = self.minPos - temp;
                    } else {
                        var temp = self.maxPos;
                        self.maxPos += Math.round(d3.event.dy);
                        self.maxPos = Math.min(self.maxPos, HEIGHT);
                        self.maxPos = Math.max(self.maxPos, self.minPos);
                        change = self.maxPos - temp;
                    }
                    if(Math.abs(change) >= 1) {
                        self._updateMinBar(startPos);
                        self.component.refreshPoints(self.minPos, self.maxPos);
                    }
                });

            var maxDrag = d3.behavior.drag()
                .on("dragstart", function() {
                    // silence other listeners
                    d3.event.sourceEvent.stopPropagation();
                })
                .on('drag', function () {
                    var change = 0;
                    if(self.isHorizontal){
                        var temp = self.maxPos;
                        self.maxPos += Math.round(d3.event.dx);
                        self.maxPos = Math.min(self.maxPos, HEIGHT);
                        self.maxPos = Math.max(self.maxPos, self.minPos);
                        change = self.maxPos - temp;
                    } else {
                        var temp = self.minPos;
                        self.minPos += Math.round(d3.event.dy);
                        self.minPos = Math.max(self.minPos, 0);
                        self.minPos = Math.min(self.minPos, self.maxPos);
                        change = self.minPos - temp;
                    }
                    if(Math.abs(change) >= 1) {
                        self._updateMaxBar(startPos);
                        self.component.refreshPoints(self.minPos, self.maxPos);
                    }
                });

            var minBarG = this._legendG.selectAll('path.' + MIN_BAR_CLASS_NAME).data([0]);
            minBarG.enter().append('path').attr('class', MIN_BAR_CLASS_NAME);
            minBarG
                .attr('d', this.isHorizontal ? this.component.getLeftBarPath() : this.component.getTopBarPath())
                .call(minDrag);

            var maxBarG = this._legendG.selectAll('path.' + MAX_BAR_CLASS_NAME).data([0]);
            maxBarG.enter().append('path').attr('class', MAX_BAR_CLASS_NAME);
            maxBarG
                .attr('d', this.isHorizontal ? this.component.getRightBarPath() : this.component.getBottomBarPath())
                .call(maxDrag);

            var labelStyle = this.component.componentOption.style;
            if(!this._labelUseHtml()){
                var minLabelG = this._legendG.selectAll('text.' +  MIN_BAR_CLASS_NAME).data([0]);
                minLabelG.enter().append('text').attr('class', MIN_BAR_CLASS_NAME);
                minLabelG
                    .attr('dy', '.32em')
                    .call(BaseUtils.setTextStyle, labelStyle);

                var maxLabelG = this._legendG.selectAll('text.' + MAX_BAR_CLASS_NAME).data([0]);
                maxLabelG.enter().append('text').attr('class', MAX_BAR_CLASS_NAME);
                maxLabelG
                    .attr('dy', '.32em')
                    .call(BaseUtils.setTextStyle, labelStyle);
            }

            this._updateMinBar(startPos);
            this._updateMaxBar(startPos);
        },

        _createDefs:function() {
            if(!this._legendG.selectAll('defs').empty()){
                return this._legendG.selectAll('defs').select('linearGradient');
            }
            var defs = this._legendG.append('defs');

            var IDPrefix = this.component.vanchart.getIDPrefix();

            defs.append('clipPath').attr('id', CLIP_ID + IDPrefix).append('rect');

            var linearGradient = defs.append('linearGradient')
                .attr('id','gradient-range-legend' + IDPrefix)
                .attr('x1','0%')
                .attr('y1',this.isHorizontal ? '0%' : '100%')
                .attr('x2',this.isHorizontal ? '100%' : '0%')
                .attr('y2','0%');

            var valueAndColorArray = this.component.getValueAndColors();

            valueAndColorArray.forEach(function(valueAndColor){
                var value = valueAndColor[0];
                var color = valueAndColor[1];
                linearGradient.append('stop')
                    .attr('offset', value)
                    .style('stop-color', color);
            });

            return linearGradient;
        },

        _updateMinBar:function(startPos) {
            this.isHorizontal ? this._updateHorizontalMinBar(startPos)
                : this._updateVerticalMinBar(startPos);
        },

        _updateVerticalMinBar: function(startPos) {
            var x = PADDING + WIDTH;
            var y = startPos + this.maxPos;

            this._legendG.select('path.' + MIN_BAR_CLASS_NAME)
                .attr('transform', 'translate('+ x  +','+ y +')')
                .style('fill', this.component.colorScale((HEIGHT - this.maxPos)/HEIGHT));

            var label = this.component.getGradientLabelContent(this.maxPos);
            var labelStyle = this.component.componentOption.style;
            var labelDim = BaseUtils.getTextDimension(label, labelStyle, true);

            if(this._labelUseHtml()){
                var labelY = this._getIntPos(startPos + this.maxPos + BAR_HEIGHT / 2 - labelDim.height/2);
                var labelBounds = this._getAbsoluteBounds(labelDim, PADDING + WIDTH + BAR_WIDTH + BAR_TEXT_GAP, labelY);
                this.labelDivManager.clearLabels(MIN_BAR_CLASS_NAME);
                this.labelDivManager.addLabelWidthBounds(label, labelBounds, labelStyle, MIN_BAR_CLASS_NAME);
            } else {
                this._legendG.select('text.' + MIN_BAR_CLASS_NAME)
                    .attr('text-anchor', 'middle')
                    .attr('x', this._getIntPos(PADDING + WIDTH + BAR_WIDTH + BAR_TEXT_GAP + labelDim.width / 2))
                    .attr('y', this._getIntPos(startPos + this.maxPos + BAR_HEIGHT / 2))
                    .text(label);
            }

            this._updateVerticalLinearColorClipPath(startPos);
        },

        _getAbsoluteBounds: function (labelDim, relativeX, relativeY) {
            return {
                x:this.component.bounds.x + relativeX,
                y:this.component.bounds.y + relativeY,
                width:labelDim.width,
                height:labelDim.height
            };
        },

        _getIntPos: function (pos) {
            return Math.round(pos);
        },

        _labelUseHtml: function () {
            return this.component.componentOption.useHtml;
        },

        _updateHorizontalMinBar: function(startPos) {
            var x = startPos - BAR_HEIGHT + this.minPos;
            var y = PADDING + WIDTH;

            this._legendG.select('path.' + MIN_BAR_CLASS_NAME)
                .attr('transform', 'translate('+ x  +','+ y +')')
                .style('fill', this.component.colorScale(this.minPos/HEIGHT));

            var label = this.component.getGradientLabelContent(this.minPos);
            var labelStyle = this.component.componentOption.style;
            var labelDim = BaseUtils.getTextDimension(label, labelStyle, true);

            if(this._labelUseHtml()){
                var labelBounds = this._getAbsoluteBounds(labelDim, this._getIntPos(startPos + this.minPos - labelDim.width), PADDING + WIDTH + BAR_WIDTH + BAR_TEXT_GAP);
                this.labelDivManager.clearLabels(MIN_BAR_CLASS_NAME);
                this.labelDivManager.addLabelWidthBounds(label, labelBounds, labelStyle, MIN_BAR_CLASS_NAME);
            } else {
                this._legendG.select('text.' + MIN_BAR_CLASS_NAME)
                    .attr('text-anchor', 'left')
                    .attr('y', this._getIntPos(PADDING + WIDTH + BAR_WIDTH + BAR_TEXT_GAP + labelDim.height/2))
                    .attr('x', this._getIntPos(startPos + this.minPos - labelDim.width))
                    .text(label);
            }

            this._updateHorizontalLinearColorClipPath(startPos);
        },

        _updateMaxBar: function (startPos) {
            this.isHorizontal ? this._updateHorizontalMaxBar(startPos)
                : this._updateVerticalMaxBar(startPos);
        },

        _updateVerticalMaxBar: function(startPos) {
            var x = PADDING + WIDTH;
            var y = startPos - BAR_HEIGHT + this.minPos;

            this._legendG.select('path.' + MAX_BAR_CLASS_NAME)
                .attr('transform', 'translate('+ x  +','+ y +')')
                .style('fill', this.component.colorScale((HEIGHT - this.minPos)/HEIGHT));

            var label = this.component.getGradientLabelContent(this.minPos);
            var labelStyle = this.component.componentOption.style;
            var labelDim = BaseUtils.getTextDimension(label, labelStyle, true);

            if(this._labelUseHtml()){
                var labelY = this._getIntPos(startPos + this.minPos - BAR_HEIGHT/2 - labelDim.height/2);
                var labelBounds = this._getAbsoluteBounds(labelDim, PADDING + WIDTH + BAR_WIDTH + BAR_TEXT_GAP, labelY);
                this.labelDivManager.clearLabels(MAX_BAR_CLASS_NAME);
                this.labelDivManager.addLabelWidthBounds(label, labelBounds, labelStyle, MAX_BAR_CLASS_NAME);
            } else {
                this._legendG.select('text.' + MAX_BAR_CLASS_NAME)
                    .attr('text-anchor', 'middle')
                    .attr('x', this._getIntPos(PADDING + WIDTH + BAR_WIDTH + BAR_TEXT_GAP + labelDim.width/2))
                    .attr('y', this._getIntPos(startPos + this.minPos - BAR_HEIGHT/2))
                    .text(label);
            }

            this._updateVerticalLinearColorClipPath(startPos);
        },

        _updateHorizontalMaxBar: function(startPos) {
            var x = startPos + this.maxPos;
            var y = PADDING + WIDTH;

            this._legendG.select('path.' + MAX_BAR_CLASS_NAME)
                .attr('transform', 'translate('+ x  +','+ y +')')
                .style('fill', this.component.colorScale(this.maxPos/HEIGHT));

            var label = this.component.getGradientLabelContent(this.maxPos);
            var labelStyle = this.component.componentOption.style;
            var labelDim = BaseUtils.getTextDimension(label, labelStyle, true);

            if(this._labelUseHtml()){
                var labelBounds = this._getAbsoluteBounds(labelDim, this._getIntPos(startPos + this.maxPos), PADDING + WIDTH + BAR_WIDTH + BAR_TEXT_GAP);
                this.labelDivManager.clearLabels(MAX_BAR_CLASS_NAME);
                this.labelDivManager.addLabelWidthBounds(label, labelBounds, labelStyle, MAX_BAR_CLASS_NAME);
            } else {
                this._legendG.select('text.' + MAX_BAR_CLASS_NAME)
                    .attr('text-anchor', 'left')
                    .attr('y', this._getIntPos(PADDING + WIDTH + BAR_WIDTH + BAR_TEXT_GAP + labelDim.height/2))
                    .attr('x', this._getIntPos(startPos + this.maxPos))
                    .text(label);
            }

            this._updateHorizontalLinearColorClipPath(startPos);
        },

        _updateVerticalLinearColorClipPath: function (startPos) {
            var IDPrefix = this.component.vanchart.getIDPrefix();

            this._legendG.select('defs')
                .select('clipPath#' + CLIP_ID + IDPrefix)
                .select('rect')
                .attr('x', PADDING)
                .attr('y', startPos + this.minPos)
                .attr('width', WIDTH)
                .attr('height', this.maxPos - this.minPos);
        },

        _updateHorizontalLinearColorClipPath: function (startPos) {
            var IDPrefix = this.component.vanchart.getIDPrefix();

            this._legendG.select('defs')
                .select('clipPath#' + CLIP_ID + IDPrefix)
                .select('rect')
                .attr('x', startPos + this.minPos)
                .attr('y', PADDING)
                .attr('width', this.maxPos - this.minPos)
                .attr('height', WIDTH);
        },

        _renderInterval:function() {
            if(this.component.items.length <= 0){
                return;
            }

            var itemS = this._legendG.selectAll('g.' + RANGE_ITEM)
                .data(this.component.items);

            var self = this;

            itemS.enter().append('g').attr('class', RANGE_ITEM)
                . each(function () {
                    var newItem = d3.select(this);
                    newItem.append('rect').attr('class', RANGE_ITEM);
                    if(!self._labelUseHtml()){
                        newItem.append('text').attr('class', RANGE_ITEM);
                    }
                    newItem.call(self._bindMouseEvent.bind(self));
                });

            this.isHorizontal ? this._updateHorizontalIntervalItems(itemS)
                : this._updateVerticalIntervalItems(itemS);
        },

        _updateVerticalIntervalItems: function (itemS) {
            var cfg = this.component.componentOption;
            var labelStyle = cfg.style;

            var x = PADDING;
            var labelX = PADDING + WIDTH + BAR_TEXT_GAP;
            var startY = (this.component.bounds.height - this.component.items.length * ITEM_WIDTH - (this.component.items.length - 1) * ITEM_GAP)/2;
            startY = this._getIntPos(startY);

            var self = this;
            itemS.each(function(d){
                var item = d3.select(this);

                var labelDim = BaseUtils.getTextDimension(d.label, labelStyle);

                item.select('rect')
                    .attr('rx', 2)
                    .attr('ry', 2)
                    .attr('x', x)
                    .attr('y', startY)
                    .attr('width', WIDTH)
                    .attr('height', ITEM_WIDTH)
                    .style('fill', d.visible ? d.color : d.hiddenColor);

                if(self._labelUseHtml()) {
                    var labelBounds = self._getAbsoluteBounds(labelDim, self._getIntPos(labelX),  self._getIntPos(startY + ITEM_WIDTH / 2 - labelDim.height/2));
                    self.labelDivManager.addLabelWidthBounds(d.label, labelBounds, labelStyle);
                } else {
                    item.select('text')
                        .text(function (d) {
                            return d.label
                        })
                        .attr('x', self._getIntPos(labelX + labelDim.width / 2))
                        .attr('y', self._getIntPos(startY + ITEM_WIDTH / 2))
                        .attr('dy', '.32em')
                        .attr('text-anchor', 'middle')
                        .call(BaseUtils.setTextStyle, labelStyle)
                        .style('fill', d.visible ? labelStyle.color : d.hiddenColor);
                }

                startY += (ITEM_WIDTH + ITEM_GAP);
            });
        },

        _updateHorizontalIntervalItems: function (itemS) {
            var cfg = this.component.componentOption;
            var labelStyle = cfg.style;
            var startX = (this.component.bounds.width - this.component.items.length * ITEM_WIDTH - (this.component.items.length - 1) * ITEM_GAP)/2;
            startX = this._getIntPos(startX);

            var self = this;
            itemS.each(function(d, i){
                var item = d3.select(this);

                var labelDim = BaseUtils.getTextDimension(d.label, labelStyle);
                var topLabelY = PADDING;
                var iconY = topLabelY + labelDim.height + BAR_TEXT_GAP;
                var bottomY = iconY + WIDTH + BAR_TEXT_GAP;

                item.select('rect')
                    .attr('rx', 2)
                    .attr('ry', 2)
                    .attr('x', startX)
                    .attr('y', iconY)
                    .attr('width', ITEM_WIDTH)
                    .attr('height', WIDTH)
                    .style('fill', d.visible ? d.color : d.hiddenColor);

                if(self._labelUseHtml()) {
                    var labelY = self._getIntPos(i % 2 == 0 ? topLabelY : bottomY);
                    var labelBounds = self._getAbsoluteBounds(labelDim, self._getIntPos(startX), labelY);
                    self.labelDivManager.addLabelWidthBounds(d.label, labelBounds, labelStyle);
                } else {
                    item.select('text')
                        .text(function (d) {
                            return d.label
                        })
                        .attr('x', self._getIntPos(startX + ITEM_WIDTH / 2))
                        .attr('y', self._getIntPos(i % 2 == 0 ? topLabelY + labelDim.height / 2 : bottomY + labelDim.height / 2))
                        .attr('dy', '.32em')
                        .attr('text-anchor', 'middle')
                        .call(BaseUtils.setTextStyle, labelStyle)
                        .style('fill', d.visible ? labelStyle.color : d.hiddenColor);
                }

                startX += (ITEM_WIDTH + ITEM_GAP);
            });
        },

        _bindMouseEvent:function(rowSelection){
            var vanChart = this.component.vanchart;
            var cfg = this.component.componentOption;
            var labelColor = cfg.style.color;

            rowSelection
                .style('cursor', 'pointer')
                .on('mouseenter', function(d){
                    d3.select(this).select('text.' + RANGE_ITEM).style('fill', d.hoverColor);
                })
                .on('mouseleave', function(d){
                    var textColor = d.visible ? labelColor : d.hiddenColor;
                    d3.select(this).select('text.' + RANGE_ITEM).style('fill', textColor);
                })
                .on('click', function(d){
                    d.visible = !d.visible;
                    var iconColor = d.visible ? d.color : d.hiddenColor;
                    var textColor = d.visible ? labelColor : d.hiddenColor;
                    d3.select(this).select('rect.' + RANGE_ITEM).style('fill', iconColor);
                    d3.select(this).select('text.' + RANGE_ITEM).style('fill', textColor);

                    var hasMap = vanChart.getChart(Constants.MAP_CHART);
                    d.points.forEach(function (point) {
                        if(!hasMap || (hasMap && point.points && point.points[0] == point)){
                            point.visible = d.visible;
                            if(hasMap){
                                var points = point.points;
                                for(var i = 1, len = points.length; i < len; i++){
                                    points[i].visible = point.visible;
                                }
                            }
                        }
                    });

                    vanChart.renderOnlyCharts();
                });
        },

        remove:function(){
            this._legendG && this._legendG.remove();
            this._legendG = null;
        }
    });
    
    require('./RenderLibrary').register(Constants.RANGE_LEGEND_SVG, RangeLegendSvgRender);

    return RangeLegendSvgRender;
});

/**
 * Created by eason on 15/8/12.
 */
define('render/VanChartSvgRender',['require','../Constants','./BaseRender','../utils/BaseUtils','./RenderLibrary'],function(require){

    var Constants = require('../Constants');

    var BaseRender = require('./BaseRender');
    var BaseUtils = require('../utils/BaseUtils');

    var CHART_GRADUAL = 'chart-gradual-background';
    var PLOT_GRADUAL = 'plot-gradual-background';
    var TREND_LINE = 'trend-line';

    var VanChartSvgRender = BaseRender.extend({
        render:function(){
            var dom = this.component.getParentDom();
            var width = this.component.chartWidth();
            var height = this.component.chartHeight();
            
            if(!this.svgRoot){
                this.svgRoot = d3.select(dom).append('svg')
                    .attr('width', width).attr('height', height);
                var clipID = this.component.getBodyClipID();
                this.svgRoot.append('defs').append('clipPath').attr('id', clipID);
            }

            this.svgRoot.style("pointer-events", this.component._leaflet ? 'none': 'all');

            this._updateBodyClip();

            var charts = this.component.getChartRenders();

            var fixed = this.component.getFixedComponentRenders();
            var float = this.component.getFloatComponentRenders();

            this._renderBackground();

            this.svgRoot.selectAll('g.' + Constants.AXIS_GROUP).data([0]).enter()
                .append('g').attr('class', Constants.AXIS_GROUP);

            fixed.forEach(function(render){
                render.render();
            });

            charts.forEach(function(render){
                render.render();
            });

            float.forEach(function(render){
                render.render();
            });

            this.component.getComponent(Constants.TOOLBAR_COMPONENT) &&
            this.component.getComponent(Constants.TOOLBAR_COMPONENT).render.toFront();

            this._renderTrendLine();
        },

        _updateBodyClip:function(){

            var clipBounds = this.component.getPlotClipBounds();

            var clipPath = this.svgRoot.select('#' + this.component.getBodyClipID());

            clipPath.select('rect').remove();

            clipPath
                .append('rect')
                .attr('x', clipBounds.x)
                .attr('y', clipBounds.y)
                .attr('width', clipBounds.width)
                .attr('height', clipBounds.height);
        },

        //图表区和绘图区的背景
        _renderBackground:function(){

            var IDPrefix = this.component.getIDPrefix();

            var chartBounds = BaseUtils.makeBounds(0,0,this.component.chartWidth() - 5, this.component.chartHeight() - 5);
            var chartBackground = this.component.getChartBackgroundOption();

            var plotBounds = this.component.getPlotBounds();
            var plotBackground = this.component.getPlotBackgroundOption();

            if(!this._backgroundG){
                this._backgroundG = this.svgRoot.append('g');
            }

            this._backgroundG.selectAll('.background').remove();
            this._backgroundG.selectAll('defs').remove();

            this._createGradualDefs(this._backgroundG, chartBackground.color, CHART_GRADUAL + IDPrefix);
            this._createGradualDefs(this._backgroundG, plotBackground.color, PLOT_GRADUAL + IDPrefix);

            this._renderBackgroundWithBounds(chartBackground, chartBounds, CHART_GRADUAL + IDPrefix);
            this._renderBackgroundWithBounds(plotBackground, plotBounds, PLOT_GRADUAL + IDPrefix);
        },

        _renderBackgroundWithBounds:function(option, bounds, ID){

            if(ID.indexOf(CHART_GRADUAL) != -1) {
                var bw = option.borderWidth;
                bounds = BaseUtils.rectSubPixelOpt(bounds.x + bw/2, bounds.y + bw/2, bounds.width - bw, bounds.height - bw, option.borderWidth);
            } else {
                bounds = BaseUtils.rectSubPixelOpt(bounds.x, bounds.y, bounds.width, bounds.height, option.borderWidth);
            }
            var dom = this.component.getDivParentDom();
            //阴影
            if(option.chartShadow){
                d3.select(dom).style('box-shadow', '1px 1px 2px rgba(0,0,0,0.1)')
            }else if(option.plotShadow){
                var width = [5, 3, 1];
                var opacity = [0.05, 0.1, 0.15];

                var shadowBounds = BaseUtils.rectSubPixelOpt(bounds.x, bounds.y, bounds.width, bounds.height, 1);

                for(var i = 0; i < 3; i++){
                    this._backgroundG
                        .append('rect')
                        .attr('class', 'background')
                        .attr('x', shadowBounds.x)
                        .attr('y', shadowBounds.y)
                        .attr('width', shadowBounds.width)
                        .attr('height', shadowBounds.height)
                        .attr('transform', 'translate(1, 1)')
                        .attr('rx', option.borderRadius)
                        .attr('ry', option.borderRadius)
                        .style('fill', 'none')
                        .style('stroke', 'black')
                        .style('stroke-width', width[i])
                        .style('stroke-opacity', opacity[i]);
                }

                this._backgroundG
                    .append('rect')
                    .attr('class', 'background')
                    .attr('x', shadowBounds.x)
                    .attr('y', shadowBounds.y)
                    .attr('width', shadowBounds.width)
                    .attr('height', shadowBounds.height)
                    .attr('rx', option.borderRadius)
                    .attr('ry', option.borderRadius)
                    .style('fill', 'white');
            }

            this._backgroundG
                .append('rect')
                .attr('class', 'background')
                .attr('x', bounds.x)
                .attr('y', bounds.y)
                .attr('width', bounds.width)
                .attr('height', bounds.height)
                .attr('rx', option.borderRadius)
                .attr('ry', option.borderRadius)
                .style('fill', function(){
                    if(option.color){
                        return typeof option.color == 'string' ? option.color : "url(#" + ID + ")";
                    }
                    return 'none';
                })
                .style('stroke', option.borderColor)
                .style('stroke-width', option.borderWidth);

            if(option.image){
                this._backgroundG
                    .append('image')
                    .attr('class', 'background')
                    .attr('preserveAspectRatio', 'none')
                    .attr('x', bounds.x)
                    .attr('y', bounds.y)
                    .attr('width', bounds.width)
                    .attr('height', bounds.height)
                    .attr('xlink:href', option.image);
            }

        },

        _renderTrendLine:function(){

            var trendLines = this.component.getTrendLineOption();
            var plotBounds = this.component.getPlotBounds();
            var clipID = this.component.getBodyClipID();

            if(!this._trendG){
                this._trendG = this.svgRoot
                    .append('g')
                    .attr('clip-path', "url(#" + clipID +")");
            }

            this._trendG
                .attr('transform', 'translate('+ plotBounds.x + ','+ plotBounds.y+')');

            var selection = this._trendG.selectAll('line').data(trendLines);

            selection.enter().append('line');
            selection.exit().remove();

            selection
                .attr('x1', function(d){return d.x1})
                .attr('y1', function(d){return d.y1})
                .attr('x2', function(d){return d.x2})
                .attr('y2', function(d){return d.y2})
                .style('stroke', function(d){
                    return d.trendLine.color;
                })
                .style('stroke-width', function(d){
                    return d.trendLine.width;
                })
                .style('stroke-dasharray', function(d){
                    return Constants.DASH_TYPE[d.trendLine.dashStyle];
                });
        },

        getRenderRoot:function(){
            return this.svgRoot;
        },

        remove:function(){
            this.svgRoot.remove();
            var charts = this.component.getChartRenders();
            var components = this.component.getComponentRenders();

            charts.forEach(function(render){
                render.removeDivLabels();
            });

            components.forEach(function(render){
                render.removeDivLabels();
            });
        }
    });

    require('./RenderLibrary').register(Constants.VANCHART_SVG, VanChartSvgRender);

    return VanChartSvgRender;
});
/**
 * Created by eason on 16/2/5.
 */

define('ModernBrowserRequire',['require','./chart/Pie','./chart/MultiPie','./chart/Bar','./chart/Line','./chart/Area','./chart/Gauge','./chart/Radar','./chart/Bubble','./chart/Scatter','./chart/Map','./render/PieSvgRender','./render/MultiPieSvgRender','./render/BarSvgRender','./render/LineSvgRender','./render/AreaSvgRender','./render/GaugeSvgRender','./render/RadarSvgRender','./render/BubbleSvgRender','./render/ScatterSvgRender','./render/MapSvgRender','./render/DrillToolsSvgRender','./render/TitleSvgRender','./render/CategoryAxisSvgRender','./render/ValueAxisSvgRender','./render/RadiusAxisSvgRender','./render/AngleAxisSvgRender','./render/DateAxisSvgRender','./render/LegendSvgRender','./render/ToolbarSvgRender','./render/DataSheetSvgRender','./render/RangeLegendSvgRender','./VanCharts','./render/VanChartSvgRender'],function(require){

    require('./chart/Pie');
    require('./chart/MultiPie');
    require('./chart/Bar');
    require('./chart/Line');
    require('./chart/Area');
    require('./chart/Gauge');
    require('./chart/Radar');
    require('./chart/Bubble');
    require('./chart/Scatter');
    require('./chart/Map');

    require('./render/PieSvgRender');
    require('./render/MultiPieSvgRender');
    require('./render/BarSvgRender');
    require('./render/LineSvgRender');
    require('./render/AreaSvgRender');
    require('./render/GaugeSvgRender');
    require('./render/RadarSvgRender');
    require('./render/BubbleSvgRender');
    require('./render/ScatterSvgRender');
    require('./render/MapSvgRender');

    require('./render/DrillToolsSvgRender');
    require('./render/TitleSvgRender');
    require('./render/CategoryAxisSvgRender');
    require('./render/ValueAxisSvgRender');
    require('./render/RadiusAxisSvgRender');
    require('./render/AngleAxisSvgRender')
    require('./render/DateAxisSvgRender');
    require('./render/LegendSvgRender');
    require('./render/ToolbarSvgRender');
    require('./render/DataSheetSvgRender');
    require('./render/RangeLegendSvgRender');

    require('./VanCharts');
    require('./render/VanChartSvgRender');

});
/**
 * Created by eason on 15/12/31.
 */
define('render/RadarVmlRender',['require','./BaseRender','../utils/BaseUtils','../utils/ColorUtils','../Constants','./RenderLibrary'],function(require){

    var BaseRender = require('./BaseRender');
    var BaseUtils = require('../utils/BaseUtils');
    var ColorUtils = require('../utils/ColorUtils');
    var Constants = require('../Constants');

    var VALUE_TICK_GAP = 2;

    var RadarVmlRender = BaseRender.extend({
        render:function(){

            this._removeAll();

            var paper = this.component.getVanchartRender().getRenderRoot();

            var radarCenter = this.component.getRadarCenter();

            this._bodySet = paper.set();

            this._axisSet = paper.set();

            this._lineSet = {};

            this.markerMap = {};

            this._drawRadarAxis(paper, radarCenter);

            this._drawRadarSeries(paper, radarCenter);

            this._drawDataLabels(paper, radarCenter);
        },

        _drawDataLabels:function(paper, radarCenter){
            var radarData = this.component.getVisibleChartData();

            var labelSet = paper.set();

            this._axisSet.push(labelSet);

            for(var i = 0, count = radarData.length; i < count; i++){

                var points = radarData[i].points;

                this._drawVmlDataLabels(paper, labelSet, points, radarCenter[0], radarCenter[1]);
            }
        },

        _drawRadarSeries:function(paper, radarCenter){
            var radarData = this.component.getVisibleChartData();

            for(var i = 0, count = radarData.length; i < count; i++){
                var seryData = radarData[i];
                var points = seryData.points;

                var seriesSet = paper.set();
                this._lineSet[seryData.seriesName] = seriesSet;
                this._bodySet.push(seriesSet);

                if(this.component.isColumnType()){
                    for(var pIndex = 0, pCount = points.length; pIndex < pCount; pIndex++){
                        var d = points[pIndex];

                        var rect = paper.path(this.component._getRadarColumnPath(d.y0, d.y, d.radian))
                            .attr({
                                fill: d.color,
                                'fill-opacity': d.fillColorOpacity,
                                stroke: d.borderColor,
                                'stroke-width': d.borderWidth
                            })
                            .transform(BaseUtils.makeTranslate(radarCenter))
                            .datum(d);

                        this.markerMap[d.className] = rect;

                        this.addShapeEventHandler(rect);

                        seriesSet.push(rect);
                    }

                }else{

                    var line = paper.path(this.component._getRadarSeriesStrokePath(seryData.pathSegment, seryData.connectNulls))
                        .attr({
                            fill: 'none',
                            stroke:seryData.lineColor,
                            'stroke-width':seryData.lineWidth
                        })
                        .transform(BaseUtils.makeTranslate(radarCenter))
                        .datum(seryData);

                    this.addSeriesEventHandler(line);

                    seriesSet.push(line);

                    var fill = paper.path(this.component._getRadarSeriesFillPath(seryData.pathSegment, seryData.connectNulls))
                        .attr({
                            fill: seryData.fillColor,
                            'fill-opacity': seryData.fillColor ? seryData.fillColorOpacity : 0,
                            stroke:'none'
                        })
                        .transform(BaseUtils.makeTranslate(radarCenter))
                        .datum(seryData);

                    this.addSeriesEventHandler(fill);

                    seriesSet.push(fill);

                    for(var pIndex = 0, pCount = points.length; pIndex < pCount; pIndex++){
                        var point = points[pIndex];
                        var pos = point.pos;

                        var marker = this._createVmlMarker(paper, point, [radarCenter[0] + pos[0], radarCenter[1] + pos[1]])

                        this.markerMap[point.className] = marker;

                        seriesSet.push( marker.marker );
                    }
                }
            }
        },

        _drawRadarAxis:function(paper, radarCenter){

            // this._drawPlotBands(paper, radarCenter);
            //
            // this._drawPlotLines(paper, radarCenter);
            //
            // this._drawGridLine(paper, radarCenter);
            //
            // this._drawAxisLine(paper, radarCenter);
            //
            // this._drawTickLabel(paper, radarCenter);
        },

        _drawPlotBands:function(paper, radarCenter){
            var plotBands = this.component.getRadarPlotBands();
            var axisSet = this._axisSet;
            plotBands.forEach(function(band){
                axisSet.push(
                    paper.path(band.path)
                        .attr({
                            'fill': band.color,
                            'stroke': 'none'
                        })
                        .transform(BaseUtils.makeTranslate(radarCenter))
                )
            });
        },

        _drawPlotLines:function(paper, radarCenter){
            var plotLines = this.component.getRadarPlotLines();
            var self = this;

            plotLines.forEach(function(d){

                self._axisSet.push(

                    paper.path(self.component._getGridPath(d.value))
                        .attr({
                            fill:'none',
                            stroke: d.color,
                            'stroke-width': d.width,
                            'stroke-dasharray': d.dataArray
                        })
                        .transform(BaseUtils.makeTranslate(radarCenter))

                );

                if(d.text){
                    var textStyle = BaseUtils.cssNormalization(d.style);
                    paper.text(0, d.baseY, d.text)
                        .attr(textStyle)
                        .attr('text-anchor', d.textAnchor)
                        .transform(BaseUtils.makeTranslate(radarCenter));
                }

            });
        },

        _drawGridLine:function(paper, radarCenter){
            var valueAxis = this.component.getValueAxis();
            var cfg = valueAxis.componentOption;
            var ticks = valueAxis.getTickData();
            var gridLineColor = cfg.gridLineColor;
            var gridLineWidth = cfg.gridLineWidth;

            var self = this;

            ticks.forEach(function(d){

                self._axisSet.push(

                    paper.path(self.component._getGridPath(d.tickValue))
                        .attr({
                            'fill':'none',
                            'stroke':gridLineColor,
                            'stroke-width':gridLineWidth
                        })
                        .transform(BaseUtils.makeTranslate(radarCenter))
                );

            });
        },

        _drawAxisLine:function(paper, radarCenter) {

            var valueAxis = this.component.getValueAxis();
            var cfg = valueAxis.componentOption;
            var lineWidth = cfg.lineWidth;
            var lineColor = cfg.lineColor;
            var self = this;

            var axisLineData = this.component.getAxisLineData();

            axisLineData.forEach(function (d) {

                self._axisSet.push(
                    paper.path(self._getLinePath([0, 0], d))
                        .attr({
                            'fill': 'none',
                            'stroke': lineColor,
                            'stroke-width': lineWidth
                        })
                        .transform(BaseUtils.makeTranslate(radarCenter))
                );

            });

            var baseAxis = this.component.getBaseAxis();
            var categoryLineWidth = baseAxis.componentOption.lineWidth;
            var categoryLineColor = baseAxis.componentOption.lineColor;
            var maxValue = valueAxis.scale.domain()[1];

            this._axisSet.push(

                paper.path(this.component._getGridPath(maxValue))
                    .attr({
                        'fill':'none',
                        'stroke':categoryLineColor,
                        'stroke-width':categoryLineWidth
                    })
                    .transform(BaseUtils.makeTranslate(radarCenter))

            );
        },

        _drawTickLabel:function(paper, radarCenter){

            this._drawValueTickLabel(paper, radarCenter);

            this._drawCategoryTickLabel(paper, radarCenter);
        },

        _drawValueTickLabel:function(paper, radarCenter){

            var valueAxis = this.component.getValueAxis();
            var cfg = valueAxis.componentOption;
            var ticks = BaseUtils.clone(valueAxis.getTickData());

            //最大值标签不显示
            ticks.length = Math.max(ticks.length - 1, 0);

            var labelStyle = cfg.labelStyle;
            var labelRotation = cfg.labelRotation || 0;
            var useHtml = cfg.useHtml;
            var valueScale = this.component.valueScale;

            if(useHtml && !labelRotation){

                for(var i = 0, len = ticks.length; i < len; i++){

                    var tick = ticks[i];

                    var x = -tick.tickDim.width - VALUE_TICK_GAP + radarCenter[0];
                    var y = -valueScale(tick.tickValue)-tick.tickDim.height + radarCenter[1];

                    this.labelDivManager.addLabel(tick.tickContent, {x:x, y:y}, labelStyle);
                }

            }else{

                for(var i = 0, count = ticks.length; i < count; i++){

                    var tick = ticks[i];

                    var normalDim = BaseUtils.getTextDimension(tick.tickContent, labelStyle, useHtml);

                    var x = radarCenter[0] - VALUE_TICK_GAP - normalDim.width/2;
                    var y = radarCenter[1] - valueScale(tick.tickValue) - normalDim.height/2;

                    this._axisSet.push(
                        paper.text(x, y, tick.tickContent)
                            .attr(BaseUtils.cssNormalization(labelStyle))
                            .transform('r' + labelRotation)
                    )
                }
            }

        },

        _drawCategoryTickLabel:function(paper, radarCenter){

            var baseAxis = this.component.getBaseAxis();
            var cfg = baseAxis.componentOption;

            var labelStyle = cfg.labelStyle;
            var labelRotation = cfg.labelRotation || 0;
            var useHtml = cfg.useHtml;

            var ticks = this.component.categoryLabel;
            var lineHeight = BaseUtils.getTextHeight(labelStyle);

            if(useHtml && !labelRotation){

                for(var i = 0, len = ticks.length; i < len; i++){

                    var tick = ticks[i];

                    var x = tick.tickPos.x + radarCenter[0];
                    var y = tick.tickPos.y + radarCenter[1];

                    this.labelDivManager.addLabel(tick.tickContent, {x:x, y:y}, labelStyle);
                }

            }else{

                for(var i = 0, count = ticks.length; i < count; i++){

                    var tick = ticks[i];
                    var tickContent = tick.tickContent;

                    if(BaseUtils.isArray(tickContent)){

                        var startX = radarCenter[0] + tick.tickPos.x;
                        var startY = radarCenter[1] + tick.tickPos.y + lineHeight/2;

                        var dx = tick.tickPos.x < 0 ? tick.tickDim.width : 0;
                        var textAnchor = tick.tickPos.x < 0 ? 'end' : 'start';
                        var x = dx + startX;

                        for(var j = 0, len = tickContent.length; j < len; j++){

                            var y = startY + j * (1.3 * lineHeight);
                            var t_content = tickContent[j];

                            this._axisSet.push(
                                paper.text(x, y, t_content)
                                    .attr(BaseUtils.cssNormalization(labelStyle))
                                    .attr('text-anchor', textAnchor)
                                    .transform('t' + labelRotation)
                            );
                        }

                    }else{

                        var rx = radarCenter[0] + tick.tickPos.x + tick.tickDim.width/2;

                        var ry = radarCenter[1] + tick.tickPos.y + tick.tickDim.height/2;

                        this._axisSet.push(
                            paper.text(rx, ry, tickContent)
                                .attr(BaseUtils.cssNormalization(labelStyle))
                                .transform('r' + labelRotation)
                        );
                    }
                }
            }

        },

        getElementByData:function(d){
            return this.markerMap[d.className];
        },

        mouseOver:function(event){
            if(event && event.target){
                var d = event.target.datum();
                if(d.columnType){
                    event.target.attr({
                        'stroke':ColorUtils.mixColorWithAlpha(d.mouseOverColor, 0.35),
                        'fill':  d.mouseOverColor ? d.mouseOverColor : d.color,
                        'stroke-width':6
                    });
                }else{
                    this._makeVmlMarkerChosenState(d);
                }
            }
        },

        mouseOut:function(event){
            if(event && event.target){
                var d = event.target.datum();
                if(d.columnType){
                    event.target
                        .attr({
                            'stroke':d.borderColor,
                            'fill':  d.color,
                            'stroke-width': d.borderWidth
                        });
                }else{
                    this._cancelVmlMarkerChosenState(d);
                }
            }
        },
        
        _removeAll:function(){

            if(this._bodySet){

                if(this.component.getVisibleChartData().length){
                    this._bodySet.remove();
                    this._axisSet.remove();
                }else{
                    this._bodySet.remove();
                }

                this.labelDivManager.clearAllLabels();
            }
        }
    });

    require('./RenderLibrary').register(Constants.RADAR_VML, RadarVmlRender);
});
/**
 * Created by eason on 15/12/2.
 */
define('render/GaugeVmlRender',['require','../utils/BaseUtils','../Constants','./BaseRender','../utils/ColorUtils','./RenderLibrary'],function(require){

    var BaseUtils = require('../utils/BaseUtils');
    var Constants = require('../Constants');
    var BaseRender = require('./BaseRender');
    var ColorUtils = require('../utils/ColorUtils');

    var THERMOMETER_R = 5;

    var GaugeVmlRender = BaseRender.extend({
        render:function(){

            this._removeAll();

            var paper = this.component.getVanchartRender().getRenderRoot();
            var plotBounds = this.component.getPlotBounds();
            var plotX = plotBounds.x;
            var plotY = plotBounds.y;

            this._bodySet = paper.set();

            var gaugeData = this.component.getVisibleChartData();

            for(var i = 0, len = gaugeData.length; i < len; i++){
                var gaugeSet = paper.set();
                var d = gaugeData[i];
                var style = d.style;

                switch (style){
                    case Constants.GAUGE_POINTER:
                        this._createPointer(paper, gaugeSet, d);
                        break;

                    case Constants.GAUGE_POINTER_SEMI:
                        this._createPointerSemi(paper, gaugeSet, d);
                        break;

                    case Constants.GAUGE_SLOT:
                        this._createSlot(paper, gaugeSet, d);
                        break;

                    case Constants.GAUGE_THERMOMETER:
                        this._createThermometer(paper, gaugeSet, d);
                        break;

                    case Constants.GAUGE_RING:
                        this._createRing(paper, gaugeSet, d);
                        break;
                }

                gaugeSet.transform('t' + (d.centerX + plotX) + ',' + (d.centerY + plotY));

                this._bodySet.push(gaugeSet);
            }

            this.component.vanchart.hoverSeries = gaugeData[0];
        },

        _createPointer:function(paper, gaugeSet, d){
            var arc = d3.svg.arc().startAngle(0).endAngle(2 * Math.PI)
                .innerRadius(0).outerRadius(d.radius);

            var domain = d.gaugeAxis.scale.domain();
            var scale = d3.scale.linear().domain(domain)
                .range([BaseUtils.toRadian(-150), BaseUtils.toRadian(150)]);

            //底盘
            gaugeSet.push(
                paper.path(arc()).attr({
                    fill:d.paneBackgroundColor,
                    'fill-opacity':ColorUtils.getColorOpacity(d.paneBackgroundColor),
                    stroke:'none'
                })
            );

            //枢纽背景
            arc.outerRadius(0.16 * d.radius);
            gaugeSet.push(
                paper.path(arc()).attr({
                    fill:d.hingeBackgroundColor,
                    'fill-opacity':ColorUtils.getColorOpacity(d.hingeBackgroundColor),
                    stroke:'none'
                })
            );

            this._drawGaugeLabels(paper, gaugeSet, d);

            this._drawPointerTicks(paper, gaugeSet, d, scale);
            //
            this._drawPointerArrow(paper, gaugeSet, d, scale);

            //枢纽
            arc.outerRadius(0.07 * d.radius);
            gaugeSet.push(
                paper.path(arc()).attr({
                    fill: d.hinge,
                    'fill-opacity':ColorUtils.getColorOpacity(d.hinge),
                    stroke:'none'
                })
            );
        },

        _createPointerSemi:function(paper, gaugeSet, d){

            var circle = d3.svg.arc().startAngle(0).endAngle(2 * Math.PI).innerRadius(0);

            var arc = d3.svg.arc().startAngle(BaseUtils.toRadian(-98))
                .endAngle(BaseUtils.toRadian(98))
                .innerRadius(0).outerRadius(d.radius).toCenter(false);

            var domain = d.gaugeAxis.scale.domain();
            var scale = d3.scale.linear().domain(domain)
                .range([BaseUtils.toRadian(-90), BaseUtils.toRadian(90)]);

            //底盘
            gaugeSet.push(
                paper.path(arc()).attr({
                    fill:d.paneBackgroundColor,
                    'fill-opacity':ColorUtils.getColorOpacity(d.paneBackgroundColor),
                    stroke:'none'
                })
            );

            //枢纽背景
            circle.outerRadius(0.11 * d.radius);
            gaugeSet.push(
                paper.path(circle()).attr({
                    fill:d.hingeBackgroundColor,
                    'fill-opacity':ColorUtils.getColorOpacity(d.hingeBackgroundColor),
                    stroke:'none'
                })
            );

            this._drawGaugeLabels(paper, gaugeSet, d);

            this._drawPointerTicks(paper, gaugeSet, d, scale);
            //
            this._drawPointerArrow(paper, gaugeSet, d, scale);

            //枢纽
            circle.outerRadius(0.055 * d.radius);
            gaugeSet.push(
                paper.path(circle()).attr({
                    fill: d.hinge,
                    'fill-opacity':ColorUtils.getColorOpacity(d.hinge),
                    stroke:'none'
                })
            );
        },

        _drawGaugeLabels:function(paper, gaugeSet, d){

            if(d.seriesLabelContent){
                this._drawLabel(paper, gaugeSet, d.seriesLabelContent, d.seriesLabelPos, d.seriesLabelStyle,
                    d.seriesLabelDim, d, d.seriesLabel.useHtml);
            }

            if(d.percentageLabelContent){
                this._drawLabel(paper, gaugeSet, d.percentageLabelContent, d.percentageLabelPos, d.percentageLabelStyle,
                    d.percentageLabelDim, d, d.percentageLabel.useHtml);
            }

            if(d.valueLabelContent){

                //指针类型的仪表盘值标签后面有背景
                if(d.valueLabelBackground){

                    var opt = d.valueLabelBackground;

                    gaugeSet.push(
                        paper.rect(opt.x, opt.y, opt.width, opt.height)
                            .attr({
                                fill:d.valueLabel.backgroundColor,
                                'fill-opacity':ColorUtils.getColorOpacity(d.valueLabel.backgroundColor),
                                stroke:'none'
                            })
                    );

                }

                for(var i = 0, len = d.valueLabelContent.length; i < len; i++){
                    var valueLabel = d.valueLabelContent[i];
                    this._drawLabel(paper, gaugeSet, valueLabel.labelContent, valueLabel.labelPos, valueLabel.labelStyle,
                        valueLabel.labelDim, d, d.valueLabel.useHtml);
                }

            }
        },

        _drawLabel:function(paper, gaugeSet, labelContent, labelPos, labelStyle, labelDim, gauge, useHtml){

            //ie678有自体大小不一致的问题,暂时统一用div
            var plotBounds = this.component.getPlotBounds();
            var centerX = gauge.centerX;
            var centerY = gauge.centerY;

            labelPos = {
                x:labelPos.x + centerX + plotBounds.x,
                y:labelPos.y + centerY + plotBounds.y
            };

            this.labelDivManager.addLabel(labelContent, labelPos, labelStyle);
        },

        _drawPointerArrow:function(paper, gaugeSet, d, scale){
            var self = this;

            d.points.forEach(function(point) {

                var endRadian = scale(point.valueInDomain);

                var p0 = self._getArcPoint(0.9 * d.radius, endRadian);

                var p1 = self._getArcPoint(0.02 * d.radius, endRadian + Math.PI / 2);

                var p2 = self._getArcPoint(0.02 * d.radius, endRadian - Math.PI / 2);

                var pointer = paper.path('M' + self._dealWithFloat(p0[0]) + ',' + self._dealWithFloat(p0[1])
                    + 'L' + self._dealWithFloat(p1[0]) + ',' + self._dealWithFloat(p1[1])
                    + 'L' + self._dealWithFloat(p2[0]) + ',' + self._dealWithFloat(p2[1]) + 'Z');

                pointer
                    .attr({
                        fill: d.needle,
                        'fill-opacity':ColorUtils.getColorOpacity(d.needle),
                        stroke:'none'
                    })
                    .datum(point);

                self.addShapeEventHandler(pointer);

                gaugeSet.push(pointer);
            });

        },

        _drawPointerTicks:function(paper, gaugeSet, d, scale){

            var tickData = d.gaugeAxis.getTickData();

            var axisOption = d.gaugeAxis.componentOption;
            var labelStyle = axisOption.labelStyle;
            var useHtml = axisOption.useHtml;

            var minorTickData = d.gaugeAxis.getMinorTickData();

            var self = this;

            var tickR = (1 - 0.05) * d.radius;

            var bands = d.bands;
            var plotBounds = this.component.getPlotBounds();
            var transX = plotBounds.x + d.centerX;
            var transY = plotBounds.y + d.centerY;
            tickData.forEach(function(tick){

                var radian = scale(tick.tickValue);
                var start = self._getArcPoint(tickR, radian);
                var end = self._getArcPoint(tickR - 0.1 * d.radius, radian);

                var color = self.component._getColorFromBands(tick.tickValue, bands);

                gaugeSet.push(
                    paper.path(self._getLinePath(start, end)).attr({
                        stroke:color
                    })
                );

                var labelR = (1 - 0.05 - 0.1 - 0.01) * d.radius;
                var tickDim = tick.tickDim;

                var angle = Math.atan(tickDim.width / tickDim.height);
                var joinPoint = self._getArcPoint(labelR, radian);
                var x = joinPoint[0];
                var y = joinPoint[1];

                var labelCenterX, labelCenterY;
                if(Math.abs(radian) < angle){

                    var gap = tickDim.height/2;
                    labelCenterX = x + gap * x / y;
                    labelCenterY = y + gap;

                }else if(radian >= angle && radian <= (Math.PI - angle)){//右

                    var gap = tickDim.width/2;
                    labelCenterX = x - gap;
                    labelCenterY = y - gap * y / x;

                }else if(radian >= angle - Math.PI && radian <= -angle){//左

                    var gap = tickDim.width/2;
                    labelCenterX = x + gap;
                    labelCenterY = y + gap * y / x;

                }else{
                    //下
                    var gap = tickDim.height/2;
                    labelCenterX = x - gap * x / y;
                    labelCenterY = y - gap;
                }

                if(useHtml){
                    var labelPos = {
                        x:transX + labelCenterX - tick.tickDim.width/2,
                        y:transY + labelCenterY - tick.tickDim.height/2
                    };
                    self.labelDivManager.addLabel(tick.tickContent, labelPos, labelStyle);
                }else{
                    gaugeSet.push(
                        paper.text(labelCenterX, labelCenterY, tick.tickContent)
                            .attr(BaseUtils.cssNormalization(labelStyle))
                    );
                }

            });

            minorTickData.forEach(function(value){

                var radian = scale(value);
                var start = self._getArcPoint(tickR, radian);
                var end = self._getArcPoint(tickR - 0.05 * d.radius, radian);

                var color = self.component._getColorFromBands(value, bands);

                gaugeSet.push(
                    paper.path(self._getLinePath(start, end)).attr({
                        stroke:color
                    })
                );

            });
        },

        _getArcPoint:function(r, radian){
            return [r * Math.sin(radian), -r * Math.cos(radian)]
        },

        _createSlot:function(paper, gaugeSet, d){

            var arc = d3.svg.arc().startAngle(BaseUtils.toRadian(-135))
                .endAngle(BaseUtils.toRadian(135))
                .innerRadius(0).outerRadius(d.radius)
                .toCenter(false).closePath(false);

            var circle = d3.svg.arc().startAngle(BaseUtils.toRadian(-135))
                .endAngle(BaseUtils.toRadian(135))
                .innerRadius(0).outerRadius(d.radius)
                .toCenter(false).closePath(false);

            gaugeSet.push(
                paper.path(circle()).attr({
                    'fill':'none',
                    'stroke': d.slotBackgroundColor,
                    'stroke-linecap':'round',
                    'stroke-width': d.radius * 0.16
                })
            );

            var domain = d.gaugeAxis.scale.domain();
            var startRadian = BaseUtils.toRadian(-135);
            var scale = d3.scale.linear().domain(domain).range([startRadian, BaseUtils.toRadian(135)]);
            var point = d.points[0];
            if(!point){
                return;
            }

            var valueInDomain = point.valueInDomain;
            var endRadian = scale(valueInDomain);
            var endStroke = point.color;
            var cP = this._getArcPoint(d.radius, endRadian);

            if(Math.abs(endRadian - startRadian) < 1e-6){
                gaugeSet.push(
                    paper.circle(cP[0], cP[1], 0.08 * d.radius)
                        .attr({
                            fill: endStroke,
                            stroke: 'none'
                        })
                );
            }else{

                var outerStroke = paper.path(arc.endAngle(endRadian)())
                    .attr({
                        'fill':'none',
                        'stroke': endStroke,
                        'stroke-linecap':'round',
                        'stroke-width': d.radius * 0.16
                    }).datum(d);
                this.addSeriesEventHandler(outerStroke);
                gaugeSet.push(outerStroke);
            }

            gaugeSet.push(
                paper.circle(cP[0], cP[1], 0.048 * d.radius)
                    .attr({
                        fill: d.needle,
                        'fill-opacity':ColorUtils.getColorOpacity(d.needle),
                        stroke: 'none'
                    })
            );

            this._drawGaugeLabels(paper, gaugeSet, d);
        },

        _createThermometer:function(paper, gaugeSet, d){
            d.thermometerLayout == Constants.HORIZONTAL_LAYOUT
                ? this._createHorizontalThermometer(paper, gaugeSet, d) : this._createVerticalThermometer(paper, gaugeSet, d);

        },

        _createHorizontalThermometer:function(paper, gaugeSet, d){

            var domain = d.gaugeAxis.scale.domain();
            var point = d.points[0];
            if(!point){
                return;
            }

            var valueInDomain = point.valueInDomain;
            var color = point.color;

            var radius = d.radius;
            var scale = d3.scale.linear()
                .domain(domain).range([-radius, radius]);

            gaugeSet.push(
                paper.path(this._getLinePath([-radius,0], [radius,0]))
                    .attr({
                        'fill':'none',
                        'stroke': d.slotBackgroundColor,
                        'stroke-width':THERMOMETER_R * 2,
                        'stroke-linecap':'round'
                    })
            );

            var outerStroke = paper.path(this._getLinePath([-radius,0], [scale(valueInDomain),0]))
                .attr({
                    'fill':'none',
                    'stroke': color,
                    'stroke-width':THERMOMETER_R * 2,
                    'stroke-linecap':'round'
                }).datum(d);

            this.addSeriesEventHandler(outerStroke);
            gaugeSet.push(outerStroke);

            gaugeSet.push(
                paper.circle(scale(valueInDomain), 0, THERMOMETER_R * 0.9)
                    .attr({
                        'fill': d.needle,
                        'fill-opacity':ColorUtils.getColorOpacity(d.needle),
                        'stroke-width': THERMOMETER_R * 0.6,
                        'stroke':ColorUtils.mixColorWithHSB(color, 0, 0.1, -0.1)
                    })

            );

            this._drawGaugeLabels(paper, gaugeSet, d);

            this._drawHorizontalThermometerTicks(paper, gaugeSet, d, scale);
        },

        _drawHorizontalThermometerTicks:function(paper, gaugeSet, d, scale){
            var tickData = d.gaugeAxis.getTickData();

            var axisOption = d.gaugeAxis.componentOption;
            var labelStyle = axisOption.labelStyle;
            var useHtml = axisOption.useHtml;

            var minorTickData = d.gaugeAxis.getMinorTickData();

            var plotBounds = this.component.getPlotBounds();
            var transX = plotBounds.x + d.centerX;
            var transY = plotBounds.y + d.centerY;
            var self = this;

            tickData.forEach(function(tick){

                var x = scale(tick.tickValue);

                gaugeSet.push(
                    paper.path(self._getLinePath([x,-9],[x,-15]))
                        .attr({
                            stroke:axisOption.tickColor,
                            'stroke-width':1
                        })
                );

                if(useHtml){

                    var labelPos = {
                        x:transX + x - tick.tickDim.width/2,
                        y:transY -19 - tick.tickDim.height
                    };

                    self.labelDivManager.addLabel(tick.tickContent, labelPos, labelStyle);

                }else{
                    gaugeSet.push(
                        paper.text(x, -19 - tick.tickDim.height/2, tick.tickContent)
                            .attr(BaseUtils.cssNormalization(labelStyle))

                    );
                }



            });

            minorTickData.forEach(function(value){

                var x = scale(value);

                gaugeSet.push(
                    paper.path(self._getLinePath([x,-9],[x,-13]))
                        .attr({
                            stroke:axisOption.minorTickColor,
                            'stroke-width':1
                        })
                );

            });

        },

        _createVerticalThermometer:function(paper, gaugeSet, d){

            var domain = d.gaugeAxis.scale.domain();
            var point = d.points[0];
            if(!point){
                return;
            }

            var color = point.color;
            var valueInDomain = point.valueInDomain;
            var radius = d.radius;
            var scale = d3.scale.linear()
                .domain(domain).range([radius, -radius]);

            gaugeSet.push(
                paper.path(this._getLinePath([0,radius], [0,-radius]))
                    .attr({
                        'fill':'none',
                        'stroke': d.slotBackgroundColor,
                        'stroke-width':THERMOMETER_R * 2,
                        'stroke-linecap':'round'
                    })
            );

            var outerStroke = paper.path(this._getLinePath([0,radius], [0, scale(valueInDomain)]))
                .attr({
                    'fill':'none',
                    'stroke': color,
                    'stroke-width':THERMOMETER_R * 2,
                    'stroke-linecap':'round'
                }).datum(d);
            this.addSeriesEventHandler(outerStroke);
            gaugeSet.push(outerStroke);

            gaugeSet.push(
                paper.circle(0, scale(valueInDomain), THERMOMETER_R * 0.9)
                    .attr({
                        'fill': d.needle,
                        'fill-opacity':ColorUtils.getColorOpacity(d.needle),
                        'stroke-width': THERMOMETER_R * 0.6,
                        'stroke':ColorUtils.mixColorWithHSB(color, 0, 0.1, -0.1)
                    })

            );

            this._drawGaugeLabels(paper, gaugeSet, d);

            this._drawVerticalThermometerTicks(paper, gaugeSet, d, scale);
        },

        _drawVerticalThermometerTicks:function(paper, gaugeSet, d, scale){

            var tickData = d.gaugeAxis.getTickData();

            var axisOption = d.gaugeAxis.componentOption;
            var labelStyle = axisOption.labelStyle;
            var useHtml = axisOption.useHtml;

            var minorTickData = d.gaugeAxis.getMinorTickData();

            var plotBounds = this.component.getPlotBounds();
            var transX = plotBounds.x + d.centerX;
            var transY = plotBounds.y + d.centerY;
            var self = this;

            tickData.forEach(function(tick){

                var y = scale(tick.tickValue);

                gaugeSet.push(
                    paper.path(self._getLinePath([9,y],[15,y]))
                        .attr({
                            stroke:axisOption.tickColor,
                            'stroke-width':1
                        })
                );

                if(useHtml){

                    var labelPos = {
                        x:transX + 19,
                        y:transY + y - tick.tickDim.height/2
                    };

                    self.labelDivManager.addLabel(tick.tickContent, labelPos, labelStyle);

                }else{
                    gaugeSet.push(
                        paper.text(19, y, tick.tickContent)
                            .attr(BaseUtils.cssNormalization(labelStyle))
                            .attr('text-anchor', 'start')

                    );
                }

            });

            minorTickData.forEach(function(value){

                var y = scale(value);

                gaugeSet.push(
                    paper.path(self._getLinePath([9,y],[13,y]))
                        .attr({
                            stroke:axisOption.minorTickColor,
                            'stroke-width':1
                        })
                );

            });
        },

        _createRing:function(paper, gaugeSet, d){
            var circle = d3.svg.arc()
                .startAngle(0).endAngle(2 * Math.PI)
                .innerRadius(0).outerRadius(d.radius);

            var arc = d3.svg.arc().startAngle(0)
                .innerRadius(0).outerRadius(d.radius);

            var point = d.points[0];
            if(!point){
                return;
            }

            var arcPercentage = Math.max(point.percentage, 0);
            var endRadian = 2 * Math.PI * arcPercentage * (d.clockwise ? 1 : -1);
            var endFill = point.color;
            var innerR = d.radius * 0.8;
            var outerStrokeR = innerR + 2;

            gaugeSet.push(
                paper.path(circle())
                    .attr({
                        fill:d.paneBackgroundColor,
                        'fill-opacity':ColorUtils.getColorOpacity(d.paneBackgroundColor),
                        stroke:'none'
                    })
            );


            var outerRing = paper.path(arc.endAngle(endRadian)())
                .attr({
                    fill:endFill,
                    'fill-opacity':ColorUtils.getColorOpacity(endFill),
                    stroke:'none'
                })
                .datum(d);
            this.addSeriesEventHandler(outerRing);
            gaugeSet.push(outerRing);

            gaugeSet.push(
                paper.path(circle.outerRadius(innerR)())
                    .attr({
                        fill:d.innerPaneBackgroundColor,
                        'fill-opacity':ColorUtils.getColorOpacity(d.innerPaneBackgroundColor),
                        stroke:'none'
                    })
            );

            gaugeSet.push(
                paper.path(circle.outerRadius(outerStrokeR)())
                    .attr({
                        'fill': 'none',
                        'stroke':'#000000',
                        'stroke-opacity':0.05,
                        'stroke-width':4
                    })
            );

            this._drawGaugeLabels(paper, gaugeSet, d);
        },

        _removeAll:function(){
            if(this._bodySet){
                this._bodySet.remove();
            }
            this.labelDivManager.clearAllLabels();
        }
    });

    require('./RenderLibrary').register(Constants.GAUGE_VML, GaugeVmlRender);
});
/**
 * Created by eason on 15/11/6.
 */
define('render/LineVmlRender',['require','./BaseRender','../utils/BaseUtils','../Constants','./RenderLibrary'],function(require){

    var BaseRender = require('./BaseRender');
    var BaseUtils = require('../utils/BaseUtils');
    var Constants = require('../Constants');


    var LineVmlRender = BaseRender.extend({
        render:function(){

            this._removeAll();

            var paper = this.component.getVanchartRender().getRenderRoot();
            var plotBounds = this.component.getPlotBounds();
            var transX = plotBounds.x;
            var transY = plotBounds.y;

            this._bodySet = paper.set();

            this._lineSet = paper.set();
            this._markerSet = paper.set();
            this._labelSet = paper.set();

            this._bodySet.push(this._lineSet);
            this._bodySet.push(this._markerSet);
            this._bodySet.push(this._labelSet);

            this.markerMap = {};

            var lines = this.component.getVisibleChartData();
            var self = this;
            lines.forEach(function(line){

                var dataBands = line.dataBands;

                var needsClipRect = dataBands.length > 1;

                //先画堆积的面积图,不用移动到最上层
                dataBands.forEach(function(band){
                    var lineData = band.lineData;

                    if(self.component.componentType == Constants.AREA_CHART && lineData.isStack){
                        var area = paper.path(lineData.areaSvg(lineData.points))
                            .attr({
                                'fill':band.fillColor,
                                'fill-opacity':band.fillColorOpacity,
                                'stroke':'none'
                            })
                            .datum(lineData);

                        self.addSeriesEventHandler(area);

                        if(needsClipRect){
                            area.attr('clip-rect', self._getClipRect(band));
                        }

                        self._lineSet.push(area);
                    }
                });
            });

            lines.forEach(function(line){

                var dataBands = line.dataBands;

                var needsClipRect = dataBands.length > 1;

                dataBands.forEach(function(band){

                    var lineData = band.lineData;

                    if(self.component.componentType == Constants.AREA_CHART && !lineData.isStack){

                        var area = paper.path(lineData.areaSvg(lineData.points))
                            .attr({
                                'fill':band.fillColor,
                                'fill-opacity':band.fillColorOpacity,
                                'stroke':'none'
                            })
                            .datum(lineData);

                        self.addSeriesEventHandler(area);

                        if(needsClipRect){
                            area.attr('clip-rect', self._getClipRect(band));
                        }

                        self._lineSet.push(area);

                    }

                    var singleLine = paper
                        .path(lineData.lineSvg(lineData.points))
                        .attr({
                            'fill':'none',
                            'stroke':band.color,
                            'stroke-width':lineData.lineWidth
                        })
                        .datum(lineData);

                    self.addSeriesEventHandler(singleLine);

                    if(needsClipRect){
                        singleLine.attr('clip-rect', self._getClipRect(band));
                    }

                    self._lineSet.push(singleLine);
                });

            });

            lines.forEach(function(line){
                line.points.forEach(function(point){

                    var x = point.x + transX;
                    var y = point.y + transY;

                    var marker = self._createVmlMarker(paper, point, [x,y]);

                    self.markerMap[point.className] = marker;

                    if(marker.marker){
                        self._markerSet.push(marker.marker);
                    }

                    if(marker.strokeMarker){
                        self._markerSet.push(marker.strokeMarker);
                    }
                });
            });

            this._drawDataLabels(paper);

            this._lineSet.transform('t' + plotBounds.x + ',' + plotBounds.y);
        },

        _getClipRect:function(band){

            var plotBounds = this.component.getPlotBounds();

            return (band.x + plotBounds.x) + ',' + (band.y + plotBounds.y) + ',' + band.width + ',' + band.height;
        },

        getElementByData:function(d){

            if(this.markerMap && this.markerMap[d.className]){
                return this.markerMap[d.className];
            }

        },

        mouseOver:function(event){
            if(event && event.target){
                var d = event.target.datum();
                this._makeVmlMarkerChosenState(d);
            }
        },

        mouseOut:function(event){
            if(event && event.target){
                var d = event.target.datum();
                this._cancelVmlMarkerChosenState(d);
            }
        },

        _drawDataLabels:function(paper){

            var lines = this.component.getVisibleChartData();
            var plotBounds = this.component.getPlotBounds();
            var labelSet = this._labelSet;
            var self = this;

            lines.forEach(function(line){

                var points = line.points;

                self._drawVmlDataLabels(paper, labelSet, points, plotBounds.x, plotBounds.y);
            });
        },

        _removeAll:function(){
            if(this._bodySet){
                this._bodySet.remove();
            }
            this.labelDivManager.clearAllLabels();
        }
    });
    
    require('./RenderLibrary').register(Constants.LINE_VML, LineVmlRender);

    return LineVmlRender;

});
/**
 * Created by eason on 15/11/6.
 */

define('render/AreaVmlRender',['require','../Constants','./LineVmlRender','./RenderLibrary'],function(require){

    var Constants = require('../Constants');
    var LineVmlRender = require('./LineVmlRender');

    var AreaVmlRender = LineVmlRender.extend({});

    require('./RenderLibrary').register(Constants.AREA_VML, AreaVmlRender);
});
/**
 * Created by eason on 15/9/24.
 */
define('render/BarVmlRender',['require','./BaseRender','../utils/BaseUtils','../utils/ColorUtils','../Constants','./RenderLibrary'],function(require){

    var BaseRender = require('./BaseRender');
    var BaseUtils = require('../utils/BaseUtils');
    var ColorUtils = require('../utils/ColorUtils');
    var Constants = require('../Constants');

    var BarVmlRender = BaseRender.extend({

        render:function(){

            this._removeAll();

            var paper = this.component.getVanchartRender().getRenderRoot();
            var plotBounds = this.component.getPlotBounds();

            this._bodySet = paper.set();
            var barSet = paper.set();
            this._bodySet.push(barSet);

            this.shapeMap = {};

            var clipRect = this._getPlotClipRect();

            var series = this.component.getVisibleChartData();

            for(var i = 0, count = series.length; i < count; i++){
                var points = series[i].points;

                for(var j = 0, len = points.length; j < len; j++){
                    barSet.push(
                        this._createBar(points[j], paper, clipRect)
                    )
                }
            }

            barSet.transform('t' + plotBounds.x + ',' + plotBounds.y);

            this._drawDataLabels(paper);
        },

        _createBar:function(d, paper, clipRect){

            var rect = paper.rect(d.x, d.y, d.width, d.height)
                .attr({
                    rx: d.borderRadius,
                    ry: d.borderRadius,
                    fill:d.color,
                    'fill-opacity':ColorUtils.getColorOpacity(d.color),
                    stroke:d.borderColor,
                    'stroke-width':d.borderWidth
                })
                .datum(d);
            
            this.addShapeEventHandler(rect);

            this.shapeMap[d.className] = rect;

            return rect;
        },

        _getPlotClipRect:function(){

            var clipBounds = this.component.vanchart.getPlotClipBounds();
            var plotBounds = this.component.getPlotBounds();

            var x = plotBounds.x + clipBounds.x;
            var y = plotBounds.y + clipBounds.y;
            var width = clipBounds.width;
            var height = clipBounds.height;

            return x + ',' + y + ',' + width + ',' + height;
        },

        _drawDataLabels:function(paper){

            var series = this.component.getVisibleChartData();
            var plotBounds = this.component.getPlotBounds();


            for(var i = 0, len = series.length; i < len; i++){
                var labelSet = paper.set();
                this._bodySet.push(labelSet);

                var points = series[i].points;

                this._drawVmlDataLabels(paper, labelSet, points, plotBounds.x, plotBounds.y);
            }
        },

        _removeAll:function(){
            if(this._bodySet){
                this._bodySet.remove();
            }
            this.labelDivManager.clearAllLabels();
        },

        getElementByData:function(d){
            return this.shapeMap[d.className];
        },

        mouseOver:function(event){
            if(event && event.target){
                var d = event.target.datum();
                event.target.attr({
                        'stroke': d.mouseOverColor,
                        'stroke-opacity':0.35,
                        'fill':d.mouseOverColor ? d.mouseOverColor : d.color,
                        'stroke-width':6
                    });
            }
        },

        mouseOut:function(event){
            if(event && event.target){
                var d = event.target.datum();
                event.target
                    .attr({
                        'fill':d.color,
                        'fill-opacity':ColorUtils.getColorOpacity(d.color),
                        'stroke':d.borderColor,
                        'stroke-opacity':1,
                        'stroke-width':d.borderWidth
                    });
            }
        },

        mouseDown:function(event){
            if(event && event.target){
                var d = event.target.datum();
                event.target.attr('fill', d.clickColor);
            }
        },

        mouseUp:function(event){
            if(event && event.target){
                var d = event.target.datum();
                event.target.attr('fill', d.mouseOverColor);
            }
        }

    });

    require('./RenderLibrary').register(Constants.BAR_VML, BarVmlRender);
});
/**
 * Created by eason on 15/8/13.
 */
define('render/PieVmlRender',['require','./BaseRender','../utils/BaseUtils','../utils/ColorUtils','../Constants','./RenderLibrary'],function(require){

    var BaseRender = require('./BaseRender');
    var BaseUtils = require('../utils/BaseUtils');
    var ColorUtils = require('../utils/ColorUtils');
    var Constants = require('../Constants');

    var HOVER_PERCENT = 1.1;

    var PieVmlRender = BaseRender.extend({
        render:function(){

            this._removeAll();

            var paper = this.component.getVanchartRender().getRenderRoot();
            var plotBounds = this.component.getPlotBounds();

            this._bodySet = paper.set();
            this.dataMap = {};

            paper.customAttributes.segment = function(innerRadius, outerRadius, startAngle, endAngle, color){
                var arc = d3.svg.arc().innerRadius(innerRadius).outerRadius(outerRadius);
                var attrs = {
                    path: arc({startAngle:startAngle, endAngle:endAngle})
                };

                if(color){
                    attrs.fill = color;
                    attrs['fill-opacity'] = ColorUtils.getColorOpacity(color);
                }

                return attrs;
            };

            var arcMap = this.component.getVisibleChartData();

            for(var i = 0, len = arcMap.length; i < len; i++){
                var config = arcMap[i];

                var pathSet = paper.set();
                this._bodySet.push(pathSet);

                var translateX = plotBounds.x + config.centerX;
                var translateY = plotBounds.y + config.centerY;

                var innerRadius = config.innerRadius;
                var points = config.visiblePoints;

                for(var j = 0, count = points.length; j < count; j++){
                    var point = points[j];
                    var slice = paper.path()
                        .attr({
                            segment:[innerRadius, point.radius, point.startAngle, point.endAngle],
                            fill:point.color,
                            'fill-opacity':ColorUtils.getColorOpacity(point.color),
                            stroke:point.borderColor,
                            'stroke-width':point.borderWidth
                        })
                        .datum(point);

                    this.dataMap[point.className] = slice;

                    this.addShapeEventHandler(slice);

                    pathSet.push(slice);
                }

                pathSet.transform('t' + translateX + ',' + translateY);
            }
            //标签
            this._renderDataLabels(paper);
        },

        _renderDataLabels:function(paper){
            var arcMap = this.component.getVisibleChartData();

            for(var i = 0, len = arcMap.length; i < len; i++){

                var config = arcMap[i];

                var labelSet = paper.set();
                this._bodySet.push(labelSet);

                var plotBounds = this.component.getPlotBounds();
                var transX = plotBounds.x + config.centerX;
                var transY = plotBounds.y + config.centerY;

                var points = config.visiblePoints;

                this._drawVmlDataLabels(paper, labelSet, points, transX, transY);
            }
        },

        _removeAll:function(){
            if(this._bodySet){
                this._bodySet.remove();
            }
            this.labelDivManager.clearAllLabels();
        },

        mouseOver:function(event){
            if(event && event.target){
                var d = event.target.datum();
                var startAngle = d.startAngle;
                var endAngle = d.endAngle;
                var innerRadius = d.innerRadius;
                var radius = d.radius;
                var color = d.mouseOverColor ? d.mouseOverColor : d.color;
                event.target.attr({segment: [innerRadius, radius * HOVER_PERCENT, startAngle, endAngle, color]});
            }
        },

        mouseOut:function(event){
            if(event && event.target){
                var d = event.target.datum();

                var startAngle = d.startAngle;
                var endAngle = d.endAngle;
                var innerRadius = d.innerRadius;
                var radius = d.radius;

                event.target.attr({segment: [innerRadius, radius, startAngle, endAngle, d.color]});
            }
        },

        onDragStart:function(){

        },

        onDrag:function(){

        },

        onDragEnd:function(){
            
        }

    });

    require('./RenderLibrary').register(Constants.PIE_VML, PieVmlRender);

    return PieVmlRender;
});
/**
 * Created by Yuqian on 16/7/1.
 */
define('render/MultiPieVmlRender',['require','./BaseRender','../utils/BaseUtils','../utils/ColorUtils','../Constants','./RenderLibrary'],function(require){

    var BaseRender = require('./BaseRender');
    var BaseUtils = require('../utils/BaseUtils');
    var ColorUtils = require('../utils/ColorUtils');
    var Constants = require('../Constants');

    var INNER_RING_RADIUS = 15;
    var INNER_RING_STROKE_WIDTH = 5;

    var MultiPieVmlRender = BaseRender.extend({
        render:function(){

            this._removeAll();
        
            var paper = this.component.getVanchartRender().getRenderRoot();
            var plotBounds = this.component.getPlotBounds();
            var center = this.component.getCenter();

            this._bodySet = paper.set();

            paper.customAttributes.segment = function(d){

                var arc = d3.svg.arc()
                    .startAngle(function (d) { return d.x; })
                    .endAngle(function (d) { return d.x + d.dx; })
                    .innerRadius(function(d) { return d.y;})
                    .outerRadius(function(d) { return d.y + d.dy;});

                var attrs = {
                    path: arc(d)
                };
        
                return attrs;
            };
        
            var points = this.component.getChartNodes();


            var pathSet = paper.set();
            this._bodySet.push(pathSet);

            // var translateX = plotBounds.x + config.centerX;
            // var translateY = plotBounds.y + config.centerY;

            for(var j = 0, count = points.length; j < count; j++){
                var point = points[j];
                var slice = paper.path()
                    .attr({
                        segment: point,
                        fill:point.color,
                        'fill-opacity':ColorUtils.getColorOpacity(point.color),
                        stroke:point.borderColor,
                        'stroke-width':point.borderWidth,
                        opacity: (point.depth && point.dx && (point.y+point.dy) > INNER_RING_RADIUS) ? 1 : 0
                    })
                    .datum(point);
                
                slice.node.style.display = (point.name || !point.depth) ? '' : 'none';

                this.addShapeEventHandler(slice);

                pathSet.push(slice);
            }

            pathSet.transform('t' + center[0] + ',' + center[1]);

            //标签
            this._renderDataLabels(paper);
        },

        _renderDataLabels:function(paper){
            var center = this.component.getCenter();

            var labelSet = paper.set();
            this._bodySet.push(labelSet);

            // var plotBounds = this.component.getPlotBounds();
            // var transX = plotBounds.x + center[0];
            // var transY = plotBounds.y + center[1];

            var points = this.component.getChartNodes();

            this._drawVmlDataLabels(paper, labelSet, points, center[0], center[1]);
        },

        drillDown: function (d) {
            this.render();
            if (d.depth) {
                var paper = this.component.getVanchartRender().getRenderRoot();
                var center = this.component.getCenter();
                this._bodySet.push(
                    paper.path()
                        .attr({
                            segment: {
                                x: 0,
                                dx: Math.PI * 2,
                                y: INNER_RING_RADIUS,
                                dy: INNER_RING_STROKE_WIDTH
                            },
                            stroke: 'none',
                            fill: '#000',
                            'fill-opacity': 0.1
                        })
                        .transform('t' + center[0] + ',' + center[1])
                )
            }

        },

        _removeAll:function(){
            if(this._bodySet){
                this._bodySet.remove();
            }
            this.labelDivManager.clearAllLabels();
        },

        mouseOver:function(event){
            if(event && event.target){
                var d = event.target.datum();
                if (d.depth && d.y+d.dy === INNER_RING_RADIUS) {
                    event.target
                        .attr('opacity', 1)
                } else {
                    event.target.attr({
                        fill: d.mouseOverColor,
                        'fill-opacity': ColorUtils.getColorOpacity(d.mouseOverColor)
                    });

                    if (d.tooltip && d.tooltip.shared) {
                        var handler = this.component.vanchart.handler;
                        var p, node = d;
                        while ((p = node.parent) && p.depth && p.y + p.dy !== INNER_RING_RADIUS) {
                            node = p;
                            handler.fireEventByData(p, 'cover', event);
                        }
                    }
                }
            }
        },

        mouseOut:function(event){
            if(event && event.target){
                var d = event.target.datum();
                if (d.depth && d.y+d.dy === INNER_RING_RADIUS) {
                    event.target
                        .attr('opacity', 0)
                } else {
                    event.target.attr({
                        fill: d.color,
                        'fill-opacity': ColorUtils.getColorOpacity(d.color)
                    });

                    if (d.tooltip && d.tooltip.shared) {
                        var handler = this.component.vanchart.handler;
                        var p, node = d;
                        while ((p = node.parent) && p.depth && p.y + p.dy !== INNER_RING_RADIUS) {
                            node = p;
                            handler.fireEventByData(p, 'leave', event);
                        }
                    }
                }
            }
        },

        mouseUp: function (event) {
            if(event && event.target){
                var d = event.target.datum();

                if (this.component.getDrilldown()) {
                    this.component.drillDown(d);
                }
            }
        },

        mouseDown: function () {

        },

        onDragStart:function(){

        },

        onDrag:function(){

        },

        onDragEnd:function(){

        }
    });

    require('./RenderLibrary').register(Constants.MULTIPIE_VML, MultiPieVmlRender);

    return MultiPieVmlRender;
});
/**
 * Created by Mitisky on 16/3/14.
 */
define('render/BubbleVmlRender',['require','./BaseRender','../utils/BaseUtils','../Constants','./RenderLibrary'],function(require){
    var BaseRender = require('./BaseRender');
    var BaseUtils = require('../utils/BaseUtils');
    var Constants = require('../Constants');

    var BubbleVmlRender = BaseRender.extend({

        render:function(){
            this._removeAll();

            var paper = this.component.getVanchartRender().getRenderRoot();

            this._bodySet = paper.set();

            this.shapeMap = {};
            this._createBubbles(paper);
        },

        filterRender: function () {
            this.render();
        },

        _createBubbles:function(paper){
            var plotBounds = this.component.getPlotBounds();
            var seriesS = this.component.getVisibleChartData();

            var bubbleSet = paper.set();

            var transX = plotBounds.x;
            var transY = plotBounds.y;

            for(var i = 0, count = seriesS.length; i < count; i++){
                var sery = seriesS[i];

                this._createSeriesLine(paper, sery, transX, transY);

                var points = sery.points;
                for(var j = 0, len = points.length; j < len; j++){
                    var point = points[j];
                    if(point.visible) {
                        bubbleSet.push(
                            this._createPoint(point, paper, transX, transY)
                        );
                    }
                }

                var labelSet = paper.set();
                this._bodySet.push(labelSet);
                this._drawVmlDataLabels(paper, labelSet, points, transX, transY);
            }

            this._bodySet.push(bubbleSet);
        },

        _createSeriesLine: function (paper, sery, transX, transY) {
        },

        _createPoint:function(point, paper, transX, transY){
            var plotBounds = this.component.getPlotBounds();

            var clipY = plotBounds.y + 5;

            var bubble = paper.path(d3.svg.arc().outerRadius(point.radius)({startAngle:0, endAngle:2 * Math.PI}))
                .attr({
                    'fill':point.color,
                    'fill-opacity':point.fillColorOpacity,
                    'stroke-width':0
                })
                .datum(point)
                .transform('t' + (point.posX + transX) + ',' + (point.posY + transY));
            
            this.addShapeEventHandler(bubble);

            this.shapeMap[point.className] = bubble;

            return bubble;
        },

        _removeAll:function(){
            if(this._bodySet){
                this._bodySet.remove();
            }
            this.labelDivManager.clearAllLabels();
        },

        mouseOver:function(event){
            if(this.component.isLargeMode()){
                return;
            }
            if(event && event.target){
                var d = event.target.datum();
                event.target.attr({
                        'stroke': d.mouseOverColor,
                        'stroke-opacity':0.35,
                        'stroke-width':6,
                        'fill':d.mouseOverColor,
                        'fill-opacity': 0.65
                    });
            }
        },

        mouseOut:function(event){
            if(this.component.isLargeMode()){
                return;
            }

            if(event && event.target){
                var d = event.target.datum();
                event.target
                    .attr({
                        'fill':d.color,
                        'fill-opacity':d.fillColorOpacity,
                        'stroke-width':0
                    });
            }
        },

        mouseDown:function(event){

            if(this.component.isLargeMode()){
                return;
            }

            if(event && event.target){
                var d = event.target.datum();
                event.target.attr('fill', d.clickColor);
            }
        },

        mouseUp:function(event){
            if(event && event.target){
                var d = event.target.datum();
                event.target.attr('fill', d.mouseOverColor);
            }
        }
    });

    require('./RenderLibrary').register(Constants.BUBBLE_VML, BubbleVmlRender);

    return BubbleVmlRender;
});

/**
 * Created by Mitisky on 16/3/24.
 */
define('render/ScatterVmlRender',['require','./BubbleVmlRender','../utils/BaseUtils','../Constants','./RenderLibrary'],function(require){
    var BubbleVmlRender = require('./BubbleVmlRender');
    var BaseUtils = require('../utils/BaseUtils');
    var Constants = require('../Constants');

    var ScatterVmlRender = BubbleVmlRender.extend({
        _createSeriesLine: function (paper, sery, transX, transY) {
            var plotBounds = this.component.getPlotBounds();

            var singleLine = paper
                .path(sery.lineSvg(sery.points))
                .transform('t' + transX + ',' + transY)
                .attr({
                    'fill':'none',
                    'stroke':sery.color,
                    'stroke-width':sery.lineWidth
                })
                .datum(sery);

            this._bodySet.push(singleLine);
        },

        _createPoint:function(point, paper, transX, transY){

            var x = point.posX + transX;
            var y = point.posY + transY;

            var marker = this._createVmlMarker(paper, point, [x,y]);

            this.shapeMap[point.className] = marker;

            return marker.marker;
        },

        getElementByData:function(d){
            if(this.shapeMap && this.shapeMap[d.className]){
                return this.shapeMap[d.className];
            }
        },

        mouseOver:function(event){
            if(event && event.target){
                var d = event.target.datum();
                this._makeVmlMarkerChosenState(d);
            }
        },

        mouseOut:function(event){
            if(event && event.target){
                var d = event.target.datum();
                this._cancelVmlMarkerChosenState(d);
            }
        }
    });
    
    require('./RenderLibrary').register(Constants.SCATTER_VML, ScatterVmlRender);

    return ScatterVmlRender;
});

/**
 * Created by eason on 16/5/9.
 */
define('render/MapVmlRender',['require','../utils/ColorUtils','../Constants','./MapSvgRender','./RenderLibrary'],function(require){

    var ColorUtils = require('../utils/ColorUtils');
    var Constants = require('../Constants');
    var MapSvgRender = require('./MapSvgRender');

    var MapVmlRender = MapSvgRender.extend({

        _bubbleMapHandler:function(layer){
            var map = this.component, renderer = this;
            var tooltip = map.vanchart.getComponent(Constants.TOOLTIP_COMPONENT);
            return {
                click:function(e){
                    var feature = layer._data;
                    map.drillDown(feature);
                    feature.onClick && feature.onClick(e.originalEvent);
                },

                mouseover:function(){
                    var feature = layer._data;
                    var areaLayers = renderer._bubbleLayer.getLayers();
                    for(var i = 0, len = areaLayers.length; i < len; i++){
                        if(areaLayers[i]._data.name == layer._data.name){
                            areaLayers[i].setStyle({
                                fillColor:feature.mouseOverColor,
                                opacity:0.35,
                                stroke:feature.mouseOverColor,
                                weight:6,
                                stroke:true
                            });
                        }
                    }
                },

                mouseout:function(){
                    tooltip.hide();
                    var areaLayers = renderer._bubbleLayer.getLayers();
                    var feature = layer._data;
                    for(var i = 0, len = areaLayers.length; i < len; i++){
                        if(areaLayers[i]._data.name == layer._data.name){
                            areaLayers[i].setStyle({
                                stroke:false,
                                fillColor:feature.color,
                                fillOpacity:feature.fillColorOpacity,
                                weight:0
                            });
                        }
                    }
                },

                mousemove:function(){
                    var feature = layer._data;
                    tooltip.showWithPoint(feature);
                }
            }
        },

        _scatterMapHandler:function(layer){
            var map = this.component, renderer = this;
            var tooltip = map.vanchart.getComponent(Constants.TOOLTIP_COMPONENT);

            return {
                click:function(e){
                    var feature = layer._data;
                    map.drillDown(feature);
                    feature.onClick && feature.onClick(e.originalEvent);
                },

                mouseover:function(){
                    var feature = layer._data;
                    var markerType = feature.marker.symbol;
                    var radius =  feature.marker.radius || map.getDefaultMarkerRadius();
                    var markerHighlightColor = ColorUtils.getHighLightColor(feature.marker.fillColor);
                    var isHollow = renderer._isHollowMarker(feature.marker.symbol);

                    var areaLayers = renderer._scatterLayer.getLayers();
                    for(var i = 0, len = areaLayers.length; i < len; i++){
                        if(areaLayers[i]._data.name == layer._data.name){

                        }
                    }

                },

                mouseout:function(){
                    tooltip.hide();

                    var feature = layer._data;
                    var markerType = feature.marker.symbol;
                    var radius =  feature.marker.radius || map.getDefaultMarkerRadius();
                    var areaLayers = renderer._scatterLayer.getLayers();
                    var isHollow = renderer._isHollowMarker(feature.marker.symbol);
                    for(var i = 0, len = areaLayers.length; i < len; i++){
                        if(areaLayers[i]._data.name == layer._data.name){

                        }
                    }
                },

                mousemove:function(){
                    var feature = layer._data;
                    tooltip.showWithPoint(feature);
                }
            }
        },

        _createDropShadow:function(){

        }
    });

    require('./RenderLibrary').register(Constants.MAP_VML, MapVmlRender);
});
/**
 * Created by eason on 16/5/17.
 */
define('render/DrillToolsVmlRender',['require','./BaseRender','../Constants','../utils/BaseUtils','./RenderLibrary'],function(require){

    var BaseRender = require('./BaseRender');
    var Constants = require('../Constants');
    var BaseUtils = require('../utils/BaseUtils');

    var DrillToolsVmlRender = BaseRender.extend({
        render:function(){

            this._bodySet && this._bodySet.remove();

            var paper = this.component.getVanchartRender().getRenderRoot();
            var cfg = this.component.componentOption;
            var textStyle = cfg.style;
            var bounds = this.component.bounds;
            var dTools = this.component;
            var map = dTools.vanchart.getChart(Constants.MAP_CHART);
            var iconData = this.component.getIconData();

            this._bodySet = paper.set();

            var textHeight = BaseUtils.getTextHeight(textStyle);
            var bodySet = this._bodySet;
            for(var i = 0; i < iconData.length; i++){
                var d = iconData[i];

                var transX = d.aniEnd + bounds.x;
                var transY = bounds.y;

                var label = d.geo.geoName;
                var textDim = BaseUtils.getTextDimension(label, textStyle);

                (function(d){
                    var path = paper.path(dTools.getBookMarkPath(d))
                        .attr({
                            'fill':cfg.backgroundColor,
                            'stroke':'none',
                            'cursor':'pointer'
                        })
                        .transform('t' + transX + ',' + transY)
                        .click(function(){

                            cfg.click && cfg.click(d.geo.geoName);

                            map.drillUp(d);
                        });

                    var text = paper.text((dTools.leftPadding(d)*textHeight) + textDim.width/2, (dTools.topPadding() + 0.5) * textHeight, label)
                        .attr(BaseUtils.cssNormalization(textStyle))
                        .transform('t' + transX + ',' + transY)
                        .click(function(){

                            var dataPoint = dTools.findDataPointByName(d.geo.geoName);
                            cfg.click && cfg.click(dataPoint);
                            
                            map.drillUp(d);
                        })
                        .mouseover(function(){
                            text.attr('fill', dTools.mouseOverColor(d));
                        })
                        .mouseout(function(){
                            text.attr('fill', dTools.textColor(d));
                        });

                    if(i == iconData.length - 1){
                        text.attr('fill', cfg.currentColor);
                    }

                    bodySet.push(path);
                    bodySet.push(text);
                })(d);
            }

        }
    });

    require('./RenderLibrary').register(Constants.DRILL_TOOLS_VML, DrillToolsVmlRender);

    return DrillToolsVmlRender;
});
/**
 * Created by eason on 15/10/12.
 */

define('render/DataSheetVmlRender',['require','./BaseRender','../utils/BaseUtils','../Constants','./LegendIconFactory','./RenderLibrary'],function(require){

    var BaseRender = require('./BaseRender');
    var BaseUtils = require('../utils/BaseUtils');
    var Constants = require('../Constants');
    var LegendIconFactory = require('./LegendIconFactory');

    var DataSheetVmlRender = BaseRender.extend({

        render:function(){

            if(this.componentSet){
                return;
            }

            var paper = this.component.getVanchartRender().getRenderRoot();

            var axis = this.component.vanchart.xAxis();
            var categories = axis.getCategories();
            var unitLength = this.component.getPlotBounds().width / categories.length;

            var seriesWidth = this.component.getMaxSeriesWidth();
            var categoryHeight = this.component.getCategoryHeight();

            var transX = this.component.bounds.x;
            var transY = this.component.bounds.y;


            this.componentSet = paper.set();
            this.iconSet = paper.set();

            this._drawLines(paper, seriesWidth, categoryHeight, unitLength);

            this._drawCategory(paper, seriesWidth, categoryHeight, unitLength);

            this._drawSeries(paper, seriesWidth, categoryHeight, transX, transY);

            this._drawValues(paper, seriesWidth, categoryHeight, unitLength);

            this.componentSet.transform('t' + transX + ',' + transY);
        },

        _drawLines:function(paper, seriesWidth, categoryHeight, unitLength){

            var lineG = paper.set();
            this.componentSet.push(lineG);

            var cfg = this.component.componentOption;

            var endX = this.component.bounds.width;
            var endY = this.component.bounds.height;
            var style = {
                fill:'none',
                stroke:cfg.borderColor,
                'stroke-width':cfg.borderWidth
            };

            lineG.push(paper.path('M' + seriesWidth + ',0' + 'L' + endX + ',0' + 'L' + endX + ' ' + endY + 'L0' + ',' + endY + 'L0' + ',' + categoryHeight));

            var cateCount = this.component.categoryNames.length;

            var startX = seriesWidth;

            for(var i = 0; i < cateCount; i++){
                lineG.push(paper.path(this._getLinePath([startX,0], [startX, endY])));
                startX += unitLength;
            }

            var seriesCount = this.component.seriesNames.length;
            var height = categoryHeight;

            for(var i = 0; i < seriesCount; i++){
                lineG.push(paper.path(this._getLinePath([0,height], [endX, height])));

                height += this.component.getSeriesHeight(i);
            }

            lineG.attr(style);
        },

        _drawValues:function(paper, seriesWidth, categoryHeight, unitLength){

            var valueG = paper.set();
            this.componentSet.push(valueG);

            var values = this.component.values;

            var valueStyle = this.component._valueStyle();
            var valueLineHeight = BaseUtils.getTextHeight(valueStyle);
            var textPadding = this.component.getTextPadding();
            var startX = seriesWidth;
            var startY = categoryHeight;

            for(var lineIndex = 0; lineIndex < values.length; lineIndex++){
                var singleLine = values[lineIndex];

                var valueHeight = this.component.getSeriesHeight(lineIndex);

                for(var valueIndex = 0; valueIndex < singleLine.length; valueIndex++){

                    var singleName = singleLine[valueIndex];

                    if (!singleName) {
                        continue;
                    }

                    var firstY = startY + this._getStartY(singleName, valueStyle, valueHeight) + valueLineHeight * 0.5;

                    for(var i = 0; i < singleName.length; i++){


                        valueG.push(

                            paper.text(startX + unitLength/2 + unitLength * valueIndex,
                                firstY + (valueLineHeight + textPadding) * i,
                                singleName[i])

                        );
                    }
                }

                startY += valueHeight;
            }

            valueStyle = BaseUtils.cssNormalization(valueStyle);
            valueStyle['text-anchor'] = 'middle';

            valueG.attr(valueStyle);
        },

        _drawCategory:function(paper, seriesWidth, categoryHeight, unitLength){

            var categoryG = paper.set();
            this.componentSet.push(categoryG);

            var categoryNames = this.component.categoryNames;

            var startX = seriesWidth;

            var categoryStyle = this.component._categoryStyle();

            var categoryLineHeight = BaseUtils.getTextHeight(categoryStyle);
            var textPadding = this.component.getTextPadding();

            for(var index = 0, cCount = categoryNames.length; index < cCount; index++){

                var singleName = categoryNames[index];

                var startY = this._getStartY(singleName, categoryStyle, categoryHeight) + categoryLineHeight * 0.5;

                for(var i = 0; i < singleName.length; i++){

                    categoryG.push(
                        paper.text(startX + unitLength/2 + unitLength * index, startY + (categoryLineHeight + textPadding) * i, singleName[i])
                    );

                }

            }

            categoryStyle = BaseUtils.cssNormalization(categoryStyle);
            categoryStyle['text-anchor'] = 'middle';

            categoryG.attr(categoryStyle);
        },

        _drawSeries:function(paper, seriesWidth, categoryHeight, transX, transY){

            var seriesG = paper.set();
            var itemG = paper.set();
            this.componentSet.push(seriesG);
            this.componentSet.push(itemG);

            var seriesNames = this.component.seriesNames;

            var startX = 16 + (seriesWidth - 16) / 2;
            var startY = categoryHeight;

            var seriesStyle = this.component._seriesStyle();
            var seriesLineHeight = BaseUtils.getTextHeight(seriesStyle);
            var textPadding = this.component.getTextPadding();

            for(var index = 0, sCount = seriesNames.length; index < sCount; index++){

                var singleName = seriesNames[index];
                var seriesHeight = this.component.getSeriesHeight(index);

                var firstY = startY + this._getStartY(singleName, seriesStyle, seriesHeight) + seriesLineHeight * 0.5;

                for(var i = 0; i < singleName.length; i++){

                    seriesG.push(
                        paper.text(startX, firstY + (seriesLineHeight + textPadding) * i, singleName[i])
                    );

                }

                var iconType = this.component.getLegendIconTypeWithSeriesIndex(index);
                var iconHeight = LegendIconFactory.getLegendIconSize(iconType).height;

                var tmpX = 2 + transX;
                var tmpY = (seriesHeight - iconHeight)/2 + startY + transY;

                if(LegendIconFactory.hasIcon(iconType)){
                    this.iconSet.push(
                        paper.path(LegendIconFactory.getLegendIconPath(iconType))
                            .attr({
                                'fill' : this.component._getDefaultSeriesColor(singleName[0]),
                                'stroke' : 'none'
                            })
                            .transform('t' + tmpX +',' + tmpY )

                    );
                }else{
                    this.iconSet.push(
                        paper.image(iconType,0,0,12,12).transform('t' + tmpX +',' + tmpY)
                    );
                }

                startY += seriesHeight;
            }


            seriesStyle = BaseUtils.cssNormalization(seriesStyle);
            seriesStyle['text-anchor'] = 'middle';
            seriesG.attr(seriesStyle);
        },

        _getStartY:function(textArray, style, boxHeight){

            var textPadding = this.component.getTextPadding();

            var textCount = textArray.length;

            var textHeight = BaseUtils.getTextHeight(style) * textCount + (textCount - 1) * textPadding;

            return (boxHeight - textHeight) / 2;
        },

        remove:function(){
            this.componentSet && this.componentSet.remove();
            this.iconSet && this.iconSet.remove();
        }

    });

    require('./RenderLibrary').register(Constants.DATA_SHEET_VML, DataSheetVmlRender);
});
/**
 * Created by eason on 15/8/24.
 */

define('render/ToolbarVmlRender',['require','./BaseRender','../Constants','./RenderLibrary'],function(require){

    var BaseRender = require('./BaseRender');
    var Constants = require('../Constants');

    var ToolbarVmlRender = BaseRender.extend({
        render:function(){
            var cfg = this.component.componentOption;

            if(!cfg.enabled){
                return;
            }

            //todo 下次再改吧
            if(this.component.refreshIcon.iconRender.itemSet){

                this.toFront();

            }else{

                var paper = this.component.getVanchartRender().getRenderRoot();

                if(this.component.menuIcon){
                    this.component.menuIcon.render(paper);
                }

                this.component.refreshIcon.render(paper);

                var toolbarIcons = this.component.getToolbarIcons();

                for(var i = 0, len = toolbarIcons.length; i < len; i++){
                    toolbarIcons[i].render(paper);
                }
            }
        },

        hide:function(){
            var toolbarIcons = this.component.getToolbarIcons();
            var iconSize = toolbarIcons.length;

            for(var i = 0; i < iconSize; i++){
                toolbarIcons[i].hideIcon();
            }

            var refreshIcon = this.component.getRefreshIcon();

            var left = 4 * (iconSize + 1) ;
            var right = 4 * (iconSize + 1) + 33 * iconSize;

            if(refreshIcon.visible){
                refreshIcon.refreshMove(left, right);
            }
        },

        show:function(){
            var toolbarIcons = this.component.getToolbarIcons();
            var iconSize = toolbarIcons.length;

            for(var i = 0; i < iconSize; i++){
                toolbarIcons[i].showIcon();
            }

            var refreshIcon = this.component.getRefreshIcon();

            var left = 4 * (iconSize + 1) + 33 * iconSize;
            var right = 4 * (iconSize + 1);

            if(refreshIcon.visible){
                refreshIcon.refreshMove(left, right);
            }
        },

        toFront:function(iconRender){
            if(iconRender){
                iconRender.itemSet.toFront();
            } else {
                if(this.component.menuIcon){
                    this.toFront(this.component.menuIcon.iconRender)
                }

                this.toFront(this.component.refreshIcon.iconRender);

                var toolbarIcons = this.component.getToolbarIcons();

                for(var i = 0, len = toolbarIcons.length; i < len; i++){
                    this.toFront(toolbarIcons[i].iconRender);
                }
            }
        }
    });

    require('./RenderLibrary').register(Constants.TOOLBAR_VML, ToolbarVmlRender);
    return ToolbarVmlRender;
});
/**
 * Created by eason on 15/8/14.
 */

define('render/LegendVmlRender',['require','./BaseRender','../utils/BaseUtils','../Constants','./LegendIconFactory','./RenderLibrary'],function(require){

    var BaseRender = require('./BaseRender');
    var BaseUtils = require('../utils/BaseUtils');
    var Constants = require('../Constants');
    var LegendIconFactory = require('./LegendIconFactory');

    var ENABLED_COLOR = 'rgb(67,67,72)';
    var DISABLED_COLOR = 'rgb(204,204,204)';

    var LegendVmlRender = BaseRender.extend({
        render:function(){

            if(!this.component.componentOption.visible){
                this.remove();
                return;
            }

            if(!this.component.componentOption.initState){
                this.refreshRestore();
                this.component.componentOption.initState = true;
            }else{
                this.background.forEach(function(element){
                    BaseUtils.toFront(element.node);
                });

                this.pageButton.forEach(function(element){
                    BaseUtils.toFront(element.node);
                });

                this.rectSet.forEach(function(element){
                    BaseUtils.toFront(element.node);
                });

                this.markerSet.forEach(function(element){
                    BaseUtils.toFront(element.node);
                });

                this.labelSet.forEach(function(element){
                    BaseUtils.toFront(element.node);
                });
            }

        },

        _render:function(){

            var option = this.component.componentOption;
            var bounds = this.component.bounds;
            var paper = this.component.getVanchartRender().getRenderRoot();

            this._renderVmlBackground(this.background, paper, option, bounds);

            this.component.isHorizontal() ? this._renderHorizontal(paper) : this._renderVertical(paper);
        },

        _renderWithPages:function(paper){

            var pages = this.component.getVerticalPages();

            this._renderWithoutPages(paper, pages[0], 0);

            var x = this.component.bounds.x;
            var y = this.component.bounds.y;

            var width = this.component.bounds.width;
            var height = this.component.bounds.height;
            height -= this.component.getButtonHeight();

            var buttonWidth = 40;
            var leftButtonTopX = x + (width - buttonWidth) / 2;
            var rightButtonTopX = x + (width + buttonWidth) / 2;
            var topY = y + height + this.component.getPadding();
            var labelX = x + width/2;

            var pageCount = pages.length;


            var label = paper.text(labelX, topY, '1/' + pageCount)
                .attr({
                    "textAnchor":"middle",
                    'font-family': 'Verdana',
                    'font-size': '14'
                });

            var pageIndex = 0;

            var self = this;

            var leftButton = paper.path(this._prePageButtonPath(leftButtonTopX, topY))
                .attr({
                    cursor:'pointer',
                    fill:DISABLED_COLOR,
                    stroke:'none'
                })
                .click(function(){
                    if(pageIndex <= 0){
                        return;
                    }

                    pageIndex--;
                    var showIndex = pageIndex + 1;
                    label.attr('text', showIndex + "/" + pageCount);

                    self._clearAllLegendItems();
                    self._renderWithoutPages(paper, pages[pageIndex], self._preItemCount(pageIndex));

                    rightButton.attr('fill', pageIndex == pageCount - 1 ? DISABLED_COLOR : ENABLED_COLOR)
                    leftButton.attr('fill', pageIndex <= 0 ? DISABLED_COLOR : ENABLED_COLOR);

                });

            var rightButton = paper.path(this._nextPageButtonPath(rightButtonTopX, topY))
                .attr({
                    cursor:'pointer',
                    fill:ENABLED_COLOR,
                    stroke:'none'
                })
                .click(function(){
                    if(pageIndex == pageCount - 1){
                        return;
                    }

                    pageIndex++;
                    var showIndex = pageIndex + 1;
                    label.attr('text', showIndex + "/" + pageCount);

                    self._clearAllLegendItems();
                    self._renderWithoutPages(paper, pages[pageIndex], self._preItemCount(pageIndex));

                    rightButton.attr('fill', pageIndex == pageCount - 1 ? DISABLED_COLOR : ENABLED_COLOR);
                    leftButton.attr('fill', pageIndex <= 0 ? DISABLED_COLOR : ENABLED_COLOR)
                })

            this.pageButton.push(label);
            this.pageButton.push(leftButton);
            this.pageButton.push(rightButton);
        },

        _preItemCount:function(pageIndex){

            var pages = this.component.getVerticalPages();

            var count = 0;
            for(var i = 0; i < pageIndex; i++){
                count += pages[i].length;
            }

            return count;
        },

        _prePageButtonPath:function(topX, topY){
            var edge = 12;

            var leftBottomX = topX - edge / 2;
            var leftBottomY = (edge / 2) * Math.sqrt(3) + topY;

            var rightBottomX = topX + edge / 2;
            var rightBottomY = leftBottomY;

            return 'M' + topX + ',' + topY + 'L' + leftBottomX + ',' + leftBottomY + 'L' + rightBottomX + ',' + rightBottomY + 'Z';
        },

        _nextPageButtonPath:function(topX, topY){
            var edge = 12;

            var topLeftX = topX - edge/2;
            var topLeftY = topY;

            var topRightX = topX + edge/2;
            var topRightY = topY;

            var bottomX = topX;
            var bottomY = (edge / 2) * Math.sqrt(3) + topY;

            return 'M' + topLeftX + ',' + topLeftY + 'L' + topRightX + ',' + topRightY + 'L' + bottomX + ',' + bottomY + 'Z';
        },

        _renderWithoutPages:function(paper, items, startIndex){

            items = items || this.component.getLegendItems();
            startIndex = startIndex || 0;

            var cfg = this.component.componentOption;

            var PADDING = this.component.getPadding() + this.component.verticalAlign;
            var GAP = this.component.getGap();

            var x = this.component.bounds.x;
            var y = this.component.bounds.y;
            var boundsWidth = this.component.bounds.width;

            var textStyle = BaseUtils.cssNormalization(cfg.style);

            for(var i = 0, len = items.length; i < len; i++){
                var d = items[i];

                var iconSize = LegendIconFactory.getLegendIconSize(d.legendIconType);
                var labelDim = BaseUtils.getTextDimension(d.itemName, cfg.style, true);
                var detY = Math.max(iconSize.height, labelDim.height)/2;

                var dataIndex = startIndex + i;
                var preHeight = this.component.getPreHeight(startIndex, dataIndex);
                var itemHeight = this.component.getVerticalItemHeight(dataIndex);

                var iconX = x + PADDING;
                var iconY = y + preHeight;

                var rect = paper.rect(x, iconY + detY - iconSize.height/2, boundsWidth, itemHeight)
                    .attr({
                        fill:'white',
                        'fill-opacity':0,
                        stroke:'none'
                    });

                var markerColor = d.visible ? d.color : d.hiddenColor;

                var textColor = d.visible ? cfg.style.color : d.hiddenColor;

                var marker;
                if(LegendIconFactory.hasIcon(d.legendIconType)){
                    marker = paper.path(LegendIconFactory.getLegendIconPath(d.legendIconType))
                        .attr('fill', markerColor)
                        .attr('stroke-width', 0)
                        .transform('t' + iconX + ',' + (iconY + detY - iconSize.height/2));
                }else{
                    marker = paper.image(d.legendIconType,iconX,(iconY + detY - iconSize.height/2), 12, 12);
                }

                var label = paper.text(iconX + iconSize.width + GAP, iconY + detY, d.itemName)
                    .attr('text-anchor', 'start')
                    .attr(textStyle)
                    .attr('fill', textColor);


                this._bindDataAndMarkerEvent(rect, d, i);
                this._bindDataAndMarkerEvent(marker, d, i);
                this._bindDataAndLabelEvent(label, d, i);

                this.rectSet.push(rect);
                this.markerSet.push(marker);
                this.labelSet.push(label);
            }
        },

        _clearAllLegendItems:function(){

            this.markerSet.forEach(function(element){
                element.remove();
            });

            this.labelSet.forEach(function(element){
                element.remove();
            });

            this.rectSet.forEach(function(element){
                element.remove();
            });

            this.markerSet = [];
            this.labelSet = [];
            this.rectSet = [];
        },

        _renderVertical:function(paper){
            this.component.hasEnoughVerticalSpace() ? this._renderWithoutPages(paper) : this._renderWithPages(paper);
        },

        _renderHorizontal:function(paper){

            var PADDING = this.component.getPadding();
            var HORIZONTAL_GAP = this.component.getHorizontalGap();
            var GAP = this.component.getGap();

            var lineItems = this.component.getHorizontalLineItems();

            var cfg = this.component.componentOption;
            var textStyle = BaseUtils.cssNormalization(cfg.style);

            var lineHeight = this.component.getLineHeight();

            var boundsWidth = this.component.bounds.width;

            var boundsX = this.component.bounds.x;
            var boundsY = this.component.bounds.y;

            var y = boundsY + PADDING;

            var itemIndex = 0;

            for(var lineIndex = 0, len = lineItems.length; lineIndex < len; lineIndex++){

                var items = lineItems[lineIndex];

                var itemsWidth = this.component.getHorizontalItemsWidth(items);

                var x = boundsX + (boundsWidth - itemsWidth) / 2;

                var startX = [x];

                for(var i = 1, count = items.length; i < count; i++){
                    var preItem = items[i - 1];
                    var iconSize = LegendIconFactory.getLegendIconSize(preItem.legendIconType);
                    var labelDim = BaseUtils.getTextDimension(preItem.itemName, cfg.style, true);
                    x += iconSize.width + GAP + labelDim.width + HORIZONTAL_GAP;
                    startX.push(x);
                }

                for(var i = 0, count = items.length; i < count; i++){

                    var d = items[i];
                    var iconSize = LegendIconFactory.getLegendIconSize(d.legendIconType);
                    var labelDim = BaseUtils.getTextDimension(d.itemName, cfg.style, true);
                    var detY = Math.max(iconSize.height, labelDim.height)/2;

                    var itemWidth = this.component.getHorizontalItemWidth(i);
                    var itemHeight = lineHeight[lineIndex] + PADDING;

                    var rect = paper.rect(startX[i], (y + detY - iconSize.height/2), itemWidth, itemHeight)
                        .attr({
                            fill:'white',
                            'fill-opacity':0,
                            stroke:'none'
                        });

                    var markerColor = d.visible ? d.color : d.hiddenColor;

                    var textColor = d.visible ? cfg.style.color : d.hiddenColor;

                    var marker;
                    if(LegendIconFactory.hasIcon(d.legendIconType)){
                        marker = paper.path(LegendIconFactory.getLegendIconPath(d.legendIconType))
                            .attr('fill', markerColor)
                            .attr('stroke-width', 0)
                            .transform('t' + startX[i] + ',' + (y + detY - iconSize.height/2));
                    }else{
                        marker = paper.image(d.legendIconType,startX[i],(y + detY - iconSize.height/2), 12, 12);
                    }

                    var label = paper.text(startX[i] + iconSize.width + GAP, (y + detY), d.itemName)
                        .attr('text-anchor', 'start')
                        .attr(textStyle)
                        .attr('fill', textColor);;

                    this._bindDataAndMarkerEvent(rect, d, itemIndex);
                    this._bindDataAndMarkerEvent(marker, d, itemIndex);
                    this._bindDataAndLabelEvent(label, d, itemIndex);

                    itemIndex++;

                    this.rectSet.push(rect);
                    this.markerSet.push(marker);
                    this.labelSet.push(label);

                }

                y += lineHeight[lineIndex] + PADDING;
            }
        },

        _clickHandler:function(d, index){

            var vanchart = this.component.vanchart;
            var cfg = this.component.componentOption;

            var series = d.series;
            var name = d.itemName;

            vanchart.series.map(function(sery){

                if(sery.type == Constants.PIE_CHART || sery.type === Constants.MULTIPIE_CHART){

                    var key = sery.type == Constants.PIE_CHART ? 'seriesName': 'name';
                    sery.points.map(function(point){
                        if(point[key] == name){
                            point.visible = !point.visible;
                        }
                    });

                    sery.updateVisiblePoints();

                } else {
                    if (sery.name === name) {
                        sery.visible = !sery.visible;
                    }
                }
            });

            vanchart.currentOption.byClassName = true;
            vanchart.refreshComponentsAndSeries();

            d.visible = !d.visible;

            var markerColor = d.visible ? d.color : d.hiddenColor;
            if(LegendIconFactory.hasIcon(d.legendIconType)){
                this.markerSet[index].attr('fill', markerColor);
            }

            var textColor = d.visible ? cfg.style.color : d.hiddenColor;
            this.labelSet[index].attr('fill', textColor);
        },

        _bindDataAndMarkerEvent:function(element, data, index){

            element.data('data', data);
            element.attr('cursor', 'pointer');

            var self = this;
            element.click(function(){
                self._clickHandler(data, index);
            });

        },

        _bindDataAndLabelEvent:function(element, data, index){
            var cfg = this.component.componentOption;

            element.data('data', data);
            element.attr('cursor', 'pointer');

            element.mousemove(function(){
                this.attr('fill', data.hoverColor);
            });

            element.mouseout(function(){
                var textColor = data.visible ? cfg.style.color : data.hiddenColor;
                this.attr('fill', textColor);
            });

            var self = this;
            element.click(function(){
                self._clickHandler(data, index);
            });

        },

        refreshRestore:function(){
            this.remove();
            this.background = [];
            this.pageButton = [];

            this._render();
        },

        remove:function(){
            this._clearAllLegendItems();

            this.background.forEach(function(element){
                element.remove();
            });

            this.pageButton.forEach(function(element){
                element.remove();
            });
        }
    });

    LegendVmlRender.addInitHook(function(){
        this.markerSet = [];
        this.labelSet = [];
        this.rectSet = [];
        this.pageButton = [];
        this.background = [];
    });

    require('./RenderLibrary').register(Constants.LEGEND_VML, LegendVmlRender);

    return LegendVmlRender;
});
/**
 * Created by Yuqian on 16/5/10.
 */

define('render/AngleAxisVmlRender',['require','./BaseRender','../utils/BaseUtils','../utils/BezierEasing','../Constants','../utils/ColorUtils','./RenderLibrary'],function(require){

    var BaseRender = require('./BaseRender');
    var BaseUtils = require('../utils/BaseUtils');
    var BezierEasing = require('../utils/BezierEasing');
    var Constants = require('../Constants');
    var ColorUtils = require('../utils/ColorUtils');

    var AngleAxisVmlRender = BaseRender.extend({
        render: function () {

            this._removeAll();

            var paper = this.component.polar.getVanchartRender().getRenderRoot();

            var center = this.component.polar.center;

            this._axisSet = paper.set();

            this.markerMap = {};

            this._drawAxisLine(paper, center);

            this._drawGridLine(paper, center);

            this._drawTickLabel(paper, center);

        },

        _removeAll:function(){

            if(this._axisSet){
                this._axisSet.remove();
            }

            this.labelDivManager.clearAllLabels();
        },

        _drawAxisLine:function(paper, center){
            var radiusAxis = this.component.polar.radiusAxis;

            var angleAxis = this.component;
            var lineWidth = angleAxis.componentOption.lineWidth;
            var lineColor = angleAxis.componentOption.lineColor;
            var maxValue = radiusAxis.scale.domain()[1];

            this._axisSet.push(
                paper.path(radiusAxis._getRadiusGridPath(maxValue))
                    .attr({
                        'fill':'none',
                        'stroke':lineColor,
                        'stroke-width':lineWidth
                    })
                    .transform(BaseUtils.makeTranslate(center))
            );

        },

        _drawGridLine:function(paper, center){

            var cfg = this.component.polar.radiusAxis.componentOption;
            var lineWidth = cfg.lineWidth;
            var lineColor = cfg.lineColor;

            var axisLineData = this.component.getAngleGridLineData();

            var self = this;
            axisLineData.forEach(function (d) {

                self._axisSet.push(
                    paper.path(self._getLinePath([0, 0], d))
                        .attr({
                            'fill': 'none',
                            'stroke': lineColor,
                            'stroke-width': lineWidth
                        })
                        .transform(BaseUtils.makeTranslate(center))
                );

            });

        },

        _drawTickLabel:function(paper, radarCenter){
            var angleAxis = this.component;
            var cfg = angleAxis.componentOption;

            var labelStyle = cfg.labelStyle;
            var labelRotation = cfg.labelRotation || 0;
            var useHtml = cfg.useHtml;

            var ticks = angleAxis.tickData;
            var lineHeight = BaseUtils.getTextHeight(labelStyle);

            if(useHtml && !labelRotation){

                var center = angleAxis.polar.center;

                for(var i = 0, len = ticks.length; i < len; i++){

                    var tick = ticks[i];

                    var x = tick.tickPos.x + center[0];
                    var y = tick.tickPos.y + center[1];

                    this.labelDivManager.addLabel(tick.tickContent, {x:x, y:y}, labelStyle);
                }

            }else{

                if (cfg.showLabel) {
                    for (var i = 0, count = ticks.length; i < count; i++) {

                        var tick = ticks[i];
                        var tickContent = tick.tickContent;

                        if (BaseUtils.isArray(tickContent)) {

                            var startX = radarCenter[0] + tick.tickPos.x;
                            var startY = radarCenter[1] + tick.tickPos.y + lineHeight / 2;

                            var dx = tick.tickPos.x < 0 ? tick.tickDim.width : 0;
                            var textAnchor = tick.tickPos.x < 0 ? 'end' : 'start';
                            var x = dx + startX;

                            for (var j = 0, len = tickContent.length; j < len; j++) {

                                var y = startY + j * (1.3 * lineHeight);
                                var t_content = tickContent[j];

                                this._axisSet.push(
                                    paper.text(x, y, t_content)
                                        .attr(BaseUtils.cssNormalization(labelStyle))
                                        .attr('text-anchor', textAnchor)
                                        .transform('t' + labelRotation)
                                );
                            }

                        } else {

                            var rx = radarCenter[0] + tick.tickPos.x + tick.tickDim.width / 2;

                            var ry = radarCenter[1] + tick.tickPos.y + tick.tickDim.height / 2;

                            this._axisSet.push(
                                paper.text(rx, ry, tickContent)
                                    .attr(BaseUtils.cssNormalization(labelStyle))
                                    .transform('r' + labelRotation)
                            );
                        }
                    }
                }
            }
        },

        removeHighlightBand:function(){

            var paper = this.component.getVanchartRender().getRenderRoot();
            var band = paper.getById(this.highlightBandID);
            band && band.remove();

        },

        drawHighlightBand:function(pos){
            var axis = this.component;
            if (!axis._getBandByPosition) {
                return;
            }

            var paper = this.component.getVanchartRender().getRenderRoot();

            var center = this.component.polar.center;

            var drawBand = axis._getBandByPosition(pos);
            var highlightType = axis.getHighlightType();

            this.removeHighlightBand();

            switch (highlightType) {
                case 'band':
                    var highlightBand =
                        paper.path(drawBand.d)
                            .attr({
                                'stroke':'none',
                                'fill': 'rgb(98,179,240)',
                                'fill-opacity': 0.2
                            })
                            .transform(BaseUtils.makeTranslate(center));

                    this.highlightBandID = highlightBand.id;

                    highlightBand.insertBefore(this._axisSet[0]);

                    break;
                case 'line':
                default:
                    var highlightBand =
                        paper.path(this._getLinePath([0, 0], [drawBand.x, drawBand.y]))
                            .attr({
                                'stroke': 'rgb(140,140,140)',
                                'stroke-width': 1
                            })
                            .transform(BaseUtils.makeTranslate(center));

                    this.highlightBandID = highlightBand.id;

                    highlightBand.insertBefore(this._axisSet[0]);
            }
        },

        remove:function(){
            this._removeAll();
        }
    });

    require('./RenderLibrary').register(Constants.ANGLE_AXIS_VML, AngleAxisVmlRender);
});
/**
 * Created by Yuqian on 16/5/10.
 */

define('render/RadiusAxisVmlRender',['require','./BaseRender','../utils/BaseUtils','../utils/BezierEasing','../Constants','../utils/ColorUtils','./RenderLibrary'],function(require){

    var BaseRender = require('./BaseRender');
    var BaseUtils = require('../utils/BaseUtils');
    var BezierEasing = require('../utils/BezierEasing');
    var Constants = require('../Constants');
    var ColorUtils = require('../utils/ColorUtils');

    var VALUE_TICK_GAP = 2;

    var RadiusAxisVmlRender = BaseRender.extend({
        render: function () {

            this._removeAll();

            var paper = this.component.polar.getVanchartRender().getRenderRoot();

            var center = this.component.polar.center;

            this._axisSet = paper.set();

            this.markerMap = {};

            // this._drawAxisLine(paper, center);

            this._drawGridLine(paper, center);

            this._drawPlotBands(paper, center);

            this._drawPlotLines(paper, center);

            this._drawTickLabel(paper, center);

        },

        _removeAll:function(){

            if(this._axisSet){
                this._axisSet.remove();
            }

            this.labelDivManager.clearAllLabels();
        },

        _drawAxisLine: function (paper, center) {
            var cfg = this.component.componentOption;
            var lineWidth = cfg.lineWidth;
            var lineColor = cfg.lineColor;

            var axisLineData = this.component.getPolarInitPoint();
            this._axisSet.push(
                paper.path(this._getLinePath([0, 0], axisLineData))
                    .attr({
                        'fill': 'none',
                        'stroke': lineColor,
                        'stroke-width': lineWidth
                    })
                    .transform(BaseUtils.makeTranslate(center))
            );

        },

        _drawGridLine: function (paper, center) {

            var radiusAxis = this.component;
            var cfg = radiusAxis.componentOption;
            var ticks = radiusAxis.getTickData();
            var gridLineColor = cfg.gridLineColor;
            var gridLineWidth = cfg.gridLineWidth;

            var self = this;

            ticks.forEach(function(d){

                self._axisSet.push(

                    paper.path(self.component._getRadiusGridPath(d.tickValue))
                        .attr({
                            'fill':'none',
                            'stroke':gridLineColor,
                            'stroke-width':gridLineWidth
                        })
                        .transform(BaseUtils.makeTranslate(center))
                );

            });

        },

        _drawPlotBands: function (paper, center) {

            var plotBands = this.component.getRadiusPlotBands();

            var self = this;
            plotBands.forEach(function(band){
                self._axisSet.push(
                    paper.path(band.path)
                        .attr({
                            'fill': band.color,
                            'stroke': 'none'
                        })
                        .transform(BaseUtils.makeTranslate(center))
                )
            });

        },

        _drawPlotLines:function(paper, center){

            var plotLines = this.component.getPlotLines();
            var self = this;

            plotLines.forEach(function(d){

                self._axisSet.push(

                    paper.path(self.component._getRadiusGridPath(d.value))
                        .attr({
                            fill:'none',
                            stroke: d.color,
                            'stroke-width': d.width,
                            'stroke-dasharray': d.dataArray
                        })
                        .transform(BaseUtils.makeTranslate(center))

                );

                if(d.text){
                    var textStyle = BaseUtils.cssNormalization(d.style);
                    paper.text(0, d.baseY, d.text)
                        .attr(textStyle)
                        .attr('text-anchor', d.textAnchor)
                        .transform(BaseUtils.makeTranslate(center));
                }

            });

        },

        _drawTickLabel:function(paper, center){

            var radiusAxis = this.component;
            var scale = radiusAxis.scale;
            var lastScale = radiusAxis.lastScale || radiusAxis.scale;
            var cfg = radiusAxis.componentOption;
            var ticks = radiusAxis.getTickData();

            //最大值标签不显示
            ticks.length = Math.max(ticks.length - 1, 0);

            var labelStyle = cfg.labelStyle;
            var labelRotation = cfg.labelRotation || 0;
            var useHtml = cfg.useHtml;

            if(useHtml && !labelRotation){

                for(var i = 0, len = ticks.length; i < len; i++){

                    var tick = ticks[i];

                    var x = -tick.tickDim.width - VALUE_TICK_GAP + center[0];
                    var y = -scale(tick.tickValue)-tick.tickDim.height + center[1];

                    this.labelDivManager.addLabel(tick.tickContent, {x:x, y:y}, labelStyle);
                }

            }else{

                for(var i = 0, count = ticks.length; i < count; i++){

                    var tick = ticks[i];

                    var normalDim = BaseUtils.getTextDimension(tick.tickContent, labelStyle, useHtml);

                    var x = center[0] - VALUE_TICK_GAP - normalDim.width/2;
                    var y = center[1] - scale(tick.tickValue) - normalDim.height/2;

                    this._axisSet.push(
                        paper.text(x, y, tick.tickContent)
                            .attr(BaseUtils.cssNormalization(labelStyle))
                            .transform('r' + labelRotation)
                    )
                }
            }
        },
        
        remove:function(){
            this._removeAll();
        }
    });
    
    require('./RenderLibrary').register(Constants.RADIUS_AXIS_VML, RadiusAxisVmlRender);
});
/**
 * Created by eason on 15/9/25.
 */

define('render/BaseAxisVmlRender',['require','./BaseRender','../utils/BaseUtils','../utils/BezierEasing','../Constants','../utils/ColorUtils'],function(require){

    var BaseRender = require('./BaseRender');
    var BaseUtils = require('../utils/BaseUtils');
    var BezierEasing = require('../utils/BezierEasing');
    var Constants = require('../Constants');
    var ColorUtils = require('../utils/ColorUtils');

    var BaseAxisVmlRender = BaseRender.extend({
        render:function(){
            
            this.highlightBandID = null;

            this._removeAll();

            var paper = this.component.getVanchartRender().getRenderRoot();

            this._bodySet = paper.set();

            var cfg = this.component.componentOption;

            this._drawAxisLine(paper, cfg);

            this._drawArrow(paper, cfg);

            this._drawAxisTicks(paper, cfg);

            this._drawMinorTickLine(paper, cfg);

            this._drawGridLines(paper, cfg);

            this._drawAxisLabels(paper, cfg);

            this._drawPlotBands(paper);

            this._drawAxisTitle(paper);

            this._drawPlotLines(paper, cfg);
        },

        _removeAll:function(){

            if(this._bodySet){
                this._bodySet.remove();
            }

            this.labelDivManager.clearAllLabels();
        },

        _drawAxisLine:function(paper, cfg){

            var axisOrigon = this.component._getAxisOriginPoint();

            var lineWidth = cfg.lineWidth;
            var lineColor = cfg.lineColor;

            var width = this.component.bounds.width;
            var height = this.component.bounds.height;

            var line;
            if(this.component.isHorizontal()){
                line = paper.path(this._getLinePath([0,0], [width, 0]));
            }else{
                line = paper.path('M0,0' + 'L'+'0,' + height);
            }

            line.attr({
                    'stroke':lineColor,
                    'stroke-width':lineWidth
                })
                .transform(BaseUtils.makeTranslate(axisOrigon));

            this._bodySet.push(line);
        },

        _drawArrow:function(paper, cfg){

            if(!this.component.showArrow()){
                return;
            }

            var plotBounds = this.component.getPlotBounds();
            var cfg = this.component.componentOption;
            var lineWidth = cfg.lineWidth;
            var lineColor = cfg.lineColor;
            var pathDet = BaseUtils.lineSubPixelOpt(0, lineWidth);
            var axisOrigin = this.component._getAxisOriginPoint();

            var line, arrow;

            line = paper.path(this._getLinePath([0, 0],[6, 0]));
            arrow = paper.path("M2,2 L10,6 L2,10 L6,6 L2,2");

            var transformLine, transformArrow, r;
            if (this.component.isHorizontal()) {
                if (this.component.isAxisReversed()) {
                    transformLine = BaseUtils.makeTranslate([axisOrigin.x, axisOrigin.y]);
                    transformArrow = BaseUtils.makeTranslate([axisOrigin.x, axisOrigin.y + 6]);
                    r = 'r180,0,0';
                } else {
                    transformLine = BaseUtils.makeTranslate([axisOrigin.x + plotBounds.width, axisOrigin.y]);
                    transformArrow = BaseUtils.makeTranslate([axisOrigin.x + plotBounds.width, axisOrigin.y - 6]);
                }
            } else {
                if (this.component.isAxisReversed()) {
                    transformLine = BaseUtils.makeTranslate([axisOrigin.x, axisOrigin.y + plotBounds.height]);
                    transformArrow = BaseUtils.makeTranslate([axisOrigin.x+6, axisOrigin.y + plotBounds.height]);
                    r = 'r90,0,0';
                } else {
                    transformLine = BaseUtils.makeTranslate([axisOrigin.x, axisOrigin.y]);
                    transformArrow = BaseUtils.makeTranslate([axisOrigin.x-6, axisOrigin.y]);
                    r = 'r-90,0,0';
                }
            }

            line
                .attr({
                    'fill':'none',
                    'stroke':lineColor,
                    'stroke-width':lineWidth
                })
                .transform(transformLine + r);

            arrow
                .attr({
                    'fill':lineColor,
                    'stroke':'none'
                })
                .transform(transformArrow + r);

            this._bodySet.push(line);
            this._bodySet.push(arrow);

        },

        _drawMinorTickLine:function(paper, cfg){

            var minorTickLength = cfg.enableMinorTick ? cfg.minorTickLength : 0;
            var minorTickWidth = cfg.minorTickWidth;
            var minorTickColor = cfg.minorTickColor;
            var minorTickData = this.component.getMinorTickData();

            var axisOrigin = this.component._getAxisOriginPoint();

            var isCategory = this.component.type == Constants.CATEGORY_AXIS_COMPONENT;
            var scale = this.component.scale;

            var self = this;

            if(minorTickLength){

                minorTickData.forEach(function(d){

                    self._bodySet.push(
                        paper.path(self._getTickPath(isCategory ? d : scale(d), minorTickLength))
                            .attr({
                                'stroke':minorTickColor,
                                'stroke-width':minorTickWidth
                            })
                            .transform(BaseUtils.makeTranslate(axisOrigin))
                    );

                });
            }

        },

        _drawAxisTicks:function(paper, cfg){
            var ticks = this.component.getMainTickData();
            var self = this;
            var axisOrigin = this.component._getAxisOriginPoint();

            //主要刻度线
            if(cfg.enableTick){
                var tickColor = cfg.tickColor;
                var tickWidth = cfg.tickWidth;
                var tickLength = cfg.tickLength;

                ticks.forEach(function(tick){

                    self._bodySet.push(
                        paper.path(self._getTickPath(tick.tickPos, tickLength))
                            .attr({
                                'stroke':tickColor,
                                'stroke-width':tickWidth
                            })
                            .transform(BaseUtils.makeTranslate(axisOrigin))
                    );

                });
            }

        },

        _getTickPath:function(tickPos, tickLength){

            var position = this.component.getPosition();

            switch (position){
                case Constants.TOP:
                    return this._getLinePath([tickPos, 0], [tickPos, -tickLength ]);

                case Constants.BOTTOM:
                    return this._getLinePath([tickPos, 0], [tickPos, tickLength ]);

                case Constants.LEFT:
                    return this._getLinePath([0, tickPos], [-tickLength, tickPos]);

                case Constants.RIGHT:
                    return this._getLinePath([0, tickPos], [tickLength, tickPos]);

            };
        },

        _getGridLinePath:function(tickPos, useLength){

            if(this.component.isHorizontal()){

                return this._getLinePath([tickPos, 0], [tickPos, useLength]);

            }else{

                return this._getLinePath([0, tickPos], [useLength, tickPos]);

            }

        },

        _drawGridLines:function(paper, cfg){

            var gridLineColor = cfg.gridLineColor;
            var gridLineWidth = cfg.gridLineWidth;

            var plotBounds = this.component.getPlotBounds();

            var useLength = this.component.isHorizontal() ? plotBounds.height : plotBounds.width;

            var ticks = this.component.getTickData();

            var self = this;

            ticks.forEach(function(tick){

                self._bodySet.push(
                    paper.path(self._getGridLinePath(tick.tickPos, useLength))
                        .attr({
                            'stroke':gridLineColor,
                            'stroke-width':gridLineWidth
                        })
                        .transform(BaseUtils.makeTranslate(plotBounds))
                );

            });

        },

        _drawAxisLabels:function(paper){

            this.labelDivManager.clearAllLabels();

            var labelDivManager = this.labelDivManager;
            var cfg = this.component.componentOption;

            var origin = this.component._getAxisOriginPoint();

            var transX = origin.x;
            var transY = origin.y;

            var orient = this.component.getPosition();
            var isHorizontal = this.component.isHorizontal();
            var scale = this.component.getTickScale();
            var ticks = this.component.getTickData();

            var tickSpacing = (scale.rangeBand ? 0 : cfg.tickLength) + cfg.tickPadding;

            var labelStyle = cfg.labelStyle;
            var labelHeight = BaseUtils.getTextHeight(labelStyle);

            if (scale.rangeBand) {
                var scale0 = scale.copy();
                var dx = scale0.rangeBand();

                scale = function(d) {
                    return scale0(d) + dx/2;
                };
            }


            var self = this;
            var sign = orient === "top" || orient === "right" ? -1 : 1;

            ticks.forEach(function(tick){

                var x,y;

                var labelDim = BaseUtils.getTextDimension(tick.tickContent, labelStyle, false);
                if(isHorizontal){
                    y = orient == Constants.TOP ? -(tickSpacing + labelHeight) : tickSpacing;
                    x = scale(tick.tickValue) - labelDim.width/2;
                }else{
                    x = orient == Constants.LEFT ? -(tickSpacing + labelDim.width) : tickSpacing;
                    y = scale(tick.tickValue) - labelHeight/2;
                }

                if(cfg.useHtml){
                    labelDivManager.addLabel(tick.tickContent, {x:x + transX, y:y + transY}, labelStyle);
                }else{

                    var labelRotation = cfg.labelRotation || 0;
                    var rx = transX + x + labelDim.width/2;
                    var ry = transY + y + labelHeight/2;

                    if(Math.abs(labelRotation)){

                        var detY = Math.abs(labelDim.height - tick.tickDim.height);

                        var detX = Math.abs(labelDim.width - tick.tickDim.width);

                        if(orient === Constants.TOP || orient === Constants.BOTTOM){
                            ry += sign * detY/2;
                        }else{
                            rx += sign * detX/2;
                        }

                    }

                    var tickLabel = paper
                        .text(rx, ry, tick.tickContent)
                        .attr(BaseUtils.cssNormalization(labelStyle))
                        .transform('r' + labelRotation);

                    self._bodySet.push(tickLabel);
                }

            });

        },

        _drawAxisTitle:function(paper){
            this.component.isHorizontal() ? this._drawHorizontalTitle(paper)
                : this._drawVerticalTitle(paper);
        },

        _drawHorizontalTitle:function(paper){

            var position = this.component.getPosition();

            var titleBounds = this.component.getAxisTitleBounds();
            var transX = titleBounds.x;
            var transY = titleBounds.y + (position == Constants.TOP ? titleBounds.height : 0);

            var cfg = this.component.componentOption;

            if(cfg.title){
                var title = cfg.title;
                if(title.useHtml){
                    this._drawHorizontalAxisTitleWithHtml(title, titleBounds);
                }else{
                    var textStyle = BaseUtils.cssNormalization(title.style);
                    var rotation = title.rotation || 0;

                    var textDim = BaseUtils.getTextDimension(title.text, title.style, title.useHtml);
                    var textBounds = BaseUtils.getTextDimensionWithRotation(title.text, title.style, title.useHtml, rotation);

                    var sign = position == Constants.BOTTOM ? 1 : -1;

                    var rx = transX;
                    var ry = transY + sign * textDim.height / 2;

                    var align = this.component.getTitleAlign();
                    switch(align){
                        case 'left':
                            rx += textDim.width/2;
                            break;
                        case 'center':
                            rx += titleBounds.width/2;
                            break;
                        case 'right':
                            rx += (titleBounds.width - textDim.width/2);
                            break;
                    }

                    var detY = Math.abs(textBounds.height - textDim.height)/2;

                    this._bodySet.push(
                        paper
                            .text(rx, ry + sign * detY, title.text)
                            .attr(textStyle)
                            .transform('r' + rotation)
                    );
                }
            }

        },

        _drawVerticalTitle:function(paper){

            var position = this.component.getPosition();

            var titleBounds = this.component.getAxisTitleBounds();
            var transX = titleBounds.x + (position == Constants.LEFT ? titleBounds.width : 0);
            var transY = titleBounds.y;
            var cfg = this.component.componentOption;

            var sign = position == Constants.LEFT ? 1 : -1;

            if(cfg.title){
                var title = cfg.title;
                if(title.useHtml){
                    this._drawVerticalAxisTitleWithHtml(title, titleBounds);
                }else{
                    var textStyle = BaseUtils.cssNormalization(title.style);
                    var rotation = title.rotation || 0;

                    var textDim = BaseUtils.getTextDimension(title.text, title.style, title.useHtml);
                    var textBounds = BaseUtils.getTextDimensionWithRotation(title.text, title.style, title.useHtml, rotation);

                    var rx = transX - textDim.width/2 * sign;
                    var ry = transY;

                    var align = this.component.getTitleAlign();
                    switch(align){
                        case 'top':
                            ry += textDim.width/2;
                            break;
                        case 'center':
                            ry += titleBounds.height/2;
                            break;
                        case 'bottom':
                            ry += (titleBounds.height - textDim.width/2);
                            break;
                    }

                    var detX = Math.abs(textBounds.width - textDim.width)/2;

                    this._bodySet.push(
                        paper
                            .text(rx + detX * sign, ry, title.text)
                            .attr(textStyle)
                            .transform('r' + rotation)
                    );
                }
            }
        },

        _drawPlotLines:function(paper){
            var plotLines = this.component._preCalculatePlotLines();

            var plotBounds = this.component.getPlotBounds();

            var self = this;

            plotLines.forEach(function(line){
                self._bodySet.push(
                    paper.path(self._getLinePath([line.startPos.x, line.startPos.y], [line.endPos.x, line.endPos.y]))
                        .attr({
                            'stroke': line.color,
                            'stroke-width': line.width,
                            'stroke-dasharray': line.dataArray
                        })
                        .transform(BaseUtils.makeTranslate(plotBounds))
                );

                var text = line.text;
                var style = BaseUtils.cssNormalization(line.style);

                if(text){
                    self._bodySet.push(
                        paper.text(line.textX + line.textDim.width/2, line.textY + line.textDim.height/2, text)
                            .attr(style)
                            .transform(BaseUtils.makeTranslate(plotBounds))
                    );

                }

            })
        },

        _drawPlotBands:function(paper){

            var plotBands = this.component._preCalculatePlotBands();
            var plotBounds = this.component.getPlotBounds();

            var self = this;
            plotBands.forEach(function(bands){
                self._bodySet.push(
                    paper.rect(bands.x, bands.y, bands.width, bands.height)
                        .attr({
                            'stroke':'none',
                            fill:bands.color,
                            'fill-opacity':ColorUtils.getColorOpacity(bands.color)
                        })
                        .transform(BaseUtils.makeTranslate(plotBounds))
                );
            })
        },

        removeHighlightBand:function(){

            var paper = this.component.getVanchartRender().getRenderRoot();
            var band = paper.getById(this.highlightBandID);
            band && band.remove();

        },
        
        drawHighlightBand:function(pos){
            var axis = this.component;
            if (!axis._getBandByPosition) {
                return;
            }

            var paper = this.component.getVanchartRender().getRenderRoot();

            var drawBand = axis._getBandByPosition(pos);
            var highlightType = axis.getHighlightType();

            this.removeHighlightBand();

            switch (highlightType) {
                case 'band':
                    var highlightBand =
                        paper.rect(drawBand.x, drawBand.y, drawBand.width, drawBand.height)
                        .attr({
                            'stroke':'none',
                            'fill': 'rgb(98,179,240)',
                            'fill-opacity': 0.2
                        });

                    this.highlightBandID = highlightBand.id;

                    highlightBand.insertBefore(this._bodySet[0]);

                    break;
                case 'line':
                default:
                    var highlightBand =
                        paper.path(this._getLinePath([drawBand.x, drawBand.y], [drawBand.x + drawBand.width, drawBand.y + drawBand.height]))
                            .attr({
                                'stroke': 'rgb(140,140,140)',
                                'stroke-width': 1
                            });

                    this.highlightBandID = highlightBand.id;

                    highlightBand.insertBefore(this._bodySet[0]);
            }
        },

        remove:function(){
            this._removeAll();
        }
    });

    return BaseAxisVmlRender;
});
/**
 * Created by eason on 15/11/2.
 */

define('render/DateAxisVmlRender',['require','./BaseAxisVmlRender','../Constants','./RenderLibrary'],function(require){

    var BaseAxisRender = require('./BaseAxisVmlRender');
    var Constants = require('../Constants');
    var DateAxisVmlRender = BaseAxisRender.extend({});
    require('./RenderLibrary').register(Constants.DATE_AXIS_VML, DateAxisVmlRender);
});
/**
 * Created by eason on 15/9/25.
 */
define('render/ValueAxisVmlRender',['require','./BaseAxisVmlRender','../Constants','./RenderLibrary'],function(require){

    var BaseAxisRender = require('./BaseAxisVmlRender');
    var Constants = require('../Constants');

    var ValueAxisVmlRender = BaseAxisRender.extend({});

    require('./RenderLibrary').register(Constants.VALUE_AXIS_VML, ValueAxisVmlRender);
});
/**
 * Created by eason on 15/9/25.
 */

define('render/CategoryAxisVmlRender',['require','./BaseAxisVmlRender','../Constants','./RenderLibrary'],function(require){

    var BaseAxisRender = require('./BaseAxisVmlRender');
    
    var Constants = require('../Constants');

    var CategoryAxisVmlRender = BaseAxisRender.extend({});

    require('./RenderLibrary').register(Constants.CATEGORY_AXIS_VML, CategoryAxisVmlRender);
});
/**
 * Created by eason on 15/8/14.
 */
define('render/TitleVmlRender',['require','./BaseRender','../utils/BaseUtils','../Constants','./RenderLibrary'],function(require){

    var BaseRender = require('./BaseRender');
    var BaseUtils = require('../utils/BaseUtils');
    var Constants = require('../Constants');

    var TitleVmlRender = BaseRender.extend({
        render:function(){

            if(this.componentSet){
                if(this.background){
                    this.background.toFront();
                }

                this.componentSet.toFront();
                return;
            }

            var cfg = this.component.componentOption;
            var bounds = this.component.bounds;

            var toolbarWidth = this.component.vanchart.getToolbarWidth();
            toolbarWidth = this.component.isFloat ? 0 : toolbarWidth;

            var paper = this.component.getVanchartRender().getRenderRoot();
            //背景
            if(cfg.backgroundColor){
                this.background = paper.rect(bounds.x, bounds.y, bounds.width, bounds.height)
                    .attr({
                        rx:cfg.borderRadius,
                        ry:cfg.borderRadius,
                        fill:this._getRaphaelFill(cfg.backgroundColor),
                        'stroke-width':0
                    })
                    .attr('fill-opacity', this._getFillOpacity(cfg.backgroundColor));
            }

            this.componentSet = paper.set();

            var textDim = this.component.textDim;
            var padding = this.component.getPadding();
            var textBounds = {
                x: bounds.x + padding,
                y: bounds.y + padding,
                width: textDim.width,
                height: textDim.height
            };

            if (!this.component.isFloat && cfg.align === 'center') {
                textBounds.x = bounds.x + bounds.width / 2 - textDim.width / 2;
            }

            this.textBounds = textBounds;

            if (cfg.useHtml) {
                this._drawTitle(cfg, textBounds);
            } else {
                var result = BaseUtils.splitText(cfg.text, cfg.style, textBounds.width);

                var lineHeight = textDim.height / result.length;

                var textStyle = BaseUtils.cssNormalization(cfg.style);

                var x, textAnchor;
                var align = cfg.align || 'left';
                switch (align) {
                    case 'left':
                        textAnchor = 'start';
                        x = textBounds.x;
                        break;
                    case 'center':
                        textAnchor = 'middle';
                        x = textBounds.x + textDim.width / 2;
                        break;
                    case 'right':
                        textAnchor = 'end';
                        x = textBounds.x + textDim.width;
                        break;
                }

                for (var index = 0, len = result.length; index < len; index++) {

                    var y = textBounds.y + lineHeight * index + lineHeight / 2;

                    this.componentSet.push(
                        paper.text(x, y, result[index])
                            .attr(textStyle)
                            .attr('text-anchor', textAnchor)
                    );
                }
            }

        },

        changeTextRightSpace: function (changes) {

            if (this.component.isFloat) {
                return;
            }

            switch (this.component.componentOption.align) {
                case 'center':
                    var bounds = this.component.bounds;
                    var initTextDim = this.component.textDim;
                    var initTextX = bounds.x + bounds.width / 2 - initTextDim.width / 2;
                    var textBounds = this.textBounds;
                    var padding = this.component.getPadding();
                    var barWidth = this.component.vanchart.getToolbarWidth();
                    var initBarWidth = this.component.initBarWidth;

                    var gap = bounds.width / 2 - initTextDim.width / 2 - initBarWidth - padding;

                    var changesToInit = barWidth - initBarWidth;

                    var x = textBounds.x;
                    var width = textBounds.width;

                    if (gap <= 0 && changesToInit) {
                        x = bounds.x;
                        width = bounds.width - barWidth;
                    } else if (gap < changesToInit) {
                        x = initTextX - (changesToInit - gap);
                    } else {
                        x = initTextX;
                        width = initTextDim.width;
                    }

                    this.labelDivManager.changeLabelDim({
                        left: x - textBounds.x,
                        width: width - textBounds.width
                    });

                    this.translateX(width - textBounds.width + x - textBounds.x);

                    this.textBounds.x = x;
                    this.textBounds.width = width;

                    break;
                default:
                    // adjust width
                    this.labelDivManager.changeLabelDim({
                        width: -changes
                    });

                    this.translateX(-changes);
            }

        },

        translateX:function(width){

            this.labelDivManager.translateLabelsHorizontal(width);

            var gap = 0;

            if(gap > Math.abs(width)){
                return;
            }

            this.componentSet.forEach(function(component){
                var matrix = component.matrix;

                matrix.translate(width, 0);
                component.transform(matrix.toTransformString());
            });
        },

        _removeAll:function(){

            if(this.componentSet){
                this.componentSet.remove();
                this.componentSet = null;
            }

            this.labelDivManager.clearAllLabels();
        },

        remove:function(){
            this._removeAll();
        }
    });

    require('./RenderLibrary').register(Constants.TITLE_VML, TitleVmlRender);
    return TitleVmlRender;
});
/**
 * Created by Mitisky on 16/3/24.
 */
define('render/RangeLegendVmlRender',['require','./BaseRender','../utils/BaseUtils','../Constants','./RenderLibrary'],function (require) {
    var BaseRender = require('./BaseRender');
    var BaseUtils = require('../utils/BaseUtils');
    var Constants = require('../Constants');

    var PADDING = 10;

    var WIDTH = 15;
    var HEIGHT = 100;
    var BAR_WIDTH = 15;
    var BAR_HEIGHT = 10;
    var BAR_TEXT_GAP = 5;
    var ITEM_WIDTH = 25;
    var ITEM_GAP = 2;

    var MIN_BAR_CLASS_NAME = 'min-bar-class-name';
    var MAX_BAR_CLASS_NAME = 'max-bar-class-name';

    var RangeLegendVmlRender = BaseRender.extend({
        render: function () {

            this.remove();

            if(!this.component.componentOption.visible){
                return;
            }

            var option = this.component.componentOption;
            var bounds = this.component.bounds;
            this.isHorizontal = this.component.isHorizontal();
            var paper = this.component.getVanchartRender().getRenderRoot();

            this.background = [];
            this._bodySet = paper.set();

            this._renderVmlBackground(this.background, paper, option, bounds);

            this.component.isIntervalLegend ? this._renderInterval(paper, bounds)
                : this._renderGradient(paper, bounds);
        },

        _renderGradient: function (paper, bounds) {
            this.minPos = 0;
            this.maxPos = HEIGHT;
            var labelStyle = this.component.componentOption.style;
            var startPos = this.isHorizontal ? bounds.x : bounds.y;
            startPos += ((this.isHorizontal ? bounds.width : bounds.height)- HEIGHT)/2;

            this._bodySet.push(
                paper.rect(this.isHorizontal ? startPos : bounds.x + PADDING,
                    this.isHorizontal ? bounds.y + PADDING : startPos,
                    this.isHorizontal ? HEIGHT : WIDTH,
                    this.isHorizontal ? WIDTH : HEIGHT)
                    .attr('class', 'legend-gradient-background')
                    .attr('rx', 2)
                    .attr('ry', 2)
                    .attr('fill', '#eaeaea')
                    .attr('stroke-width', 0)
            );

            var gradientBar = paper.rect(this.isHorizontal ? startPos : bounds.x + PADDING,
                this.isHorizontal ? bounds.y + PADDING : startPos,
                this.isHorizontal ? HEIGHT : WIDTH,
                this.isHorizontal ? WIDTH : HEIGHT)
                .attr('class', 'legend-gradient-bar')
                .attr('rx', 2)
                .attr('ry', 2)
                .attr('fill', this._getGradientFillColor())
                .attr('stroke-width', 0)
                .attr('clip-rect', this._getGradientClipRect(startPos));

            var minBar = paper.path(this.isHorizontal ? this.component.getLeftBarPath() : this.component.getTopBarPath())
                .attr('class', MIN_BAR_CLASS_NAME)
                .attr('fill', this.component.colorScale(this.minPos/HEIGHT))
                .transform('t' + this._getMinBarPosX(this.isHorizontal, bounds, this.minPos, this.maxPos, startPos) +
                    ',' + this._getMinBarPosY(this.isHorizontal, bounds, this.minPos, this.maxPos, startPos))
                .attr('cursor', 'pointer')
                .attr('stroke-width', 0);

            var label = this.component.getGradientLabelContent(this.isHorizontal ? this.minPos : this.maxPos);
            var labelDim = BaseUtils.getTextDimension(label, labelStyle, true);
            var minBarLabel = paper.text(this._getMinLabelCenterX(this.isHorizontal, labelDim, bounds, startPos),
                this._getMinLabelCenterY(this.isHorizontal, labelDim, bounds, startPos)
                , label)
                .attr(BaseUtils.cssNormalization(labelStyle));

            var self = this;
            minBar.mousedown(function (event) {
                self._mindraging = true;
                self._mosX = event.screenX;
                self._mosY = event.screenY;
            });
            minBar.mouseup(function (event) {
                self._mindraging = false;
            });
            minBar.mouseout(function(event) {
                self._mindraging = false;
            });
            minBar.mousemove(function (event) {
                if(self._mindraging){
                    var change = 0;
                    if(self.isHorizontal){
                        var temp = self.minPos;
                        self.minPos += Math.round(event.screenX - self._mosX);
                        self.minPos = Math.max(0, self.minPos);
                        self.minPos = Math.min(self.minPos, self.maxPos);
                        change = self.minPos - temp;
                    } else {
                        var temp = self.maxPos;
                        self.maxPos += Math.round(event.screenY - self._mosY);
                        self.maxPos = Math.min(HEIGHT, self.maxPos);
                        self.maxPos = Math.max(self.maxPos, self.minPos);
                        change = self.maxPos - temp;
                    }

                    self._mosX = event.screenX;
                    self._mosY = event.screenY;

                    if(Math.abs(change) >= 1) {
                        minBar
                            .attr('fill', self.component.colorScale((self.isHorizontal ? self.minPos : HEIGHT - self.maxPos) / HEIGHT))
                            .transform('t' + self._getMinBarPosX(self.isHorizontal, bounds, self.minPos, self.maxPos, startPos) +
                                ',' + self._getMinBarPosY(self.isHorizontal, bounds, self.minPos, self.maxPos, startPos));
                        var label = self.component.getGradientLabelContent(self.isHorizontal ? self.minPos : self.maxPos);
                        var labelDim = BaseUtils.getTextDimension(label, labelStyle, true);
                        minBarLabel
                            .attr('text', label)
                            .attr('x', self._getMinLabelCenterX(self.isHorizontal, labelDim, bounds, startPos))
                            .attr('y', self._getMinLabelCenterY(self.isHorizontal, labelDim, bounds, startPos));
                        gradientBar
                            .attr('clip-rect', self._getGradientClipRect(startPos));
                        self.component.refreshPoints(self.minPos, self.maxPos);
                    }
                }
            });

            var maxBar = paper.path(this.isHorizontal ? this.component.getRightBarPath() : this.component.getBottomBarPath())
                .attr('class', MAX_BAR_CLASS_NAME)
                .attr('fill', this.component.colorScale(this.maxPos/HEIGHT))
                .transform('t' + this._getMaxBarPosX(this.isHorizontal, bounds, this.minPos, this.maxPos, startPos) +
                    ',' + this._getMaxBarPosY(this.isHorizontal, bounds, this.minPos, this.maxPos, startPos))
                .attr('cursor', 'pointer')
                .attr('stroke-width', 0);

            var maxLabel = this.component.getGradientLabelContent(this.isHorizontal ? this.maxPos : this.minPos);
            var maxLabelDim = BaseUtils.getTextDimension(maxLabel, labelStyle, true);
            var maxBarLabel = paper.text(this._getMaxLabelCenterX(this.isHorizontal, maxLabelDim, bounds, startPos),
                this._getMaxLabelCenterY(this.isHorizontal, maxLabelDim, bounds, startPos)
                , maxLabel)
                .attr(BaseUtils.cssNormalization(labelStyle));

            maxBar.mousedown(function () {
                self._maxdraging = true;
                self._mosX = event.screenX;
                self._mosY = event.screenY;
            });
            maxBar.mouseup(function () {
                self._maxdraging = false;
            });
            maxBar.mouseout(function() {
                self._maxdraging = false;
            });

            maxBar.mousemove(function (event) {
                if(self._maxdraging){
                    var change = 0;
                    if(self.isHorizontal){
                        var temp = self.maxPos;
                        self.maxPos += Math.round(event.screenX - self._mosX);
                        self.maxPos = Math.min(HEIGHT, self.maxPos);
                        self.maxPos = Math.max(self.maxPos, self.minPos);
                        change = self.maxPos - temp;
                    } else {
                        var temp = self.minPos;
                        self.minPos += Math.round(event.screenY - self._mosY);
                        self.minPos = Math.max(0, self.minPos);
                        self.minPos = Math.min(self.minPos, self.maxPos);
                        change = self.minPos - temp;
                    }
                    self._mosX = event.screenX;
                    self._mosY = event.screenY;
                    if(Math.abs(change) >= 1) {
                        maxBar
                            .attr('fill', self.component.colorScale((self.isHorizontal ? self.maxPos : HEIGHT - self.minPos) / HEIGHT))
                            .transform('t' + self._getMaxBarPosX(self.isHorizontal, bounds, self.minPos, self.maxPos, startPos) +
                                ',' + self._getMaxBarPosY(self.isHorizontal, bounds, self.minPos, self.maxPos, startPos));
                        var maxLabel = self.component.getGradientLabelContent(self.isHorizontal ? self.maxPos : self.minPos);
                        var maxLabelDim = BaseUtils.getTextDimension(maxLabel, labelStyle, true);
                        maxBarLabel
                            .attr('text', maxLabel)
                            .attr('x', self._getMaxLabelCenterX(self.isHorizontal, maxLabelDim, bounds, startPos))
                            .attr('y', self._getMaxLabelCenterY(self.isHorizontal, maxLabelDim, bounds, startPos));
                        gradientBar
                            .attr('clip-rect', self._getGradientClipRect(startPos));
                        self.component.refreshPoints(self.minPos, self.maxPos);
                    }
                }
            });

            var bodySet = this._bodySet;
            [gradientBar, minBar, minBarLabel, maxBar, maxBarLabel].forEach(function(component){
                bodySet.push(component);
            });
        },

        _getMinBarPosX: function (isHorizontal, bounds, minPos, maxPos, startPos) {
            return isHorizontal ? startPos - BAR_HEIGHT + minPos : bounds.x + PADDING + WIDTH;
        },

        _getMinBarPosY: function (isHorizontal, bounds, minPos, maxPos, startPos) {
            return isHorizontal ? bounds.y + PADDING + WIDTH : startPos + maxPos;
        },

        _getMaxBarPosX: function (isHorizontal, bounds, minPos, maxPos, startPos) {
            return isHorizontal ? startPos + maxPos : bounds.x + PADDING + WIDTH;
        },

        _getMaxBarPosY: function (isHorizontal, bounds, minPos, maxPos, startPos) {
            return isHorizontal ? bounds.y + PADDING + WIDTH : startPos - BAR_HEIGHT + minPos;
        },

        _getMinLabelCenterX: function (isHorizontal, labelDim, bounds, startPos) {
            return isHorizontal ? startPos + this.minPos - BAR_HEIGHT/2 - labelDim.width/2
                : bounds.x + PADDING + WIDTH + BAR_WIDTH + BAR_TEXT_GAP + labelDim.width/2;
        },

        _getMinLabelCenterY: function (isHorizontal, labelDim, bounds, startPos) {
            return isHorizontal ? bounds.y + PADDING + WIDTH + BAR_WIDTH + BAR_TEXT_GAP + labelDim.height/2
                : startPos + this.maxPos + BAR_HEIGHT/2;
        },

        _getMaxLabelCenterX: function (isHorizontal, labelDim, bounds, startPos) {
            return isHorizontal ? startPos + this.maxPos + BAR_HEIGHT/2 + labelDim.width/2
                : bounds.x + PADDING + WIDTH + BAR_WIDTH + BAR_TEXT_GAP + labelDim.width/2;
        },

        _getMaxLabelCenterY: function (isHorizontal, labelDim, bounds, startPos) {
            return isHorizontal ? bounds.y + PADDING + WIDTH + BAR_WIDTH + BAR_TEXT_GAP + labelDim.height/2
                : startPos + this.minPos - BAR_HEIGHT/2;
        },

        _getGradientClipRect: function(startPos) {
            var bounds = this.component.bounds;
            var x = bounds.x + PADDING;
            var y = startPos + this.minPos;
            var width = WIDTH;
            var height = this.maxPos - this.minPos;
            if(this.isHorizontal){
                x = startPos + this.minPos;
                y = bounds.y + PADDING;
                width = this.maxPos - this.minPos;
                height = WIDTH;
            }
            return x + ',' + y + ',' + width + ',' + height;
        },

        _getGradientFillColor: function() {
            var fillColor = this.isHorizontal ? 0 : 90;

            var valueAndColorArray = this.component.getValueAndColors();

            valueAndColorArray.forEach(function(valueAndColor){
                var value = valueAndColor[0];
                var color = valueAndColor[1];
                fillColor += ('-' + color + ':' + value * 100);
            });

            return fillColor;
        },

        _renderInterval: function (paper, bounds) {
            var items =  this.component.items;
            var labelStyle = this.component.componentOption.style;

            this.isHorizontal ? this._renderHorizontalInterval(paper, bounds, items, labelStyle)
                : this._renderVerticalInterval(paper, bounds, items, labelStyle);
        },

        _renderHorizontalInterval: function (paper, bounds, itemS, labelStyle) {
            var len = this.component.items.length;
            var startX = bounds.x + (bounds.width - len * ITEM_WIDTH - (len - 1) * ITEM_GAP)/2;

            for(var i = 0; i < len; i++){
                var item = itemS[i];
                var labelContent = item.label;
                var labelDim = BaseUtils.getTextDimension(labelContent, labelStyle);
                var topLabelY = bounds.y + PADDING;
                var iconY = topLabelY + labelDim.height + BAR_TEXT_GAP;
                var bottomY = iconY + WIDTH + BAR_TEXT_GAP;

                var icon = paper.rect(startX, iconY, ITEM_WIDTH, WIDTH)
                    .attr({
                        fill:item.visible ? item.color : item.hiddenColor,
                        'fill-opacity':1,
                        stroke:'none'
                    });

                var label = paper.text(startX + ITEM_WIDTH/2, i%2 == 0 ? topLabelY + labelDim.height/2 : bottomY + labelDim.height/2, labelContent)
                    .attr('text-anchor', 'middle')
                    .attr(BaseUtils.cssNormalization(labelStyle));

                this._bindMouseEvent(item, icon, label, labelStyle);

                var bodySet = this._bodySet;
                [icon, label].forEach(function(component){
                    bodySet.push(component);
                });

                startX += (ITEM_WIDTH + ITEM_GAP);
            }
        },

        _renderVerticalInterval: function (paper, bounds, itemS, labelStyle) {
            var iconX = bounds.x + PADDING;
            var labelX = bounds.x + PADDING + WIDTH + BAR_TEXT_GAP;
            var startY = bounds.y + (this.component.bounds.height - this.component.items.length * ITEM_WIDTH - (this.component.items.length - 1) * ITEM_GAP)/2;

            for(var i = 0, len = itemS.length; i < len; i++){
                var item = itemS[i];
                var labelContent = item.label;
                var labelDim = BaseUtils.getTextDimension(labelContent, labelStyle);

                var icon = paper.rect(iconX, startY, WIDTH, ITEM_WIDTH)
                    .attr({
                        fill:item.visible ? item.color : item.hiddenColor,
                        'fill-opacity':1,
                        stroke:'none'
                    });

                var label = paper.text(labelX + labelDim.width/2, startY +  ITEM_WIDTH/ 2, labelContent)
                    .attr('text-anchor', 'middle')
                    .attr(BaseUtils.cssNormalization(labelStyle));

                this._bindMouseEvent(item, icon, label, labelStyle);

                var bodySet = this._bodySet;
                [icon, label].forEach(function(component){
                    bodySet.push(component);
                });

                startY += (ITEM_WIDTH + ITEM_GAP);
            }

        },

        _bindMouseEvent:function(item, icon, label, labelStyle) {
            icon.attr('cursor', 'pointer');
            label.attr('cursor', 'pointer');

            label.mousemove(function(){
                label.attr('fill', item.hoverColor);
            });

            label.mouseout(function(){
                var textColor = item.visible ? labelStyle.color : item.hiddenColor;
                label.attr('fill', textColor);
            });

            var self = this;
            icon.click(function(){
                self._clickHandler(item, icon, label, labelStyle.color);
            });

            label.click(function () {
                self._clickHandler(item, icon, label, labelStyle.color);
            })
        },

        _clickHandler: function (item, icon, label, labelColor) {
            item.visible = !item.visible;
            var iconColor = item.visible ? item.color : item.hiddenColor;
            var textColor = item.visible ? labelColor : item.hiddenColor;

            label.attr('fill', textColor);
            icon.attr('fill', iconColor);

            item.points.forEach(function (point) {
                point.visible = item.visible;
            });

            this.component.vanchart.renderOnlyCharts();
        },

        remove:function(){
            if(this.background) {
                this.background.forEach(function (element) {
                    element.remove();
                });
            }

            if(this._bodySet){
                this._bodySet.forEach(function(element){
                    element.remove();
                });
            }

            this.background = null;
            this._bodySet = null;
        }

    });
    
    require('./RenderLibrary').register(Constants.RANGE_LEGEND_VML, RangeLegendVmlRender);

    return RangeLegendVmlRender;
});
/**
 * Created by eason on 15/8/12.
 */
define('render/VanChartVmlRender',['require','./BaseRender','../utils/BaseUtils','../Constants','./RenderLibrary'],function(require){

    var BaseRender = require('./BaseRender');
    var BaseUtils = require('../utils/BaseUtils');
    var Constants = require('../Constants');

    var VanChartVmlRender = BaseRender.extend({
        render:function(){

            var dom = this.component.getParentDom();

            var width = this.component.chartWidth();
            var height = this.component.chartHeight();

            if(!this.paper){
                this.paper = Raphael(dom, width, height);
            }

            var charts = this.component.getChartRenders();

            var fixed = this.component.getFixedComponentRenders();
            var float = this.component.getFloatComponentRenders();

            this._renderBackground();

            fixed.forEach(function(render){
                render.render();
            });

            charts.forEach(function(render){
                render.render();
            });

            float.forEach(function(render){
                render.render();
            });

            this.component.getComponent(Constants.TOOLBAR_COMPONENT) &&
            this.component.getComponent(Constants.TOOLBAR_COMPONENT).render.toFront();

            this._renderTrendLine();
        },

        _renderBackground:function(){

            if(this.backgroundSet){
                this.backgroundSet.remove();
            }

            this.backgroundSet = this.paper.set();

            var chartBounds = BaseUtils.makeBounds(0,0,this.component.chartWidth() - 5, this.component.chartHeight() - 5);
            var chartBackground = this.component.getChartBackgroundOption();
            chartBounds = BaseUtils.rectSubPixelOpt(chartBounds.x, chartBounds.y, chartBounds.width - chartBackground.borderWidth, chartBounds.height - chartBackground.borderWidth, chartBackground.borderWidth);

            var plotBounds = this.component.getPlotBounds();
            var plotBackground = this.component.getPlotBackgroundOption();

            this._renderBackgroundWithBounds(chartBackground, chartBounds);
            this._renderBackgroundWithBounds(plotBackground, plotBounds);
        },

        _renderTrendLine:function(){

            if(this.trendLineSet){
                this.trendLineSet.remove();
            }

            this.trendLineSet = this.paper.set();

            var trendLines = this.component.getTrendLineOption();
            var plotBounds = this.component.getPlotBounds();

            var self = this;

            trendLines.forEach(function(d){

                self.trendLineSet.push(
                    self.paper
                        .path(self._getLinePath([d.x1, d.y1], [d.x2, d.y2]))
                        .attr({
                            'stroke':d.trendLine.color,
                            'stroke-width':d.trendLine.width,
                            'stroke-dasharray': d.trendLine.dashStyle == Constants.DASH_TYPE ? '-' : ''
                        })
                );

            });

            this.trendLineSet.transform('t' + plotBounds.x + ',' + plotBounds.y);
        },

        _renderBackgroundWithBounds:function(option, bounds){

            var dom = this.component.getParentDom();
            if(option.chartShadow){
                dom.style.boxShadow = '1px 1px 2px rgba(0,0,0,0.1)';
            }else if(option.plotShadow){
                var width = [5, 3, 1];
                var opacity = [0.05, 0.1, 0.15];
                var shadowBounds = BaseUtils.rectSubPixelOpt(bounds.x, bounds.y, bounds.width, bounds.height, 1);
                for(var i = 0; i < 3; i++){
                    var rect = this.paper.rect(shadowBounds.x, shadowBounds.y, shadowBounds.width, shadowBounds.height)
                        .attr({
                            fill: 'none',
                            stroke: 'rgb(0,0,0)',
                            'stroke-opacity':opacity[i],
                            'stroke-width': width[i],
                            'rx': option.borderRadius,
                            'ry': option.borderRadius
                        })
                        .transform('t1,1');

                    this.backgroundSet.push(rect);
                }

                var rect = this.paper.rect(shadowBounds.x, shadowBounds.y, shadowBounds.width, shadowBounds.height)
                    .attr({
                        fill: 'white',
                        stroke: 'none',
                        'rx': option.borderRadius,
                        'ry': option.borderRadius
                    });

                this.backgroundSet.push(rect);
            }

            var bw = option.borderWidth;
            bounds = BaseUtils.rectSubPixelOpt(bounds.x + bw/2, bounds.y + bw/2, bounds.width - bw, bounds.height - bw, option.borderWidth);

            var rect = this.paper.rect(bounds.x, bounds.y, bounds.width, bounds.height)
                .attr({
                    fill: this._getRaphaelFill(option.color),
                    stroke: option.borderColor,
                    'stroke-width': option.borderWidth,
                    'rx': option.borderRadius,
                    'ry': option.borderRadius
                })
                .attr('fill-opacity', this._getFillOpacity(option.color));

            this.backgroundSet.push(rect);

            if(option.image){
                var image = this.paper.image(option.image, bounds.x, bounds.y, bounds.width, bounds.height);
                this.backgroundSet.push(image);
            }
        },

        getRenderRoot:function(){
            return this.paper;
        },

        remove:function(){
            this.paper.remove();

            var charts = this.component.getChartRenders();
            var components = this.component.getComponentRenders();

            charts.forEach(function(render){
                render.removeDivLabels();
            });

            components.forEach(function(render){
                render.removeDivLabels();
            });
        }
    });
    
    require('./RenderLibrary').register(Constants.VANCHART_VML, VanChartVmlRender);

    return VanChartVmlRender;
});

/**
 * Created by eason on 16/2/5.
 */

define('IERequire',['require','./chart/Pie','./chart/MultiPie','./chart/Bar','./chart/Line','./chart/Area','./chart/Gauge','./chart/Radar','./chart/Bubble','./chart/Scatter','./chart/Map','./render/RadarVmlRender','./render/GaugeVmlRender','./render/AreaVmlRender','./render/LineVmlRender','./render/BarVmlRender','./render/PieVmlRender','./render/MultiPieVmlRender','./render/BubbleVmlRender','./render/ScatterVmlRender','./render/MapVmlRender','./render/DrillToolsVmlRender','./render/DataSheetVmlRender','./render/ToolbarVmlRender','./render/LegendVmlRender','./render/AngleAxisVmlRender','./render/RadiusAxisVmlRender','./render/DateAxisVmlRender','./render/ValueAxisVmlRender','./render/CategoryAxisVmlRender','./render/TitleVmlRender','./render/RangeLegendVmlRender','./VanCharts','./render/VanChartVmlRender'],function(require){

    require('./chart/Pie');
    require('./chart/MultiPie');
    require('./chart/Bar');
    require('./chart/Line');
    require('./chart/Area');
    require('./chart/Gauge');
    require('./chart/Radar');
    require('./chart/Bubble');
    require('./chart/Scatter');
    require('./chart/Map');

    require('./render/RadarVmlRender');
    require('./render/GaugeVmlRender');
    require('./render/AreaVmlRender');
    require('./render/LineVmlRender');
    require('./render/BarVmlRender');
    require('./render/PieVmlRender');
    require('./render/MultiPieVmlRender');
    require('./render/BubbleVmlRender');
    require('./render/ScatterVmlRender');
    require('./render/MapVmlRender');

    require('./render/DrillToolsVmlRender');
    require('./render/DataSheetVmlRender');
    require('./render/ToolbarVmlRender');
    require('./render/LegendVmlRender');
    require('./render/AngleAxisVmlRender');
    require('./render/RadiusAxisVmlRender');
    require('./render/DateAxisVmlRender');
    require('./render/ValueAxisVmlRender');
    require('./render/CategoryAxisVmlRender');
    require('./render/TitleVmlRender');
    require('./render/RangeLegendVmlRender');

    require('./VanCharts');
    require('./render/VanChartVmlRender');
});
/**
 * Created by eason on 15/12/25.
 */

//The modules for your project will be inlined above
//this snippet. Ask almond to synchronously require the
//module value for 'main' here and return it as the
//value to use for the public API for the built file.
var VanCharts = require('VanCharts');

require('chart/Pie');
require('chart/MultiPie');
require('chart/Bar');
require('chart/Line');
require('chart/Area');
require('chart/Gauge');
require('chart/Radar');
require('chart/Scatter');
require('chart/Bubble');
require('chart/Map');

require('render/VanChartSvgRender');
require('render/VanChartVmlRender');

require('render/TitleSvgRender');
require('render/CategoryAxisSvgRender');
require('render/ValueAxisSvgRender');
require('render/DateAxisSvgRender');
require('render/RadiusAxisSvgRender');
require('render/AngleAxisSvgRender');
require('render/LegendSvgRender');
require('render/ToolbarSvgRender');
require('render/DataSheetSvgRender');
require('render/RangeLegendSvgRender');
require('render/DrillToolsSvgRender');

require('render/PieSvgRender');
require('render/MultiPieSvgRender');
require('render/BarSvgRender');
require('render/LineSvgRender');
require('render/AreaSvgRender');
require('render/GaugeSvgRender');
require('render/RadarSvgRender');
require('render/ScatterSvgRender');
require('render/BubbleSvgRender');
require('render/MapSvgRender');

require('render/RadarVmlRender');
require('render/GaugeVmlRender');
require('render/AreaVmlRender');
require('render/LineVmlRender');
require('render/BarVmlRender');
require('render/PieVmlRender');
require('render/MultiPieVmlRender');
require('render/ScatterVmlRender');
require('render/BubbleVmlRender');
require('render/MapVmlRender');

require('render/DataSheetVmlRender');
require('render/ToolbarVmlRender');
require('render/LegendVmlRender');
require('render/DateAxisVmlRender');
require('render/ValueAxisVmlRender');
require('render/CategoryAxisVmlRender');
require('render/AngleAxisVmlRender');
require('render/RadiusAxisVmlRender');
require('render/TitleVmlRender');
require('render/RangeLegendVmlRender');
require('render/DrillToolsVmlRender');

return VanCharts;
}));
