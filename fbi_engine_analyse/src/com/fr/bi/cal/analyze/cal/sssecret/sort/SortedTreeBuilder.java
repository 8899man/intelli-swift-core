package com.fr.bi.cal.analyze.cal.sssecret.sort;import com.fr.general.ComparatorUtils;import java.util.ArrayList;import java.util.Arrays;import java.util.List;/** * Created by Hiram on 2015/1/18. */public class SortedTreeBuilder {    SortedTree sortedTree = new SortedTree();    InfoNode root = new InfoNode(0, 0, sortedTree.getRoot());    List<InfoArray> sortedNum = new ArrayList<InfoArray>();    private boolean isFirstAdd = true;    private InfoNode getLastInfo(int deep) {        InfoNode ret = root;        for (int i = 0; i < deep; i++) {            ret = ret.getLastInfoNode();        }        return ret;    }    public void add(int deep, int index, Number targetValue) {        ensureCapacity(deep + 1);        getLastInfo(deep).addChild(new InfoNode(index, targetValue, new SortedNode()));    }    private InfoArray getInfoArray(int deep) {        return sortedNum.get(deep);    }    private boolean isLastValueSame(InfoArray infoArray, int index) {        if (infoArray.size() == 0) {            return false;        }        return infoArray.get(infoArray.size() - 1).getIndex() != index;    }    private void refreshLastSortGroup(int deep) {        for (int j = deep; j < sortedNum.size(); j++) {            sortedNum.get(j).clear();        }    }    private void buildSortedNode(int deep) {        for (int i = sortedNum.size() - 1; i >= deep; i--) {            InfoArray infoArray = sortedNum.get(i);            int[] sortedIndex = infoArray.getSortedIndex();            int[] addIndex = infoArray.getSortedAddIndex();            int nodeDeep = i - 1;//构建Node所在的维度            if (nodeDeep < 0) { //为root                sortedTree.getRoot().setSortedIndex(sortedIndex);                sortedTree.getRoot().resetChildren(addIndex);            } else {                SortedNode sortedNode = new SortedNode();                sortedNode.setSortedIndex(sortedIndex);                sortedTree.getLastSortedNode(nodeDeep).addChild(sortedNode);            }        }    }    private void ensureCapacity(int length) {        if (sortedNum.size() < length) {            for (int i = sortedNum.size(); i < length; i++) {                sortedNum.add(new InfoArray());            }        }    }    public SortedTree build() {        sortedTree.setRoot(root.buildSortedNode());        return sortedTree;    }}class InfoArray {    private List<InfoNode> list = new ArrayList<InfoNode>();    public void add(InfoNode infoNode) {        list.add(infoNode);    }    public InfoNode get(int i) {        return list.get(i);    }    public int size() {        return list.size();    }    public int[] getSortedIndex() {        InfoNode[] infoNodes = new InfoNode[list.size()];        list.toArray(infoNodes);        Arrays.sort(infoNodes);        int[] ret = new int[infoNodes.length];        for (int i = 0; i < ret.length; i++) {            ret[i] = infoNodes[i].getIndex();        }        return ret;    }    public SortedNode[] getSortedNodes() {        InfoNode[] infoNodes = new InfoNode[list.size()];        list.toArray(infoNodes);        Arrays.sort(infoNodes);        SortedNode[] ret = new SortedNode[infoNodes.length];        for (int i = 0; i < ret.length; i++) {            ret[i] = infoNodes[i].buildSortedNode();        }        return ret;    }    public int[] getSortedAddIndex() {        InfoNode[] infoNodes = new InfoNode[list.size()];        list.toArray(infoNodes);        Arrays.sort(infoNodes);        int[] ret = new int[infoNodes.length];        for (int i = 0; i < ret.length; i++) {            ret[i] = infoNodes[i].getAddIndex();        }        return ret;    }    public void clear() {        list.clear();    }}class InfoNode implements Comparable<InfoNode> {    int index;    Number targetValue;    int addIndex;    SortedNode sortedNode;    InfoArray infoArray = new InfoArray();    public InfoNode(int index, Number targetValue, SortedNode node) {        this.index = index;        this.targetValue = targetValue;        this.sortedNode = node;    }    public InfoNode getLastInfoNode() {        if (infoArray.size() == 0) {            return null;        }        return infoArray.get(infoArray.size() - 1);    }    public void addChild(InfoNode child) {        infoArray.add(child);    }    public SortedNode buildSortedNode() {        sortedNode.setSortedIndex(infoArray.getSortedIndex());        sortedNode.setChildren(infoArray.getSortedNodes());        return sortedNode;    }    public int getIndex() {        return index;    }    public void setIndex(int index) {        this.index = index;    }    public Number getTargetValue() {        return targetValue;    }    public void setTargetValue(int targetValue) {        this.targetValue = targetValue;    }    public int getAddIndex() {        return addIndex;    }    public void setAddIndex(int addIndex) {        this.addIndex = addIndex;    }    public SortedNode getSortedNode() {        return sortedNode;    }    public void setSortedNode(SortedNode sortedNode) {        this.sortedNode = sortedNode;    }    @Override    public int compareTo(InfoNode other) {        return ComparatorUtils.compare(targetValue, other.targetValue);    }}