package com.fr.bi.cal.analyze.cal.sssecret;import com.fr.bi.cal.analyze.cal.result.MergerNode;import com.fr.bi.cal.analyze.cal.result.Node;import com.fr.bi.stable.data.Table;import com.fr.bi.stable.data.key.date.BIDay;import com.finebi.cube.api.ICubeDataLoader;import com.fr.bi.stable.gvi.GroupValueIndex;import com.fr.bi.stable.report.key.TargetGettingKey;import com.fr.bi.stable.report.result.DimensionCalculator;import com.fr.bi.stable.report.result.LightNode;import java.util.HashMap;import java.util.Map;/** * Created by Hiram on 2015/1/28. */public class TreeSingleDimensionGroup implements ISingleDimensionGroup {    protected TargetGettingKey tkey;    protected DimensionCalculator column;    protected transient DimensionCalculator[] pcolumns;    protected transient int[] pckindex;    protected transient Object[] data;    protected transient int ckIndex;    private Table tableKey;    private ICubeDataLoader loader;    private LightNode root;    public TreeSingleDimensionGroup(LightNode root) {        this.root = root;    }    /**     * Group计算的构造函数     *     * @param tableKey     * @param pcolumns     * @param pckindex     * @param column   维度     * @param data     * @param ckIndex     * @param gvi   获取实际过滤条件的对象     * @param loader     */    protected TreeSingleDimensionGroup(Table tableKey, DimensionCalculator[] pcolumns, int[] pckindex, DimensionCalculator column, Object[] data, int ckIndex, GroupValueIndex gvi, ICubeDataLoader loader) {        this.loader = loader;        this.tableKey = tableKey;        this.pcolumns = pcolumns;        this.column = column;        this.pckindex = pckindex;        this.ckIndex = ckIndex;        this.data = data;    }    @Override    public int getChildIndexByValue(Object value) {        for (int i = 0; i < root.getChildLength(); i++) {            LightNode node = root.getChild(i);            if (node.getComparator().compare(node.getData(), value) == 0) {                return i;            }        }        return -1;    }    @Override    public NoneDimensionGroup getChildDimensionGroup(int row) {        if (isOutOfBounds(row)) {            return NoneDimensionGroup.NULL;        }        return new TreeNoneDimensionGroup(root.getChild(row), loader);    }    @Override    public Object getChildData(int row) {        return getChild(row).getData();    }    @Override    public String getChildShowName(int row) {        return getChild(row).getShowValue();    }    @Override    public Node getChildNode(int row) {        return castToNode(getChild(row));    }    private LightNode getChild(int row) {        checkRow(row);        return root.getChild(row);    }    private void checkRow(int row) {        if (row >= root.getChildLength()) {            throw GroupOutOfBoundsException.create(row);        }    }    private LightNode createEmptyNode() {        MergerNode child = new MergerNode(BIDay.NULL);        Map<TargetGettingKey, GroupValueIndex> targetIndexValueMap = new HashMap<TargetGettingKey, GroupValueIndex>();        targetIndexValueMap.putAll(root.getTargetIndexValueMap());        child.setTargetIndexValueMap(targetIndexValueMap);        return child;    }    private boolean isOutOfBounds(int row) {        return row >= root.getChildLength();    }    private Node castToNode(LightNode node) {        Node ret = new Node(null, node.getData());        ret.setTargetIndexValueMap(node.getTargetIndexValueMap());        return ret;    }    @Override    public LightNode getRoot() {        return root;    }    @Override    public void release() {    }    @Override    public int getCurrentTotalRow() {        return root.getChildLength();    }    @Override    public Object[] getData() {        return data;    }}