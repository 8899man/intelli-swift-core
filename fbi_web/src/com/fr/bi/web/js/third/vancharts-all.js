(function (root, factory) {
    if (typeof define === 'function' && define.amd) {
        //Allow using this built library as an AMD module
        //in another project. That other project will only
        //see this AMD call, not the internal modules in
        //the closure below.
        define([], factory);
    } else {
        //Browser globals case. Just assign the
        //result to a property on the global.
        root.VanCharts = factory();
    }
}(this, function () {
/**
 * @license almond 0.3.1 Copyright (c) 2011-2014, The Dojo Foundation All Rights Reserved.
 * Available via the MIT or new BSD license.
 * see: http://github.com/jrburke/almond for details
 */
//Going sloppy to avoid 'use strict' string cost, but strict practices should
//be followed.
/*jslint sloppy: true */
/*global setTimeout: false */

var requirejs, require, define;
(function (undef) {
    var main, req, makeMap, handlers,
        defined = {},
        waiting = {},
        config = {},
        defining = {},
        hasOwn = Object.prototype.hasOwnProperty,
        aps = [].slice,
        jsSuffixRegExp = /\.js$/;

    function hasProp(obj, prop) {
        return hasOwn.call(obj, prop);
    }

    /**
     * Given a relative module name, like ./something, normalize it to
     * a real name that can be mapped to a path.
     * @param {String} name the relative name
     * @param {String} baseName a real name that the name arg is relative
     * to.
     * @returns {String} normalized name
     */
    function normalize(name, baseName) {
        var nameParts, nameSegment, mapValue, foundMap, lastIndex,
            foundI, foundStarMap, starI, i, j, part,
            baseParts = baseName && baseName.split("/"),
            map = config.map,
            starMap = (map && map['*']) || {};

        //Adjust any relative paths.
        if (name && name.charAt(0) === ".") {
            //If have a base name, try to normalize against it,
            //otherwise, assume it is a top-level require that will
            //be relative to baseUrl in the end.
            if (baseName) {
                name = name.split('/');
                lastIndex = name.length - 1;

                // Node .js allowance:
                if (config.nodeIdCompat && jsSuffixRegExp.test(name[lastIndex])) {
                    name[lastIndex] = name[lastIndex].replace(jsSuffixRegExp, '');
                }

                //Lop off the last part of baseParts, so that . matches the
                //"directory" and not name of the baseName's module. For instance,
                //baseName of "one/two/three", maps to "one/two/three.js", but we
                //want the directory, "one/two" for this normalization.
                name = baseParts.slice(0, baseParts.length - 1).concat(name);

                //start trimDots
                for (i = 0; i < name.length; i += 1) {
                    part = name[i];
                    if (part === ".") {
                        name.splice(i, 1);
                        i -= 1;
                    } else if (part === "..") {
                        if (i === 1 && (name[2] === '..' || name[0] === '..')) {
                            //End of the line. Keep at least one non-dot
                            //path segment at the front so it can be mapped
                            //correctly to disk. Otherwise, there is likely
                            //no path mapping for a path starting with '..'.
                            //This can still fail, but catches the most reasonable
                            //uses of ..
                            break;
                        } else if (i > 0) {
                            name.splice(i - 1, 2);
                            i -= 2;
                        }
                    }
                }
                //end trimDots

                name = name.join("/");
            } else if (name.indexOf('./') === 0) {
                // No baseName, so this is ID is resolved relative
                // to baseUrl, pull off the leading dot.
                name = name.substring(2);
            }
        }

        //Apply map config if available.
        if ((baseParts || starMap) && map) {
            nameParts = name.split('/');

            for (i = nameParts.length; i > 0; i -= 1) {
                nameSegment = nameParts.slice(0, i).join("/");

                if (baseParts) {
                    //Find the longest baseName segment match in the config.
                    //So, do joins on the biggest to smallest lengths of baseParts.
                    for (j = baseParts.length; j > 0; j -= 1) {
                        mapValue = map[baseParts.slice(0, j).join('/')];

                        //baseName segment has  config, find if it has one for
                        //this name.
                        if (mapValue) {
                            mapValue = mapValue[nameSegment];
                            if (mapValue) {
                                //Match, update name to the new value.
                                foundMap = mapValue;
                                foundI = i;
                                break;
                            }
                        }
                    }
                }

                if (foundMap) {
                    break;
                }

                //Check for a star map match, but just hold on to it,
                //if there is a shorter segment match later in a matching
                //config, then favor over this star map.
                if (!foundStarMap && starMap && starMap[nameSegment]) {
                    foundStarMap = starMap[nameSegment];
                    starI = i;
                }
            }

            if (!foundMap && foundStarMap) {
                foundMap = foundStarMap;
                foundI = starI;
            }

            if (foundMap) {
                nameParts.splice(0, foundI, foundMap);
                name = nameParts.join('/');
            }
        }

        return name;
    }

    function makeRequire(relName, forceSync) {
        return function () {
            //A version of a require function that passes a moduleName
            //value for items that may need to
            //look up paths relative to the moduleName
            var args = aps.call(arguments, 0);

            //If first arg is not require('string'), and there is only
            //one arg, it is the array form without a callback. Insert
            //a null so that the following concat is correct.
            if (typeof args[0] !== 'string' && args.length === 1) {
                args.push(null);
            }
            return req.apply(undef, args.concat([relName, forceSync]));
        };
    }

    function makeNormalize(relName) {
        return function (name) {
            return normalize(name, relName);
        };
    }

    function makeLoad(depName) {
        return function (value) {
            defined[depName] = value;
        };
    }

    function callDep(name) {
        if (hasProp(waiting, name)) {
            var args = waiting[name];
            delete waiting[name];
            defining[name] = true;
            main.apply(undef, args);
        }

        if (!hasProp(defined, name) && !hasProp(defining, name)) {
            throw new Error('No ' + name);
        }
        return defined[name];
    }

    //Turns a plugin!resource to [plugin, resource]
    //with the plugin being undefined if the name
    //did not have a plugin prefix.
    function splitPrefix(name) {
        var prefix,
            index = name ? name.indexOf('!') : -1;
        if (index > -1) {
            prefix = name.substring(0, index);
            name = name.substring(index + 1, name.length);
        }
        return [prefix, name];
    }

    /**
     * Makes a name map, normalizing the name, and using a plugin
     * for normalization if necessary. Grabs a ref to plugin
     * too, as an optimization.
     */
    makeMap = function (name, relName) {
        var plugin,
            parts = splitPrefix(name),
            prefix = parts[0];

        name = parts[1];

        if (prefix) {
            prefix = normalize(prefix, relName);
            plugin = callDep(prefix);
        }

        //Normalize according
        if (prefix) {
            if (plugin && plugin.normalize) {
                name = plugin.normalize(name, makeNormalize(relName));
            } else {
                name = normalize(name, relName);
            }
        } else {
            name = normalize(name, relName);
            parts = splitPrefix(name);
            prefix = parts[0];
            name = parts[1];
            if (prefix) {
                plugin = callDep(prefix);
            }
        }

        //Using ridiculous property names for space reasons
        return {
            f: prefix ? prefix + '!' + name : name, //fullName
            n: name,
            pr: prefix,
            p: plugin
        };
    };

    function makeConfig(name) {
        return function () {
            return (config && config.config && config.config[name]) || {};
        };
    }

    handlers = {
        require: function (name) {
            return makeRequire(name);
        },
        exports: function (name) {
            var e = defined[name];
            if (typeof e !== 'undefined') {
                return e;
            } else {
                return (defined[name] = {});
            }
        },
        module: function (name) {
            return {
                id: name,
                uri: '',
                exports: defined[name],
                config: makeConfig(name)
            };
        }
    };

    main = function (name, deps, callback, relName) {
        var cjsModule, depName, ret, map, i,
            args = [],
            callbackType = typeof callback,
            usingExports;

        //Use name if no relName
        relName = relName || name;

        //Call the callback to define the module, if necessary.
        if (callbackType === 'undefined' || callbackType === 'function') {
            //Pull out the defined dependencies and pass the ordered
            //values to the callback.
            //Default to [require, exports, module] if no deps
            deps = !deps.length && callback.length ? ['require', 'exports', 'module'] : deps;
            for (i = 0; i < deps.length; i += 1) {
                map = makeMap(deps[i], relName);
                depName = map.f;

                //Fast path CommonJS standard dependencies.
                if (depName === "require") {
                    args[i] = handlers.require(name);
                } else if (depName === "exports") {
                    //CommonJS module spec 1.1
                    args[i] = handlers.exports(name);
                    usingExports = true;
                } else if (depName === "module") {
                    //CommonJS module spec 1.1
                    cjsModule = args[i] = handlers.module(name);
                } else if (hasProp(defined, depName) ||
                    hasProp(waiting, depName) ||
                    hasProp(defining, depName)) {
                    args[i] = callDep(depName);
                } else if (map.p) {
                    map.p.load(map.n, makeRequire(relName, true), makeLoad(depName), {});
                    args[i] = defined[depName];
                } else {
                    throw new Error(name + ' missing ' + depName);
                }
            }

            ret = callback ? callback.apply(defined[name], args) : undefined;

            if (name) {
                //If setting exports via "module" is in play,
                //favor that over return value and exports. After that,
                //favor a non-undefined return value over exports use.
                if (cjsModule && cjsModule.exports !== undef &&
                    cjsModule.exports !== defined[name]) {
                    defined[name] = cjsModule.exports;
                } else if (ret !== undef || !usingExports) {
                    //Use the return value from the function.
                    defined[name] = ret;
                }
            }
        } else if (name) {
            //May just be an object definition for the module. Only
            //worry about defining if have a module name.
            defined[name] = callback;
        }
    };

    requirejs = require = req = function (deps, callback, relName, forceSync, alt) {
        if (typeof deps === "string") {
            if (handlers[deps]) {
                //callback in this case is really relName
                return handlers[deps](callback);
            }
            //Just return the module wanted. In this scenario, the
            //deps arg is the module name, and second arg (if passed)
            //is just the relName.
            //Normalize module name, if it contains . or ..
            return callDep(makeMap(deps, callback).f);
        } else if (!deps.splice) {
            //deps is a config object, not an array.
            config = deps;
            if (config.deps) {
                req(config.deps, config.callback);
            }
            if (!callback) {
                return;
            }

            if (callback.splice) {
                //callback is an array, which means it is a dependency list.
                //Adjust args if there are dependencies
                deps = callback;
                callback = relName;
                relName = null;
            } else {
                deps = undef;
            }
        }

        //Support require(['a'])
        callback = callback || function () {};

        //If relName is a function, it is an errback handler,
        //so remove it.
        if (typeof relName === 'function') {
            relName = forceSync;
            forceSync = alt;
        }

        //Simulate async callback;
        if (forceSync) {
            main(undef, deps, callback, relName);
        } else {
            //Using a non-zero value because of concern for what old browsers
            //do, and latest browsers "upgrade" to 4 if lower value is used:
            //http://www.whatwg.org/specs/web-apps/current-work/multipage/timers.html#dom-windowtimers-settimeout:
            //If want a value immediately, use require('id') instead -- something
            //that works in almond on the global level, but not guaranteed and
            //unlikely to work in other AMD implementations.
            setTimeout(function () {
                main(undef, deps, callback, relName);
            }, 4);
        }

        return req;
    };

    /**
     * Just drops the config on the floor, but returns req in case
     * the config return value is used.
     */
    req.config = function (cfg) {
        return req(cfg);
    };

    /**
     * Expose module registry for debugging and tooling
     */
    requirejs._defined = defined;

    define = function (name, deps, callback) {
        if (typeof name !== 'string') {
            throw new Error('See almond README: incorrect module build, no module name');
        }

        //This module may not have dependencies
        if (!deps.splice) {
            //deps is not an array, so probably means
            //an object literal or factory function for
            //the value. Adjust args.
            callback = deps;
            deps = [];
        }

        if (!hasProp(defined, name) && !hasProp(waiting, name)) {
            waiting[name] = [name, deps, callback];
        }
    };

    define.amd = {
        jQuery: true
    };
}());
define("almond", function(){});

/*! Hammer.JS - v2.0.7 - 2016-04-22
 * http://hammerjs.github.io/
 *
 * Copyright (c) 2016 Jorik Tangelder;
 * Licensed under the MIT license */
(function(window, document, exportName, undefined) {
    'use strict';

    var VENDOR_PREFIXES = ['', 'webkit', 'Moz', 'MS', 'ms', 'o'];
    var TEST_ELEMENT = document.createElement('div');

    var TYPE_FUNCTION = 'function';

    var _preventDefault = function (e) {

        if (e.preventDefault) {
            e.preventDefault();
        } else {
            e.returnValue = false;
        }
        return this;
    };

    var ie8 = !(window.SVGSVGElement);

    var round = Math.round;
    var abs = Math.abs;
    var now = Date.now;

    /**
     * set a timeout with a given scope
     * @param {Function} fn
     * @param {Number} timeout
     * @param {Object} context
     * @returns {number}
     */
    function setTimeoutContext(fn, timeout, context) {
        return setTimeout(bindFn(fn, context), timeout);
    }

    /**
     * if the argument is an array, we want to execute the fn on each entry
     * if it aint an array we don't want to do a thing.
     * this is used by all the methods that accept a single and array argument.
     * @param {*|Array} arg
     * @param {String} fn
     * @param {Object} [context]
     * @returns {Boolean}
     */
    function invokeArrayArg(arg, fn, context) {
        if (Array.isArray(arg)) {
            each(arg, context[fn], context);
            return true;
        }
        return false;
    }

    /**
     * walk objects and arrays
     * @param {Object} obj
     * @param {Function} iterator
     * @param {Object} context
     */
    function each(obj, iterator, context) {
        var i;

        if (!obj) {
            return;
        }

        if (obj.forEach) {
            obj.forEach(iterator, context);
        } else if (obj.length !== undefined) {
            i = 0;
            while (i < obj.length) {
                iterator.call(context, obj[i], i, obj);
                i++;
            }
        } else {
            for (i in obj) {
                obj.hasOwnProperty(i) && iterator.call(context, obj[i], i, obj);
            }
        }
    }

    /**
     * wrap a method with a deprecation warning and stack trace
     * @param {Function} method
     * @param {String} name
     * @param {String} message
     * @returns {Function} A new function wrapping the supplied method.
     */
    function deprecate(method, name, message) {
        var deprecationMessage = 'DEPRECATED METHOD: ' + name + '\n' + message + ' AT \n';
        return function() {
            var e = new Error('get-stack-trace');
            var stack = e && e.stack ? e.stack.replace(/^[^\(]+?[\n$]/gm, '')
                .replace(/^\s+at\s+/gm, '')
                .replace(/^Object.<anonymous>\s*\(/gm, '{anonymous}()@') : 'Unknown Stack Trace';

            var log = window.console && (window.console.warn || window.console.log);
            if (log) {
                log.call(window.console, deprecationMessage, stack);
            }
            return method.apply(this, arguments);
        };
    }

    /**
     * extend object.
     * means that properties in dest will be overwritten by the ones in src.
     * @param {Object} target
     * @param {...Object} objects_to_assign
     * @returns {Object} target
     */
    var assign;
    if (typeof Object.assign !== 'function') {
        assign = function assign(target) {
            if (target === undefined || target === null) {
                throw new TypeError('Cannot convert undefined or null to object');
            }

            var output = Object(target);
            for (var index = 1; index < arguments.length; index++) {
                var source = arguments[index];
                if (source !== undefined && source !== null) {
                    for (var nextKey in source) {
                        if (source.hasOwnProperty(nextKey)) {
                            output[nextKey] = source[nextKey];
                        }
                    }
                }
            }
            return output;
        };
    } else {
        assign = Object.assign;
    }

    /**
     * extend object.
     * means that properties in dest will be overwritten by the ones in src.
     * @param {Object} dest
     * @param {Object} src
     * @param {Boolean} [merge=false]
     * @returns {Object} dest
     */
    var extend = deprecate(function extend(dest, src, merge) {
        var keys = Object.keys(src);
        var i = 0;
        while (i < keys.length) {
            if (!merge || (merge && dest[keys[i]] === undefined)) {
                dest[keys[i]] = src[keys[i]];
            }
            i++;
        }
        return dest;
    }, 'extend', 'Use `assign`.');

    /**
     * merge the values from src in the dest.
     * means that properties that exist in dest will not be overwritten by src
     * @param {Object} dest
     * @param {Object} src
     * @returns {Object} dest
     */
    var merge = deprecate(function merge(dest, src) {
        return extend(dest, src, true);
    }, 'merge', 'Use `assign`.');

    /**
     * simple class inheritance
     * @param {Function} child
     * @param {Function} base
     * @param {Object} [properties]
     */
    function inherit(child, base, properties) {
        var baseP = base.prototype,
            childP;

        childP = child.prototype = Object.create(baseP);
        childP.constructor = child;
        childP._super = baseP;

        if (properties) {
            assign(childP, properties);
        }
    }

    /**
     * simple function bind
     * @param {Function} fn
     * @param {Object} context
     * @returns {Function}
     */
    function bindFn(fn, context) {
        return function boundFn() {
            return fn.apply(context, arguments);
        };
    }

    /**
     * let a boolean value also be a function that must return a boolean
     * this first item in args will be used as the context
     * @param {Boolean|Function} val
     * @param {Array} [args]
     * @returns {Boolean}
     */
    function boolOrFn(val, args) {
        if (typeof val == TYPE_FUNCTION) {
            return val.apply(args ? args[0] || undefined : undefined, args);
        }
        return val;
    }

    /**
     * use the val2 when val1 is undefined
     * @param {*} val1
     * @param {*} val2
     * @returns {*}
     */
    function ifUndefined(val1, val2) {
        return (val1 === undefined) ? val2 : val1;
    }

    /**
     * addEventListener with multiple events at once
     * @param {EventTarget} target
     * @param {String} types
     * @param {Function} handler
     */
    function addEventListeners(target, types, handler) {
        each(splitStr(types), function(type) {
            if(target.attachEvent){
                target.attachEvent('on' + type, handler);
            }else if (target.addEventListener){
                target.addEventListener(type, handler, true);
            }
        });
    }

    /**
     * removeEventListener with multiple events at once
     * @param {EventTarget} target
     * @param {String} types
     * @param {Function} handler
     */
    function removeEventListeners(target, types, handler) {
        each(splitStr(types), function(type) {
            target.removeEventListener(type, handler, false);
        });
    }

    /**
     * find if a node is in the given parent
     * @method hasParent
     * @param {HTMLElement} node
     * @param {HTMLElement} parent
     * @return {Boolean} found
     */
    function hasParent(node, parent) {
        while (node) {
            if (node == parent) {
                return true;
            }
            node = node.parentNode;
        }
        return false;
    }

    /**
     * small indexOf wrapper
     * @param {String} str
     * @param {String} find
     * @returns {Boolean} found
     */
    function inStr(str, find) {
        return str.indexOf(find) > -1;
    }

    /**
     * split string on whitespace
     * @param {String} str
     * @returns {Array} words
     */
    function splitStr(str) {
        return str.trim().split(/\s+/g);
    }

    /**
     * find if a array contains the object using indexOf or a simple polyFill
     * @param {Array} src
     * @param {String} find
     * @param {String} [findByKey]
     * @return {Boolean|Number} false when not found, or the index
     */
    function inArray(src, find, findByKey) {
        if (src.indexOf && !findByKey) {
            return src.indexOf(find);
        } else {
            var i = 0;
            while (i < src.length) {
                if ((findByKey && src[i][findByKey] == find) || (!findByKey && src[i] === find)) {
                    return i;
                }
                i++;
            }
            return -1;
        }
    }

    /**
     * convert array-like objects to real arrays
     * @param {Object} obj
     * @returns {Array}
     */
    function toArray(obj) {
        return Array.prototype.slice.call(obj, 0);
    }

    /**
     * unique array with objects based on a key (like 'id') or just by the array's value
     * @param {Array} src [{id:1},{id:2},{id:1}]
     * @param {String} [key]
     * @param {Boolean} [sort=False]
     * @returns {Array} [{id:1},{id:2}]
     */
    function uniqueArray(src, key, sort) {
        var results = [];
        var values = [];
        var i = 0;

        while (i < src.length) {
            var val = key ? src[i][key] : src[i];
            if (inArray(values, val) < 0) {
                results.push(src[i]);
            }
            values[i] = val;
            i++;
        }

        if (sort) {
            if (!key) {
                results = results.sort();
            } else {
                results = results.sort(function sortUniqueArray(a, b) {
                    return a[key] > b[key];
                });
            }
        }

        return results;
    }

    /**
     * get the prefixed property
     * @param {Object} obj
     * @param {String} property
     * @returns {String|Undefined} prefixed
     */
    function prefixed(obj, property) {
        var prefix, prop;
        var camelProp = property.charAt(0).toUpperCase() + property.slice(1);

        var i = 0;
        while (i < VENDOR_PREFIXES.length) {
            prefix = VENDOR_PREFIXES[i];
            prop = (prefix) ? prefix + camelProp : property;

            if (prop in obj) {
                return prop;
            }
            i++;
        }
        return undefined;
    }

    /**
     * get a unique id
     * @returns {number} uniqueId
     */
    var _uniqueId = 1;
    function uniqueId() {
        return _uniqueId++;
    }

    /**
     * get the window object of an element
     * @param {HTMLElement} element
     * @returns {DocumentView|Window}
     */
    function getWindowForElement(element) {
        var doc = element.ownerDocument || element;
        return (doc.defaultView || doc.parentWindow || window);
    }

    var MOBILE_REGEX = /mobile|tablet|ip(ad|hone|od)|android/i;

    var SUPPORT_TOUCH = ('ontouchstart' in window);
    var SUPPORT_POINTER_EVENTS = prefixed(window, 'PointerEvent') !== undefined;
    var SUPPORT_ONLY_TOUCH = SUPPORT_TOUCH && MOBILE_REGEX.test(navigator.userAgent);

    var INPUT_TYPE_TOUCH = 'touch';
    var INPUT_TYPE_PEN = 'pen';
    var INPUT_TYPE_MOUSE = 'mouse';
    var INPUT_TYPE_KINECT = 'kinect';

    var COMPUTE_INTERVAL = 25;

    var INPUT_START = 1;
    var INPUT_MOVE = 2;
    var INPUT_END = 4;
    var INPUT_CANCEL = 8;

    var DIRECTION_NONE = 1;
    var DIRECTION_LEFT = 2;
    var DIRECTION_RIGHT = 4;
    var DIRECTION_UP = 8;
    var DIRECTION_DOWN = 16;

    var DIRECTION_HORIZONTAL = DIRECTION_LEFT | DIRECTION_RIGHT;
    var DIRECTION_VERTICAL = DIRECTION_UP | DIRECTION_DOWN;
    var DIRECTION_ALL = DIRECTION_HORIZONTAL | DIRECTION_VERTICAL;

    var PROPS_XY = ['x', 'y'];
    var PROPS_CLIENT_XY = ['clientX', 'clientY'];

    /**
     * create new input type manager
     * @param {Manager} manager
     * @param {Function} callback
     * @returns {Input}
     * @constructor
     */
    function Input(manager, callback) {
        var self = this;
        this.manager = manager;
        this.callback = callback;
        this.element = manager.element;
        this.target = manager.options.inputTarget;

        // smaller wrapper around the handler, for the scope and the enabled state of the manager,
        // so when disabled the input events are completely bypassed.
        this.domHandler = function(ev) {
            if (boolOrFn(manager.options.enable, [manager])) {
                self.handler(ev);
            }
        };

        this.init();

    }

    Input.prototype = {
        /**
         * should handle the inputEvent data and trigger the callback
         * @virtual
         */
        handler: function() { },

        /**
         * bind the events
         */
        init: function() {
            this.evEl && addEventListeners(this.element, this.evEl, this.domHandler);
            this.evTarget && addEventListeners(this.target, this.evTarget, this.domHandler);
            this.evWin && addEventListeners(getWindowForElement(this.element), this.evWin, this.domHandler);
        },

        /**
         * unbind the events
         */
        destroy: function() {
            this.evEl && removeEventListeners(this.element, this.evEl, this.domHandler);
            this.evTarget && removeEventListeners(this.target, this.evTarget, this.domHandler);
            this.evWin && removeEventListeners(getWindowForElement(this.element), this.evWin, this.domHandler);
        }
    };

    /**
     * create new input type manager
     * called by the Manager constructor
     * @param {Hammer} manager
     * @returns {Input}
     */
    function createInputInstance(manager) {
        var Type;
        var inputClass = manager.options.inputClass;

        if (inputClass) {
            Type = inputClass;
        } else if (SUPPORT_POINTER_EVENTS) {
            Type = PointerEventInput;
        } else if (SUPPORT_ONLY_TOUCH) {
            Type = TouchInput;
        } else if (!SUPPORT_TOUCH) {
            Type = MouseInput;
        } else {
            Type = TouchMouseInput;
        }
        return new (Type)(manager, inputHandler);
    }

    /**
     * handle input events
     * @param {Manager} manager
     * @param {String} eventType
     * @param {Object} input
     */
    function inputHandler(manager, eventType, input) {
        var pointersLen = input.pointers.length;
        var changedPointersLen = input.changedPointers.length;
        var isFirst = (eventType & INPUT_START && (pointersLen - changedPointersLen === 0));
        var isFinal = (eventType & (INPUT_END | INPUT_CANCEL) && (pointersLen - changedPointersLen === 0));

        input.isFirst = !!isFirst;
        input.isFinal = !!isFinal;

        if (isFirst) {
            manager.session = {};
        }

        // source event is the normalized value of the domEvents
        // like 'touchstart, mouseup, pointerdown'
        input.eventType = eventType;

        // compute scale, rotation etc
        computeInputData(manager, input);

        // emit secret event
        manager.emit('hammer.input', input);

        manager.recognize(input);
        manager.session.prevInput = input;
    }

    /**
     * extend the data with some usable properties like scale, rotate, velocity etc
     * @param {Object} manager
     * @param {Object} input
     */
    function computeInputData(manager, input) {
        var session = manager.session;
        var pointers = input.pointers;
        var pointersLength = pointers.length;

        // store the first input to calculate the distance and direction
        if (!session.firstInput) {
            session.firstInput = simpleCloneInputData(input);
        }

        // to compute scale and rotation we need to store the multiple touches
        if (pointersLength > 1 && !session.firstMultiple) {
            session.firstMultiple = simpleCloneInputData(input);
        } else if (pointersLength === 1) {
            session.firstMultiple = false;
        }

        var firstInput = session.firstInput;
        var firstMultiple = session.firstMultiple;
        var offsetCenter = firstMultiple ? firstMultiple.center : firstInput.center;

        var center = input.center = getCenter(pointers);
        input.timeStamp = now();
        input.deltaTime = input.timeStamp - firstInput.timeStamp;

        input.angle = getAngle(offsetCenter, center);
        input.distance = getDistance(offsetCenter, center);

        computeDeltaXY(session, input);
        input.offsetDirection = getDirection(input.deltaX, input.deltaY);

        var overallVelocity = getVelocity(input.deltaTime, input.deltaX, input.deltaY);
        input.overallVelocityX = overallVelocity.x;
        input.overallVelocityY = overallVelocity.y;
        input.overallVelocity = (abs(overallVelocity.x) > abs(overallVelocity.y)) ? overallVelocity.x : overallVelocity.y;

        input.scale = firstMultiple ? getScale(firstMultiple.pointers, pointers) : 1;
        input.rotation = firstMultiple ? getRotation(firstMultiple.pointers, pointers) : 0;

        input.maxPointers = !session.prevInput ? input.pointers.length : ((input.pointers.length >
        session.prevInput.maxPointers) ? input.pointers.length : session.prevInput.maxPointers);

        computeIntervalInputData(session, input);

        // find the correct target
        var target = manager.element;
        if (hasParent(input.srcEvent.target, target)) {
            target = input.srcEvent.target;
        }
        input.target = target;
    }

    function computeDeltaXY(session, input) {
        var center = input.center;
        var offset = session.offsetDelta || {};
        var prevDelta = session.prevDelta || {};
        var prevInput = session.prevInput || {};

        if (input.eventType === INPUT_START || prevInput.eventType === INPUT_END) {
            prevDelta = session.prevDelta = {
                x: prevInput.deltaX || 0,
                y: prevInput.deltaY || 0
            };

            offset = session.offsetDelta = {
                x: center.x,
                y: center.y
            };
        }

        input.deltaX = prevDelta.x + (center.x - offset.x);
        input.deltaY = prevDelta.y + (center.y - offset.y);
    }

    /**
     * velocity is calculated every x ms
     * @param {Object} session
     * @param {Object} input
     */
    function computeIntervalInputData(session, input) {
        var last = session.lastInterval || input,
            deltaTime = input.timeStamp - last.timeStamp,
            velocity, velocityX, velocityY, direction;

        if (input.eventType != INPUT_CANCEL && (deltaTime > COMPUTE_INTERVAL || last.velocity === undefined)) {
            var deltaX = input.deltaX - last.deltaX;
            var deltaY = input.deltaY - last.deltaY;

            var v = getVelocity(deltaTime, deltaX, deltaY);
            velocityX = v.x;
            velocityY = v.y;
            velocity = (abs(v.x) > abs(v.y)) ? v.x : v.y;
            direction = getDirection(deltaX, deltaY);

            session.lastInterval = input;
        } else {
            // use latest velocity info if it doesn't overtake a minimum period
            velocity = last.velocity;
            velocityX = last.velocityX;
            velocityY = last.velocityY;
            direction = last.direction;
        }

        input.velocity = velocity;
        input.velocityX = velocityX;
        input.velocityY = velocityY;
        input.direction = direction;
    }

    /**
     * create a simple clone from the input used for storage of firstInput and firstMultiple
     * @param {Object} input
     * @returns {Object} clonedInputData
     */
    function simpleCloneInputData(input) {
        // make a simple copy of the pointers because we will get a reference if we don't
        // we only need clientXY for the calculations
        var pointers = [];
        var i = 0;
        while (i < input.pointers.length) {
            pointers[i] = {
                clientX: round(input.pointers[i].clientX),
                clientY: round(input.pointers[i].clientY)
            };
            i++;
        }

        return {
            timeStamp: now(),
            pointers: pointers,
            center: getCenter(pointers),
            deltaX: input.deltaX,
            deltaY: input.deltaY
        };
    }

    /**
     * get the center of all the pointers
     * @param {Array} pointers
     * @return {Object} center contains `x` and `y` properties
     */
    function getCenter(pointers) {
        var pointersLength = pointers.length;

        // no need to loop when only one touch
        if (pointersLength === 1) {
            return {
                x: round(pointers[0].clientX),
                y: round(pointers[0].clientY)
            };
        }

        var x = 0, y = 0, i = 0;
        while (i < pointersLength) {
            x += pointers[i].clientX;
            y += pointers[i].clientY;
            i++;
        }

        return {
            x: round(x / pointersLength),
            y: round(y / pointersLength)
        };
    }

    /**
     * calculate the velocity between two points. unit is in px per ms.
     * @param {Number} deltaTime
     * @param {Number} x
     * @param {Number} y
     * @return {Object} velocity `x` and `y`
     */
    function getVelocity(deltaTime, x, y) {
        return {
            x: x / deltaTime || 0,
            y: y / deltaTime || 0
        };
    }

    /**
     * get the direction between two points
     * @param {Number} x
     * @param {Number} y
     * @return {Number} direction
     */
    function getDirection(x, y) {
        if (x === y) {
            return DIRECTION_NONE;
        }

        if (abs(x) >= abs(y)) {
            return x < 0 ? DIRECTION_LEFT : DIRECTION_RIGHT;
        }
        return y < 0 ? DIRECTION_UP : DIRECTION_DOWN;
    }

    /**
     * calculate the absolute distance between two points
     * @param {Object} p1 {x, y}
     * @param {Object} p2 {x, y}
     * @param {Array} [props] containing x and y keys
     * @return {Number} distance
     */
    function getDistance(p1, p2, props) {
        if (!props) {
            props = PROPS_XY;
        }
        var x = p2[props[0]] - p1[props[0]],
            y = p2[props[1]] - p1[props[1]];

        return Math.sqrt((x * x) + (y * y));
    }

    /**
     * calculate the angle between two coordinates
     * @param {Object} p1
     * @param {Object} p2
     * @param {Array} [props] containing x and y keys
     * @return {Number} angle
     */
    function getAngle(p1, p2, props) {
        if (!props) {
            props = PROPS_XY;
        }
        var x = p2[props[0]] - p1[props[0]],
            y = p2[props[1]] - p1[props[1]];
        return Math.atan2(y, x) * 180 / Math.PI;
    }

    /**
     * calculate the rotation degrees between two pointersets
     * @param {Array} start array of pointers
     * @param {Array} end array of pointers
     * @return {Number} rotation
     */
    function getRotation(start, end) {
        return getAngle(end[1], end[0], PROPS_CLIENT_XY) + getAngle(start[1], start[0], PROPS_CLIENT_XY);
    }

    /**
     * calculate the scale factor between two pointersets
     * no scale is 1, and goes down to 0 when pinched together, and bigger when pinched out
     * @param {Array} start array of pointers
     * @param {Array} end array of pointers
     * @return {Number} scale
     */
    function getScale(start, end) {
        return getDistance(end[0], end[1], PROPS_CLIENT_XY) / getDistance(start[0], start[1], PROPS_CLIENT_XY);
    }

    var MOUSE_INPUT_MAP = {
        mousedown: INPUT_START,
        mousemove: INPUT_MOVE,
        mouseup: INPUT_END
    };

    var MOUSE_ELEMENT_EVENTS = 'mousedown mousemove mouseout mouseover';
    var MOUSE_WINDOW_EVENTS = 'mousemove mouseup';

    //ie8的bug,在document上mouseup不相应
    if(ie8){
        MOUSE_ELEMENT_EVENTS = 'mousedown mousemove mouseout mouseover mouseup';
        MOUSE_WINDOW_EVENTS = 'mousemove';
    }

    /**
     * Mouse events input
     * @constructor
     * @extends Input
     */
    function MouseInput() {
        this.evEl = MOUSE_ELEMENT_EVENTS;
        this.evWin = MOUSE_WINDOW_EVENTS;

        this.pressed = false; // mousedown state

        Input.apply(this, arguments);
    }

    inherit(MouseInput, Input, {
        /**
         * handle mouse events
         * @param {Object} ev
         */
        handler: function MEhandler(ev) {
            var data = {
                pointers: [ev],
                changedPointers: [ev],
                pointerType: INPUT_TYPE_MOUSE,
                srcEvent: ev
            };

            var eventType = MOUSE_INPUT_MAP[ev.type];

            var isLeftButton = ie8 ? ev.button === 1 : ev.button === 0;

            // on start we want to have the left mouse button down
            if (eventType & INPUT_START && isLeftButton) {
                this.pressed = true;
            }

            if (eventType & INPUT_MOVE && ev.which !== 1) {
                eventType = INPUT_END;
            }

            // mouse must be down
            if (!this.pressed) {

                var handlers = this.manager.handlers[ev.type]
                    && this.manager.handlers[ev.type].slice();

                if(handlers && handlers.length){
                    var i = 0;
                    while (i < handlers.length) {
                        handlers[i](data);
                        i++;
                    }
                }
                return;
            }

            if (eventType & INPUT_END) {
                this.pressed = false;
            }

            this.callback(this.manager, eventType, data);
        }
    });

    var POINTER_INPUT_MAP = {
        pointerdown: INPUT_START,
        pointermove: INPUT_MOVE,
        pointerup: INPUT_END,
        pointercancel: INPUT_CANCEL,
        pointerout: INPUT_CANCEL
    };

// in IE10 the pointer types is defined as an enum
    var IE10_POINTER_TYPE_ENUM = {
        2: INPUT_TYPE_TOUCH,
        3: INPUT_TYPE_PEN,
        4: INPUT_TYPE_MOUSE,
        5: INPUT_TYPE_KINECT // see https://twitter.com/jacobrossi/status/480596438489890816
    };

    var POINTER_ELEMENT_EVENTS = 'pointerdown';
    var POINTER_WINDOW_EVENTS = 'pointermove pointerup pointercancel';

// IE10 has prefixed support, and case-sensitive
    if (window.MSPointerEvent && !window.PointerEvent) {
        POINTER_ELEMENT_EVENTS = 'MSPointerDown';
        POINTER_WINDOW_EVENTS = 'MSPointerMove MSPointerUp MSPointerCancel';
    }

    /**
     * Pointer events input
     * @constructor
     * @extends Input
     */
    function PointerEventInput() {
        this.evEl = POINTER_ELEMENT_EVENTS;
        this.evWin = POINTER_WINDOW_EVENTS;

        Input.apply(this, arguments);

        this.store = (this.manager.session.pointerEvents = []);
    }

    inherit(PointerEventInput, Input, {
        /**
         * handle mouse events
         * @param {Object} ev
         */
        handler: function PEhandler(ev) {
            var store = this.store;
            var removePointer = false;

            var eventTypeNormalized = ev.type.toLowerCase().replace('ms', '');
            var eventType = POINTER_INPUT_MAP[eventTypeNormalized];
            var pointerType = IE10_POINTER_TYPE_ENUM[ev.pointerType] || ev.pointerType;

            var isTouch = (pointerType == INPUT_TYPE_TOUCH);

            // get index of the event in the store
            var storeIndex = inArray(store, ev.pointerId, 'pointerId');

            // start and mouse must be down
            if (eventType & INPUT_START && (ev.button === 0 || isTouch)) {
                if (storeIndex < 0) {
                    store.push(ev);
                    storeIndex = store.length - 1;
                }
            } else if (eventType & (INPUT_END | INPUT_CANCEL)) {
                removePointer = true;
            }

            // it not found, so the pointer hasn't been down (so it's probably a hover)
            if (storeIndex < 0) {
                return;
            }

            // update the event in the store
            store[storeIndex] = ev;

            this.callback(this.manager, eventType, {
                pointers: store,
                changedPointers: [ev],
                pointerType: pointerType,
                srcEvent: ev
            });

            if (removePointer) {
                // remove from the store
                store.splice(storeIndex, 1);
            }
        }
    });

    var SINGLE_TOUCH_INPUT_MAP = {
        touchstart: INPUT_START,
        touchmove: INPUT_MOVE,
        touchend: INPUT_END,
        touchcancel: INPUT_CANCEL
    };

    var SINGLE_TOUCH_TARGET_EVENTS = 'touchstart';
    var SINGLE_TOUCH_WINDOW_EVENTS = 'touchstart touchmove touchend touchcancel';

    /**
     * Touch events input
     * @constructor
     * @extends Input
     */
    function SingleTouchInput() {
        this.evTarget = SINGLE_TOUCH_TARGET_EVENTS;
        this.evWin = SINGLE_TOUCH_WINDOW_EVENTS;
        this.started = false;

        Input.apply(this, arguments);
    }

    inherit(SingleTouchInput, Input, {
        handler: function TEhandler(ev) {
            var type = SINGLE_TOUCH_INPUT_MAP[ev.type];

            // should we handle the touch events?
            if (type === INPUT_START) {
                this.started = true;
            }

            if (!this.started) {
                return;
            }

            var touches = normalizeSingleTouches.call(this, ev, type);

            // when done, reset the started state
            if (type & (INPUT_END | INPUT_CANCEL) && touches[0].length - touches[1].length === 0) {
                this.started = false;
            }

            this.callback(this.manager, type, {
                pointers: touches[0],
                changedPointers: touches[1],
                pointerType: INPUT_TYPE_TOUCH,
                srcEvent: ev
            });
        }
    });

    /**
     * @this {TouchInput}
     * @param {Object} ev
     * @param {Number} type flag
     * @returns {undefined|Array} [all, changed]
     */
    function normalizeSingleTouches(ev, type) {
        var all = toArray(ev.touches);
        var changed = toArray(ev.changedTouches);

        if (type & (INPUT_END | INPUT_CANCEL)) {
            all = uniqueArray(all.concat(changed), 'identifier', true);
        }

        return [all, changed];
    }

    var TOUCH_INPUT_MAP = {
        touchstart: INPUT_START,
        touchmove: INPUT_MOVE,
        touchend: INPUT_END,
        touchcancel: INPUT_CANCEL
    };

    var TOUCH_TARGET_EVENTS = 'touchstart touchmove touchend touchcancel';

    /**
     * Multi-user touch events input
     * @constructor
     * @extends Input
     */
    function TouchInput() {
        this.evTarget = TOUCH_TARGET_EVENTS;
        this.targetIds = {};

        Input.apply(this, arguments);
    }

    inherit(TouchInput, Input, {
        handler: function MTEhandler(ev) {
            var type = TOUCH_INPUT_MAP[ev.type];
            var touches = getTouches.call(this, ev, type);
            if (!touches) {
                return;
            }

            this.callback(this.manager, type, {
                pointers: touches[0],
                changedPointers: touches[1],
                pointerType: INPUT_TYPE_TOUCH,
                srcEvent: ev
            });
        }
    });

    /**
     * @this {TouchInput}
     * @param {Object} ev
     * @param {Number} type flag
     * @returns {undefined|Array} [all, changed]
     */
    function getTouches(ev, type) {
        var allTouches = toArray(ev.touches);
        var targetIds = this.targetIds;

        // when there is only one touch, the process can be simplified
        if (type & (INPUT_START | INPUT_MOVE) && allTouches.length === 1) {
            targetIds[allTouches[0].identifier] = true;
            return [allTouches, allTouches];
        }

        var i,
            targetTouches,
            changedTouches = toArray(ev.changedTouches),
            changedTargetTouches = [],
            target = this.target;

        // get target touches from touches
        targetTouches = allTouches.filter(function(touch) {
            return hasParent(touch.target, target);
        });

        // collect touches
        if (type === INPUT_START) {
            i = 0;
            while (i < targetTouches.length) {
                targetIds[targetTouches[i].identifier] = true;
                i++;
            }
        }

        // filter changed touches to only contain touches that exist in the collected target ids
        i = 0;
        while (i < changedTouches.length) {
            if (targetIds[changedTouches[i].identifier]) {
                changedTargetTouches.push(changedTouches[i]);
            }

            // cleanup removed touches
            if (type & (INPUT_END | INPUT_CANCEL)) {
                delete targetIds[changedTouches[i].identifier];
            }
            i++;
        }

        if (!changedTargetTouches.length) {
            return;
        }

        return [
            // merge targetTouches with changedTargetTouches so it contains ALL touches, including 'end' and 'cancel'
            uniqueArray(targetTouches.concat(changedTargetTouches), 'identifier', true),
            changedTargetTouches
        ];
    }

    /**
     * Combined touch and mouse input
     *
     * Touch has a higher priority then mouse, and while touching no mouse events are allowed.
     * This because touch devices also emit mouse events while doing a touch.
     *
     * @constructor
     * @extends Input
     */

    var DEDUP_TIMEOUT = 2500;
    var DEDUP_DISTANCE = 25;

    function TouchMouseInput() {
        Input.apply(this, arguments);

        var handler = bindFn(this.handler, this);
        this.touch = new TouchInput(this.manager, handler);
        this.mouse = new MouseInput(this.manager, handler);

        this.primaryTouch = null;
        this.lastTouches = [];
    }

    inherit(TouchMouseInput, Input, {
        /**
         * handle mouse and touch events
         * @param {Hammer} manager
         * @param {String} inputEvent
         * @param {Object} inputData
         */
        handler: function TMEhandler(manager, inputEvent, inputData) {
            var isTouch = (inputData.pointerType == INPUT_TYPE_TOUCH),
                isMouse = (inputData.pointerType == INPUT_TYPE_MOUSE);

            if (isMouse && inputData.sourceCapabilities && inputData.sourceCapabilities.firesTouchEvents) {
                return;
            }

            // when we're in a touch event, record touches to  de-dupe synthetic mouse event
            if (isTouch) {
                recordTouches.call(this, inputEvent, inputData);
            } else if (isMouse && isSyntheticEvent.call(this, inputData)) {
                return;
            }

            this.callback(manager, inputEvent, inputData);
        },

        /**
         * remove the event listeners
         */
        destroy: function destroy() {
            this.touch.destroy();
            this.mouse.destroy();
        }
    });

    function recordTouches(eventType, eventData) {
        if (eventType & INPUT_START) {
            this.primaryTouch = eventData.changedPointers[0].identifier;
            setLastTouch.call(this, eventData);
        } else if (eventType & (INPUT_END | INPUT_CANCEL)) {
            setLastTouch.call(this, eventData);
        }
    }

    function setLastTouch(eventData) {
        var touch = eventData.changedPointers[0];

        if (touch.identifier === this.primaryTouch) {
            var lastTouch = {x: touch.clientX, y: touch.clientY};
            this.lastTouches.push(lastTouch);
            var lts = this.lastTouches;
            var removeLastTouch = function() {
                var i = lts.indexOf(lastTouch);
                if (i > -1) {
                    lts.splice(i, 1);
                }
            };
            setTimeout(removeLastTouch, DEDUP_TIMEOUT);
        }
    }

    function isSyntheticEvent(eventData) {
        var x = eventData.srcEvent.clientX, y = eventData.srcEvent.clientY;
        for (var i = 0; i < this.lastTouches.length; i++) {
            var t = this.lastTouches[i];
            var dx = Math.abs(x - t.x), dy = Math.abs(y - t.y);
            if (dx <= DEDUP_DISTANCE && dy <= DEDUP_DISTANCE) {
                return true;
            }
        }
        return false;
    }

    var PREFIXED_TOUCH_ACTION = prefixed(TEST_ELEMENT.style, 'touchAction');
    var NATIVE_TOUCH_ACTION = PREFIXED_TOUCH_ACTION !== undefined;

// magical touchAction value
    var TOUCH_ACTION_COMPUTE = 'compute';
    var TOUCH_ACTION_AUTO = 'auto';
    var TOUCH_ACTION_MANIPULATION = 'manipulation'; // not implemented
    var TOUCH_ACTION_NONE = 'none';
    var TOUCH_ACTION_PAN_X = 'pan-x';
    var TOUCH_ACTION_PAN_Y = 'pan-y';
    var TOUCH_ACTION_MAP = getTouchActionProps();

    /**
     * Touch Action
     * sets the touchAction property or uses the js alternative
     * @param {Manager} manager
     * @param {String} value
     * @constructor
     */
    function TouchAction(manager, value) {
        this.manager = manager;
        this.set(value);
    }

    TouchAction.prototype = {
        /**
         * set the touchAction value on the element or enable the polyfill
         * @param {String} value
         */
        set: function(value) {
            // find out the touch-action by the event handlers
            if (value == TOUCH_ACTION_COMPUTE) {
                value = this.compute();
            }

            if (NATIVE_TOUCH_ACTION && this.manager.element.style && TOUCH_ACTION_MAP[value]) {
                this.manager.element.style[PREFIXED_TOUCH_ACTION] = value;
            }
            this.actions = value.toLowerCase().trim();
        },

        /**
         * just re-set the touchAction value
         */
        update: function() {
            this.set(this.manager.options.touchAction);
        },

        /**
         * compute the value for the touchAction property based on the recognizer's settings
         * @returns {String} value
         */
        compute: function() {
            var actions = [];
            each(this.manager.recognizers, function(recognizer) {
                if (boolOrFn(recognizer.options.enable, [recognizer])) {
                    actions = actions.concat(recognizer.getTouchAction());
                }
            });
            return cleanTouchActions(actions.join(' '));
        },

        /**
         * this method is called on each input cycle and provides the preventing of the browser behavior
         * @param {Object} input
         */
        preventDefaults: function(input) {
            var srcEvent = input.srcEvent;
            var direction = input.offsetDirection;

            // if the touch action did prevented once this session
            if (this.manager.session.prevented) {
                _preventDefault(srcEvent);
                return;
            }

            var actions = this.actions;
            var hasNone = inStr(actions, TOUCH_ACTION_NONE) && !TOUCH_ACTION_MAP[TOUCH_ACTION_NONE];
            var hasPanY = inStr(actions, TOUCH_ACTION_PAN_Y) && !TOUCH_ACTION_MAP[TOUCH_ACTION_PAN_Y];
            var hasPanX = inStr(actions, TOUCH_ACTION_PAN_X) && !TOUCH_ACTION_MAP[TOUCH_ACTION_PAN_X];

            if (hasNone) {
                //do not prevent defaults if this is a tap gesture

                var isTapPointer = input.pointers.length === 1;
                var isTapMovement = input.distance < 2;
                var isTapTouchTime = input.deltaTime < 250;

                if (isTapPointer && isTapMovement && isTapTouchTime) {
                    return;
                }
            }

            if (hasPanX && hasPanY) {
                // `pan-x pan-y` means browser handles all scrolling/panning, do not prevent
                return;
            }

            if (hasNone ||
                (hasPanY && direction & DIRECTION_HORIZONTAL) ||
                (hasPanX && direction & DIRECTION_VERTICAL)) {
                return this.preventSrc(srcEvent);
            }
        },

        /**
         * call preventDefault to prevent the browser's default behavior (scrolling in most cases)
         * @param {Object} srcEvent
         */
        preventSrc: function(srcEvent) {
            this.manager.session.prevented = true;
            _preventDefault(srcEvent);
        }
    };

    /**
     * when the touchActions are collected they are not a valid value, so we need to clean things up. *
     * @param {String} actions
     * @returns {*}
     */
    function cleanTouchActions(actions) {
        // none
        if (inStr(actions, TOUCH_ACTION_NONE)) {
            return TOUCH_ACTION_NONE;
        }

        var hasPanX = inStr(actions, TOUCH_ACTION_PAN_X);
        var hasPanY = inStr(actions, TOUCH_ACTION_PAN_Y);

        // if both pan-x and pan-y are set (different recognizers
        // for different directions, e.g. horizontal pan but vertical swipe?)
        // we need none (as otherwise with pan-x pan-y combined none of these
        // recognizers will work, since the browser would handle all panning
        if (hasPanX && hasPanY) {
            return TOUCH_ACTION_NONE;
        }

        // pan-x OR pan-y
        if (hasPanX || hasPanY) {
            return hasPanX ? TOUCH_ACTION_PAN_X : TOUCH_ACTION_PAN_Y;
        }

        // manipulation
        if (inStr(actions, TOUCH_ACTION_MANIPULATION)) {
            return TOUCH_ACTION_MANIPULATION;
        }

        return TOUCH_ACTION_AUTO;
    }

    function getTouchActionProps() {
        if (!NATIVE_TOUCH_ACTION) {
            return false;
        }
        var touchMap = {};
        var cssSupports = window.CSS && window.CSS.supports;
        ['auto', 'manipulation', 'pan-y', 'pan-x', 'pan-x pan-y', 'none'].forEach(function(val) {

            // If css.supports is not supported but there is native touch-action assume it supports
            // all values. This is the case for IE 10 and 11.
            touchMap[val] = cssSupports ? window.CSS.supports('touch-action', val) : true;
        });
        return touchMap;
    }

    /**
     * Recognizer flow explained; *
     * All recognizers have the initial state of POSSIBLE when a input session starts.
     * The definition of a input session is from the first input until the last input, with all it's movement in it. *
     * Example session for mouse-input: mousedown -> mousemove -> mouseup
     *
     * On each recognizing cycle (see Manager.recognize) the .recognize() method is executed
     * which determines with state it should be.
     *
     * If the recognizer has the state FAILED, CANCELLED or RECOGNIZED (equals ENDED), it is reset to
     * POSSIBLE to give it another change on the next cycle.
     *
     *               Possible
     *                  |
     *            +-----+---------------+
     *            |                     |
     *      +-----+-----+               |
     *      |           |               |
     *   Failed      Cancelled          |
     *                          +-------+------+
     *                          |              |
     *                      Recognized       Began
     *                                         |
     *                                      Changed
     *                                         |
     *                                  Ended/Recognized
     */
    var STATE_POSSIBLE = 1;
    var STATE_BEGAN = 2;
    var STATE_CHANGED = 4;
    var STATE_ENDED = 8;
    var STATE_RECOGNIZED = STATE_ENDED;
    var STATE_CANCELLED = 16;
    var STATE_FAILED = 32;

    /**
     * Recognizer
     * Every recognizer needs to extend from this class.
     * @constructor
     * @param {Object} options
     */
    function Recognizer(options) {
        this.options = assign({}, this.defaults, options || {});

        this.id = uniqueId();

        this.manager = null;

        // default is enable true
        this.options.enable = ifUndefined(this.options.enable, true);

        this.state = STATE_POSSIBLE;

        this.simultaneous = {};
        this.requireFail = [];
    }

    Recognizer.prototype = {
        /**
         * @virtual
         * @type {Object}
         */
        defaults: {},

        /**
         * set options
         * @param {Object} options
         * @return {Recognizer}
         */
        set: function(options) {
            assign(this.options, options);

            // also update the touchAction, in case something changed about the directions/enabled state
            this.manager && this.manager.touchAction.update();
            return this;
        },

        /**
         * recognize simultaneous with an other recognizer.
         * @param {Recognizer} otherRecognizer
         * @returns {Recognizer} this
         */
        recognizeWith: function(otherRecognizer) {
            if (invokeArrayArg(otherRecognizer, 'recognizeWith', this)) {
                return this;
            }

            var simultaneous = this.simultaneous;
            otherRecognizer = getRecognizerByNameIfManager(otherRecognizer, this);
            if (!simultaneous[otherRecognizer.id]) {
                simultaneous[otherRecognizer.id] = otherRecognizer;
                otherRecognizer.recognizeWith(this);
            }
            return this;
        },

        /**
         * drop the simultaneous link. it doesnt remove the link on the other recognizer.
         * @param {Recognizer} otherRecognizer
         * @returns {Recognizer} this
         */
        dropRecognizeWith: function(otherRecognizer) {
            if (invokeArrayArg(otherRecognizer, 'dropRecognizeWith', this)) {
                return this;
            }

            otherRecognizer = getRecognizerByNameIfManager(otherRecognizer, this);
            delete this.simultaneous[otherRecognizer.id];
            return this;
        },

        /**
         * recognizer can only run when an other is failing
         * @param {Recognizer} otherRecognizer
         * @returns {Recognizer} this
         */
        requireFailure: function(otherRecognizer) {
            if (invokeArrayArg(otherRecognizer, 'requireFailure', this)) {
                return this;
            }

            var requireFail = this.requireFail;
            otherRecognizer = getRecognizerByNameIfManager(otherRecognizer, this);
            if (inArray(requireFail, otherRecognizer) === -1) {
                requireFail.push(otherRecognizer);
                otherRecognizer.requireFailure(this);
            }
            return this;
        },

        /**
         * drop the requireFailure link. it does not remove the link on the other recognizer.
         * @param {Recognizer} otherRecognizer
         * @returns {Recognizer} this
         */
        dropRequireFailure: function(otherRecognizer) {
            if (invokeArrayArg(otherRecognizer, 'dropRequireFailure', this)) {
                return this;
            }

            otherRecognizer = getRecognizerByNameIfManager(otherRecognizer, this);
            var index = inArray(this.requireFail, otherRecognizer);
            if (index > -1) {
                this.requireFail.splice(index, 1);
            }
            return this;
        },

        /**
         * has require failures boolean
         * @returns {boolean}
         */
        hasRequireFailures: function() {
            return this.requireFail.length > 0;
        },

        /**
         * if the recognizer can recognize simultaneous with an other recognizer
         * @param {Recognizer} otherRecognizer
         * @returns {Boolean}
         */
        canRecognizeWith: function(otherRecognizer) {
            return !!this.simultaneous[otherRecognizer.id];
        },

        /**
         * You should use `tryEmit` instead of `emit` directly to check
         * that all the needed recognizers has failed before emitting.
         * @param {Object} input
         */
        emit: function(input) {
            var self = this;
            var state = this.state;

            function emit(event) {
                self.manager.emit(event, input);
            }

            // 'panstart' and 'panmove'
            if (state < STATE_ENDED) {
                emit(self.options.event + stateStr(state));
            }

            emit(self.options.event); // simple 'eventName' events

            if (input.additionalEvent) { // additional event(panleft, panright, pinchin, pinchout...)
                emit(input.additionalEvent);
            }

            // panend and pancancel
            if (state >= STATE_ENDED) {
                emit(self.options.event + stateStr(state));
            }
        },

        /**
         * Check that all the require failure recognizers has failed,
         * if true, it emits a gesture event,
         * otherwise, setup the state to FAILED.
         * @param {Object} input
         */
        tryEmit: function(input) {
            if (this.canEmit()) {
                return this.emit(input);
            }
            // it's failing anyway
            this.state = STATE_FAILED;
        },

        /**
         * can we emit?
         * @returns {boolean}
         */
        canEmit: function() {
            var i = 0;
            while (i < this.requireFail.length) {
                if (!(this.requireFail[i].state & (STATE_FAILED | STATE_POSSIBLE))) {
                    return false;
                }
                i++;
            }
            return true;
        },

        /**
         * update the recognizer
         * @param {Object} inputData
         */
        recognize: function(inputData) {
            // make a new copy of the inputData
            // so we can change the inputData without messing up the other recognizers
            var inputDataClone = assign({}, inputData);

            // is is enabled and allow recognizing?
            if (!boolOrFn(this.options.enable, [this, inputDataClone])) {
                this.reset();
                this.state = STATE_FAILED;
                return;
            }

            // reset when we've reached the end
            if (this.state & (STATE_RECOGNIZED | STATE_CANCELLED | STATE_FAILED)) {
                this.state = STATE_POSSIBLE;
            }

            this.state = this.process(inputDataClone);

            // the recognizer has recognized a gesture
            // so trigger an event
            if (this.state & (STATE_BEGAN | STATE_CHANGED | STATE_ENDED | STATE_CANCELLED)) {
                this.tryEmit(inputDataClone);
            }
        },

        /**
         * return the state of the recognizer
         * the actual recognizing happens in this method
         * @virtual
         * @param {Object} inputData
         * @returns {Const} STATE
         */
        process: function(inputData) { }, // jshint ignore:line

        /**
         * return the preferred touch-action
         * @virtual
         * @returns {Array}
         */
        getTouchAction: function() { },

        /**
         * called when the gesture isn't allowed to recognize
         * like when another is being recognized or it is disabled
         * @virtual
         */
        reset: function() { }
    };

    /**
     * get a usable string, used as event postfix
     * @param {Const} state
     * @returns {String} state
     */
    function stateStr(state) {
        if (state & STATE_CANCELLED) {
            return 'cancel';
        } else if (state & STATE_ENDED) {
            return 'end';
        } else if (state & STATE_CHANGED) {
            return 'move';
        } else if (state & STATE_BEGAN) {
            return 'start';
        }
        return '';
    }

    /**
     * direction cons to string
     * @param {Const} direction
     * @returns {String}
     */
    function directionStr(direction) {
        if (direction == DIRECTION_DOWN) {
            return 'down';
        } else if (direction == DIRECTION_UP) {
            return 'up';
        } else if (direction == DIRECTION_LEFT) {
            return 'left';
        } else if (direction == DIRECTION_RIGHT) {
            return 'right';
        }
        return '';
    }

    /**
     * get a recognizer by name if it is bound to a manager
     * @param {Recognizer|String} otherRecognizer
     * @param {Recognizer} recognizer
     * @returns {Recognizer}
     */
    function getRecognizerByNameIfManager(otherRecognizer, recognizer) {
        var manager = recognizer.manager;
        if (manager) {
            return manager.get(otherRecognizer);
        }
        return otherRecognizer;
    }

    /**
     * This recognizer is just used as a base for the simple attribute recognizers.
     * @constructor
     * @extends Recognizer
     */
    function AttrRecognizer() {
        Recognizer.apply(this, arguments);
    }

    inherit(AttrRecognizer, Recognizer, {
        /**
         * @namespace
         * @memberof AttrRecognizer
         */
        defaults: {
            /**
             * @type {Number}
             * @default 1
             */
            pointers: 1
        },

        /**
         * Used to check if it the recognizer receives valid input, like input.distance > 10.
         * @memberof AttrRecognizer
         * @param {Object} input
         * @returns {Boolean} recognized
         */
        attrTest: function(input) {
            var optionPointers = this.options.pointers;
            return optionPointers === 0 || input.pointers.length === optionPointers;
        },

        /**
         * Process the input and return the state for the recognizer
         * @memberof AttrRecognizer
         * @param {Object} input
         * @returns {*} State
         */
        process: function(input) {
            var state = this.state;
            var eventType = input.eventType;

            var isRecognized = state & (STATE_BEGAN | STATE_CHANGED);
            var isValid = this.attrTest(input);

            // on cancel input and we've recognized before, return STATE_CANCELLED
            if (isRecognized && (eventType & INPUT_CANCEL || !isValid)) {
                return state | STATE_CANCELLED;
            } else if (isRecognized || isValid) {
                if (eventType & INPUT_END) {
                    return state | STATE_ENDED;
                } else if (!(state & STATE_BEGAN)) {
                    return STATE_BEGAN;
                }
                return state | STATE_CHANGED;
            }
            return STATE_FAILED;
        }
    });

    /**
     * Pan
     * Recognized when the pointer is down and moved in the allowed direction.
     * @constructor
     * @extends AttrRecognizer
     */
    function PanRecognizer() {
        AttrRecognizer.apply(this, arguments);

        this.pX = null;
        this.pY = null;
    }

    inherit(PanRecognizer, AttrRecognizer, {
        /**
         * @namespace
         * @memberof PanRecognizer
         */
        defaults: {
            event: 'pan',
            threshold: 10,
            pointers: 1,
            direction: DIRECTION_ALL
        },

        getTouchAction: function() {
            var direction = this.options.direction;
            var actions = [];
            if (direction & DIRECTION_HORIZONTAL) {
                actions.push(TOUCH_ACTION_PAN_Y);
            }
            if (direction & DIRECTION_VERTICAL) {
                actions.push(TOUCH_ACTION_PAN_X);
            }
            return actions;
        },

        directionTest: function(input) {
            var options = this.options;
            var hasMoved = true;
            var distance = input.distance;
            var direction = input.direction;
            var x = input.deltaX;
            var y = input.deltaY;

            // lock to axis?
            if (!(direction & options.direction)) {
                if (options.direction & DIRECTION_HORIZONTAL) {
                    direction = (x === 0) ? DIRECTION_NONE : (x < 0) ? DIRECTION_LEFT : DIRECTION_RIGHT;
                    hasMoved = x != this.pX;
                    distance = Math.abs(input.deltaX);
                } else {
                    direction = (y === 0) ? DIRECTION_NONE : (y < 0) ? DIRECTION_UP : DIRECTION_DOWN;
                    hasMoved = y != this.pY;
                    distance = Math.abs(input.deltaY);
                }
            }
            input.direction = direction;

            return hasMoved && distance > options.threshold && direction & options.direction;
        },

        attrTest: function(input) {
            return AttrRecognizer.prototype.attrTest.call(this, input) &&
                (this.state & STATE_BEGAN || (!(this.state & STATE_BEGAN) && this.directionTest(input)));
        },

        emit: function(input) {

            this.pX = input.deltaX;
            this.pY = input.deltaY;

            var direction = directionStr(input.direction);

            if (direction) {
                input.additionalEvent = this.options.event + direction;
            }
            this._super.emit.call(this, input);
        }
    });

    /**
     * Pinch
     * Recognized when two or more pointers are moving toward (zoom-in) or away from each other (zoom-out).
     * @constructor
     * @extends AttrRecognizer
     */
    function PinchRecognizer() {
        AttrRecognizer.apply(this, arguments);
    }

    inherit(PinchRecognizer, AttrRecognizer, {
        /**
         * @namespace
         * @memberof PinchRecognizer
         */
        defaults: {
            event: 'pinch',
            threshold: 0,
            pointers: 2
        },

        getTouchAction: function() {
            return [TOUCH_ACTION_NONE];
        },

        attrTest: function(input) {
            return this._super.attrTest.call(this, input) &&
                (Math.abs(input.scale - 1) > this.options.threshold || this.state & STATE_BEGAN);
        },

        emit: function(input) {
            if (input.scale !== 1) {
                var inOut = input.scale < 1 ? 'in' : 'out';
                input.additionalEvent = this.options.event + inOut;
            }
            this._super.emit.call(this, input);
        }
    });

    /**
     * Press
     * Recognized when the pointer is down for x ms without any movement.
     * @constructor
     * @extends Recognizer
     */
    function PressRecognizer() {
        Recognizer.apply(this, arguments);

        this._timer = null;
        this._input = null;
    }

    inherit(PressRecognizer, Recognizer, {
        /**
         * @namespace
         * @memberof PressRecognizer
         */
        defaults: {
            event: 'press',
            pointers: 1,
            time: 251, // minimal time of the pointer to be pressed
            threshold: 9 // a minimal movement is ok, but keep it low
        },

        getTouchAction: function() {
            return [TOUCH_ACTION_AUTO];
        },

        process: function(input) {
            var options = this.options;
            var validPointers = input.pointers.length === options.pointers;
            var validMovement = input.distance < options.threshold;
            var validTime = input.deltaTime > options.time;

            this._input = input;

            // we only allow little movement
            // and we've reached an end event, so a tap is possible
            if (!validMovement || !validPointers || (input.eventType & (INPUT_END | INPUT_CANCEL) && !validTime)) {
                this.reset();
            } else if (input.eventType & INPUT_START) {
                this.reset();
                this._timer = setTimeoutContext(function() {
                    this.state = STATE_RECOGNIZED;
                    this.tryEmit();
                }, options.time, this);
            } else if (input.eventType & INPUT_END) {
                return STATE_RECOGNIZED;
            }
            return STATE_FAILED;
        },

        reset: function() {
            clearTimeout(this._timer);
        },

        emit: function(input) {
            if (this.state !== STATE_RECOGNIZED) {
                return;
            }

            if (input && (input.eventType & INPUT_END)) {
                this.manager.emit(this.options.event + 'up', input);
            } else {
                this._input.timeStamp = now();
                this.manager.emit(this.options.event, this._input);
            }
        }
    });

    /**
     * Rotate
     * Recognized when two or more pointer are moving in a circular motion.
     * @constructor
     * @extends AttrRecognizer
     */
    function RotateRecognizer() {
        AttrRecognizer.apply(this, arguments);
    }

    inherit(RotateRecognizer, AttrRecognizer, {
        /**
         * @namespace
         * @memberof RotateRecognizer
         */
        defaults: {
            event: 'rotate',
            threshold: 0,
            pointers: 2
        },

        getTouchAction: function() {
            return [TOUCH_ACTION_NONE];
        },

        attrTest: function(input) {
            return this._super.attrTest.call(this, input) &&
                (Math.abs(input.rotation) > this.options.threshold || this.state & STATE_BEGAN);
        }
    });

    /**
     * Swipe
     * Recognized when the pointer is moving fast (velocity), with enough distance in the allowed direction.
     * @constructor
     * @extends AttrRecognizer
     */
    function SwipeRecognizer() {
        AttrRecognizer.apply(this, arguments);
    }

    inherit(SwipeRecognizer, AttrRecognizer, {
        /**
         * @namespace
         * @memberof SwipeRecognizer
         */
        defaults: {
            event: 'swipe',
            threshold: 10,
            velocity: 0.3,
            direction: DIRECTION_HORIZONTAL | DIRECTION_VERTICAL,
            pointers: 1
        },

        getTouchAction: function() {
            return PanRecognizer.prototype.getTouchAction.call(this);
        },

        attrTest: function(input) {
            var direction = this.options.direction;
            var velocity;

            if (direction & (DIRECTION_HORIZONTAL | DIRECTION_VERTICAL)) {
                velocity = input.overallVelocity;
            } else if (direction & DIRECTION_HORIZONTAL) {
                velocity = input.overallVelocityX;
            } else if (direction & DIRECTION_VERTICAL) {
                velocity = input.overallVelocityY;
            }

            return this._super.attrTest.call(this, input) &&
                direction & input.offsetDirection &&
                input.distance > this.options.threshold &&
                input.maxPointers == this.options.pointers &&
                abs(velocity) > this.options.velocity && input.eventType & INPUT_END;
        },

        emit: function(input) {
            var direction = directionStr(input.offsetDirection);
            if (direction) {
                this.manager.emit(this.options.event + direction, input);
            }

            this.manager.emit(this.options.event, input);
        }
    });

    /**
     * A tap is ecognized when the pointer is doing a small tap/click. Multiple taps are recognized if they occur
     * between the given interval and position. The delay option can be used to recognize multi-taps without firing
     * a single tap.
     *
     * The eventData from the emitted event contains the property `tapCount`, which contains the amount of
     * multi-taps being recognized.
     * @constructor
     * @extends Recognizer
     */
    function TapRecognizer() {
        Recognizer.apply(this, arguments);

        // previous time and center,
        // used for tap counting
        this.pTime = false;
        this.pCenter = false;

        this._timer = null;
        this._input = null;
        this.count = 0;
    }

    inherit(TapRecognizer, Recognizer, {
        /**
         * @namespace
         * @memberof PinchRecognizer
         */
        defaults: {
            event: 'tap',
            pointers: 1,
            taps: 1,
            interval: 300, // max time between the multi-tap taps
            time: 250, // max time of the pointer to be down (like finger on the screen)
            threshold: 9, // a minimal movement is ok, but keep it low
            posThreshold: 10 // a multi-tap can be a bit off the initial position
        },

        getTouchAction: function() {
            return [TOUCH_ACTION_MANIPULATION];
        },

        process: function(input) {
            var options = this.options;

            var validPointers = input.pointers.length === options.pointers;
            var validMovement = input.distance < options.threshold;
            var validTouchTime = input.deltaTime < options.time;

            this.reset();

            if ((input.eventType & INPUT_START) && (this.count === 0)) {
                return this.failTimeout();
            }

            // we only allow little movement
            // and we've reached an end event, so a tap is possible
            if (validMovement && validTouchTime && validPointers) {
                if (input.eventType != INPUT_END) {
                    return this.failTimeout();
                }

                var validInterval = this.pTime ? (input.timeStamp - this.pTime < options.interval) : true;
                var validMultiTap = !this.pCenter || getDistance(this.pCenter, input.center) < options.posThreshold;

                this.pTime = input.timeStamp;
                this.pCenter = input.center;

                if (!validMultiTap || !validInterval) {
                    this.count = 1;
                } else {
                    this.count += 1;
                }

                this._input = input;

                // if tap count matches we have recognized it,
                // else it has began recognizing...
                var tapCount = this.count % options.taps;
                if (tapCount === 0) {
                    // no failing requirements, immediately trigger the tap event
                    // or wait as long as the multitap interval to trigger
                    if (!this.hasRequireFailures()) {
                        return STATE_RECOGNIZED;
                    } else {
                        this._timer = setTimeoutContext(function() {
                            this.state = STATE_RECOGNIZED;
                            this.tryEmit();
                        }, options.interval, this);
                        return STATE_BEGAN;
                    }
                }
            }
            return STATE_FAILED;
        },

        failTimeout: function() {
            this._timer = setTimeoutContext(function() {
                this.state = STATE_FAILED;
            }, this.options.interval, this);
            return STATE_FAILED;
        },

        reset: function() {
            clearTimeout(this._timer);
        },

        emit: function() {
            if (this.state == STATE_RECOGNIZED) {
                this._input.tapCount = this.count;
                this.manager.emit(this.options.event, this._input);
            }
        }
    });

    /**
     * Simple way to create a manager with a default set of recognizers.
     * @param {HTMLElement} element
     * @param {Object} [options]
     * @constructor
     */
    function Hammer(element, options) {
        options = options || {};
        options.recognizers = ifUndefined(options.recognizers, Hammer.defaults.preset);
        return new Manager(element, options);
    }

    /**
     * @const {string}
     */
    Hammer.VERSION = '2.0.7';

    /**
     * default settings
     * @namespace
     */
    Hammer.defaults = {
        /**
         * set if DOM events are being triggered.
         * But this is slower and unused by simple implementations, so disabled by default.
         * @type {Boolean}
         * @default false
         */
        domEvents: false,

        /**
         * The value for the touchAction property/fallback.
         * When set to `compute` it will magically set the correct value based on the added recognizers.
         * @type {String}
         * @default compute
         */
        touchAction: TOUCH_ACTION_COMPUTE,

        /**
         * @type {Boolean}
         * @default true
         */
        enable: true,

        /**
         * EXPERIMENTAL FEATURE -- can be removed/changed
         * Change the parent input target element.
         * If Null, then it is being set the to main element.
         * @type {Null|EventTarget}
         * @default null
         */
        inputTarget: null,

        /**
         * force an input class
         * @type {Null|Function}
         * @default null
         */
        inputClass: null,

        /**
         * Default recognizer setup when calling `Hammer()`
         * When creating a new Manager these will be skipped.
         * @type {Array}
         */
        preset: [
            // RecognizerClass, options, [recognizeWith, ...], [requireFailure, ...]
            [RotateRecognizer, {enable: false}],
            [PinchRecognizer, {enable: false}, ['rotate']],
            [SwipeRecognizer, {direction: DIRECTION_HORIZONTAL}],
            [PanRecognizer, {direction: DIRECTION_HORIZONTAL}, ['swipe']],
            [TapRecognizer],
            [TapRecognizer, {event: 'doubletap', taps: 2}, ['tap']],
            [PressRecognizer]
        ],

        /**
         * Some CSS properties can be used to improve the working of Hammer.
         * Add them to this method and they will be set when creating a new Manager.
         * @namespace
         */
        cssProps: {
            /**
             * Disables text selection to improve the dragging gesture. Mainly for desktop browsers.
             * @type {String}
             * @default 'none'
             */
            userSelect: 'none',

            /**
             * Disable the Windows Phone grippers when pressing an element.
             * @type {String}
             * @default 'none'
             */
            touchSelect: 'none',

            /**
             * Disables the default callout shown when you touch and hold a touch target.
             * On iOS, when you touch and hold a touch target such as a link, Safari displays
             * a callout containing information about the link. This property allows you to disable that callout.
             * @type {String}
             * @default 'none'
             */
            touchCallout: 'none',

            /**
             * Specifies whether zooming is enabled. Used by IE10>
             * @type {String}
             * @default 'none'
             */
            contentZooming: 'none',

            /**
             * Specifies that an entire element should be draggable instead of its contents. Mainly for desktop browsers.
             * @type {String}
             * @default 'none'
             */
            userDrag: 'none',

            /**
             * Overrides the highlight color shown when the user taps a link or a JavaScript
             * clickable element in iOS. This property obeys the alpha value, if specified.
             * @type {String}
             * @default 'rgba(0,0,0,0)'
             */
            tapHighlightColor: 'rgba(0,0,0,0)'
        }
    };

    var STOP = 1;
    var FORCED_STOP = 2;

    /**
     * Manager
     * @param {HTMLElement} element
     * @param {Object} [options]
     * @constructor
     */
    function Manager(element, options) {
        this.options = assign({}, Hammer.defaults, options || {});

        this.options.inputTarget = this.options.inputTarget || element;

        this.handlers = {};
        this.session = {};
        this.recognizers = [];
        this.oldCssProps = {};

        this.element = element;
        this.input = createInputInstance(this);
        this.touchAction = new TouchAction(this, this.options.touchAction);

        toggleCssProps(this, true);

        each(this.options.recognizers, function(item) {
            var recognizer = this.add(new (item[0])(item[1]));
            item[2] && recognizer.recognizeWith(item[2]);
            item[3] && recognizer.requireFailure(item[3]);
        }, this);
    }

    Manager.prototype = {
        /**
         * set options
         * @param {Object} options
         * @returns {Manager}
         */
        set: function(options) {
            assign(this.options, options);

            // Options that need a little more setup
            if (options.touchAction) {
                this.touchAction.update();
            }
            if (options.inputTarget) {
                // Clean up existing event listeners and reinitialize
                this.input.destroy();
                this.input.target = options.inputTarget;
                this.input.init();
            }
            return this;
        },

        /**
         * stop recognizing for this session.
         * This session will be discarded, when a new [input]start event is fired.
         * When forced, the recognizer cycle is stopped immediately.
         * @param {Boolean} [force]
         */
        stop: function(force) {
            this.session.stopped = force ? FORCED_STOP : STOP;
        },

        /**
         * run the recognizers!
         * called by the inputHandler function on every movement of the pointers (touches)
         * it walks through all the recognizers and tries to detect the gesture that is being made
         * @param {Object} inputData
         */
        recognize: function(inputData) {
            var session = this.session;
            if (session.stopped) {
                return;
            }

            // run the touch-action polyfill
            this.touchAction.preventDefaults(inputData);

            var recognizer;
            var recognizers = this.recognizers;

            // this holds the recognizer that is being recognized.
            // so the recognizer's state needs to be BEGAN, CHANGED, ENDED or RECOGNIZED
            // if no recognizer is detecting a thing, it is set to `null`
            var curRecognizer = session.curRecognizer;

            // reset when the last recognizer is recognized
            // or when we're in a new session
            if (!curRecognizer || (curRecognizer && curRecognizer.state & STATE_RECOGNIZED)) {
                curRecognizer = session.curRecognizer = null;
            }

            var i = 0;
            while (i < recognizers.length) {
                recognizer = recognizers[i];

                // find out if we are allowed try to recognize the input for this one.
                // 1.   allow if the session is NOT forced stopped (see the .stop() method)
                // 2.   allow if we still haven't recognized a gesture in this session, or the this recognizer is the one
                //      that is being recognized.
                // 3.   allow if the recognizer is allowed to run simultaneous with the current recognized recognizer.
                //      this can be setup with the `recognizeWith()` method on the recognizer.
                if (session.stopped !== FORCED_STOP && ( // 1
                    !curRecognizer || recognizer == curRecognizer || // 2
                    recognizer.canRecognizeWith(curRecognizer))) { // 3
                    recognizer.recognize(inputData);
                } else {
                    recognizer.reset();
                }

                // if the recognizer has been recognizing the input as a valid gesture, we want to store this one as the
                // current active recognizer. but only if we don't already have an active recognizer
                if (!curRecognizer && recognizer.state & (STATE_BEGAN | STATE_CHANGED | STATE_ENDED)) {
                    curRecognizer = session.curRecognizer = recognizer;
                }
                i++;
            }
        },

        /**
         * get a recognizer by its event name.
         * @param {Recognizer|String} recognizer
         * @returns {Recognizer|Null}
         */
        get: function(recognizer) {
            if (recognizer instanceof Recognizer) {
                return recognizer;
            }

            var recognizers = this.recognizers;
            for (var i = 0; i < recognizers.length; i++) {
                if (recognizers[i].options.event == recognizer) {
                    return recognizers[i];
                }
            }
            return null;
        },

        /**
         * add a recognizer to the manager
         * existing recognizers with the same event name will be removed
         * @param {Recognizer} recognizer
         * @returns {Recognizer|Manager}
         */
        add: function(recognizer) {
            if (invokeArrayArg(recognizer, 'add', this)) {
                return this;
            }

            // remove existing
            var existing = this.get(recognizer.options.event);
            if (existing) {
                this.remove(existing);
            }

            this.recognizers.push(recognizer);
            recognizer.manager = this;

            this.touchAction.update();
            return recognizer;
        },

        /**
         * remove a recognizer by name or instance
         * @param {Recognizer|String} recognizer
         * @returns {Manager}
         */
        remove: function(recognizer) {
            if (invokeArrayArg(recognizer, 'remove', this)) {
                return this;
            }

            recognizer = this.get(recognizer);

            // let's make sure this recognizer exists
            if (recognizer) {
                var recognizers = this.recognizers;
                var index = inArray(recognizers, recognizer);

                if (index !== -1) {
                    recognizers.splice(index, 1);
                    this.touchAction.update();
                }
            }

            return this;
        },

        /**
         * bind event
         * @param {String} events
         * @param {Function} handler
         * @returns {EventEmitter} this
         */
        on: function(events, handler) {
            if (events === undefined) {
                return;
            }
            if (handler === undefined) {
                return;
            }

            var handlers = this.handlers;
            each(splitStr(events), function(event) {
                handlers[event] = handlers[event] || [];
                handlers[event].push(handler);
            });
            return this;
        },

        /**
         * unbind event, leave emit blank to remove all handlers
         * @param {String} events
         * @param {Function} [handler]
         * @returns {EventEmitter} this
         */
        off: function(events, handler) {
            if (events === undefined) {
                return;
            }

            var handlers = this.handlers;
            each(splitStr(events), function(event) {
                if (!handler) {
                    delete handlers[event];
                } else {
                    handlers[event] && handlers[event].splice(inArray(handlers[event], handler), 1);
                }
            });
            return this;
        },

        /**
         * emit event to the listeners
         * @param {String} event
         * @param {Object} data
         */
        emit: function(event, data) {
            // we also want to trigger dom events
            if (this.options.domEvents) {
                triggerDomEvent(event, data);
            }

            // no handlers, so skip it all
            var handlers = this.handlers[event] && this.handlers[event].slice();
            if (!handlers || !handlers.length) {
                return;
            }

            data.type = event;
            data.preventDefault = function() {
                _preventDefault(data.srcEvent);
            };

            var i = 0;
            while (i < handlers.length) {
                handlers[i](data);
                i++;
            }
        },

        /**
         * destroy the manager and unbinds all events
         * it doesn't unbind dom events, that is the user own responsibility
         */
        destroy: function() {
            this.element && toggleCssProps(this, false);

            this.handlers = {};
            this.session = {};
            this.input.destroy();
            this.element = null;
        }
    };

    /**
     * add/remove the css properties as defined in manager.options.cssProps
     * @param {Manager} manager
     * @param {Boolean} add
     */
    function toggleCssProps(manager, add) {
        var element = manager.element;
        if (!element.style) {
            return;
        }
        var prop;
        each(manager.options.cssProps, function(value, name) {
            prop = prefixed(element.style, name);
            if (add) {
                manager.oldCssProps[prop] = element.style[prop];
                element.style[prop] = value;
            } else {
                element.style[prop] = manager.oldCssProps[prop] || '';
            }
        });
        if (!add) {
            manager.oldCssProps = {};
        }
    }

    /**
     * trigger dom event
     * @param {String} event
     * @param {Object} data
     */
    function triggerDomEvent(event, data) {
        var gestureEvent = document.createEvent('Event');
        gestureEvent.initEvent(event, true, true);
        gestureEvent.gesture = data;
        data.target.dispatchEvent(gestureEvent);
    }

    assign(Hammer, {
        INPUT_START: INPUT_START,
        INPUT_MOVE: INPUT_MOVE,
        INPUT_END: INPUT_END,
        INPUT_CANCEL: INPUT_CANCEL,

        STATE_POSSIBLE: STATE_POSSIBLE,
        STATE_BEGAN: STATE_BEGAN,
        STATE_CHANGED: STATE_CHANGED,
        STATE_ENDED: STATE_ENDED,
        STATE_RECOGNIZED: STATE_RECOGNIZED,
        STATE_CANCELLED: STATE_CANCELLED,
        STATE_FAILED: STATE_FAILED,

        DIRECTION_NONE: DIRECTION_NONE,
        DIRECTION_LEFT: DIRECTION_LEFT,
        DIRECTION_RIGHT: DIRECTION_RIGHT,
        DIRECTION_UP: DIRECTION_UP,
        DIRECTION_DOWN: DIRECTION_DOWN,
        DIRECTION_HORIZONTAL: DIRECTION_HORIZONTAL,
        DIRECTION_VERTICAL: DIRECTION_VERTICAL,
        DIRECTION_ALL: DIRECTION_ALL,

        Manager: Manager,
        Input: Input,
        TouchAction: TouchAction,

        TouchInput: TouchInput,
        MouseInput: MouseInput,
        PointerEventInput: PointerEventInput,
        TouchMouseInput: TouchMouseInput,
        SingleTouchInput: SingleTouchInput,

        Recognizer: Recognizer,
        AttrRecognizer: AttrRecognizer,
        Tap: TapRecognizer,
        Pan: PanRecognizer,
        Swipe: SwipeRecognizer,
        Pinch: PinchRecognizer,
        Rotate: RotateRecognizer,
        Press: PressRecognizer,

        on: addEventListeners,
        off: removeEventListeners,
        each: each,
        merge: merge,
        extend: extend,
        assign: assign,
        inherit: inherit,
        bindFn: bindFn,
        prefixed: prefixed
    });

// this prevents errors when Hammer is loaded in the presence of an AMD
//  style loader but by script tag, not by the loader.
    var freeGlobal = (typeof window !== 'undefined' ? window : (typeof self !== 'undefined' ? self : {})); // jshint ignore:line
    freeGlobal.Hammer = Hammer;

    if (typeof define === 'function' && define.amd) {
        define('hammer',[],function() {
            return Hammer;
        });
    } else if (typeof module != 'undefined' && module.exports) {
        module.exports = Hammer;
    } else {
        window[exportName] = Hammer;
    }

})(window, document, 'Hammer');

/**
 * Created by eason on 15/6/30.
 * some of the following methods are borrowed from zrender
 */

//Copyright (c) 2013, Baidu Inc.
//    All rights reserved.
//
//    Redistribution and use of this software in source and binary forms, with or
//    without modification, are permitted provided that the following conditions
//are met:
//
//    Redistributions of source code must retain the above copyright notice, this
//list of conditions and the following disclaimer.
//
//    Redistributions in binary form must reproduce the above copyright notice,
//    this list of conditions and the following disclaimer in the documentation
//and/or other materials provided with the distribution.
//
//    Neither the name of Baidu Inc. nor the names of its contributors may be used
//to endorse or promote products derived from this software without specific
//prior written permission of Baidu Inc.
//
//    THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
//AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
//IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
//DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR
//ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
//(INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
//LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON
//ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
//(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
//SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.

define('utils/ColorUtils',[],function(){
    var _nameColors = {
        aliceblue : '#f0f8ff',
        antiquewhite : '#faebd7',
        aqua : '#0ff',
        aquamarine : '#7fffd4',
        azure : '#f0ffff',
        beige : '#f5f5dc',
        bisque : '#ffe4c4',
        black : '#000',
        blanchedalmond : '#ffebcd',
        blue : '#00f',
        blueviolet : '#8a2be2',
        brown : '#a52a2a',
        burlywood : '#deb887',
        cadetblue : '#5f9ea0',
        chartreuse : '#7fff00',
        chocolate : '#d2691e',
        coral : '#ff7f50',
        cornflowerblue : '#6495ed',
        cornsilk : '#fff8dc',
        crimson : '#dc143c',
        cyan : '#0ff',
        darkblue : '#00008b',
        darkcyan : '#008b8b',
        darkgoldenrod : '#b8860b',
        darkgray : '#a9a9a9',
        darkgrey : '#a9a9a9',
        darkgreen : '#006400',
        darkkhaki : '#bdb76b',
        darkmagenta : '#8b008b',
        darkolivegreen : '#556b2f',
        darkorange : '#ff8c00',
        darkorchid : '#9932cc',
        darkred : '#8b0000',
        darksalmon : '#e9967a',
        darkseagreen : '#8fbc8f',
        darkslateblue : '#483d8b',
        darkslategray : '#2f4f4f',
        darkslategrey : '#2f4f4f',
        darkturquoise : '#00ced1',
        darkviolet : '#9400d3',
        deeppink : '#ff1493',
        deepskyblue : '#00bfff',
        dimgray : '#696969',
        dimgrey : '#696969',
        dodgerblue : '#1e90ff',
        firebrick : '#b22222',
        floralwhite : '#fffaf0',
        forestgreen : '#228b22',
        fuchsia : '#f0f',
        gainsboro : '#dcdcdc',
        ghostwhite : '#f8f8ff',
        gold : '#ffd700',
        goldenrod : '#daa520',
        gray : '#808080',
        grey : '#808080',
        green : '#008000',
        greenyellow : '#adff2f',
        honeydew : '#f0fff0',
        hotpink : '#ff69b4',
        indianred : '#cd5c5c',
        indigo : '#4b0082',
        ivory : '#fffff0',
        khaki : '#f0e68c',
        lavender : '#e6e6fa',
        lavenderblush : '#fff0f5',
        lawngreen : '#7cfc00',
        lemonchiffon : '#fffacd',
        lightblue : '#add8e6',
        lightcoral : '#f08080',
        lightcyan : '#e0ffff',
        lightgoldenrodyellow : '#fafad2',
        lightgray : '#d3d3d3',
        lightgrey : '#d3d3d3',
        lightgreen : '#90ee90',
        lightpink : '#ffb6c1',
        lightsalmon : '#ffa07a',
        lightseagreen : '#20b2aa',
        lightskyblue : '#87cefa',
        lightslategray : '#789',
        lightslategrey : '#789',
        lightsteelblue : '#b0c4de',
        lightyellow : '#ffffe0',
        lime : '#0f0',
        limegreen : '#32cd32',
        linen : '#faf0e6',
        magenta : '#f0f',
        maroon : '#800000',
        mediumaquamarine : '#66cdaa',
        mediumblue : '#0000cd',
        mediumorchid : '#ba55d3',
        mediumpurple : '#9370d8',
        mediumseagreen : '#3cb371',
        mediumslateblue : '#7b68ee',
        mediumspringgreen : '#00fa9a',
        mediumturquoise : '#48d1cc',
        mediumvioletred : '#c71585',
        midnightblue : '#191970',
        mintcream : '#f5fffa',
        mistyrose : '#ffe4e1',
        moccasin : '#ffe4b5',
        navajowhite : '#ffdead',
        navy : '#000080',
        oldlace : '#fdf5e6',
        olive : '#808000',
        olivedrab : '#6b8e23',
        orange : '#ffa500',
        orangered : '#ff4500',
        orchid : '#da70d6',
        palegoldenrod : '#eee8aa',
        palegreen : '#98fb98',
        paleturquoise : '#afeeee',
        palevioletred : '#d87093',
        papayawhip : '#ffefd5',
        peachpuff : '#ffdab9',
        peru : '#cd853f',
        pink : '#ffc0cb',
        plum : '#dda0dd',
        powderblue : '#b0e0e6',
        purple : '#800080',
        red : '#f00',
        rosybrown : '#bc8f8f',
        royalblue : '#4169e1',
        saddlebrown : '#8b4513',
        salmon : '#fa8072',
        sandybrown : '#f4a460',
        seagreen : '#2e8b57',
        seashell : '#fff5ee',
        sienna : '#a0522d',
        silver : '#c0c0c0',
        skyblue : '#87ceeb',
        slateblue : '#6a5acd',
        slategray : '#708090',
        slategrey : '#708090',
        snow : '#fffafa',
        springgreen : '#00ff7f',
        steelblue : '#4682b4',
        tan : '#d2b48c',
        teal : '#008080',
        thistle : '#d8bfd8',
        tomato : '#ff6347',
        turquoise : '#40e0d0',
        violet : '#ee82ee',
        wheat : '#f5deb3',
        white : '#fff',
        whitesmoke : '#f5f5f5',
        yellow : '#ff0',
        yellowgreen : '#9acd32'
    };

    var colorRegExp = /^\s*((#[a-f\d]{6})|(#[a-f\d]{3})|rgba?\(\s*([\d\.]+%?\s*,\s*[\d\.]+%?\s*,\s*[\d\.]+%?(?:\s*,\s*[\d\.]+%?)?)\s*\)|hsba?\(\s*([\d\.]+(?:deg|\xb0|%)?\s*,\s*[\d\.]+%?\s*,\s*[\d\.]+%?(?:\s*,\s*[\d\.]+)?)%?\s*\)|hsla?\(\s*([\d\.]+(?:deg|\xb0|%)?\s*,\s*[\d\.]+%?\s*,\s*[\d\.]+%?(?:\s*,\s*[\d\.]+)?)%?\s*\))\s*$/i;

    function trim(color) {
        return String(color).replace(/\s+/g, '');
    }

    // 调整值区间
    function adjust(value, region) {
        if (value <= region[0]) {
            value = region[0];
        }
        else if (value >= region[1]) {
            value = region[1];
        }
        return value;
    }

    // 数组映射
    function map(array, fun) {
        if (typeof fun !== 'function') {
            throw new TypeError();
        }
        var len = array ? array.length : 0;
        for (var i = 0; i < len; i++) {
            array[i] = fun(array[i]);
        }
        return array;
    }

    /**
     * 把颜色转化成数组数据，用于计算
     * @param color 颜色
     */
    function getRGBAColorArray(color){
        if (_nameColors[color]) {
            color = _nameColors[color];
        }

        color = trim(color);

        if (/^#[\da-f]{3}$/i.test(color)) {
            color = parseInt(color.slice(1), 16);
            var r = (color & 0xf00) << 8;
            var g = (color & 0xf0) << 4;
            var b = color & 0xf;

            color = '#' + ((1 << 24) + (r << 4) + r + (g << 4) + g + (b << 4) + b).toString(16).slice(1);
        }

        var r = color.match(colorRegExp);

        var d;
        var a;
        var data = [];
        var rgb;

        if (r[2]) {
            // #rrggbb
            d = r[2].replace('#', '').split('');
            rgb = [ d[0] + d[1], d[2] + d[3], d[4] + d[5] ];
            data = map(rgb,
                function(c) {
                    return adjust(parseInt(c, 16), [ 0, 255 ]);
                }
            );
        } else if (r[4]) {
            // rgb rgba
            var rgba = (r[4]).split(',');
            a = rgba[3];
            rgb = rgba.slice(0, 3);
            data = map(
                rgb,
                function(c) {
                    c = Math.floor(
                        c.indexOf('%') > 0 ? parseInt(c, 0) * 2.55 : c
                    );
                    return adjust(c, [ 0, 255 ]);
                }
            );

            if (typeof a !== 'undefined') {
                data.push(adjust(parseFloat(a), [ 0, 1 ]));
            }
        }


        //统一rgba的格式
        if(data.length == 3){
            data.push(1);
        }

        return data;
    }

    function toColor(data, format){
        format = format || 'rgb';
        if (data && (data.length === 3 || data.length === 4)) {
            data = map(data,
                function(c) {
                    return c > 1 ? Math.ceil(c) : c;
                }
            );

            if (format.indexOf('hex') > -1) {
                return '#' + ((1 << 24) + (data[0] << 16) + (data[1] << 8) + (+data[2])).toString(16).slice(1);
            }
            else if (format.indexOf('hs') > -1) {
                var sx = map(data.slice(1, 3),
                    function(c) {
                        return c + '%';
                    }
                );
                data[1] = sx[0];
                data[2] = sx[1];
            }

            if (format.indexOf('a') > -1) {
                if (data.length === 3) {
                    data.push(1);
                }
                data[3] = adjust(data[3], [ 0, 1 ]);
                return format + '(' + data.slice(0, 4).join(',') + ')';
            }

            return format + '(' + data.slice(0, 3).join(',') + ')';
        }
    }

    function getHighLightColor(color){
        var rgba = getRGBAColorArray(color);
        var tmp = [];
        for(var i = 0; i < 3; i++){
            var x = rgba[i];
            if(x <= 128){
                tmp.push(adjust(x-(255-x)*(255-2*x)/(2*x), [0,255]));
            }else{
                tmp.push(adjust(x+x*(2*x-255)/(2*(255-x)), [0,255]));
            }
        }

        var result = [];
        for(i = 0; i < 3; i++){
            result.push(Math.round(0.65 * rgba[i] + 0.35 * tmp[i]));
        }

        return toColor(result, 'rgb');
    }

    function getColorWithDivider(color, divider){
        var rgba = getRGBAColorArray(color);

        rgba.length = 3;

        for(var i = 0; i < 3; i++){
            rgba[i] = parseInt(rgba[i] / divider, 10);
        }

        return toColor(rgba, 'rgb');
    }

    function getClickColor(color){

        var rgba = getRGBAColorArray(color);

        rgba.length = 3;

        for(var i = 0; i < 2; i++){
            rgba[i] = parseInt(rgba[i] * 0.95, 10);
        }

        return toColor(rgba, 'rgb');
    }

    function mixColorWithAlpha(color, alpha){
        var rgba = getRGBAColorArray(color);
        rgba[3] = alpha;
        return toColor(rgba, 'rgba');
    }

    function mixColorWithHSB(color, detH, detS, detB){
        var rgba = getRGBAColorArray(color);

        var hsb = rgb2hsb(rgba[0], rgba[1], rgba[2]);

        hsb[0] += detH;
        hsb[1] += detS;
        hsb[2] += detB;

        var rgb = hsb2rgb(hsb[0], hsb[1], hsb[2]);

        return toColor(rgb, 'rgb');
    }

    function hsb2rgb(hue, saturation, brightness){

        saturation = Math.min(1, Math.max(0, saturation));

        brightness = Math.min(1, Math.max(0, brightness));

        var r = 0, g = 0, b = 0;
        if (saturation === 0) {
            r = g = b = brightness * 255.0 + 0.5;
        } else {
            var h = (hue - Math.floor(hue)) * 6.0;
            var f = h - Math.floor(h);
            var p = brightness * (1.0 - saturation);
            var q = brightness * (1.0 - saturation * f);
            var t = brightness * (1.0 - (saturation * (1.0 - f)));
            switch (Math.floor(h)) {
                case 0:
                    r = brightness * 255.0 + 0.5;
                    g = t * 255.0 + 0.5;
                    b = p * 255.0 + 0.5;
                    break;
                case 1:
                    r = q * 255.0 + 0.5;
                    g = brightness * 255.0 + 0.5;
                    b = p * 255.0 + 0.5;
                    break;
                case 2:
                    r = p * 255.0 + 0.5;
                    g = brightness * 255.0 + 0.5;
                    b = t * 255.0 + 0.5;
                    break;
                case 3:
                    r = p * 255.0 + 0.5;
                    g = q * 255.0 + 0.5;
                    b = brightness * 255.0 + 0.5;
                    break;
                case 4:
                    r = t * 255.0 + 0.5;
                    g = p * 255.0 + 0.5;
                    b = brightness * 255.0 + 0.5;
                    break;
                case 5:
                    r = brightness * 255.0 + 0.5;
                    g = p * 255.0 + 0.5;
                    b = q * 255.0 + 0.5;
                    break;
            }
        }
        var rgb = [];
        rgb.push(Math.floor(r));
        rgb.push(Math.floor(g));
        rgb.push(Math.floor(b));
        return rgb;
    }

    function createColorsWithHsb(color, count){

        color = color || 'blue';
        count = count || 1;

        var rgba = getRGBAColorArray(color);
        var hsb = rgb2hsb(rgba[0], rgba[1], rgba[2]);

        var result = [], h = hsb[0], s = hsb[1], b = hsb[2];

        for(var i = 0; i < count; i++){
            var tmpS = s * (1 - i / count);
            var tmpB = b + i * (1 - b) / count;
            result.push(toColor(hsb2rgb(h, tmpS, tmpB)));
        }

        return result;
    }

    function rgb2hsb(r, g, b){

        var hue, saturation, brightness;

        var hsbvals = [3];
        var cmax = (r > g) ? r : g;
        if (b > cmax) {
            cmax = b;
        }
        var cmin = (r < g) ? r : g;
        if (b < cmin) {
            cmin = b;
        }

        brightness = cmax / 255.0;
        if (cmax !== 0) {
            saturation = (cmax - cmin) / cmax;
        }else{
            saturation = 0;
        }


        if (saturation === 0) {
            hue = 0;
        }else{
            var redc = (cmax - r) / (cmax - cmin);
            var greenc = (cmax - g) / (cmax - cmin);
            var bluec = (cmax - b) / (cmax - cmin);
            if (r == cmax) {
                hue = bluec - greenc;
            }
            else if (g == cmax) {
                hue = 2.0 + redc - bluec;
            }
            else {
                hue = 4.0 + greenc - redc;
            }
            hue = hue / 6.0;
            if (hue < 0) {
                hue = hue + 1.0;
            }
        }

        hsbvals[0] = hue;
        hsbvals[1] = saturation;
        hsbvals[2] = brightness;
        return hsbvals;
    }

    function getColorOpacity(color){

        return (color && typeof color == 'string' && (color.indexOf('rgba') != -1)) ?
            getRGBAColorArray(color)[3] :
            1;
    }

    //没有a定义的话返回空
    function getColorOpacityWithoutDefault(color){

        return (color && typeof color == 'string' && (color.indexOf('rgba') != -1))
                                                    ? getColorOpacity(color) : undefined;

    }

    function colorToHex(color){
        return colorToHexAlpha(color).hex;
    }

    function colorToHexAlpha(color){
        var rgb = toColor(getRGBAColorArray(color), 'rgba');

        var rRgba = /rgba?\((\d{1,3}),(\d{1,3}),(\d{1,3})(,([.\d]+))?\)/,
            r, g, b, a,
            rsa = rgb.replace(/\s+/g, "").match(rRgba);

        r = (+rsa[1]).toString(16);
        r = r.length === 1 ? "0" + r : r;
        g = (+rsa[2]).toString(16);
        g = g.length === 1 ? "0" + g : g;
        b = (+rsa[3]).toString(16);
        b = b.length === 1 ? "0" + b : b;
        a = +(rsa[5] ? rsa[5] : 1);

        return {hex: "#" + r + g + b, alpha: a};
    }

    /**
     * 返回十六进制颜色和透明度
     * @param color 各种形式color，rgb、gdba、red、#ffffff
     * @param alpha 透明度
     */
    function getStandardColorAndOpacity(color, alpha) {

        if(color == null){
            return {hex:color, alpha:alpha};
        }

        if(alpha == null) {
            alpha = 1;
        }
        alpha = adjust(parseFloat(alpha), [ 0, 1 ]);

        var hexAlpha = colorToHexAlpha(color);

        if(hexAlpha.alpha != null) {
            alpha *= hexAlpha.alpha;
        }

        return {hex:hexAlpha.hex, alpha: alpha};
    }

    var ColorUtils = {
        toColor:toColor,
        hsb2rgb:hsb2rgb,
        rgb2hsb:rgb2hsb,
        createColorsWithHsb:createColorsWithHsb,
        getRGBAColorArray:getRGBAColorArray,
        mixColorWithHSB:mixColorWithHSB,
        getHighLightColor:getHighLightColor,
        getColorWithDivider:getColorWithDivider,
        mixColorWithAlpha:mixColorWithAlpha,
        getColorOpacity:getColorOpacity,
        getColorOpacityWithoutDefault:getColorOpacityWithoutDefault,
        colorToHex:colorToHex,
        colorToHexAlpha:colorToHexAlpha,
        getClickColor:getClickColor,
        getStandardColorAndOpacity:getStandardColorAndOpacity
    };

    window.ColorUtils = ColorUtils;

    return ColorUtils;
});
/**
 * Created by eason on 15/5/4.
 */
define('Constants',[],function(){
    return {

        INSTANCES_KEY:'vancharts_index_',

        SELECT_ANIMATION:'select',

        CHART_HIDE: 'vancharts-chart-hide',
        EXPORT_HIDE: 'vancharts-export-hide',

        //坐标系类型
        GEO:'geographic_co_sys',
        PLANE:'plane_co_sys',

        //图表类型
        BAR_CHART:'bar',//条形图
        COLUMN_CHART:'column',//柱形图
        LINE_CHART:'line',//折线图
        AREA_CHART:'area',//面积图
        PIE_CHART:'pie',//饼图
        MULTIPIE_CHART:'multiPie',//多层饼图
        TREEMAP_CHART:'treeMap',//矩形树图
        SCATTER_CHART:'scatter',//散点图
        BUBBLE_CHART:'bubble',//气泡图
        FORCE_BUBBLE_CHART:'forceBubble',//力学气泡图

        GAUGE_CHART:'gauge',//仪表盘
        POINTER_GAUGE:'pointer',//指针仪表盘
        SLOT_GAUGE:'slot',//刻度槽仪表盘
        THERMOMETER_GAUGE:'thermometer',//试管仪表盘
        RING_GAUGE:'ring',//圆环仪表盘

        RADAR_CHART:'radar',//雷达图
        POINT_MAP:'pointMap',
        AREA_MAP:'areaMap',

        VANCHART:'vanchart',

        //工具栏的icon类型
        FULL_SCREEN_ICON : 'fullScreen',
        EXPORT_ICON : 'toImage',
        SORT : 'sort',
        MENU_ICON : 'vancharts-icon-menu',
        REFRESH_ICON : 'vancharts-icon-refresh',

        AXIS_GROUP:'vanchart-axis-group',

        //位置相关的常量
        BOTTOM:'bottom',
        TOP:'top',
        LEFT:'left',
        RIGHT:'right',
        RIGHT_TOP:'right-top',

        //动画的方向
        LEFT_TO_RIGHT:'left-to-right',
        RIGHT_TO_LEFT:'right-to-right',
        BOTTOM_TO_TOP:'bottom-to-top',
        TOP_TO_BOTTOM:'top-to-botttom',

        //图的排序的状态
        DISORDER:'disorder',
        DESCENDING:'descending',
        ASCENDING:'ascending',

        //标记点类型
        CIRCLE:'circle',
        SQUARE:'square',
        DIAMOND:'diamond',
        TRIANGLE:'triangle',

        CIRCLE_HOLLOW:'circle_hollow',
        SQUARE_HOLLOW:'square_hollow',
        DIAMOND_HOLLOW:'diamond_hollow',
        TRIANGLE_HOLLOW:'triangle_hollow',

        //图例的另外三种类型
        NORMAL_ICON:'normal-legend-icon',//一般的图例
        PIE_ICON:'pie-legend-icon',
        DONUT_ICON:'donut-legend-icon',
        BUBBLE_ICON:'bubble-legend-icon',
        SCATTER_ICON:'scatter-legend-icon',
        TREEMAP_ICON:'treeMap-legend-icon',

        //虚线的类型
        DASH_TYPE:{
            Solid:'0,0',
            Dash:'8,6'
        },

        //玫瑰图的不同形状
        SAME_ARC : 'sameArc',//所有扇形弧长相同
        DIFFERENT_ARC : 'differentArc',//所有扇形弧长不相等

        //图的排序的状态
        DISORDER:'disorder',
        DESCENDING:'descending',
        ASCENDING:'ascending',

        //标签的位置
        OUTSIDE : 'outside',
        INSIDE : 'inside',
        CENTER:'center',

        //样式的名字
        STYLE_GRADUAL:'gradual', //渐变

        //仪表盘布局
        HORIZONTAL_LAYOUT:'horizontal',
        VERTICAL_LAYOUT:'vertical',

        //雷达图底边
        POLYGON_RADAR:'polygon',
        CIRCLE_RADAR:'circle',

        //size是通过气泡的半径还是面积表现出来
        SIZE_BY_AREA:'area',
        SIZE_BY_WIDTH:'width',

        GRADUAL_LIGHTER: 'lighter',
        GRADUAL_DARKER: 'darker',

        //系列的几个状态
        STATE_TO_DROP:'to-drop',
        STATE_DROPPED:'dropped',
        STATE_TO_SHOW:'to-show',
        STATE_SHOW:'show',

        TOOLTIP_CATEGORY_STYLE: '<span style="font-size:16px;font-family:Verdana;color:white;">',
        TOOLTIP_SERIES_STYLE: '<span style="font-size:14px;font-family:Verdana;color:white">',
        TOOLTIP_VALUE_STYLE: '<span style="font-size:14px;font-family:Verdana;font-weight:bold;color:white">'
    }

});
/**
 * Created by eason on 15/5/4.
 * 一些最常用的工具方法
 */
define('utils/BaseUtils',['require','./ColorUtils','../Constants','VanCharts'],function(require){

    var ColorUtils = require('./ColorUtils');
    var Constants = require('../Constants');

    var DIV_CONTAINER, SVG_CONTAINER;

    var lastID = 0;

    var isMS = '', transPrefix = '';

    var styleToCss = {
        color:'fill',
        font:'font',
        fontFamily:'font-family',
        fontSize:'font-size',
        fontStretch:'font-stretch',
        fontStyle:'font-style',
        fontVariant:'font-variant',
        fontWeight:'font-weight',
        letterSpacing:'letter-spacing',
        lineHeight:'line-height',
        quotes:'quotes',
        textAlign:'text-align',
        textDecoration:'text-decoration',
        textIndent:'text-indent',
        textShadow:'text-shadow',
        textTransform:'text-transform',
        whiteSpace:'white-space',
        wordSpacing:'word-spacing',
        padding:'padding'
    };

    function initConst() {
        // MS includes IE and Edge
        utils.isMS = navigator.appName === 'Microsoft Internet Explorer' ||
            (navigator.appVersion.indexOf('Trident') > -1) ||
            (navigator.appName === "Netscape" && navigator.appVersion.indexOf('Edge') > -1);

        utils.transPrefix = "-webkit-transform" in document.body.style ? "-webkit-"
            : "-moz-transform" in document.body.style ? "-moz-"
            : "-ms-transform" in document.body.style ? "-ms-"
            : "";
    }

    /**
     * pick参数里第一个不为null和undefined的值
     * @returns {*}
     */
    function pick(){
        var arg, length = arguments.length;
        for (var i = 0; i < length; i++) {
            arg = arguments[i];
            if (typeof arg !== 'undefined' && arg !== null) {
                return arg;
            }
        }
        return null;
    }

    /**
     * 判断对象是否是数组
     * @param value 对象
     * @returns {boolean} 是否是数组
     */
    function isArray(value){
        return Object.prototype.toString.apply(value) === '[object Array]';
    }

    /**
     * 将具有length属性的对象转成数组
     * @param sequence 对象
     */
    function toArray(sequence){
        return Array.prototype.slice.call(sequence);
    }

    function setTextStyle(textS, style){
        style = cssNormalization(style);
        for(var attr in style){
            textS.style(attr, style[attr]);
        }
    }

    /**
     * 返回字体是fontSize(有单位，px,em)
     * @param fontSize
     */
    function getTextDimension(text, style, useHtml){
        text = pick(text, "");

        if(!DIV_CONTAINER){
            DIV_CONTAINER = document.createElement("div");
            var body = document.getElementsByTagName("body")[0];
            body.appendChild(DIV_CONTAINER);
        }

        DIV_CONTAINER.style.cssText = '';

        DIV_CONTAINER.style.visibility = "hidden";
        DIV_CONTAINER.style.whiteSpace = "nowrap";
        DIV_CONTAINER.style.position = 'absolute';

        var fontSize = '12px';

        for(var property in style){
            if(typeof(style[property]) != "function" && property != 'color'){
                DIV_CONTAINER.style[property] = style[property];
            }

            if(property == 'fontSize'){
                fontSize = style[property];
            }
        }

        if(fontSize.indexOf('pt') != -1){
            fontSize = parseFloat(fontSize) * 4 / 3;
        }else{
            fontSize = parseFloat(fontSize);
        }

        DIV_CONTAINER.innerHTML = text;
        //fireFox下面innerText的话offsetWidth为0
        //useHtml ? span.innerHTML = text : span.innerText = text;
        var width = DIV_CONTAINER.offsetWidth || 0;
        var height = DIV_CONTAINER.offsetHeight || 0;

        return {width:width, height:height};
    }

    function getTextWrapDimension(text, style, useHTML){
        text = pick(text, "");

        if(!DIV_CONTAINER){
            DIV_CONTAINER = document.createElement("div");
            var body = document.getElementsByTagName("body")[0];
            body.appendChild(DIV_CONTAINER);
        }

        DIV_CONTAINER.style.cssText = '';

        DIV_CONTAINER.style.visibility = "hidden";
        DIV_CONTAINER.style.whiteSpace = "normal";
        DIV_CONTAINER.style.position = 'absolute';
        DIV_CONTAINER.style.wordWrap = 'break-word';

        for(var property in style){
            if(typeof(style[property]) != "function" && property != 'color'){
                DIV_CONTAINER.style[property] = style[property];
            }
        }

        DIV_CONTAINER.innerHTML = text;

        //fireFox下面innerText的话offsetWidth为0
        //useHtml ? span.innerHTML = text : span.innerText = text;
        var width = DIV_CONTAINER.offsetWidth || 0;
        var height = DIV_CONTAINER.offsetHeight || 0;

        return {width:width, height:height};
    }

    function getSvgTextDim(text, style) {
        if (!text) {
            return {width:0, height:0};
        }

        if (!isSupportSVG()) {
            return getTextDimension(text, style);
        }

        if(!SVG_CONTAINER){
            SVG_CONTAINER = document.createElementNS('http://www.w3.org/2000/svg', 'svg');
            var body = document.getElementsByTagName("body")[0];
            body.appendChild(SVG_CONTAINER);

            var node = document.createElementNS('http://www.w3.org/2000/svg', 'text');
            SVG_CONTAINER.appendChild(node);

            SVG_CONTAINER._textNode = node;

            SVG_CONTAINER.style.visibility = "hidden";
        }

        var node = SVG_CONTAINER._textNode;
        node.textContent = text;

        node.style.cssText = '';

        for(var property in style){
            if(typeof(style[property]) != "function" && property != 'color'){
                node.style[property] = style[property];
            }
        }

        var box = node.getBBox();
        
        return {width: box.width, height:box.height};
    }

    function setDomBackground(dom, opt){

        var cssText = [];
        if (opt.backgroundColor) {
            if(typeof opt.backgroundColor == 'string'){
                if(isSupportSVG()){
                    cssText.push('background-Color:' + opt.backgroundColor);
                }else{
                    var hexAlpha = ColorUtils.colorToHexAlpha(opt.backgroundColor);
                    cssText.push('background-Color:' + hexAlpha.hex);
                    cssText.push('filter:alpha(opacity=' + hexAlpha.alpha + ')')
                }
            }else if(typeof opt.backgroundColor == 'object'){

                var color = opt.backgroundColor;
                var startColor = ColorUtils.colorToHex(color.startColor);
                var endColor = ColorUtils.colorToHex(color.endColor);

                var start = 'left';

                var startPos = 'left top';
                var endPos = 'right top';
                var type = 1;

                if(color.x1 == color.x2){
                    start = 'top';

                    startPos = 'left top';
                    endPos = 'left bottom';

                    type = 0;
                }

                cssText.push('background: -ms-linear-gradient(' + start + ', '+ startColor +', '+ endColor +')');

                cssText.push('background-image: -moz-linear-gradient(' + start + ', '+ startColor +', '+ endColor +')');

                cssText.push('background-image: -webkit-gradient(linear, '+startPos+', '+endPos+', color-stop(0, '+ startColor +'), color-stop(1, '+ endColor+'))');

                cssText.push('filter: progid:DXImageTransform.Microsoft.gradient(startColorstr='+startColor + ', endColorstr='+endColor+', GradientType='+type+')');
            }
        }

        if (opt.borderWidth != null) {
            cssText.push('border-width:' + opt.borderWidth + 'px');
        }

        if (opt.borderColor != null) {
            cssText.push('border-color:' + opt.borderColor);
        }

        if (opt.borderRadius != null) {
            cssText.push(
                'border-radius:' + opt.borderRadius + 'px'
            );
            cssText.push(
                '-moz-border-radius:' + opt.borderRadius + 'px'
            );
            cssText.push(
                '-webkit-border-radius:' + opt.borderRadius + 'px'
            );
            cssText.push(
                '-o-border-radius:' + opt.borderRadius + 'px'
            );
        }

        if(opt.shadow){
            cssText.push('box-shadow:1px 1px 2px rgba(0,0,0,0.2)');
        }

        dom.style.cssText += cssText.join(';') + ';';
    }

    function getTextHeight(style) {

        var fontSize = style.fontSize || '12px';

        return fontSize.indexOf('pt') != -1 ? parseFloat(fontSize) * 4 / 3 : parseFloat(fontSize);
    }

    function stamp(obj){
        obj._vanchart_id = obj._vanchart_id || ('vancharts' + ++lastID);
        return obj._vanchart_id;
    }

    function falseFn() {
        return false;
    }

    //properties mix in
    function extend(dest) {
        var i, j, len, src;

        for (j = 1, len = arguments.length; j < len; j++) {
            src = arguments[j];
            for (i in src) {
                dest[i] = src[i];
            }
        }

        return dest;
    }

    function domRotate(div, rotation){

        var cssText = [];
        cssText.push('transform:rotate(' + rotation + 'deg)');
        cssText.push('-ms-transform:rotate(' + rotation + 'deg)');
        cssText.push('-webkit-transform:rotate(' + rotation + 'deg)');
        cssText.push('-moz-transform:rotate(' + rotation + 'deg)');
        cssText.push('-o-transform:rotate(' + rotation + 'deg)');

        var costheta = Math.cos(toRadian(rotation));
        var sintheta = Math.sin(toRadian(rotation));

        //ie9的时候filter和ms-transform同时生效了
        if(!isSupportSVG()){
            var filter = rotation ? ['progid:DXImageTransform.Microsoft.Matrix(M11=', costheta,
                ', M12=', -sintheta, ', M21=', sintheta, ', M22=', costheta,
                ', sizingMethod=\'auto expand\')'].join('') : 'none';
            cssText.push('filter:' + filter);
        }

        div.style.cssText += (cssText.join(';') + ';');
    }

    function splitText(text, style, offeredSize, padding){

        if(!text){
            return [];
        }

        text += '';

        padding = padding || 0;

        offeredSize -= 2*padding;

        var result = [];

        var startIndex = 0;
        var textCount = text.length;

        while(startIndex < textCount){
            var i = startIndex;
            while(getTextDimension(text.substring(i, startIndex + 1), style, false).width < offeredSize){
                startIndex++;
                if(startIndex >= textCount){
                    break;
                }
            }

            if(i == startIndex){
                //这里的情况是一个字符都放不下
                return [];
            }else{
                result.push(text.substring(i, startIndex));
            }

        }

        return result;
    }

    function getTextDimensionWithRotation(text, style, useHtml, rotation){

        var dim = getTextDimension(text, style, useHtml);

        return getTextDimRotated(dim, rotation);
    }

    function getTextDimRotated(dim, rotation) {
        var angle = Math.abs(toRadian(rotation || 0));

        var width = dim.width * Math.cos(angle) + dim.height * Math.sin(angle);
        var height = dim.width * Math.sin(angle) + dim.height * Math.cos(angle);

        return {
            width:width,
            height:height
        }
    }

    function clone(source) {
        if (typeof source == 'object' && source !== null) {
            var result = source;
            if (isArray(source)) {
                result = [];
                for (var i = 0, len = source.length; i < len; i++) {
                    result[i] = clone(source[i]);
                }
            }else{
                result = {};
                for (var key in source) {
                    if (source.hasOwnProperty(key)) {
                        result[key] = clone(source[key]);
                    }
                }
            }
            return result;
        }

        return source;
    }

    //style对象的表示方法转css表示
    function cssNormalization(style){
        var result = {};
        for(var attr in style){
            if(styleToCss[attr]){
                result[styleToCss[attr]] = style[attr];
            }

            if(attr == 'color'){
                result.color = style[attr];
            }

            //转px
            if(attr == 'fontSize'){
                var fontSize = style[attr];
                if(fontSize.indexOf('pt') != -1){
                    fontSize = parseFloat(fontSize) * 4 / 3;
                    result['font-size'] = fontSize + 'px';
                }
            }
        }
        return result;
    }

    /**
     * css类属性数组补全，如padding，margin等~
     */
    function reformCssArray(p) {
        if (p instanceof Array) {
            switch (p.length + '') {
                case '4':
                    return p;
                case '3':
                    return [p[0], p[1], p[2], p[1]];
                case '2':
                    return [p[0], p[1], p[0], p[1]];
                case '1':
                    return [p[0], p[0], p[0], p[0]];
                case '0':
                    return [0, 0, 0, 0];
            }
        }
        else {
            return [p, p, p, p];
        }
    }

    function lineSubPixelOpt(xOry, lineWidth){
        return lineWidth % 2 == 0 ? Math.round(xOry) : Math.round(xOry - 0.5) + 0.5;
    }

    function rectSubPixelOpt(){

        var x, y, width, height, lineWidth;
        if(arguments.length == 2){
            x = arguments[0].x; y = arguments[0].y; width = arguments[0].width; height = arguments[0].height;
            lineWidth = arguments[1];
        }else{
            x = arguments[0]; y = arguments[1]; width = arguments[2]; height = arguments[3];
            lineWidth = arguments[4];
        }

        lineWidth = lineWidth || 0;
        x = lineSubPixelOpt(x, lineWidth);
        y = lineSubPixelOpt(y, lineWidth);
        width = Math.round(width);
        height = Math.round(height);
        return {x:x, y:y, width:width, height:height};
    }

    function addArray(targetArray, sourceArray){

        var result = [];

        if(targetArray && targetArray.length){
            for(var i = 0, len = targetArray.length; i < len; i++){
                result.push(targetArray[i]);
            }
        }

        if(sourceArray && sourceArray.length){
            for(var i = 0, len = sourceArray.length; i < len; i++){
                result.push(sourceArray[i]);
            }
        }

        return result;
    }

    function toFront(el){
        if(el && el.parentNode){
            el.parentNode.appendChild(el);
        }
    }

    function toBack(el){
        if(el && el.parentNode){
            el.parentNode.insertBefore(el,el.parentNode.firstChild);
        }
    }

    function toFrontOfAll(el){
        el.ownerSVGElement.appendChild(el);
    }

    function toBackOfAll(el){
        el.ownerSVGElement.appendChild(el,el.ownerSVGElement.firstChild);
    }

    //一定是在同一个坐标原点下
    function containsRect(biggerOne, smallOne){

        return biggerOne.x <= smallOne.x
                    && biggerOne.y <= smallOne.y
                    && biggerOne.x + biggerOne.width >= smallOne.x + smallOne.width
                    && biggerOne.y + biggerOne.height >= smallOne.y + smallOne.height;

    }

    function rectangleOverlapped(aBounds, bBounds){
        if (!aBounds|| !bBounds) {
            return false;
        }
        var minx = Math.max(aBounds.x, bBounds.x);
        var miny = Math.max(aBounds.y, bBounds.y);
        var maxx = Math.min(aBounds.x + aBounds.width, bBounds.x + bBounds.width);
        var maxy = Math.min(aBounds.y + aBounds.height, bBounds.y + bBounds.height);
        return (minx <= maxx && miny <= maxy);
    }

    function outsideRect(biggerOne, smallOne){

        return !containsRect(biggerOne, smallOne) && !rectangleOverlapped(biggerOne, smallOne);

    }

    function containsPoint(rect, point){
        var x = pick(point.x || point[0]);

        var y = pick(point.y || point[1]);

        return rect.x < x && rect.x + rect.width > x
                && rect.y < y && rect.y + rect.height > y;
    }

    function isSupportSVG(){
        return !!(window.SVGSVGElement);
    }

    function makeValueInRange(min, max, value){

        var rMin = Math.min(min, max);
        var rMax = Math.max(min, max);
        var gap = rMax - rMin;

        return ((value-rMin) % gap + gap) % gap + rMin;
    }

    function getValueInDomain(value, domain){

        return Math.min(Math.max(value, domain[0]), domain[1]);

    }

    function toRadian(degree){
        return Math.PI * (degree / 180);
    }

    function toDegree(radian){
        return radian * 180 / Math.PI;
    }

    //设计器那边传过来的formatter函数是字符串
    function getFormatterFunction(formatter){

        if(formatter == null || formatter == undefined){
            return null;
        }

        if(typeof formatter == 'string'){
            return (new Function("return "+ formatter))()
        }

        return formatter;
    }

    function clone(obj) {
        // Handle the 3 simple types, and null or undefined
        if (null == obj || "object" != typeof obj) return obj;

        // Handle Date
        if (obj instanceof Date) {
            var copy = new Date();
            copy.setTime(obj.getTime());
            return copy;
        }

        // Handle Array
        if (obj instanceof Array) {
            var copy = [];
            for (var i = 0, len = obj.length; i < len; ++i) {
                copy[i] = clone(obj[i]);
            }
            return copy;
        }

        if(obj instanceof String){
            return new String(obj);
        }

        // Handle Object
        if (obj instanceof Object) {
            var copy = {};
            for (var attr in obj) {
                if (obj.hasOwnProperty(attr)) copy[attr] = clone(obj[attr]);
            }
            return copy;
        }
    }

    function isEmpty(value){
        var result = value === "" || value === null || value === undefined;
        return result;
    }

    function isNull(v){
        return v == undefined || v == null
    }

    function showLightBox(options){

        var VanCharts = require('VanCharts');

        var body = document.getElementsByTagName("body")[0];

        var boxDiv = document.createElement('div');
        boxDiv.style.position = isSupportSVG() ? 'fixed' : 'absolute';
        boxDiv.style.display = 'inline';
        boxDiv.style.top = '0px';
        boxDiv.style.left = '0px';
        boxDiv.style.width = '100%';
        boxDiv.style.height = '100%';
        boxDiv.style.zIndex = 1000;
        if(isSupportSVG()){
            boxDiv.style.background = 'rgba(0,0,0,0.3)';
        }else{
            boxDiv.style.backgroundColor = 'black';
            boxDiv.style.filter = 'alpha(opacity=30)'
        }

        body.appendChild(boxDiv);

        var myWidth = boxDiv.clientWidth;
        var myHeight = boxDiv.clientHeight;

        var width = 970;
        var height = 600;

        var left = (myWidth - 970) / 2;
        var top = (myHeight - 600) / 2;


        var container = document.createElement('div');
        container.style.position = isSupportSVG() ? 'fixed' : 'absolute';
        container.style.display = 'inline';
        container.style.top = top + 'px';
        container.style.left = left + 'px';
        container.style.width = width + 'px';
        container.style.height = height + 'px';
        container.style.zIndex = 1001;

        if(isSupportSVG()){
            container.style.background = 'white';
            container.style.boxShadow = '0px 4px 50px rgba(0,0,0,0.5)';
        }else{
            container.style.backgroundColor = 'white';
            container.style.filter = 'alpha(opacity=100)';
        }

        body.appendChild(container);

        boxDiv.onclick = function(e){
            body.removeChild(boxDiv);
            body.removeChild(container);
        };

        container.onclick = function(e){
            e = e || window.event;
            if (e.stopPropagation){
                e.stopPropagation();
            }else{
                e.cancelBubble = true
            };
        }

        var vanCharts = VanCharts.init(container);
        vanCharts.isFullScreen = true;
        vanCharts.setOptions(options);

        //ie8 bug
        container.style.top = top + 'px';
        container.style.left = left + 'px';
        container.boxDiv = boxDiv;
    }

    function hideLightBox(container){
        var parent = container.parentNode;

        if(parent){
            parent.removeChild(container);
            if(container.boxDiv){
                parent.removeChild(container.boxDiv);
            }
        }
    }

    function isIE() { //ie?
        if (!!window.ActiveXObject || "ActiveXObject" in window)
            return true;
        else
            return false;
    }

    function hasNotDefined(value){
        return value == null;
    }

    function hasDefined(value){
        return !hasNotDefined(value);
    }

    function indexInArray(array, value){
        if(!array.length){
            return -1;
        }

        for(var i = 0, len = array.length; i < len; i++){
            if(array[i] == value){
                return i;
            }
        }

        return -1;
    }

    function makeBounds(){

        var x = 0, y = 0, width = 0, height = 0;

        if(arguments.length == 2){

            var pos = arguments[0];
            var dim = arguments[1];

            x = pick(pos.x, pos[0]);
            y = pick(pos.y, pos[1]);

            width = pick(dim.width, dim[0]);
            height = pick(dim.height, dim[1]);

        }else if(arguments.length == 4){

            x = arguments[0];
            y = arguments[1];

            width = arguments[2];
            height = arguments[3];
        }

        return {
            x:x,
            y:y,
            width:width,
            height:height
        };

    }

    function distance(p1, p2){
        var x1 = pick(p1.x, p1[0]);
        var y1 = pick(p1.y, p1[1]);

        var x2 = pick(p2.x, p2[0]);
        var y2 = pick(p2.y, p2[1]);

        var detX = x1 - x2;
        var detY = y1 - y2;

        return Math.sqrt(detX * detX + detY * detY);
    }

    function isEmptyBounds(bounds){
        return bounds.width <= 0 || bounds.height <= 0;
    }

    function log(logBase, value){
        return Math.log(value) / Math.log(logBase);
    }

    function getOrder(value) {
        var order = 0;
        if(value > 0 && value < 1) {
            while(value < 1) {
                value = accMul(value, 10);
                order--;
            }
        } else if(value >= 10) {
            while(value >= 10) {
                value = accDiv(value, 10);
                order++;
            }
        }

        return order;
    }

    //用百分比表示或者数字表示的值
    function getPercentValue(value, total){
        if(value){
            value += '';
            if(value.indexOf('%') != -1){
                value = parseFloat(value) * total / 100;
            }
            return parseFloat(value);
        }
        return 0;
    }

    function accAdd(arg1, arg2) {
        var r1 = 0;
        var r2 = 0;
        try {
            r1 = arg1.toString().split('.')[1].length;
        }
        catch(e) {}
        try {
            r2 = arg2.toString().split('.')[1].length;
        }
        catch(e) {}

        var m = Math.pow(10, Math.max(r1, r2));
        return (Math.round(arg1 * m) + Math.round(arg2 * m)) / m;
    }

    function accDiv(arg1,arg2){
        var s1 = arg1.toString();
        var s2 = arg2.toString();
        var m = 0;
        try {
            m = s2.split('.')[1].length;
        }
        catch(e) {}
        try {
            m -= s1.split('.')[1].length;
        }
        catch(e) {}

        return (s1.replace('.', '') - 0) / (s2.replace('.', '') - 0) * Math.pow(10, m);
    }

    function accMul(arg1, arg2){
        var m = 0, s1 = arg1.toString(), s2 = arg2.toString();

        try{
            m += s1.split(".")[1].length;
        }
        catch(e){}
        try{
            m += s2.split('.')[1].length;
        }
        catch(e){}
        return Number(s1.replace(".",""))*Number(s2.replace(".",""))/Math.pow(10,m);
    }


    function objectToArray(object){
        var result = [];
        for(var key in object){
            result.push(object[key]);
        }
        return result;
    }

    function date2int(date){

        if(typeof date == 'string'){
            date = new Date(Date.parse(date.replace(/-|\./g, "/")));
        }

        var baseDate = new Date("1970/01/01");

        if(typeof date == typeof(0)){
            return date;
        }else{
            return date.getTime() - baseDate.getTime();
        }

    }

    function int2date(milliseconds){

        var baseDate = new Date("1970/01/01");

        milliseconds = milliseconds || 0;

        return new Date(milliseconds + baseDate.getTime());
    }

    function object2date(obj){

        var date = obj;

        if(typeof date == 'string'){
            date = new Date(Date.parse(date.replace(/-|\./g, "/")));
        }else if(typeof date == typeof(0)){
            date = new Date(date)
        }

        return date;
    }

    function makeTranslate(pos){
        var x = pick(pos.x, pos[0]);
        var y = pick(pos.y, pos[1]);
        return 'translate(' + x + ',' + y + ')';
    }

    function isImageMarker(markerType){
        var ALL_SYMBOLS = Constants.CIRCLE + Constants.SQUARE + Constants.DIAMOND + Constants.TRIANGLE
            + Constants.CIRCLE_HOLLOW + Constants.SQUARE_HOLLOW + Constants.DIAMOND_HOLLOW + Constants.TRIANGLE_HOLLOW;

        return ALL_SYMBOLS.indexOf(markerType) == -1 && hasDefined(markerType);
    }

    function isNullMarker(marker){
        return hasNotDefined(marker.symbol);
    }

    function getDefaultMarkerSymbol(seriesIndex){
        var ALL_SYMBOLS = [Constants.CIRCLE, Constants.CIRCLE_HOLLOW, Constants.SQUARE, Constants.SQUARE_HOLLOW,
            Constants.DIAMOND, Constants.DIAMOND_HOLLOW, Constants.TRIANGLE, Constants.TRIANGLE_HOLLOW];

        return ALL_SYMBOLS[seriesIndex%ALL_SYMBOLS.length];
    }

    function addEvent(el, type, fn){

        if(el.attachEvent){
            el.attachEvent('on' + type, fn);
        }else if (el.addEventListener){
            el.addEventListener(type, fn, false);
        }
    }

    function splitWords (str) {
        str = str.trim ? str.trim() : str.replace(/^\s+|\s+$/g, '');
        return str.split(/\s+/);
    }

    function removeEvent(el, type, fn){

        if (el.removeEventListener) {
            el.removeEventListener(type, fn, false);
        } else if (el.attachEvent) {
            el.detachEvent('on' + type, fn);
        }

    }

    function dealFloatPrecision(v){
        return Math.abs(v) < 1e-6 ? 0 : v;
    }

    function getMousePos(ev, el){

        var event = ev.originalEvent || ev;

        event = event.touches ?  (event.touches.length ? event.touches.item(0) : event.changedTouches[0]) : event;

        var docElem = document.documentElement,
            box = el.getBoundingClientRect();

        var top = box.top  + (window.pageYOffset || docElem.scrollTop)  - (docElem.clientTop  || 0);
        var left = box.left + (window.pageXOffset || docElem.scrollLeft) - (docElem.clientLeft || 0);

        var chartX, chartY;
        if (event.pageX == undefined) {
            chartX = Math.max(event.x, event.clientX - left);
            chartY = event.y;
        } else {
            chartX = event.pageX - left;
            chartY = event.pageY - top;
        }

        return [chartX, chartY];
    }

    function hasTouch(){
        var doc = window.document;
        return doc && doc.documentElement.ontouchstart !== undefined;
    }

    function getArcPoint(r, radian){
        return [r * Math.sin(radian), -r * Math.cos(radian)]
    }

    function getArcByPoint (x, y) {
        return (2 * Math.PI - (Math.atan2(y, x) - Math.PI/2)) % (2 * Math.PI);
    }

    function calculateAutoMinMaxAndGap (minValue, maxValue, splitNumber){

        if(maxValue < minValue){
            minValue = 0; maxValue = 100;
        }

        var increment = maxValue - minValue;
        var order = getOrder(increment);
        var pow = Math.pow(10, order);

        if(order <= 0){
            minValue = accMul(minValue, Math.pow(10, 1 - order));
            minValue = accDiv(Math.floor(minValue), Math.pow(10, 1 - order));
        }else{
            minValue = Math.floor(minValue / pow) * pow;
        }

        var base = accDiv(splitNumber, 10) * pow;
        var gap = 0;
        while(gap < increment){
            gap = accAdd(base, gap);
        }

        var bd = accDiv(gap, splitNumber);

        while(minValue + bd * splitNumber < maxValue){
            gap = accAdd(base, gap);
            bd = accDiv(gap, splitNumber);
        }
        gap = accDiv(gap, splitNumber);

        maxValue = accAdd(minValue, accMul(gap, splitNumber));

        return [minValue, maxValue, gap];
    }

    //原因：FR重写了Array.prototype.indexOf，递归所有属性
    //point-points-series-point
    function arrayIndexOf(array, searchElement) {
        if(window.FR){
            for (var i = 0, len = array.length; i < len; i++) {
                if (array[i] == searchElement)
                    return i;
            }
            return -1;
        } else {
            return array.indexOf(searchElement);
        }
    }
    
    function hasChn(str) {
        return /[\u4E00-\u9FA5]/.test(str);
    }

    var utils = {
        initConst:initConst,
        isMS:isMS,
        transPrefix:transPrefix,
        getMousePos:getMousePos,
        makeTranslate:makeTranslate,
        clone:clone,
        date2int:date2int,
        int2date:int2date,
        object2date:object2date,
        log:log,
        getOrder:getOrder,
        getPercentValue:getPercentValue,
        accAdd:accAdd,
        accDiv:accDiv,
        accMul:accMul,
        dealFloatPrecision:dealFloatPrecision,
        isEmpty:isEmpty,
        isEmptyBounds:isEmptyBounds,
        objectToArray:objectToArray,
        pick:pick,
        isNull:isNull,
        getTextDimension:getTextDimension,
        getTextHeight:getTextHeight,
        splitText:splitText,
        getTextDimensionWithRotation:getTextDimensionWithRotation,
        getTextDimRotated:getTextDimRotated,
        isArray:isArray,
        indexInArray:indexInArray,
        cssNormalization:cssNormalization,
        reformCssArray:reformCssArray,
        rectSubPixelOpt:rectSubPixelOpt,
        lineSubPixelOpt:lineSubPixelOpt,
        addArray:addArray,
        toFront:toFront,
        toBack:toBack,
        toFrontOfAll:toFrontOfAll,
        toBackOfAll:toBackOfAll,
        containsRect:containsRect,
        rectangleOverlapped:rectangleOverlapped,
        outsideRect:outsideRect,
        containsPoint:containsPoint,
        isSupportSVG:isSupportSVG,
        setTextStyle:setTextStyle,
        domRotate:domRotate,
        makeValueInRange:makeValueInRange,
        getValueInDomain:getValueInDomain,
        toRadian:toRadian,
        toDegree:toDegree,
        getFormatterFunction:getFormatterFunction,
        showLightBox:showLightBox,
        hideLightBox:hideLightBox,
        isIE:isIE,
        hasTouch:hasTouch,
        hasNotDefined:hasNotDefined,
        hasDefined:hasDefined,
        distance:distance,
        makeBounds:makeBounds,
        isImageMarker:isImageMarker,
        isNullMarker:isNullMarker,
        getDefaultMarkerSymbol:getDefaultMarkerSymbol,
        addEvent:addEvent,
        removeEvent:removeEvent,
        getArcPoint:getArcPoint,
        getTextWrapDimension:getTextWrapDimension,
        stamp:stamp,
        splitWords:splitWords,
        falseFn:falseFn,
        extend:extend,
        setDomBackground:setDomBackground,
        getArcByPoint:getArcByPoint,
        calculateAutoMinMaxAndGap:calculateAutoMinMaxAndGap,
        getSvgTextDim:getSvgTextDim,
        arrayIndexOf:arrayIndexOf,
        hasChn:hasChn
    };

    window.VanUtils = utils;//export to the global env

    return utils;
});
/**
 * Created by eason on 15/6/16.
 */

define('utils/QueryUtils',['require','./BaseUtils'],function(require){
    var BaseUtils = require('./BaseUtils');

    //从选项中读出指定属性
    function query(opt, optLocation){
        if(!opt || !optLocation){
            return;
        }

        optLocation = optLocation.split('.');
        for(var index = 0, length = optLocation.length; index < length; index++){
            opt = opt[optLocation[index]];

            //这里的opt可能为0,false等
            if(opt == undefined){
                return;
            }
        }

        return opt;
    }


    //从可能的属性列表里读optLocation的属性，前面的优先级高
    function queryList(optList, optLocation){
        if(!optList || !optList.length || !optLocation){
            return undefined;
        }

        for(var i = 0; i < optList.length; i++){
            var result = query(optList[i], optLocation);
            if(result != undefined){
                return result;
            }
        }
    }

    function merge(target, source, overwrite){
        for (var key in source) {
            if (source.hasOwnProperty(key)) {
                var targetProp = target[key];
                if (typeof targetProp == 'object') {

                    //target[key]不为对象时？
                    merge(target[key], source[key], overwrite);
                }else if(overwrite || !(key in target)){
                    target[key] = source[key];
                }
            }
        }
        return target;
    }


    //从list里合并需要的选项
    function mergeList(optList, optLocation){
        if(!optList || !optList.length || !optLocation){
            return undefined;
        }

        var result;
        for(var i = 0, length = optList.length; i < length; i++){
            var tmpOption = query(optList[i], optLocation);

            if(result == undefined){
                result = BaseUtils.clone(tmpOption);
            }else{
                merge(result, tmpOption);
            }
        }

        return result;
    }

    return {
        mergeList:mergeList,
        queryList:queryList,
        query:query,
        merge:merge
    };
});
/**
 * Created by eason on 16/5/26.
 *
 * try to use Behavior Delegation
 */

define('utils/Class',['require','./QueryUtils'],function(require){

    var QueryUtils = require('./QueryUtils');

    function Class(){};

    Class.extend = function(props){

        // @function extend(props: Object): Function
        // [Extends the current class](#class-inheritance) given the properties to be included.
        // Returns a Javascript function that is a class constructor (to be called with `new`).
        var NewClass = function () {

            // call the constructor
            if (this.initialize) {
                this.initialize.apply(this, arguments);
            }

            // call all constructor hooks
            this.callInitHooks();
        };

        var parentProto = NewClass.__super__ = this.prototype;

        var proto = Object.create(parentProto);
        proto.constructor = NewClass;

        NewClass.prototype = proto;

        // inherit parent's statics
        for (var i in this) {
            if (this.hasOwnProperty(i) && i !== 'prototype') {
                NewClass[i] = this[i];
            }
        }

        //todo 暂时不知道用不用得上,先留着
        // // mix static properties into the class
        // if (props.statics) {
        //     L.extend(NewClass, props.statics);
        //     delete props.statics;
        // }
        //
        // // mix includes into the prototype
        // if (props.includes) {
        //     L.Util.extend.apply(null, [proto].concat(props.includes));
        //     delete props.includes;
        // }
        //
        // // merge options
        // if (proto.options) {
        //     props.options = L.Util.extend(L.Util.create(proto.options), props.options);
        // }

        // mix given properties into the prototype
        QueryUtils.merge(proto, props, true);

        proto._initHooks = [];

        // add method for calling all hooks
        proto.callInitHooks = function () {

            if (this._initHooksCalled) { return; }

            if (parentProto.callInitHooks) {
                parentProto.callInitHooks.call(this);
            }

            this._initHooksCalled = true;

            for (var i = 0, len = proto._initHooks.length; i < len; i++) {
                proto._initHooks[i].call(this);
            }
        };

        return NewClass;
    };

    // @function addInitHook(fn: Function)
    // Adds a [constructor hook](#class-constructor-hooks) to the class.
    Class.addInitHook = function (fn) { // (Function) || (String, args...)
        var args = Array.prototype.slice.call(arguments, 1);

        var init = typeof fn === 'function' ? fn : function () {
            this[fn].apply(this, args);
        };

        this.prototype._initHooks = this.prototype._initHooks || [];
        this.prototype._initHooks.push(init);
        return this;
    };

    return Class;
});


/**
 * Created by eason on 15/8/7.
 */
//管理标签位置
define('utils/BoundsManager',['require','./BaseUtils'],function(require){

    var BaseUtils = require('./BaseUtils');

    function BoundsManager(){
        this.addedBounds = [];
    }

    BoundsManager.prototype = {

        constructor:BoundsManager,

        addBounds:function(bounds){
            this.addedBounds.push(bounds);
        },

        isOverlapped:function(bounds){
            for (var i = 0, len = this.addedBounds.length; i < len; i++){
                if (BaseUtils.rectangleOverlapped(bounds, this.addedBounds[i])){
                    return true;
                }
            }
            return false;
        },

        isEmpty:function(){
            return this.addedBounds.length == 0;
        }

    };

    return BoundsManager;
});
/**
 * Created by eason on 15/5/18.
 * 各种注册了的组件
 */
define('ComponentLibrary',[],function(){

    var _registeredComponents = Object.create(null);

    //控制下初始化的顺序
    var ComponentsOrder = ['tooltip','tools','geo', 'title',
                            'dTools','rangeLegend','legend','zoom',
                                'xAxis','yAxis','polar','dataSheet',
                                    'radiusAxis','angleAxis','gaugeAxis', 'value',
                                                    'category', 'datetime'];

    /**
     * 根据名字获得组件的function
     * @param name 组件的名字
     */
    function get(name){
        return _registeredComponents[name];
    }

    /**
     * 注册某种组件类型
     * @param name 组件的名字
     * @param chart 组件的实现
     */
    function register(name, compnent){
        _registeredComponents[name] = compnent;
    }

    function getRegisteredComponents(){
        return _registeredComponents;
    }

    return {
        TOOLTIP_COMPONENT:'tooltip',
        TOOLBAR_COMPONENT:'tools',
        GEO_COMPONENT:'geo',
        DRILL_TOOLS:'dTools',

        TITLE_COMPONENT:'title',
        RANGE_LEGEND_COMPONENT:'rangeLegend',
        LEGEND_COMPONENT:'legend',
        DATA_SHEET_COMPONENT:'dataSheet',

        ZOOM_COMPONENT:'zoom',
        X_AXIS_COMPONENT:'xAxis',
        Y_AXIS_COMPONENT:'yAxis',
        POLAR_COMPONENT:'polar',

        RADIUS_AXIS_COMPONENT:'radiusAxis',
        ANGLE_AXIS_COMPONENT:'angleAxis',
        GAUGE_AXIS_COMPONENT:'gaugeAxis',
        VALUE_AXIS_COMPONENT:'value',

        CATEGORY_AXIS_COMPONENT:'category',
        DATE_AXIS_COMPONENT:'datetime',

        ComponentsOrder:ComponentsOrder,
        getRegisteredComponents:getRegisteredComponents,
        get:get,
        register:register
    }

});
/**
 * Created by eason on 15/5/4.
 * 注册了的图表的工厂,所有加载的图表模块都在这里注册
 */
define('ChartLibrary',['require','./Constants'],function(require){
    var _registeredCharts = {};
    var Constants = require('./Constants');
    
    /**
     * 根据名字获得某种图表类型的function
     * @param name 图表名字
     */
    function get(name){
        return _registeredCharts[name];
    }

    /**
     * 注册某种图表类型
     * @param name 图表的名字
     * @param chart 图表的实现
     */
    function register(name, chart){
        _registeredCharts[name] = chart;
    }

    function getRegisteredCharts(){
        return _registeredCharts;
    }

    return {
        getRegisteredCharts:getRegisteredCharts,
        get:get,
        register:register
    }
});
/**
 * Created by eason on 16/5/26.
 */

define('dom/Browser',['require'],function(require){

    var ua = navigator.userAgent.toLowerCase(),
        doc = document.documentElement,

        ie = 'ActiveXObject' in window,

        webkit    = ua.indexOf('webkit') !== -1,
        phantomjs = ua.indexOf('phantom') !== -1,
        android23 = ua.search('android [23]') !== -1,
        chrome    = ua.indexOf('chrome') !== -1,
        gecko     = ua.indexOf('gecko') !== -1  && !webkit && !window.opera && !ie,

        mobile = typeof orientation !== 'undefined' || ua.indexOf('mobile') !== -1,
        msPointer = !window.PointerEvent && window.MSPointerEvent,
        pointer = window.PointerEvent || msPointer,

        ie3d = ie && ('transition' in doc.style),
        webkit3d = ('WebKitCSSMatrix' in window) && ('m11' in new window.WebKitCSSMatrix()) && !android23,
        gecko3d = 'MozPerspective' in doc.style,
        opera12 = 'OTransition' in doc.style;

    var touch = !window.L_NO_TOUCH && (pointer || 'ontouchstart' in window ||
        (window.DocumentTouch && document instanceof window.DocumentTouch));

    return {
        ie: ie,

        // @property ielt9: Boolean
        // `true` for Internet Explorer versions less than 9.
        ielt9: ie && !document.addEventListener,

        // @property edge: Boolean
        // `true` for the Edge web browser.
        edge: 'msLaunchUri' in navigator && !('documentMode' in document),

        // @property webkit: Boolean
        // `true` for webkit-based browsers like Chrome and Safari (including mobile versions).
        webkit: webkit,

        // @property gecko: Boolean
        // `true` for gecko-based browsers like Firefox.
        gecko: gecko,

        // @property android: Boolean
        // `true` for any browser running on an Android platform.
        android: ua.indexOf('android') !== -1,

        // @property android23: Boolean
        // `true` for browsers running on Android 2 or Android 3.
        android23: android23,

        // @property chrome: Boolean
        // `true` for the Chrome browser.
        chrome: chrome,

        // @property safari: Boolean
        // `true` for the Safari browser.
        safari: !chrome && ua.indexOf('safari') !== -1,


        // @property ie3d: Boolean
        // `true` for all Internet Explorer versions supporting CSS transforms.
        ie3d: ie3d,

        // @property webkit3d: Boolean
        // `true` for webkit-based browsers supporting CSS transforms.
        webkit3d: webkit3d,

        // @property gecko3d: Boolean
        // `true` for gecko-based browsers supporting CSS transforms.
        gecko3d: gecko3d,

        // @property opera12: Boolean
        // `true` for the Opera browser supporting CSS transforms (version 12 or later).
        opera12: opera12,

        // @property any3d: Boolean
        // `true` for all browsers supporting CSS transforms.
        any3d: !window.L_DISABLE_3D && (ie3d || webkit3d || gecko3d) && !opera12 && !phantomjs,


        // @property mobile: Boolean
        // `true` for all browsers running in a mobile device.
        mobile: mobile,

        // @property mobileWebkit: Boolean
        // `true` for all webkit-based browsers in a mobile device.
        mobileWebkit: mobile && webkit,

        // @property mobileWebkit3d: Boolean
        // `true` for all webkit-based browsers in a mobile device supporting CSS transforms.
        mobileWebkit3d: mobile && webkit3d,

        // @property mobileOpera: Boolean
        // `true` for the Opera browser in a mobile device.
        mobileOpera: mobile && window.opera,

        // @property mobileGecko: Boolean
        // `true` for gecko-based browsers running in a mobile device.
        mobileGecko: mobile && gecko,


        // @property touch: Boolean
        // `true` for all browsers supporting [touch events](https://developer.mozilla.org/docs/Web/API/Touch_events).
        touch: !!touch,

        // @property msPointer: Boolean
        // `true` for browsers implementing the Microsoft touch events model (notably IE10).
        msPointer: !!msPointer,

        // @property pointer: Boolean
        // `true` for all browsers supporting [pointer events](https://msdn.microsoft.com/en-us/library/dn433244%28v=vs.85%29.aspx).
        pointer: !!pointer,


        // @property retina: Boolean
        // `true` for browsers on a high-resolution "retina" screen.
        retina: (window.devicePixelRatio || (window.screen.deviceXDPI / window.screen.logicalXDPI)) > 1
    };
    
});

/**
 * Created by eason on 16/5/26.
 * 尝试换一种dom事件的实现方式
 */

define('dom/DomEvent',['require','../utils/BaseUtils','./Browser'],function(require){

    var eventsKey = '_vanchart_events';

    var BaseUtils = require('../utils/BaseUtils');
    var Browser = require('./Browser');

    var DomEvent = {

        // @function on(el: HTMLElement, types: String, fn: Function, context?: Object): this
        // Adds a listener function (`fn`) to a particular DOM dom type of the
        // element `el`. You can optionally specify the context of the listener
        // (object the `this` keyword will point to). You can also pass several
        // space-separated types (e.g. `'click dblclick'`).

        // @alternative
        // @function on(el: HTMLElement, eventMap: Object, context?: Object): this
        // Adds a set of type/listener pairs, e.g. `{click: onClick, mousemove: onMouseMove}`
        on: function (obj, types, fn, context) {

            // types can be a map of types/handlers
            if (typeof types === 'object') {
                for (var type in types) {
                    // we don't process space-separated events here for performance;
                    // it's a hot path since Layer uses the on(obj) syntax
                    this._on(obj, type, types[type], fn);
                }
            } else {
                // types can be a string of space-separated words
                types = BaseUtils.splitWords(types);

                for (var i = 0, len = types.length; i < len; i++) {
                    this._on(obj, types[i], fn, context);
                }
            }

            return this;
        },

        // @function off(el: HTMLElement, types: String, fn: Function, context?: Object)
        // Removes a previously added listener function. If no function is specified,
        // it will remove all the listeners of that particular DOM dom from the element.
        // Note that if you passed a custom context to on, you must pass the same
        // context to `off` in order to remove the listener.

        // @alternative
        // @function off(el: HTMLElement, types: eventMap: Object, context?: Object): this
        off: function (obj, types, fn, context) {

            if (!types) {
                // clear all listeners if called without arguments
                delete this._events;

            } else if (typeof types === 'object') {
                for (var type in types) {
                    this._off(obj, type, types[type], fn);
                }

            } else {
                types = BaseUtils.splitWords(types);

                for (var i = 0, len = types.length; i < len; i++) {
                    this._off(obj, types[i], fn, context);
                }
            }

            return this;
        },

        _on: function (obj, type, fn, context) {
            var id = type + BaseUtils.stamp(fn) + (context ? '_' + BaseUtils.stamp(context) : '');

            if (obj[eventsKey] && obj[eventsKey][id]) { return this; }

            var handler = function (e) {
                return fn.call(context || obj, e || window.event);
            };

            var originalHandler = handler;

            // if (Browser.pointer && type.indexOf('touch') === 0) {
            //     this.addPointerListener(obj, type, handler, id);
            //
            // } else if (Browser.touch && (type === 'dblclick') && this.addDoubleTapListener) {
            //     this.addDoubleTapListener(obj, handler, id);
            //
            // }

            if ('addEventListener' in obj) {

                if (type === 'mousewheel') {
                    obj.addEventListener('onwheel' in obj ? 'wheel' : 'mousewheel', handler, false);

                } else if ((type === 'mouseenter') || (type === 'mouseleave')) {
                    handler = function (e) {
                        e = e || window.event;
                        if (DomEvent._isExternalTarget(obj, e)) {
                            originalHandler(e);
                        }
                    };
                    obj.addEventListener(type === 'mouseenter' ? 'mouseover' : 'mouseout', handler, false);

                } else {
                    if (type === 'click' && Browser.android) {
                        handler = function (e) {
                            return DomEvent._filterClick(e, originalHandler);
                        };
                    }
                    obj.addEventListener(type, handler, false);
                }

            } else if ('attachEvent' in obj) {
                obj.attachEvent('on' + type, handler);
            }

            obj[eventsKey] = obj[eventsKey] || {};
            obj[eventsKey][id] = handler;

            return this;
        },

        _off: function (obj, type, fn, context) {

            var id = type + BaseUtils.stamp(fn) + (context ? '_' + BaseUtils.stamp(context) : ''),
                handler = obj[eventsKey] && obj[eventsKey][id];

            if (!handler) { return this; }

            // if (Browser.pointer && type.indexOf('touch') === 0) {
            //     this.removePointerListener(obj, type, id);
            //
            // } else if (Browser.touch && (type === 'dblclick') && this.removeDoubleTapListener) {
            //     this.removeDoubleTapListener(obj, id);
            //
            // }

            if ('removeEventListener' in obj) {

                if (type === 'mousewheel') {
                    obj.removeEventListener('onwheel' in obj ? 'wheel' : 'mousewheel', handler, false);

                } else {
                    obj.removeEventListener(
                        type === 'mouseenter' ? 'mouseover' :
                            type === 'mouseleave' ? 'mouseout' : type, handler, false);
                }

            } else if ('detachEvent' in obj) {
                obj.detachEvent('on' + type, handler);
            }

            obj[eventsKey][id] = null;

            return this;
        },

        // @function stopPropagation(ev: DOMEvent): this
        // Stop the given dom from propagation to parent elements. Used inside the listener functions:
        // ```js
        // DomEvent.on(div, 'click', function (ev) {
        // 	DomEvent.stopPropagation(ev);
        // });
        // ```
        stopPropagation: function (e) {

            if (e.stopPropagation) {
                e.stopPropagation();
            } else if (e.originalEvent) {  // In case of Leaflet dom.
                e.originalEvent._stopped = true;
            } else {
                e.cancelBubble = true;
            }

            DomEvent._skipped(e);

            return this;
        },

        // @function disableScrollPropagation(el: HTMLElement): this
        // Adds `stopPropagation` to the element's `'mousewheel'` events (plus browser variants).
        disableScrollPropagation: function (el) {
            return DomEvent.on(el, 'mousewheel', DomEvent.stopPropagation);
        },

        // @function disableClickPropagation(el: HTMLElement): this
        // Adds `stopPropagation` to the element's `'click'`, `'doubleclick'`,
        // `'mousedown'` and `'touchstart'` events (plus browser variants).
        disableClickPropagation: function (el) {
            var stop = DomEvent.stopPropagation;

            DomEvent.on(el, Draggable.START.join(' '), stop);

            return DomEvent.on(el, {
                click: DomEvent._fakeStop,
                dblclick: stop
            });
        },

        // @function preventDefault(ev: DOMEvent): this
        // Prevents the default action of the DOM Event `ev` from happening (such as
        // following a link in the href of the a element, or doing a POST request
        // with page reload when a `<form>` is submitted).
        // Use it inside listener functions.
        preventDefault: function (e) {

            if (e.preventDefault) {
                e.preventDefault();
            } else {
                e.returnValue = false;
            }
            return this;
        },

        // @function stop(ev): this
        // Does `stopPropagation` and `preventDefault` at the same time.
        stop: function (e) {
            return DomEvent.preventDefault(e).stopPropagation(e);
        },

        // @function getWheelDelta(ev: DOMEvent): Number
        // Gets normalized wheel delta from a mousewheel DOM dom, in vertical
        // pixels scrolled (negative if scrolling down).
        // Events from pointing devices without precise scrolling are mapped to
        // a best guess of between 50-60 pixels.
        getWheelDelta: function (e) {
            return (e.deltaY && e.deltaMode === 0) ? -e.deltaY :        // Pixels
                (e.deltaY && e.deltaMode === 1) ? -e.deltaY * 18 :   // Lines
                    (e.deltaY && e.deltaMode === 2) ? -e.deltaY * 52 :   // Pages
                        (e.deltaX || e.deltaZ) ? 0 :	// Skip horizontal/depth wheel events
                            e.wheelDelta ? (e.wheelDeltaY || e.wheelDelta) / 2 : // Legacy IE pixels
                                (e.detail && Math.abs(e.detail) < 32765) ? -e.detail * 18 : // Legacy Moz lines
                                    e.detail ? e.detail / -32765 * 52 : // Legacy Moz pages
                                        0;
        },

        _skipEvents: {},

        _fakeStop: function (e) {
            // fakes stopPropagation by setting a special dom flag, checked/reset with DomEvent._skipped(e)
            DomEvent._skipEvents[e.type] = true;
        },

        _skipped: function (e) {
            var skipped = this._skipEvents[e.type];
            // reset when checking, as it's only used in map container and propagates outside of the map
            this._skipEvents[e.type] = false;
            return skipped;
        },

        // check if element really left/entered the dom target (for mouseenter/mouseleave)
        _isExternalTarget: function (el, e) {

            var related = e.relatedTarget;

            if (!related) { return true; }

            try {
                while (related && (related !== el)) {
                    related = related.parentNode;
                }
            } catch (err) {
                return false;
            }
            return (related !== el);
        },

        // this is a horrible workaround for a bug in Android where a single touch triggers two click events
        _filterClick: function (e, handler) {
            var timeStamp = (e.timeStamp || (e.originalEvent && e.originalEvent.timeStamp)),
                elapsed = DomEvent._lastClick && (timeStamp - DomEvent._lastClick);

            // are they closer together than 500ms yet more than 100ms?
            // Android typically triggers them ~300ms apart while multiple listeners
            // on the same dom should be triggered far faster;
            // or check if click is simulated on the element, and if it is, reject any non-simulated events

            if ((elapsed && elapsed > 100 && elapsed < 500) || (e.target._simulatedClick && !e._simulated)) {
                DomEvent.stop(e);
                return;
            }

            DomEvent._lastClick = timeStamp;

            handler(e);
        }
    };

    DomEvent.addListener = DomEvent.on;

    DomEvent.removeListener = DomEvent.off;

    return DomEvent;

});

/**
 * Created by eason on 16/5/26.
 */

define('dom/Evented',['require','../utils/QueryUtils','../utils/BaseUtils','../utils/Class'],function(require){

    var QueryUtils = require('../utils/QueryUtils');
    var BaseUtils = require('../utils/BaseUtils');
    var Class = require('../utils/Class');

    var Evented = Class.extend(
        {
            /* @method on(type: String, fn: Function, context?: Object): this
             * Adds a listener function (`fn`) to a particular event type of the object. You can optionally specify the context of the listener (object the this keyword will point to). You can also pass several space-separated types (e.g. `'click dblclick'`).
             *
             * @alternative
             * @method on(eventMap: Object): this
             * Adds a set of type/listener pairs, e.g. `{click: onClick, mousemove: onMouseMove}`
             */
            on: function (types, fn, context) {

                // types can be a map of types/handlers
                if (typeof types === 'object') {
                    for (var type in types) {
                        // we don't process space-separated events here for performance;
                        // it's a hot path since Layer uses the on(obj) syntax
                        this._on(type, types[type], fn);
                    }

                } else {
                    // types can be a string of space-separated words
                    types = BaseUtils.splitWords(types);

                    for (var i = 0, len = types.length; i < len; i++) {
                        this._on(types[i], fn, context);
                    }
                }

                return this;
            },

            /* @method off(type: String, fn?: Function, context?: Object): this
             * Removes a previously added listener function. If no function is specified, it will remove all the listeners of that particular event from the object. Note that if you passed a custom context to `on`, you must pass the same context to `off` in order to remove the listener.
             *
             * @alternative
             * @method off(eventMap: Object): this
             * Removes a set of type/listener pairs.
             *
             * @alternative
             * @method off: this
             * Removes all listeners to all events on the object.
             */
            off: function (types, fn, context) {

                if (!types) {
                    // clear all listeners if called without arguments
                    delete this._events;

                } else if (typeof types === 'object') {
                    for (var type in types) {
                        this._off(type, types[type], fn);
                    }

                } else {
                    types = BaseUtils.splitWords(types);

                    for (var i = 0, len = types.length; i < len; i++) {
                        this._off(types[i], fn, context);
                    }
                }

                return this;
            },

            // attach listener (without syntactic sugar now)
            _on: function (type, fn, context) {

                if(!fn){
                    return;
                }

                var events = this._events = this._events || {},
                    contextId = context && context !== this && BaseUtils.stamp(context);

                if (contextId) {
                    // store listeners with custom context in a separate hash (if it has an id);
                    // gives a major performance boost when firing and removing events (e.g. on map object)

                    var indexKey = type + '_idx',
                        indexLenKey = type + '_len',
                        typeIndex = events[indexKey] = events[indexKey] || {},
                        id = BaseUtils.stamp(fn) + '_' + contextId;

                    if (!typeIndex[id]) {
                        typeIndex[id] = {fn: fn, ctx: context};

                        // keep track of the number of keys in the index to quickly check if it's empty
                        events[indexLenKey] = (events[indexLenKey] || 0) + 1;
                    }

                } else {
                    // individual layers mostly use "this" for context and don't fire listeners too often
                    // so simple array makes the memory footprint better while not degrading performance

                    events[type] = events[type] || [];
                    events[type].push({fn: fn});
                }
            },

            _off: function (type, fn, context) {

                if(!fn){
                    return;
                }

                var events = this._events,
                    indexKey = type + '_idx',
                    indexLenKey = type + '_len';

                if (!events) { return; }

                if (!fn) {
                    // clear all listeners for a type if function isn't specified
                    delete events[type];
                    delete events[indexKey];
                    delete events[indexLenKey];
                    return;
                }

                var contextId = context && context !== this && BaseUtils.stamp(context),
                    listeners, i, len, listener, id;

                if (contextId) {
                    id = BaseUtils.stamp(fn) + '_' + contextId;
                    listeners = events[indexKey];

                    if (listeners && listeners[id]) {
                        listener = listeners[id];
                        delete listeners[id];
                        events[indexLenKey]--;
                    }

                } else {
                    listeners = events[type];

                    if (listeners) {
                        for (i = 0, len = listeners.length; i < len; i++) {
                            if (listeners[i].fn === fn) {
                                listener = listeners[i];
                                listeners.splice(i, 1);
                                break;
                            }
                        }
                    }
                }

                // set the removed listener to noop so that's not called if remove happens in fire
                if (listener) {
                    listener.fn = BaseUtils.falseFn;
                }
            },

            // @method fire(type: String, data?: Object, propagate?: Boolean): this
            // Fires an event of the specified type. You can optionally provide an data
            // object — the first argument of the listener function will contain its
            // properties. The event might can optionally be propagated to event parents.
            fire: function (type, data, propagate) {
                if (!this.listens(type, propagate)) { return this; }

                var event = BaseUtils.extend({}, data, {type: type, target: this}),
                    events = this._events;

                if (events) {
                    var typeIndex = events[type + '_idx'],
                        i, len, listeners, id;

                    if (events[type]) {
                        // make sure adding/removing listeners inside other listeners won't cause infinite loop
                        listeners = events[type].slice();

                        for (i = 0, len = listeners.length; i < len; i++) {
                            listeners[i].fn.call(this, event);
                        }
                    }

                    // fire event for the context-indexed listeners as well
                    for (id in typeIndex) {
                        typeIndex[id].fn.call(typeIndex[id].ctx, event);
                    }
                }

                if (propagate) {
                    // propagate the event to parents (set with addEventParent)
                    this._propagateEvent(event);
                }

                return this;
            },

            // @method listens(type: String): Boolean
            // Returns `true` if a particular event type has any listeners attached to it.
            listens: function (type, propagate) {
                var events = this._events;

                if (events && (events[type] || events[type + '_len'])) { return true; }

                if (propagate) {
                    // also check parents for listeners if event propagates
                    for (var id in this._eventParents) {
                        if (this._eventParents[id].listens(type, propagate)) { return true; }
                    }
                }
                return false;
            },

            _propagateEvent: function (e) {
                for (var id in this._eventParents) {
                    this._eventParents[id].fire(e.type, BaseUtils.extend({layer: e.target}, e), true);
                }
            }
        }
    );

    return Evented;
});
/**
 * Created by eason on 16/7/28.
 * 用hammer.js来封装我们的事件,这样可以统一处理移动端的问题
 */
/**
 * Created by eason on 16/2/19.
 * 处理事件
 */

define('HammerHandler',['require','./utils/BaseUtils','./Constants','./dom/DomEvent','./dom/Evented','./ComponentLibrary'],function(require){

    var BaseUtils = require('./utils/BaseUtils');
    var Constants = require('./Constants');
    var DomEvent = require('./dom/DomEvent');
    var Evented = require('./dom/Evented');
    var ComponentLibrary = require('./ComponentLibrary');

    var Handler = Evented.extend({

        initialize:function(vanchart, container){
            this.vanchart = vanchart;
            this._container = container;

            var hammer = this.hammer = new Hammer.Manager(container);

            hammer.add(new Hammer.Pan({ threshold: 0, pointers: 0 }));

            hammer.add(new Hammer.Tap());

            hammer.add(new Hammer.Press());

            hammer.on("panstart panmove panend tap press pressup", fireDOMEvent);

            //对于鼠标还要处理悬浮的情况
            if(!BaseUtils.hasTouch()){
                hammer.on('mouseover mousemove mouseout', fireDOMEvent);
            }

            var rootHandler = this; this.panTarget = null;
            rootHandler.on(rootHandler.getEvents());

            function fireDOMEvent(ev){
                var srcEvent = ev.srcEvent, type = ev.type || srcEvent.type;
                var src = srcEvent.target || srcEvent.srcElement;
                ev.containerPoint = BaseUtils.getMousePos(srcEvent, container);

                //图例的拖拽通过dom来判断并不是很准确,用位置来试一下
                var legend = vanchart.getComponent(ComponentLibrary.LEGEND_COMPONENT);

                var isHover = type === 'tap' || type === 'mouseover' || type == 'mouseout';
                var isPan = type == 'panstart' || type == 'panmove' || type == 'panend';

                var target;

                if(isPan && rootHandler.panTarget){
                    target = rootHandler.panTarget;
                }else{
                    while (src) {

                        //todo 这里可以写的更通用一点,用范围来判断target
                        if(isPan && legend && legend.visible && BaseUtils.containsPoint(legend.bounds, ev.containerPoint)){
                            target = legend;
                        }else{
                            target = vanchart.renderer.findInteractiveTarget(src);
                        }

                        if ((target && target.listens(type, true)) || (src === rootHandler._container)) {
                            break;
                        }

                        src = src.parentNode;
                    }
                    target = target && target.listens(type, true) ? target : rootHandler;
                }

                if (target && target.listens(type, true)){
                    target.fire(type, ev, true);

                    if(type == 'panstart'){
                        rootHandler.panTarget = target;
                    } else if(type == 'panend'){
                        rootHandler.panTarget = null;
                    }
                }
            }
        },

        onContainerMouseOver:function(ev){

        },

        //鼠标在绘图区域里的操作
        onContainerMouseMove:function(ev){
            var plotBounds = this.vanchart.getPlotBounds(), vanchart = this.vanchart;

            //鼠标在绘图区空白区域悬浮时,需要响应一下按照范围选中的点
            if(BaseUtils.containsPoint(plotBounds, ev.containerPoint)){

                var event = ev.srcEvent, src = event.target || event.srcElement;

                if(!this._highlightShared(ev)){
                    this._removeHightlight();
                    var closestPoint;
                    if(src.getContext){//canvas
                        closestPoint = this._getCanvasClosestPoint(ev);
                        if(closestPoint){
                            if(!closestPoint._events){
                                closestPoint.getEvents && closestPoint.on(closestPoint.getEvents(), closestPoint);
                            }
                            vanchart.showTooltip(closestPoint, ev);
                            vanchart.hoverPoint = closestPoint;
                        }
                    }else if(vanchart.hoverSeries){
                        closestPoint = vanchart.hoverSeries.getClosestPoint(ev.containerPoint);
                        if(closestPoint){
                            if(!closestPoint._events){
                                closestPoint.getEvents && closestPoint.on(closestPoint.getEvents(), closestPoint);
                            }
                            closestPoint.fire('mouseover', ev);
                        }
                    }
                }
            }else{
                //移出绘图区的时候取消所有的选中状态
                this._removeHightlight();

                if(vanchart.hoverPoint){
                    vanchart.hoverPoint.fire('mouseout', ev);
                    vanchart.hoverPoint = null;
                }

                if(vanchart.hoverSeries){
                    vanchart.hoverSeries.fire('seriesUnChosen', ev);
                }

                vanchart.getComponent(ComponentLibrary.TOOLTIP_COMPONENT).immediateHide();
            }
        },

        _getCanvasClosestPoint:function(ev){

            var series = [].concat(this.vanchart.series[Constants.BUBBLE_CHART] || [], this.vanchart.series[Constants.SCATTER_CHART] || []);
            var plotBounds = this.vanchart.getPlotBounds(), pos = ev.containerPoint;

            for(var sIndex = series.length - 1; sIndex >= 0; sIndex--){
                var sery = series[sIndex];

                for(var pIndex = sery.points.length - 1; pIndex >= 0; pIndex--){

                    var point = sery.points[pIndex];

                    var detX = point.posX + plotBounds.x - pos[0];

                    var detY = point.posY + plotBounds.y - pos[1];

                    var len = Math.sqrt(detX * detX + detY * detY);

                    var radius = point.radius || (point.marker && point.marker.radius) || 4.5;

                    if(len <= radius && point.visible){
                        return point;
                    }
                }
            }

        },

        onContainerMouseOut:function(ev){

        },

        onContainerTap:function(ev){
            this.onContainerMouseMove(ev);

            if(this.vanchart.hoverPoint){
                this.vanchart.hoverPoint.fire('tap', ev);
            }
        },

        onContainerPanStart:function(ev){

            var vanchart = this.vanchart, renderer = vanchart.renderer, hoverPoint = vanchart.hoverPoint, mousePos = ev.containerPoint;
            var plotBounds = vanchart.bounds;

            //缩放
            if(!this.selectRect && this._supportCoordinateZoom() && BaseUtils.containsPoint(plotBounds, mousePos)){
                this.selectRect = renderer.rect().style({'fill':'rgb(69,114,167)', 'fill-opacity':0.25}).add();
                this.downPos = mousePos;

                vanchart.hoverPoint && vanchart.hoverPoint.fire('mouseout');
            }

        },

        onContainerPanMove:function(ev){

            var vanchart = this.vanchart, renderer = vanchart.renderer, hoverPoint = vanchart.hoverPoint;
            var plotBounds = vanchart.bounds, options = vanchart.getOptions();
            var mousePos = ev.containerPoint, downPos = this.downPos;

            if(this.selectRect){
                var zoomType = options.zoom.zoomType;
                var x = Math.min(mousePos[0], downPos[0]);
                var y = Math.min(mousePos[1], downPos[1]);
                var width = Math.abs(mousePos[0] - downPos[0]);
                var height = Math.abs(mousePos[1] - downPos[1]);

                var isXZoom = zoomType.indexOf('x') != -1;
                var isYZoom = zoomType.indexOf('y') != -1;

                if(isXZoom && !isYZoom){
                    y = plotBounds.y;
                    height = plotBounds.height;
                }else if(isYZoom && !isXZoom){
                    x = plotBounds.x;
                    width = plotBounds.width;
                }
                this.selectRect.attr({x:x, y:y, width:width, height:height});
            }

        },

        onContainerPanEnd:function(ev){

            var vanchart = this.vanchart, renderer = vanchart.renderer, hoverPoint = vanchart.hoverPoint;
            var plotBounds = vanchart.bounds, options = vanchart.getOptions();
            var mousePos = ev.containerPoint, downPos = this.downPos;
            var toolbar = vanchart.components[ComponentLibrary.TOOLBAR_COMPONENT];

            if(this.selectRect){
                vanchart.dealAxisZoom(downPos, mousePos);
                this.selectRect.remove();
                this.selectRect = null;
                toolbar && toolbar.showRefreshIconWhenZoom();
            }

            this.panTarget = null;
        },

        _highlightShared: function (event) {

            var axis = this.vanchart.getSharedAxis();

            if(axis && axis.getPointsInCategory){
                var pos = event.containerPoint;
                var catePoints = axis.getPointsInCategory(pos);
                var sharedPoints;
                if (catePoints &&
                    (sharedPoints = catePoints.filter(function (p) { return p.tooltip && p.tooltip.shared }) )&&
                    sharedPoints.length) {
                    sharedPoints[0]._onPointMouseOver.call(sharedPoints[0], event);
                    axis.drawHighlightBackground(sharedPoints);
                    return true;
                }
            }

            return false;
        },

        _removeHightlight: function () {
            var axis = this.vanchart.getSharedAxis();
            axis && axis.removeHighlightBackground && axis.removeHighlightBackground();
        },

        getEvents:function(){
            return {
                'mouseover':this.onContainerMouseOver,
                'mousemove':this.onContainerMouseMove,
                'mouseout':this.onContainerMouseOut,

                'tap':this.onContainerTap,
                'panstart':this.onContainerPanStart,
                'panmove':this.onContainerPanMove,
                'panend':this.onContainerPanEnd
            };
        },

        _supportCoordinateZoom:function(){
            var isForceBubble = this.vanchart.hoverPoint && this.vanchart.vanChartType == 'vanChartForceBubble';
            var option = this.vanchart.getOptions();
            return BaseUtils.isSupportSVG() && option.zoom && option.zoom.zoomType && !isForceBubble;
        },

        destroy: function () {
            this.hammer.destroy();
        }
    });

    return Handler;
});
/**
 * Created by eason on 16/7/22.
 */

define('vector/ElementWrapper',['require','../utils/Class'],function(require){

    var Class = require('../utils/Class');

    var ElementWrapper = Class.extend({

        /**
         * wrap the elements to hide implementation details
         * @param rawElement dom elements for svg and vml,and data object for canvas
         * @param renderer the renderer that the rawElement belongs to
         */
        initialize:function(rawElement, renderer){
            this.rawElement = rawElement;

            this.renderer = renderer;

            return this;
        },

        node: function () {
            return this.rawElement;
        },

        /**
         * add the rawElement to the parent container
         * append to the container for svg and vml
         * or show for canvas
         * @param parentElementWrapper
         * @returns {ElementWrapper}
         */
        addTo:function(parentElementWrapper){
            this.renderer.addChildElement(this, parentElementWrapper);

            return this;
        },

        add:function(){
            if (this.type === 'div') {
                return this.addTo(this.renderer._divContainer);
            }
            return this.addTo(this.renderer._container);
        },

        append: function (childElementWrapper) {
            this.renderer.addChildElement(childElementWrapper, this);

            return childElementWrapper;
        },

        //bind data to the elementWrapper
        datum:function(){
            if(arguments.length){
                this._datum = arguments[0];
                return this;
            }
            return this._datum;
        },

        /**
         * remove from the renderer container
         * for canvas, we shall clear the context and redraw all
         * the other elements on the container
         */
        remove:function(){
            this.renderer.removeChildElement(this);

            this.rawElement = this.renderer = null;

            return this;
        },

        attr:function(){

            if (this.type === 'div') {
                this.style.apply(this, arguments);
            } else {
                this.renderer.attr(this, arguments);
            }
            return this;
        },

        style:function(){
            var styles;
            if (arguments.length === 2) {
                styles = {};
                styles[arguments[0]] = arguments[1];
            } else {
                styles = arguments[0];
            }
            this.renderer.style(this, styles);
            return this;
        },

        //ie下面用vml path模拟所有的形状,所以需要记录一下形状的类型
        type:function(type){
            this.type = type;
            return this;
        },

        textContent:function(text){
            this.renderer.textContent(this, text);
            return this;
        },

        animate:function(context, animationFn, attrs, delay){
            animationFn.call(context, this.rawElement, attrs, delay);
        },

        // rotate text(div, svg) according to center
        // for less dom operation, set textContent & style first
        // then rotate
        vRotate: function (deg) {
            this.renderer.vRotate(this, deg);
            return this;
        }

    });

    return ElementWrapper;
});
/**
 * Created by eason on 16/6/1.
 * 这个js做成类似接口的东西吧
 */

define('vector/Renderer',['require','../utils/Class','../utils/BaseUtils','./ElementWrapper'],function(require){

    var Class = require('../utils/Class');
    var BaseUtils = require('../utils/BaseUtils');
    var ElementWrapper = require('./ElementWrapper');

    var Renderer = Class.extend({
        /**
         * this._container may be svg,canvas,dom
         */
        initialize:function(dom, vanchart){
            this._container = this._initContainerDom(dom, vanchart);

            this._divContainer = this.div()
                .style({'white-space':'nowrap','pointer-events':'none'});
            dom.appendChild(this._divContainer.node());

            this.vanchart = vanchart;

            this._targets = {};

            this.isSupportSVG = BaseUtils.isSupportSVG();
        },

        remove:function(){
            this._container.remove();
            this._divContainer.remove();
        },

        div: function () {
            return new ElementWrapper(document.createElement('div'), this).type('div')
                .style({position:'absolute',left:0,top:0})
        },

        vgroup: function () {
            var divG = this.div();
            var renderG = this.group();
            return {
                divG: divG,
                renderG: renderG,
                type: 'vgroup',
                attr: function () {
                    this.divG.attr.apply(this.divG, arguments);
                    this.renderG.attr.apply(this.renderG, arguments);
                    return this;
                },
                append: function (ele) {
                    if (ele.type === 'div') {
                        divG.append(ele);
                    } else if (ele.type === 'vgroup') {
                        divG.append(ele.divG);
                        renderG.append(ele.renderG);
                    } else {
                        renderG.append(ele);
                    }
                    return ele;
                },
                add: function () {
                    this.divG.add();
                    this.renderG.add();
                    return this;
                },
                remove: function () {
                    this.divG.node() && this.divG.remove();
                    this.renderG.node() && this.renderG.remove();
                },
                vRotate: function (deg) {
                    this.divG.vRotate(deg);
                    this.renderG.vRotate(deg);
                }
            };
        },

        vtext: function (isHtml) {
            if (isHtml || !this.isSupportSVG) {
                return this.div();
            }
            return this.text();
        },

        vtspan: function (isHtml) {
            if (isHtml || !this.isSupportSVG) {
                return this.div();
            }
            return this.tspan();
        },

        addChildElement:function(childWrapper, parentWrapper){

            var dom = (parentWrapper || this._container).rawElement;

            dom.appendChild(childWrapper.rawElement);
        },

        removeChildElement:function(childWrapper){

            var dom = childWrapper.rawElement;

            this.removeInteractiveTarget(childWrapper);

            dom.parentNode.removeChild(dom);
        },

        //register visual elements that respond to events
        //data can be anything like dataPoint, series, or legend item
        registerInteractiveTarget:function(data, elementWrapper){
            this.removeInteractiveTarget(elementWrapper);
            this._targets[BaseUtils.stamp(elementWrapper.rawElement)] = elementWrapper;
            this._targets[BaseUtils.stamp(elementWrapper)] = data;
            data && data.getEvents && data.on(data.getEvents(), data);
        },

        findInteractiveTarget:function(rawElement){
            var wrapper = this._targets[BaseUtils.stamp(rawElement)];
            return wrapper && this._targets[BaseUtils.stamp(wrapper)];
        },

        removeInteractiveTarget:function(elementWrapper){
            this._targets[BaseUtils.stamp(elementWrapper.rawElement)] = null;
            var data = this._targets[BaseUtils.stamp(elementWrapper)];
            data && data.getEvents && data.off(data.getEvents(), data);
            data = null;
        }
    });

    return Renderer;
});
/**
 * Created by eason on 16/6/1.
 */

define('utils/DomUtils',['require','./BaseUtils'],function(require){

    var BaseUtils = require('./BaseUtils');

    var DomUtils = {
        // @function get(id: String|HTMLElement): HTMLElement
        // Returns an element given its DOM id, or returns the element itself
        // if it was passed directly.
        get: function (id) {
            return typeof id === 'string' ? document.getElementById(id) : id;
        },

        // @function getStyle(el: HTMLElement, styleAttrib: String): String
        // Returns the value for a certain style attribute on an element,
        // including computed values or values set through CSS.
        getStyle: function (el, style) {

            var value = el.style[style] || (el.currentStyle && el.currentStyle[style]);

            if ((!value || value === 'auto') && document.defaultView) {
                var css = document.defaultView.getComputedStyle(el, null);
                value = css ? css[style] : null;
            }

            return value === 'auto' ? null : value;
        },

        // @function create(tagName: String, className?: String, container?: HTMLElement): HTMLElement
        // Creates an HTML element with `tagName`, sets its class to `className`, and optionally appends it to `container` element.
        create: function (tagName, className, container) {

            var el = document.createElement(tagName);
            el.className = className;

            if (container) {
                container.appendChild(el);
            }

            return el;
        },

        // @function remove(el: HTMLElement)
        // Removes `el` from its parent element
        remove: function (el) {
            var parent = el.parentNode;
            if (parent) {
                parent.removeChild(el);
            }
        },

        // @function empty(el: HTMLElement)
        // Removes all of `el`'s children elements from `el`
        empty: function (el) {
            while (el.firstChild) {
                el.removeChild(el.firstChild);
            }
        },

        // @function toFront(el: HTMLElement)
        // Makes `el` the last children of its parent, so it renders in front of the other children.
        toFront: function (el) {
            el.parentNode.appendChild(el);
        },

        // @function toBack(el: HTMLElement)
        // Makes `el` the first children of its parent, so it renders back from the other children.
        toBack: function (el) {
            var parent = el.parentNode;
            parent.insertBefore(el, parent.firstChild);
        },

        // @function hasClass(el: HTMLElement, name: String): Boolean
        // Returns `true` if the element's class attribute contains `name`.
        hasClass: function (el, name) {
            if (el.classList !== undefined) {
                return el.classList.contains(name);
            }
            var className = L.DomUtil.getClass(el);
            return className.length > 0 && new RegExp('(^|\\s)' + name + '(\\s|$)').test(className);
        },

        // @function addClass(el: HTMLElement, name: String)
        // Adds `name` to the element's class attribute.
        addClass: function (el, name) {
            if (el.classList !== undefined) {
                var classes = L.Util.splitWords(name);
                for (var i = 0, len = classes.length; i < len; i++) {
                    el.classList.add(classes[i]);
                }
            } else if (!L.DomUtil.hasClass(el, name)) {
                var className = L.DomUtil.getClass(el);
                L.DomUtil.setClass(el, (className ? className + ' ' : '') + name);
            }
        },

        // @function removeClass(el: HTMLElement, name: String)
        // Removes `name` from the element's class attribute.
        removeClass: function (el, name) {
            if (el.classList !== undefined) {
                el.classList.remove(name);
            } else {
                L.DomUtil.setClass(el, L.Util.trim((' ' + L.DomUtil.getClass(el) + ' ').replace(' ' + name + ' ', ' ')));
            }
        },

        // @function setClass(el: HTMLElement, name: String)
        // Sets the element's class.
        setClass: function (el, name) {
            if (el.className.baseVal === undefined) {
                el.className = name;
            } else {
                // in case of SVG element
                el.className.baseVal = name;
            }
        },

        // @function getClass(el: HTMLElement): String
        // Returns the element's class.
        getClass: function (el) {
            return el.className.baseVal === undefined ? el.className : el.className.baseVal;
        },

        // @function setOpacity(el: HTMLElement, opacity: Number)
        // Set the opacity of an element (including old IE support).
        // `opacity` must be a number from `0` to `1`.
        setOpacity: function (el, value) {

            if ('opacity' in el.style) {
                el.style.opacity = value;

            } else if ('filter' in el.style) {
                L.DomUtil._setOpacityIE(el, value);
            }
        },

        _setOpacityIE: function (el, value) {
            var filter = false,
                filterName = 'DXImageTransform.Microsoft.Alpha';

            // filters collection throws an error if we try to retrieve a filter that doesn't exist
            try {
                filter = el.filters.item(filterName);
            } catch (e) {
                // don't set opacity to 1 if we haven't already set an opacity,
                // it isn't needed and breaks transparent pngs.
                if (value === 1) { return; }
            }

            value = Math.round(value * 100);

            if (filter) {
                filter.Enabled = (value !== 100);
                filter.Opacity = value;
            } else {
                el.style.filter += ' progid:' + filterName + '(opacity=' + value + ')';
            }
        },

        // @function testProp(props: String[]): String|false
        // Goes through the array of style names and returns the first name
        // that is a valid style name for an element. If no such name is found,
        // it returns false. Useful for vendor-prefixed styles like `transform`.
        testProp: function (props) {

            var style = document.documentElement.style;

            for (var i = 0; i < props.length; i++) {
                if (props[i] in style) {
                    return props[i];
                }
            }
            return false;
        },

        /**
         * Set or get an attribute or an object of attributes. Can't use jQuery attr because
         * it attempts to set expando properties on the SVG element, which is not allowed.
         *
         * @param {Object} elem The DOM element to receive the attribute(s)
         * @param {String|Object} prop The property or an abject of key-value pairs
         * @param {String} value The value if a single property is set
         */
        attr: function () {
            if(arguments.length < 2){
                return;
            }
            var elem = arguments[0], prop = arguments[1], value = arguments[2];
            var key, ret;
            if (typeof prop == 'string') {
                // set the value
                if (BaseUtils.hasDefined(value)) {
                    elem.setAttribute(prop, value);
                    // get the value
                } else if (elem && elem.getAttribute) { // elem not defined when printing pie demo...
                    ret = elem.getAttribute(prop);
                }
                // else if prop is defined, it is a hash of key/value pairs
            } else if (BaseUtils.hasDefined(prop) && typeof prop == 'object') {
                for (key in prop) {
                    elem.setAttribute(key, prop[key]);
                }
            }
            return ret;
        }
    };

    return DomUtils;
});
/**
 * Created by eason on 16/6/1.
 */

define('vector/SvgRenderer',['require','./Renderer','../utils/DomUtils','./ElementWrapper','../utils/BaseUtils'],function(require){

    var Renderer = require('./Renderer');
    var DomUtils = require('../utils/DomUtils');
    var ElementWrapper = require('./ElementWrapper');
    var BaseUtils = require('../utils/BaseUtils');

    var Svg = Renderer.extend({

        _initContainerDom:function(dom, vanchart){
            var root = new ElementWrapper(this.create('svg'), this);
            root.style({width:vanchart.width + 'px',height:vanchart.height + 'px'});
            dom.appendChild(root.rawElement);

            //defs里包括几样东西,线性渐变,放射渐变,内阴影,外阴影,clip
            this.defs = new ElementWrapper(this.create('defs'), this).addTo(root);

            if(vanchart._leaflet){
                root.style('pointer-events', 'none');
            }

            return root;
        },

        line:function(attrs){
            return new ElementWrapper(this.create('line'), this).attr(attrs);
        },

        rect:function(attrs){
            return new ElementWrapper(this.create('rect'), this).attr(attrs);
        },

        circle:function(attrs){
            return new ElementWrapper(this.create('circle'), this).attr(attrs);
        },

        path:function(attrs){
            return new ElementWrapper(this.create('path'), this).attr(attrs);
        },

        text:function(attrs){
            return new ElementWrapper(this.create('text'), this).attr(attrs);
        },

        tspan:function(attrs){
            return new ElementWrapper(this.create('tspan'), this).attr(attrs);
        },

        image:function(attrs){
            return new ElementWrapper(this.create('image'), this).attr(attrs);
        },

        group:function(attrs){
            return new ElementWrapper(this.create('g'), this).attr(attrs);
        },

        textContent:function(elementW, text){
            elementW.type === 'div' ? elementW.node().innerHTML = text : elementW.node().textContent = text;
        },

        colorGradient:function(attrs, stops, type){
            type = type || 'linearGradient';

            var fillFilter = new ElementWrapper(this.create(type), this);
            attrs.id = BaseUtils.stamp(fillFilter);
            fillFilter.attr(attrs);

            fillFilter.stops = [];
            for(var i = 0, len = stops.length; i < len; i++){
                fillFilter.stops[i] = new ElementWrapper(this.create('stop'), this)
                    .attr("offset", stops[i].offset)
                    .style({'stop-color':stops[i]['stop-color']})
                    .addTo(fillFilter);
            }

            return fillFilter.addTo(this.defs);
        },

        updateColorGradient:function(gradient, attrs, stops){
            gradient.attr(attrs);
            for(var i = 0, len = stops.length; i < len; i++){
                gradient.stops[i].attr("offset", stops[i].offset).style({'stop-color':stops[i]['stop-color']});
            }
        },

        createClip: function (attrs, type) {
            type = type || 'rect';
            var clip = new ElementWrapper(this.create('clipPath'), this);
            clip.attr('id', BaseUtils.stamp(clip));

            clip[type] = new ElementWrapper(this.create(type), this).attr(attrs).addTo(clip);

            clip.addTo(this.defs);

            return clip;
        },

        clip:function(elementWrapper, clipWrapper){
            elementWrapper.attr('clip-path', "url(#" + BaseUtils.stamp(clipWrapper) +")");
        },

        imagePattern:function(patterAttr, imageAttr){

            var pattern = new ElementWrapper(this.create('pattern'), this);
            patterAttr.id = BaseUtils.stamp(pattern);

            pattern.attr(patterAttr);

            pattern.image = new ElementWrapper(this.create('image'), this).addTo(pattern);
            pattern.image.attr(imageAttr);

            pattern.addTo(this.defs);

            return pattern;
        },

        updateImagePattern:function(imagePattern, patterAttr, imageAttr){
            imagePattern.attr(patterAttr);
            imagePattern.image.attr(imageAttr);
        },

        createDropShadowFilter:function(dx, dy, alpha, deviation){

            var dropFilter = new ElementWrapper(this.create('filter'), this);
            var id = BaseUtils.stamp(dropFilter);
            dropFilter.attr({
                'id':id, 'x':'-50%', 'y':'-50%', 'width':'200%', 'height':'200%'
            });

            dropFilter.feOffset = dropFilter.feOffset || new ElementWrapper(this.create('feOffset'), this).addTo(dropFilter);

            dropFilter.feOffset.attr({
                'in':'SourceAlpha', 'dx':dx, 'dy':dy, 'result':'offOut'
            });

            dropFilter.feColorMatrix = dropFilter.feColorMatrix || new ElementWrapper(this.create('feColorMatrix'), this).addTo(dropFilter);
            dropFilter.feColorMatrix.attr({
                'in':'offOut', 'type':'matrix', 'values':'0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 '+alpha+' 0','result':'matrixOut'
            });

            dropFilter.feGaussianBlur = dropFilter.feGaussianBlur || new ElementWrapper(this.create('feGaussianBlur'), this).addTo(dropFilter);
            dropFilter.feGaussianBlur.attr({
                'in':'matrixOut', 'stdDeviation':deviation, 'result':'blurOut'
            });

            dropFilter.feBlend = dropFilter.feBlend || new ElementWrapper(this.create('feBlend'), this).addTo(dropFilter);
            dropFilter.feBlend.attr({
                "in": 'SourceGraphic', 'in2':'blurOut', 'mode':'normal'
            });

            dropFilter.addTo(this.defs);

            return dropFilter;
        },

        createInnerShadowFilter:function(dx, dy, alpha, deviation){
            var innerFilter = new ElementWrapper(this.create('filter'), this);
            var id = BaseUtils.stamp(innerFilter);
            innerFilter.attr({
                'id':id, 'x':'-50%', 'y':'-50%', 'width':'200%', 'height':'200%'
            });

            innerFilter.feComponentTransfer = innerFilter.feComponentTransfer || new ElementWrapper(this.create('feComponentTransfer'), this).attr({'in':'SourceAlpha'}).addTo(innerFilter);
            innerFilter.feComponentTransfer.feFuncA = innerFilter.feComponentTransfer.feFuncA || new ElementWrapper(this.create('feFuncA'), this).attr({'type':'table', 'tableValues': '1 0'}).addTo(innerFilter.feComponentTransfer);

            innerFilter.feGaussianBlur = innerFilter.feGaussianBlur || new ElementWrapper(this.create('feGaussianBlur'), this).addTo(innerFilter);
            innerFilter.feGaussianBlur.attr('stdDeviation', deviation);

            innerFilter.feOffset = innerFilter.feOffset || new ElementWrapper(this.create('feOffset'), this).addTo(innerFilter);
            innerFilter.feOffset.attr({'dx': dx, 'dy': dy, 'result':'offsetblur'});

            innerFilter.feFlood = innerFilter.feFlood || new ElementWrapper(this.create('feFlood'), this).addTo(innerFilter);
            innerFilter.feFlood.attr({'flood-color': 'black', 'flood-opacity': alpha, 'result':'color'});

            innerFilter.feComposite1 = innerFilter.feComposite1 || new ElementWrapper(this.create('feComposite'), this).attr({'in2':'offsetblur', 'operator':'in'}).addTo(innerFilter);

            innerFilter.feComposite2 = innerFilter.feComposite2 || new ElementWrapper(this.create('feComposite'), this).attr({'in2':'SourceAlpha', 'operator':'in'}).addTo(innerFilter);

            innerFilter.merge = innerFilter.merge || new ElementWrapper(this.create('feMerge'), this).addTo(innerFilter);

            innerFilter.merge.feMergeNode1 = innerFilter.merge.feMergeNode1 || new ElementWrapper(this.create('feMergeNode'), this).attr('in', 'SourceGraphic').addTo(innerFilter.merge);
            innerFilter.merge.feMergeNode2 = innerFilter.merge.feMergeNode2 || new ElementWrapper(this.create('feMergeNode'), this).addTo(innerFilter.merge);

            innerFilter.addTo(this.defs);

            return innerFilter;
        },

        create: function (name) {
            return document.createElementNS('http://www.w3.org/2000/svg', name);
        },

        attr:function(domWrapper, attr){
            DomUtils.attr.apply(null, [domWrapper.rawElement].concat(BaseUtils.objectToArray(attr)));
        },

        style:function(domWrapper, styles){
            var oldStyles = domWrapper.styles,
                newStyles = {},
                elem = domWrapper.rawElement,
                serializedCss = '',
                hasNew = !oldStyles,
                styleName;

            // convert legacy
            if (styles && styles.color) {
                styles.fill = styles.color;
            }

            // Filter out existing styles to increase performance (#2640)
            if (oldStyles) {
                for (styleName in styles) {
                    if (styles[styleName] !== oldStyles[styleName]) {
                        newStyles[styleName] = styles[styleName];
                        hasNew = true;
                    }
                }
            }

            if (hasNew) {

                if (domWrapper.type === 'div') {
                    // some problems:
                    // 1. rotate
                    // 2. default, here add 'px' to attributes
                    var map = {
                        'x': 'left',
                        'y': 'top',
                        'dx': 'margin-left'
                        // 'dy': 'margin-top'
                    };

                    for (var name in map) {
                        if (newStyles[name] != null) {
                            newStyles[map[name]] = newStyles[name] + 'px';
                            newStyles[name] = undefined;
                        }
                    }

                    if (newStyles['transform']) {
                        var trans = transformParser(newStyles['transform'].replace(/px/gi, ''));
                        if (trans.translate) {
                            newStyles[BaseUtils.transPrefix + 'transform'] = 'translate(' + trans.translate[0] + 'px,' + trans.translate[1] + 'px)';
                        }
                    }

                }

                // Merge the new styles with the old ones
                if (oldStyles) {
                    styles = BaseUtils.extend(oldStyles, newStyles);
                }

                domWrapper.styles = styles;

                var hyphenate = function (a, b) {
                    return '-' + b.toLowerCase();
                };

                for (styleName in styles) {
                    serializedCss += styleName.replace(/([A-Z])/g, hyphenate) + ':' + styles[styleName] + ';';
                }

                elem.style.cssText = serializedCss;
            }
        },

        vRotate: function (domWrapper, deg) {
            var trans, transform, rotateStr,dom = domWrapper.node();
            if (domWrapper.type === 'div') {
                transform = domWrapper.styles[BaseUtils.transPrefix + 'transform'] || '';
                if (transform) {
                    trans = transformParser(transform.replace(/px/gi, ''));
                    transform = '';
                    if (trans.translate) {
                        transform = 'translate(' + trans.translate[0] + 'px,' + trans.translate[1] + 'px) ';
                    }
                }
                rotateStr = 'rotate(' + deg + 'deg)';
                transform += rotateStr;
                domWrapper.styles[BaseUtils.transPrefix + 'transform'] = transform;
                dom.style.transform = transform;
            } else {
                var centerX = dom.scrollWidth / 2;
                var centerY = dom.scrollHeight / 2;

                centerX += (+dom.getAttribute('x') || 0);
                centerY += (+dom.getAttribute('y') || 0);

                transform = dom.getAttribute('transform') || '';
                if (transform) {
                    trans = transformParser(transform);
                    transform = '';
                    if (trans.translate) {
                        transform = 'translate(' + trans.translate[0] + ' ' + trans.translate[1] + ') ';
                    }
                }
                rotateStr = 'rotate(' + deg + ' ' + centerX + ' ' + centerY + ')';
                transform += rotateStr;
                domWrapper.attr('transform', transform);
            }
            domWrapper.rotateStr = rotateStr;
        }
    });

    function transformParser(transformStr){

        var translate, rotate;

        translate = transformStr.match(/translate\(\s*([\d|.|e|-]+)(?:[,\s]*)([\d|.|e|-]*)\s*\)/i);
        translate && translate.shift();

        rotate = transformStr.match(/rotate\(\s*([\d|.|e|-]+[degratun]*)(?:[,\s]*)([\d|.|e|-]*)(?:[,\s]*)([\d|.|e|-]*)\s*\)/i);
        rotate = rotate && rotate[1] || 0;

        return {
            translate:translate,
            rotate:rotate
        }

    }

    return Svg;
});
/**
 * Created by eason on 16/6/20.
 */
/**
 * Created by eason on 16/6/7.
 * vml下面用path来构造所有的形状,输出vml的path
 */

define('utils/PathUtils',['require'],function(require){

    var pathCommand = /([achlmrqstvz])[\x09\x0a\x0b\x0c\x0d\x20\xa0\u1680\u180e\u2000\u2001\u2002\u2003\u2004\u2005\u2006\u2007\u2008\u2009\u200a\u202f\u205f\u3000\u2028\u2029,]*((-?\d*\.?\d*(?:e[\-+]?\d+)?[\x09\x0a\x0b\x0c\x0d\x20\xa0\u1680\u180e\u2000\u2001\u2002\u2003\u2004\u2005\u2006\u2007\u2008\u2009\u200a\u202f\u205f\u3000\u2028\u2029]*,?[\x09\x0a\x0b\x0c\x0d\x20\xa0\u1680\u180e\u2000\u2001\u2002\u2003\u2004\u2005\u2006\u2007\u2008\u2009\u200a\u202f\u205f\u3000\u2028\u2029]*)+)/ig;
    var pathValues = /(-?\d*\.?\d*(?:e[\-+]?\d+)?)[\x09\x0a\x0b\x0c\x0d\x20\xa0\u1680\u180e\u2000\u2001\u2002\u2003\u2004\u2005\u2006\u2007\u2008\u2009\u200a\u202f\u205f\u3000\u2028\u2029]*,?[\x09\x0a\x0b\x0c\x0d\x20\xa0\u1680\u180e\u2000\u2001\u2002\u2003\u2004\u2005\u2006\u2007\u2008\u2009\u200a\u202f\u205f\u3000\u2028\u2029]*/ig;
    var concat = "concat", apply = "apply", upperCase = String.prototype.toUpperCase, mmax = Math.max, math = Math, round = math.round;
    var PI = math.PI, abs = Math.abs, split = "split";
    var p2s = /,?([achlmqrstvxz]),?/gi, val = /-?[^,\s-]+/g;
    var S = " ", E = "", fillString = "fill", zoom = 1;

    function path2vml(path){
        var bites = /([clmz]),?([^clmz]*)/gi;
        var map = {M: "m", L: "l", C: "c", Z: "x", m: "t", l: "r", c: "v", z: "x"};
        var total =  /[ahqstv]/ig, command = pathToAbsolute;
        String(path).match(total) && (command = path2curve);
        total = /[clmz]/g;
        if (command == pathToAbsolute && !String(path).match(total)) {
            var res = String(path).replace(bites, function (all, command, args) {
                var vals = [],
                    isMove = command.toLowerCase() == "m",
                    res = map[command];
                args.replace(val, function (value) {
                    if (isMove && vals.length == 2) {
                        res += vals + map[command == "m" ? "l" : "L"];
                        vals = [];
                    }
                    vals.push(round(value * zoom));
                });
                return res + vals;
            });
            return res;
        }
        var pa = command(path), p, r;
        res = [];
        for (var i = 0, ii = pa.length; i < ii; i++) {
            p = pa[i];
            r = pa[i][0].toLowerCase();
            r == "z" && (r = "x");
            for (var j = 1, jj = p.length; j < jj; j++) {
                r += round(p[j] * zoom) + (j != jj - 1 ? "," : E);
            }
            res.push(r);
        }
        return res.join(S);
    }

    function parsePathString(pathString){

        if (!pathString && typeof pathString != 'string') {
            return null;
        }

        var paramCounts = {a: 7, c: 6, h: 1, l: 2, m: 2, r: 4, q: 4, s: 4, t: 2, v: 1, z: 0},
            data = [];

        String(pathString).replace(pathCommand, function (a, b, c) {
            var params = [],
                name = b.toLowerCase();
            c.replace(pathValues, function (a, b) {
                b && params.push(+b);
            });
            if (name == "m" && params.length > 2) {
                data.push([b][concat](params.splice(0, 2)));
                name = "l";
                b = b == "m" ? "l" : "L";
            }
            if (name == "r") {
                data.push([b][concat](params));
            } else while (params.length >= paramCounts[name]) {
                data.push([b][concat](params.splice(0, paramCounts[name])));
                if (!paramCounts[name]) {
                    break;
                }
            }
        });
        data.toString = path2string;
        return data;
    }

    function path2string(){
        return this.join(",").replace(p2s, "$1");
    }

    function path2curve(path, path2){

        var p = pathToAbsolute(path),
            p2 = path2 && pathToAbsolute(path2),
            attrs = {x: 0, y: 0, bx: 0, by: 0, X: 0, Y: 0, qx: null, qy: null},
            attrs2 = {x: 0, y: 0, bx: 0, by: 0, X: 0, Y: 0, qx: null, qy: null},
            processPath = function (path, d, pcom) {
                var nx, ny, tq = {T:1, Q:1};
                if (!path) {
                    return ["C", d.x, d.y, d.x, d.y, d.x, d.y];
                }
                !(path[0] in tq) && (d.qx = d.qy = null);
                switch (path[0]) {
                    case "M":
                        d.X = path[1];
                        d.Y = path[2];
                        break;
                    case "A":
                        path = ["C"][concat](a2c[apply](0, [d.x, d.y][concat](path.slice(1))));
                        break;
                    case "S":
                        if (pcom == "C" || pcom == "S") { // In "S" case we have to take into account, if the previous command is C/S.
                            nx = d.x * 2 - d.bx;          // And reflect the previous
                            ny = d.y * 2 - d.by;          // command's control point relative to the current point.
                        }
                        else {                            // or some else or nothing
                            nx = d.x;
                            ny = d.y;
                        }
                        path = ["C", nx, ny][concat](path.slice(1));
                        break;
                    case "T":
                        if (pcom == "Q" || pcom == "T") { // In "T" case we have to take into account, if the previous command is Q/T.
                            d.qx = d.x * 2 - d.qx;        // And make a reflection similar
                            d.qy = d.y * 2 - d.qy;        // to case "S".
                        }
                        else {                            // or something else or nothing
                            d.qx = d.x;
                            d.qy = d.y;
                        }
                        path = ["C"][concat](q2c(d.x, d.y, d.qx, d.qy, path[1], path[2]));
                        break;
                    case "Q":
                        d.qx = path[1];
                        d.qy = path[2];
                        path = ["C"][concat](q2c(d.x, d.y, path[1], path[2], path[3], path[4]));
                        break;
                    case "L":
                        path = ["C"][concat](l2c(d.x, d.y, path[1], path[2]));
                        break;
                    case "H":
                        path = ["C"][concat](l2c(d.x, d.y, path[1], d.y));
                        break;
                    case "V":
                        path = ["C"][concat](l2c(d.x, d.y, d.x, path[1]));
                        break;
                    case "Z":
                        path = ["C"][concat](l2c(d.x, d.y, d.X, d.Y));
                        break;
                }
                return path;
            },
            fixArc = function (pp, i) {
                if (pp[i].length > 7) {
                    pp[i].shift();
                    var pi = pp[i];
                    while (pi.length) {
                        pcoms1[i]="A"; // if created multiple C:s, their original seg is saved
                        p2 && (pcoms2[i]="A"); // the same as above
                        pp.splice(i++, 0, ["C"][concat](pi.splice(0, 6)));
                    }
                    pp.splice(i, 1);
                    ii = mmax(p.length, p2 && p2.length || 0);
                }
            },
            fixM = function (path1, path2, a1, a2, i) {
                if (path1 && path2 && path1[i][0] == "M" && path2[i][0] != "M") {
                    path2.splice(i, 0, ["M", a2.x, a2.y]);
                    a1.bx = 0;
                    a1.by = 0;
                    a1.x = path1[i][1];
                    a1.y = path1[i][2];
                    ii = mmax(p.length, p2 && p2.length || 0);
                }
            },
            pcoms1 = [], // path commands of original path p
            pcoms2 = [], // path commands of original path p2
            pfirst = "", // temporary holder for original path command
            pcom = ""; // holder for previous path command of original path
        for (var i = 0, ii = Math.max(p.length, p2 && p2.length || 0); i < ii; i++) {
            p[i] && (pfirst = p[i][0]); // save current path command

            if (pfirst != "C") // C is not saved yet, because it may be result of conversion
            {
                pcoms1[i] = pfirst; // Save current path command
                i && ( pcom = pcoms1[i-1]); // Get previous path command pcom
            }
            p[i] = processPath(p[i], attrs, pcom); // Previous path command is inputted to processPath

            if (pcoms1[i] != "A" && pfirst == "C") pcoms1[i] = "C"; // A is the only command
            // which may produce multiple C:s
            // so we have to make sure that C is also C in original path

            fixArc(p, i); // fixArc adds also the right amount of A:s to pcoms1

            if (p2) { // the same procedures is done to p2
                p2[i] && (pfirst = p2[i][0]);
                if (pfirst != "C")
                {
                    pcoms2[i] = pfirst;
                    i && (pcom = pcoms2[i-1]);
                }
                p2[i] = processPath(p2[i], attrs2, pcom);

                if (pcoms2[i]!="A" && pfirst=="C") pcoms2[i]="C";

                fixArc(p2, i);
            }
            fixM(p, p2, attrs, attrs2, i);
            fixM(p2, p, attrs2, attrs, i);
            var seg = p[i],
                seg2 = p2 && p2[i],
                seglen = seg.length,
                seg2len = p2 && seg2.length;
            attrs.x = seg[seglen - 2];
            attrs.y = seg[seglen - 1];
            attrs.bx = parseFloat(seg[seglen - 4]) || attrs.x;
            attrs.by = parseFloat(seg[seglen - 3]) || attrs.y;
            attrs2.bx = p2 && (parseFloat(seg2[seg2len - 4]) || attrs2.x);
            attrs2.by = p2 && (parseFloat(seg2[seg2len - 3]) || attrs2.y);
            attrs2.x = p2 && seg2[seg2len - 2];
            attrs2.y = p2 && seg2[seg2len - 1];
        }

        return p2 ? [p, p2] : p;
    }

    function q2c(x1, y1, ax, ay, x2, y2) {
        var _13 = 1 / 3,
            _23 = 2 / 3;
        return [
            _13 * x1 + _23 * ax,
            _13 * y1 + _23 * ay,
            _13 * x2 + _23 * ax,
            _13 * y2 + _23 * ay,
            x2,
            y2
        ];
    }

    function l2c (x1, y1, x2, y2) {
        return [x1, y1, x2, y2, x2, y2];
    }

    function a2c (x1, y1, rx, ry, angle, large_arc_flag, sweep_flag, x2, y2, recursive) {
        // for more information of where this math came from visit:
        // http://www.w3.org/TR/SVG11/implnote.html#ArcImplementationNotes
        var _120 = PI * 120 / 180,
            rad = PI / 180 * (+angle || 0),
            res = [],
            xy,
            rotate = function (x, y, rad) {
                var X = x * math.cos(rad) - y * math.sin(rad),
                    Y = x * math.sin(rad) + y * math.cos(rad);
                return {x: X, y: Y}
            };
        if (!recursive) {
            xy = rotate(x1, y1, -rad);
            x1 = xy.x;
            y1 = xy.y;
            xy = rotate(x2, y2, -rad);
            x2 = xy.x;
            y2 = xy.y;
            var cos = math.cos(PI / 180 * angle),
                sin = math.sin(PI / 180 * angle),
                x = (x1 - x2) / 2,
                y = (y1 - y2) / 2;
            var h = (x * x) / (rx * rx) + (y * y) / (ry * ry);
            if (h > 1) {
                h = math.sqrt(h);
                rx = h * rx;
                ry = h * ry;
            }
            var rx2 = rx * rx,
                ry2 = ry * ry,
                k = (large_arc_flag == sweep_flag ? -1 : 1) *
                    math.sqrt(abs((rx2 * ry2 - rx2 * y * y - ry2 * x * x) / (rx2 * y * y + ry2 * x * x))),
                cx = k * rx * y / ry + (x1 + x2) / 2,
                cy = k * -ry * x / rx + (y1 + y2) / 2,
                f1 = math.asin(((y1 - cy) / ry).toFixed(9)),
                f2 = math.asin(((y2 - cy) / ry).toFixed(9));

            f1 = x1 < cx ? PI - f1 : f1;
            f2 = x2 < cx ? PI - f2 : f2;
            f1 < 0 && (f1 = PI * 2 + f1);
            f2 < 0 && (f2 = PI * 2 + f2);
            if (sweep_flag && f1 > f2) {
                f1 = f1 - PI * 2;
            }
            if (!sweep_flag && f2 > f1) {
                f2 = f2 - PI * 2;
            }
        } else {
            f1 = recursive[0];
            f2 = recursive[1];
            cx = recursive[2];
            cy = recursive[3];
        }
        var df = f2 - f1;
        if (abs(df) > _120) {
            var f2old = f2,
                x2old = x2,
                y2old = y2;
            f2 = f1 + _120 * (sweep_flag && f2 > f1 ? 1 : -1);
            x2 = cx + rx * math.cos(f2);
            y2 = cy + ry * math.sin(f2);
            res = a2c(x2, y2, rx, ry, angle, 0, sweep_flag, x2old, y2old, [f2, f2old, cx, cy]);
        }
        df = f2 - f1;
        var c1 = math.cos(f1),
            s1 = math.sin(f1),
            c2 = math.cos(f2),
            s2 = math.sin(f2),
            t = math.tan(df / 4),
            hx = 4 / 3 * rx * t,
            hy = 4 / 3 * ry * t,
            m1 = [x1, y1],
            m2 = [x1 + hx * s1, y1 - hy * c1],
            m3 = [x2 + hx * s2, y2 - hy * c2],
            m4 = [x2, y2];
        m2[0] = 2 * m1[0] - m2[0];
        m2[1] = 2 * m1[1] - m2[1];
        if (recursive) {
            return [m2, m3, m4][concat](res);
        } else {
            res = [m2, m3, m4][concat](res).join()[split](",");
            var newres = [];
            for (var i = 0, ii = res.length; i < ii; i++) {
                newres[i] = i % 2 ? rotate(res[i - 1], res[i], rad).y : rotate(res[i], res[i + 1], rad).x;
            }
            return newres;
        }
    }

    function pathToAbsolute(pathArray) {

        if(typeof pathArray == 'string'){
            pathArray = parsePathString(pathArray);
        }

        if(!pathArray || !pathArray.length){
            return [["M", 0, 0]];
        }

        var res = [],
            x = 0,
            y = 0,
            mx = 0,
            my = 0,
            start = 0;
        if (pathArray[0][0] == "M") {
            x = +pathArray[0][1];
            y = +pathArray[0][2];
            mx = x;
            my = y;
            start++;
            res[0] = ["M", x, y];
        }
        var crz = pathArray.length == 3 && pathArray[0][0] == "M" && pathArray[1][0].toUpperCase() == "R" && pathArray[2][0].toUpperCase() == "Z";
        for (var r, pa, i = start, ii = pathArray.length; i < ii; i++) {
            res.push(r = []);
            pa = pathArray[i];
            if (pa[0] != upperCase.call(pa[0])) {
                r[0] = upperCase.call(pa[0]);
                switch (r[0]) {
                    case "A":
                        r[1] = pa[1];
                        r[2] = pa[2];
                        r[3] = pa[3];
                        r[4] = pa[4];
                        r[5] = pa[5];
                        r[6] = +(pa[6] + x);
                        r[7] = +(pa[7] + y);
                        break;
                    case "V":
                        r[1] = +pa[1] + y;
                        break;
                    case "H":
                        r[1] = +pa[1] + x;
                        break;
                    case "R":
                        var dots = [x, y][concat](pa.slice(1));
                        for (var j = 2, jj = dots.length; j < jj; j++) {
                            dots[j] = +dots[j] + x;
                            dots[++j] = +dots[j] + y;
                        }
                        res.pop();
                        res = res[concat](catmullRom2bezier(dots, crz));
                        break;
                    case "M":
                        mx = +pa[1] + x;
                        my = +pa[2] + y;
                    default:
                        for (j = 1, jj = pa.length; j < jj; j++) {
                            r[j] = +pa[j] + ((j % 2) ? x : y);
                        }
                }
            } else if (pa[0] == "R") {
                dots = [x, y][concat](pa.slice(1));
                res.pop();
                res = res[concat](catmullRom2bezier(dots, crz));
                r = ["R"][concat](pa.slice(-2));
            } else {
                for (var k = 0, kk = pa.length; k < kk; k++) {
                    r[k] = pa[k];
                }
            }
            switch (r[0]) {
                case "Z":
                    x = mx;
                    y = my;
                    break;
                case "H":
                    x = r[1];
                    break;
                case "V":
                    y = r[1];
                    break;
                case "M":
                    mx = r[r.length - 2];
                    my = r[r.length - 1];
                default:
                    x = r[r.length - 2];
                    y = r[r.length - 1];
            }
        }
        res.toString = path2string;
        return res;

    }

    function catmullRom2bezier(crp, z) {
        var d = [];
        for (var i = 0, iLen = crp.length; iLen - 2 * !z > i; i += 2) {
            var p = [
                {x: +crp[i - 2], y: +crp[i - 1]},
                {x: +crp[i],     y: +crp[i + 1]},
                {x: +crp[i + 2], y: +crp[i + 3]},
                {x: +crp[i + 4], y: +crp[i + 5]}
            ];
            if (z) {
                if (!i) {
                    p[0] = {x: +crp[iLen - 2], y: +crp[iLen - 1]};
                } else if (iLen - 4 == i) {
                    p[3] = {x: +crp[0], y: +crp[1]};
                } else if (iLen - 2 == i) {
                    p[2] = {x: +crp[0], y: +crp[1]};
                    p[3] = {x: +crp[2], y: +crp[3]};
                }
            } else {
                if (iLen - 4 == i) {
                    p[3] = p[2];
                } else if (!i) {
                    p[0] = {x: +crp[i], y: +crp[i + 1]};
                }
            }
            d.push(["C",
                (-p[0].x + 6 * p[1].x + p[2].x) / 6,
                (-p[0].y + 6 * p[1].y + p[2].y) / 6,
                (p[1].x + 6 * p[2].x - p[3].x) / 6,
                (p[1].y + 6*p[2].y - p[3].y) / 6,
                p[2].x,
                p[2].y
            ]);
        }

        return d;
    }

    function rectPath(x, y, w, h, r){
        if (r) {
            return [["M", x + r, y], ["l", w - r * 2, 0], ["a", r, r, 0, 0, 1, r, r], ["l", 0, h - r * 2], ["a", r, r, 0, 0, 1, -r, r], ["l", r * 2 - w, 0], ["a", r, r, 0, 0, 1, -r, -r], ["l", 0, r * 2 - h], ["a", r, r, 0, 0, 1, r, -r], ["z"]];
        }
        return path2vml([["M", x, y], ["l", w, 0], ["l", 0, h], ["l", -w, 0], ["z"]]);
    }

    function circlePath (x, y, r) {
        return path2vml([["M", x, y], ["m", 0, -r], ["a", r, r, 0, 1, 1, 0, 2 * r], ["a", r, r, 0, 1, 1, 0, -2 * r], ["z"]]);
    }

    function linePath(x1, y1, x2, y2){
        return path2vml([["M", x1, y1], ["L", x2, y2]]);
    }

    return {
        path2vml:path2vml,
        rectPath:rectPath,
        linePath:linePath,
        circlePath:circlePath
    }

});
/**
 * Created by eason on 16/6/1.
 */

define('vector/VmlRenderer',['require','./Renderer','../utils/PathUtils','../utils/BaseUtils','../utils/ColorUtils','./ElementWrapper','../utils/PathUtils'],function(require){
    var Renderer = require('./Renderer');
    var PathUtils = require('../utils/PathUtils');
    var BaseUtils = require('../utils/BaseUtils');
    var ColorUtils = require('../utils/ColorUtils');
    var ElementWrapper = require('./ElementWrapper');
    var PathUtils = require('../utils/PathUtils');

    var CSS = "position:absolute;left:0px;top:0px;width:1px;height:1px;behavior:url(#default#VML);display:inline-block;";

    var SubCss = "position:absolute;behavior:url(#default#VML);display:inline-block;";

    var Vml = Renderer.extend({

        _initContainerDom: function (dom){
            var root = this.div();
            dom.appendChild(root.node());
            return root;
        },

        line:function(attrs){
            return this._shapeWithPath(attrs, 'line');
        },

        rect:function(attrs){
            return this._shapeWithPath(attrs, 'rect');
        },

        circle:function(attrs){
            return this._shapeWithPath(attrs, 'circle');
        },

        path:function(attrs){
            return this._shapeWithPath(attrs, 'path');
        },

        //ie8 group套group就显示不出了,奇葩
        group:function(attrs){
            var group = this.div().style({'white-space':'nowrap','pointer-events':'none'});

            return group.attr(attrs);
        },

        textContent:function(elementW, text){
            elementW.node().innerHTML = text;
        },

        text:function(attrs){
            return this.vtext(attrs);
        },

        tspan:function(attrs){
            return this.vtspan(attrs);
        },

        image:function(){

        },

        _shapeWithPath:function(attrs, type){
            var shape = new ElementWrapper(this.create('shape'), this).type(type), container = shape.rawElement;
            container.style.cssText = CSS;container.coordsize = '1 1';

            return shape.attr(attrs);
        },

        create:(function () {
            try {
                document.namespaces.add('lvml', 'urn:schemas-microsoft-com:vml');
                return function (name) {
                    return document.createElement('<lvml:' + name + ' class="lvml">');
                };
            } catch (e) {
                return function (name) {
                    return document.createElement('<' + name + ' xmlns="urn:schemas-microsoft.com:vml" class="lvml">');
                };
            }
        })(),

        colorGradient:function(){
            return {};
        },

        updateColorGradient:function(){

        },

        createClip: function (attrs, type) {
            if(type && type != 'rect'){
                return;
            }

            var top = 0, left = 0, right = left + attrs.width, bottom = top + attrs.height;
            return 'rect(' + top + 'px '+ right +'px '+ bottom +'px ' + left + 'px)';
        },

        clip:function(elementWrapper, clipWrapper){
            if(clipWrapper){
                if(elementWrapper.node){
                    elementWrapper.node().style.clip = clipWrapper;
                }
            }
        },

        imagePattern:function(p, attrs){

        },

        createDropShadowFilter:function(){
            return {};
        },

        createInnerShadowFilter:function(){
            return {};
        },

        attr:function(domWrapper, arguments){

            if(!arguments || arguments.length <= 0 || !arguments[0]){
                return;
            }

            var attrs = {}, elem = domWrapper.rawElement;
            if(arguments.length == 2){
                attrs[arguments[0]] = arguments[1];
            }else{
                attrs = arguments[0];
            }

            var oldAttrs = domWrapper.attrs, type = domWrapper.type;

            if(oldAttrs){
                attrs = BaseUtils.extend(oldAttrs, attrs);
            }

            domWrapper.attrs = attrs;

            //transform属性先屏蔽掉,暂时只更新矩形
            if(attrs.transform){
                var transform = transformParser(attrs.transform);
                try {
                    if (transform.translate) {
                        elem.style.left = transform.translate[0] + 'px';
                        elem.style.top = transform.translate[1] + 'px';
                    }
                } catch (e) {
                    
                }

                if(transform.rotate){

                }
            }

            if(type != 'group'){

                var pathStr = '';
                if(type == 'rect'){
                    pathStr = PathUtils.rectPath(attrs.x || 0, attrs.y || 0, attrs.width, attrs.height);
                }else if(type == 'line'){
                    pathStr = PathUtils.linePath(attrs.x1, attrs.y1, attrs.x2, attrs.y2);
                }else if(type == 'path'){
                    pathStr = PathUtils.path2vml(attrs.d);
                }else if(type == 'circle'){
                    pathStr = PathUtils.circlePath(attrs.x || 0, attrs.y || 0, attrs.r);
                }
                elem.path = pathStr;
            }
        },
        
        style:function(domWrapper, styles){
            var oldStyles = domWrapper.styles,
                newStyles = {},
                elem = domWrapper.rawElement,
                styleName;

            // Filter out existing styles to increase performance (#2640)
            if (oldStyles) {
                for (styleName in styles) {
                    if (styles[styleName] !== oldStyles[styleName]) {
                        newStyles[styleName] = styles[styleName];
                    }
                }
            }

            if (domWrapper.type === 'div') {

                if (newStyles['transform']) {
                    var trans = transformParser(newStyles['transform'].replace(/px/gi, ''));
                    newStyles['transform'] = '';
                    newStyles['x'] = trans.translate[0];
                    newStyles['y'] = trans.translate[1];
                }

                var map = {
                    'x': 'left',
                    'y': 'top',
                    'dx': 'margin-left'
                    // 'dy': 'margin-top'
                };

                for (var name in map) {
                    if (newStyles[name] != null) {
                        newStyles[map[name]] = newStyles[name] + 'px';
                        newStyles[name] = undefined;
                    }
                }

            }

            // Merge the new styles with the old ones
            if (oldStyles) {
                styles = BaseUtils.extend(oldStyles, newStyles);
            }
            domWrapper.styles = styles;

            if (domWrapper.type === 'div') {
                var hyphenate = function (a, b) {
                    return '-' + b.toLowerCase();
                };

                var serializedCss = '';
                for (styleName in styles) {
                    serializedCss += styleName.replace(/([A-Z])/g, hyphenate) + ':' + styles[styleName] + ';';
                }

                elem.style.cssText = serializedCss;
            }else if(domWrapper.type != 'group'){

                var stroke = domWrapper._stroke,
                    fill = domWrapper._fill,
                    container = domWrapper.node();

                container.stroked = true;//默认的样式
                container.filled = !!(styles.fill && styles.fill != 'none');

                if (!stroke) {
                    stroke = domWrapper._stroke = this.create('stroke');
                    stroke.style.cssText = SubCss;
                }
                container.appendChild(stroke);
                stroke.weight = (styles['stroke-width'] || 0) + 'px';
                stroke.color = styles.stroke;

                var opacity = BaseUtils.hasDefined(styles['stroke-opacity']) ? styles['stroke-opacity'] : 1;
                stroke.opacity = styles['stroke-width'] ? opacity : 0;

                // if (options.dashArray) {
                //     stroke.dashStyle = L.Util.isArray(options.dashArray) ?
                //         options.dashArray.join(' ') :
                //         options.dashArray.replace(/( *, *)/g, ' ');
                // } else {
                //     stroke.dashStyle = '';
                // }

                if(styles['stroke-linecap'] == 'round'){
                    stroke.endcap = 'round';
                }

                if (container.filled) {
                    if (!fill) {
                        fill = domWrapper._fill = this.create('fill');
                        fill.style.cssText = SubCss;
                    }
                    container.appendChild(fill);

                    var fillColor = styles.fill;
                    var fillOpacity = BaseUtils.hasDefined(styles['fill-opacity']) ? styles['fill-opacity'] : 1;

                    //兼容rgba的写法
                    if(fillColor.indexOf('rgba') != -1){
                        fillColor = ColorUtils.colorToHexAlpha(fillColor);
                        fillOpacity *= fillColor.alpha;
                        fillColor = fillColor.hex;
                    }

                    fill.color = fillColor;
                    fill.opacity =  fillOpacity

                } else if (fill) {
                    container.removeChild(fill);
                    domWrapper._fill = null;
                }
            }

            if(BaseUtils.hasDefined(styles.display)){
                domWrapper.node().style.display = styles.display;
            }
        },

        // assume there's no margin
        // if margin(as offset) is needed,
        // revise this func, record offset to other attr
        // then combine the offset and the rotate adjustment to margin.
        vRotate: function (domWrapper, deg) {
            var dom = domWrapper.node();
            BaseUtils.domRotate(dom, 0);
            var ow = dom.offsetWidth, oh = dom.offsetHeight;
            BaseUtils.domRotate(dom, deg);
            var rw = dom.offsetWidth, rh = dom.offsetHeight;
            dom.style.marginLeft = (ow - rw) / 2 + 'px';
            dom.style.marginTop = (oh - rh) / 2 + 'px';
        }
    });

    function transformParser(transformStr){

        var translate, rotate;

        translate = transformStr.match(/translate\(\s*([\d|.|e|-]+)(?:[,\s]*)([\d|.|e|-]*)\s*\)/i);
        translate && translate.shift();

        rotate = transformStr.match(/rotate\(\s*([\d|.|e|-]+[degratun]*)(?:[,\s]*)([\d|.|e|-]*)(?:[,\s]*)([\d|.|e|-]*)\s*\)/i);
        rotate = rotate && rotate[1] || 0;

        return {
            translate:translate,
            rotate:rotate
        }

    }

    return Vml;
});
/**
 * Created by Yuqian on 16/5/19.
 */

define('theme/options',['require','../Constants','../utils/QueryUtils','../utils/BaseUtils'],function (require) {
    var Constants = require('../Constants');
    var QueryUtils = require('../utils/QueryUtils');
    var BaseUtils = require('../utils/BaseUtils');

    var options = {};

    var normalTooltip = {
        formatter: {
            identifier: "${CATEGORY}${SERIES}${VALUE}"
        },
        enabled:true,
        animation:true,
        follow:false,
        backgroundColor:'rgba(0,0,0,0.5)',
        borderColor:null,
        borderWidth:0,
        borderRadius:2,
        shadow:true,
        hideDelay:500,
        shared:false,
        padding:5
    };

    var disabledTooltip = BaseUtils.clone(normalTooltip);
    QueryUtils.merge(disabledTooltip, {formatter: {enabled: false}}, true);

    var seriesXYSizeTooltip = BaseUtils.clone(normalTooltip);
    QueryUtils.merge(seriesXYSizeTooltip, {formatter: {identifier: "${SERIES}${X}${Y}${SIZE}"}}, true);

    var seriesValueTooltip = BaseUtils.clone(normalTooltip);
    QueryUtils.merge(seriesValueTooltip, {formatter: {identifier: "${SERIES}${VALUE}"}}, true);

    var nameSeriesValueTooltip = BaseUtils.clone(normalTooltip);
    QueryUtils.merge(nameSeriesValueTooltip, {formatter: {identifier: "${NAME}${SERIES}${VALUE}", shared:true}}, true);

    var nameSeriesValueSizeTooltip = BaseUtils.clone(normalTooltip);
    QueryUtils.merge(nameSeriesValueSizeTooltip, {formatter: {identifier: "${NAME}${SERIES}${VALUE}${SIZE}", shared:true}}, true);


    var linePlotOptions = {

        large:false,
        connectNulls:false,
        lineWidth:2,
        step:false,
        curve:false,

        marker:{
            radius:4.5
        },

        dataLabels:{
            "formatter": {
                "identifier": "${Y}"
            },
            "enabled": false,
            "align": "outside"
        },

        tooltip:normalTooltip

    };

    var areaPlotOptions = QueryUtils.merge({}, linePlotOptions, true);
    QueryUtils.merge(areaPlotOptions, {fillColor:true, fillColorOpacity:0.15}, true);

    var columnPlotOptions = {
        categoryGap: '20%',
        gap: '20%',

        borderRadius:0,
        borderWidth:1,
        borderColor:'white',

        dataLabels:{
            "formatter": {
                "identifier": "${Y}"
            },
            "enabled": false,
            "align": "inside"
        },

        tooltip:normalTooltip
    };

    var piePlotOptions = {
        rotatable:true,
        startAngle:0,
        endAngle:360,

        borderWidth:1,
        borderColor:'white',

        dataLabels:{
            "formatter": {
                "identifier": "${Y}"
            },
            "enabled": false,
            "align": "inside"
        },

        tooltip:seriesValueTooltip
    };

    var scatterPlotOptions = {
        large:false,
        lineWidth:0,
        curve:false,

        marker:{
            radius:4.5
        },

        opacity: 1,

        tooltip:seriesXYSizeTooltip,

        dataLabels:{
            "formatter": {
                "identifier": "${X}${Y}${SIZE}"
            },
            "enabled": false,
            "align": "outside"
        }
    };

    var bubblePlotOptions = {
        large:false,
        force:false,
        displayNegative:true,
        shadow:true,
        minSize: 12,
        maxSize: 60,
        sizeBy:'area',
        opacity:0.7,

        tooltip:seriesXYSizeTooltip,

        dataLabels:{
            "formatter": {
                "identifier": "${X}${Y}${SIZE}"
            },
            "enabled": false,
            "align": "inside"
        }
    };

    var radarPlotOptions = {
        polar:0,

        fillColor:false,
        fillColorOpacity:0.15,

        columnType:false,

        marker:{
            radius:4.5
        },

        lineWidth:2,

        shape: 'circle',

        dataLabels:{
            "formatter": {
                "identifier": "${Y}"
            },
            "enabled": false,
            "align": "outside"
        },

        tooltip:normalTooltip
    };

    var gaugePlotOptions = {

        layout:'horizontal',

        tooltip:disabledTooltip

    };

    var mapPlotOptions = {
        color:'#cccccc',
        opacity:0.75,
        borderColor:'#ffffff',
        borderWidth:1,
        borderOpacity:1,

        tooltip:nameSeriesValueSizeTooltip,

        dataLabels:{
            "formatter": {
                "identifier": "${NAME}"
            },
            "enabled": false,
            "align": "inside"
        }
    };

    var pointMapPlotOptions = {
        opacity:1,

        dataLabels:{
            "formatter": {
                "identifier": "${NAME}"
            },
            "enabled": false,
            "align": "outside"
        },

        tooltip:nameSeriesValueSizeTooltip
    };

    var multiPiePlotOptions = {
        borderWidth: 1,
        borderColor: 'rgb(255,255,255)',
        rotatable: true,
        gradual: 'lighter',
        center: [],
        innerRadius: 0,
        startAngle: 0,
        endAngle: 360,
        drilldown: true,

        tooltip:nameSeriesValueTooltip,

        dataLabels:{
            "formatter": {
                "identifier": "${NAME}"
            },
            "enabled": false,
            "align": "inside"
        }
    };

    var treeMapPlotOptions = {
        borderWidth: 1,
        borderColor: 'rgb(255,255,255)',
        zoom: true,

        tooltip:nameSeriesValueTooltip,

        dataLabels: {
            "formatter": {
                "identifier": "${NAME}"
            },
            "enabled": false,
            align: 'top'
        }
    };



    options[Constants.PIE_CHART] = {
        plotOptions: {

            pie:piePlotOptions

        }
    };

    options[Constants.MULTIPIE_CHART] = {

        plotOptions: {

            multiPie:multiPiePlotOptions

        }
    };

    options[Constants.TREEMAP_CHART] = {

        plotOptions: {

            treeMap:treeMapPlotOptions

        }
    };

    options[Constants.COLUMN_CHART] = {
        plotOptions: {

            column:columnPlotOptions

        }

    };

    options[Constants.BAR_CHART] = {
        plotOptions:{

            bar:columnPlotOptions
        }

    };

    options[Constants.LINE_CHART] = {

        plotOptions:{

            line:linePlotOptions

        }
    };

    options[Constants.AREA_CHART] = {

        plotOptions:{

            area:areaPlotOptions

        }
    };

    options[Constants.GAUGE_CHART] = {
        plotOptions: {
            gauge:gaugePlotOptions
        }

    };

    options[Constants.RADAR_CHART] = {

        plotOptions:{

            radar:radarPlotOptions

        }

    };

    options[Constants.SCATTER_CHART] = {
        plotOptions: {

            scatter:scatterPlotOptions

        }

    };

    options[Constants.BUBBLE_CHART] = {
        plotOptions: {

            bubble:bubblePlotOptions

        }

    };

    options[Constants.AREA_MAP] = {
        plotOptions:{

            areaMap:mapPlotOptions

        }
    };

    options[Constants.POINT_MAP] = {
        plotOptions:{

           pointMap:pointMapPlotOptions

        }
    };

    return options
});
/**
 * Created by eason on 15/7/17.
 * 用来记录所有默认的config
 */
define('theme/config',['require','../Constants','../utils/QueryUtils','./options'],function(require){

    var Constants = require('../Constants');
    var QueryUtils = require('../utils/QueryUtils');
    var Options = require('./options');

    var config = {};

    var nullTitle = {
        align:'center',
        backgroundColor:null,
        borderRadius:0,
        floating:false,
        x:0,
        y:0,
        text:null,
        style:{
            color:'#333333',
            fontSize:'22px',
            fontFamily:'Verdana'
        },
        useHtml:false
    };

    var gradualStyle = 'gradual';

    var xyZoom = {
        zoomType:'xy',
        zoomTool:{
            enabled:false,
            resize:true
        }
    };

    var rangeLegend = {
        visible:true,
        enabled:true,
        borderColor:'#cccccc',
        borderWidth:0,
        hiddenColor:'#cccccc',
        hoverColor:'#293C55',
        style:{
            color:'#666666',
            fontFamily:'Verdana',
            fontSize:'14px'
        },
        position:'right',
        floating:false,
        x:0,
        y:0,
        layout:'vertical',
        continuous:true,
        margin:10
    };

    var disabledRangeLegend = QueryUtils.merge({}, rangeLegend, true);
    QueryUtils.merge(disabledRangeLegend, {enabled:false}, true);

    var disabledLegend = {
        visible:true,
        enabled:false,
        hiddenColor:'#cccccc',
        hoverColor:'#293C55',
        borderRadius:0,
        borderColor:'#cccccc',
        borderWidth:0,
        backgroundColor:null,
        style:{
            color:'#666666',
            fontFamily:'Verdana',
            fontSize:'14px'
        },
        position:'right',
        floating:false,
        layout:'vertical',
        x:0,
        y:0,
        shadow:false,
        margin:10
    };

    var xCategoryAxis = {
        type:'category',
        position:'bottom',
        onZero:false,
        reversed:false,
        title:{
            text:null,
            align:'center',
            rotation:0,
            useHtml:false,
            style:{
                color:'#666666',
                fontFamily:'Verdana',
                fontSize:'14px'
            }
        },
        lineWidth:1,
        lineColor:'#cccccc',
        showArrow:false,
        enableTick:true,
        enableMinorTick:false,

        minorTickColor:'#cccccc',
        minorTickWidth:1,
        minorTickLength:2,

        tickColor:'#cccccc',
        tickWidth:1,
        tickLength:4,

        tickPadding:6,
        gridLineWidth:0,
        gridLineColor:'#dddddd',

        showLabel:true,
        labelStyle:{
            color:'#666666',
            fontFamily:'Verdana',
            fontSize:'14px'
        },
        labelRotation:0,
        useHtml:false
    };

    var yValueAxis = {
        type:'value',
        position:'left',
        onZero:false,
        reversed:false,
        title:{
            text:null,
            align:'center',
            rotation:0,
            useHtml:false,
            style:{
                color:'#666666',
                fontFamily:'Verdana',
                fontSize:'14px'
            }
        },
        lineWidth:0,
        lineColor:'#cccccc',
        showArrow:false,
        enableTick:false,
        enableMinorTick:false,

        minorTickColor:'#cccccc',
        minorTickWidth:1,
        minorTickLength:2,

        tickColor:'#cccccc',
        tickWidth:1,
        tickLength:4,

        tickPadding:6,
        gridLineWidth:1,
        gridLineColor:'#dddddd',

        showLabel:true,
        labelStyle:{
            color:'#666666',
            fontFamily:'Verdana',
            fontSize:'14px'
        },
        labelRotation:0,
        useHtml:false
    };

    var xValueAxis = QueryUtils.merge({}, xCategoryAxis, true);
    QueryUtils.merge(xValueAxis, {type:'value'}, true);

    var yCategoryAxis = QueryUtils.merge({}, yValueAxis, true);
    QueryUtils.merge(yCategoryAxis, {type:'category'}, true);

    var angleAxis = {
        type:'category',

        lineWidth:1,
        lineColor:'#cccccc',

        gridLineWidth:1,
        gridLineColor:'#dddddd',

        showLabel:true,
        labelStyle:{
            color:'#666666',
            fontFamily:'Verdana',
            fontSize:'9pt'
        },
        labelRotation:0,
        useHtml:false
    };

    var radiusAxis = QueryUtils.merge({}, angleAxis, true);
    QueryUtils.merge(radiusAxis, {type:'value'}, true);

    config[Constants.PIE_CHART] = {
        style:gradualStyle,

        plotOptions:Options[Constants.PIE_CHART].plotOptions.pie
    };

    config[Constants.COLUMN_CHART] = {

        style:gradualStyle,

        zoom:xyZoom,

        xAxis:[xCategoryAxis],

        yAxis:[yValueAxis],

        plotOptions:Options[Constants.COLUMN_CHART].plotOptions.column
    };

    config[Constants.BAR_CHART] = {
        style:gradualStyle,

        zoom:xyZoom,

        xAxis:[xValueAxis],

        yAxis:[yCategoryAxis],

        plotOptions:Options[Constants.BAR_CHART].plotOptions.bar

    };

    config[Constants.LINE_CHART] = {
        zoom:xyZoom,

        xAxis:[xCategoryAxis],

        yAxis:[yValueAxis],

        plotOptions:Options[Constants.LINE_CHART].plotOptions.line
    };

    config[Constants.AREA_CHART] = {
        zoom:xyZoom,

        xAxis:[xCategoryAxis],

        yAxis:[yValueAxis],

        plotOptions:Options[Constants.AREA_CHART].plotOptions.area
    };

    config[Constants.GAUGE_CHART] = {

        legend:disabledLegend,

        gaugeAxis:[{
            type:'value',
            showLabel:true,
            step:1,

            enableTick:true,
            tickColor:'#BBBBBB',
            tickWidth:1,

            enableMinorTick:true,
            minorTickColor:'#e2e2e2',
            minorTickWidth:1,

            labelStyle:{
                color:'#666666',
                fontFamily:'Verdana',
                fontSize:'10px'
            }
        }],

        plotOptions:Options[Constants.GAUGE_CHART].plotOptions.gauge
    };

    config[Constants.POINTER_GAUGE] = {
        seriesLabel:{
            enabled:true,
            align:Constants.BOTTOM,
            useHtml:false,
            style:{
                color:'#333333',
                fontSize:'14px',
                fontFamily:'Verdana'
            },
            formatter:{
                identifier: "${CATEGORY}"
            }
        },

        valueLabel:{
            enabled:true,
            useHtml:false,
            backgroundColor:'#F5F5F7',
            style:{
                color:'#333333',
                fontSize:'11px',
                fontFamily:'Verdana'
            },
            formatter:{
                identifier: "${SERIES}${VALUE}",
                valueFormat: d3.format('.2')
            }
        },

        needle:'#E5715A',
        hinge:'#656B6D',
        hingeBackgroundColor:'#DCF2F9',
        paneBackgroundColor:'#FCFCFC'
    };

    config[Constants.SLOT_GAUGE] = {
        percentageLabel:{
            enabled:true,
            useHtml:false,
            style:{
                fontSize:'36px',
                fontFamily:'Verdana',
                fontWeight:'bold',
                textShadow:'0px 2px 0px rgba(0,0,0,0.08)'
            },

            formatter:{
                identifier: "${PERCENT}",
                percentFormat: d3.format('.2%')
            }
        },

        valueLabel:{
            enabled:true,
            useHtml:false,
            style:{
                color:'#666666',
                fontSize:'14px',
                fontFamily:'Verdana'
            },
            formatter:{
                identifier: "${CATEGORY}${VALUE}",
                valueFormat: d3.format('.2')
            }
        },

        needle:'#ffffff',
        slotBackgroundColor:'#eeeeee'
    };

    config[Constants.RING_GAUGE] = {
        percentageLabel:{
            enabled:true,

            useHtml:false,

            style:{
                fontSize:'24px',
                fontFamily:'Verdana',
                fontWeight:'bold'
            },

            formatter:{
                identifier: "${PERCENT}",
                percentFormat: d3.format('.2%')
            }

        },

        valueLabel:{
            enabled:true,

            useHtml:false,

            style:{
                color:'#777777',
                fontSize:'12px',
                fontFamily:'Verdana'
            },

            formatter:{
                identifier: "${CATEGORY}${VALUE}",
                valueFormat: d3.format('.2')
            }
        },

        clockwise:false,
        paneBackgroundColor:'#eeeeee',
        innerPaneBackgroundColor:'#f4f4f4'

    };

    config[Constants.THERMOMETER_GAUGE] = {

        percentageLabel:{
            enabled:true,

            useHtml:false,

            align:'left',

            style:{
                color:'#333333',
                fontSize:'12px',
                fontFamily:'Verdana',
                fontWeight:'bold'
            },

            formatter:{
                identifier: "${PERCENT}",
                percentFormat: d3.format('.2%')
            }
        },

        valueLabel:{
            enabled:true,

            useHtml:false,

            align:'left',

            style:{
                color:'#bababa',
                fontSize:'12px',
                fontFamily:'Verdana'
            },

            formatter:{
                identifier: "${CATEGORY}${VALUE}",
                valueFormat: d3.format('.2')
            }

        },

        needle:'#ffffff',
        slotBackgroundColor:'#eeeeee',
        thermometerLayout:'vertical'

    };

    config[Constants.RADAR_CHART] = {

        polar: {},

        angleAxis:[angleAxis],

        radiusAxis:[radiusAxis],

        plotOptions:Options[Constants.RADAR_CHART].plotOptions.radar
    };

    config[Constants.SCATTER_CHART] = {
        zoom:xyZoom,

        rangeLegend:disabledRangeLegend,

        xAxis:[xValueAxis],

        yAxis:[yValueAxis],

        plotOptions:Options[Constants.SCATTER_CHART].plotOptions.scatter

    };

    config[Constants.BUBBLE_CHART] = {
        zoom:xyZoom,

        rangeLegend:disabledRangeLegend,

        xAxis:[xValueAxis],

        yAxis:[yValueAxis],

        plotOptions:Options[Constants.BUBBLE_CHART].plotOptions.bubble

    };

    config[Constants.MULTIPIE_CHART] = {
        innerRadiusPct: 2/3,

        plotOptions:Options[Constants.MULTIPIE_CHART].plotOptions.multiPie

    };

    config[Constants.TREEMAP_CHART] = {
        topLabelGap: 6,

        plotOptions:Options[Constants.TREEMAP_CHART].plotOptions.treeMap
    };

    config[Constants.AREA_MAP] = {
        title:nullTitle,

        rangeLegend:rangeLegend,

        legend:disabledLegend,

        plotOptions:Options[Constants.AREA_MAP].plotOptions.areaMap

    };

    config[Constants.POINT_MAP] = {
        title:nullTitle,

        rangeLegend:rangeLegend,

        legend:disabledLegend,

        icon:{
            iconUrl:'../../doc/example/marker-icon.png',
            iconSize: [25, 41]
        },

        plotOptions:Options[Constants.POINT_MAP].plotOptions.pointMap
    };


    return config;
});
/**
 * Created by eason on 15/6/15.
 * 默认主题
 */
define('theme/default',[],function(){

    var tooltip = {
        enabled:true,
        animation:true,
        follow:false,
        backgroundColor:'rgba(0,0,0,0.5)',
        borderColor:null,
        borderWidth:0,
        borderRadius:2,
        shadow:true,
        hideDelay:500,
        shared:false,
        formatter: {
            identifier: "${CATEGORY}${SERIES}${VALUE}"
        },
        padding:5
    };

    var config = {
        colors:['#63b2ee','#76da91','#f8cb7f','#f89588','#7cd6cf','#9192ab','#7898e1','#efa666','#eddd86','#9987ce'],

        plotOptions:{
            animation:true,

            visible:true,

            dataLabels:{
                enabled:false,
                align:'center'
            },

            tooltip:tooltip
        },

        tooltip:tooltip,

        tools:{
            enabled:true,
            hidden:true,
            sort:{
                enabled:true
            },
            toImage:{
                enabled:true
            },
            fullScreen:{
                enabled:true
            }
        },

        inverted:false,

        dTools:{
            style:{
                "fontFamily": "Microsoft Yahei",
                "color": "#b2b2b2",
                "fontSize": "12px",
                "fontWeight": ""
            },
            currentColor:'#62b2ef',
            backgroundColor:'white',
            enabled:false
        },

        title:{
            align:'center',
            backgroundColor:null,
            borderRadius:0,
            floating:false,
            x:0,
            y:0,
            text:"title",
            style:{
                color:'#333333',
                fontSize:'22px',
                fontFamily:'Verdana'
            },
            useHtml:false
        },

        legend:{
            visible:true,
            enabled:true,
            hiddenColor:'#cccccc',
            hoverColor:'#293C55',
            borderRadius:0,
            borderColor:'#cccccc',
            borderWidth:0,
            backgroundColor:null,
            style:{
                color:'#666666',
                fontFamily:'Verdana',
                fontSize:'14px'
            },
            position:'right',
            floating:false,
            layout:'vertical',
            x:0,
            y:0,
            shadow:false,
            margin:10
        },

        backgroundColor:null,
        backgroundImage:null,
        borderColor:  '#CCCCCC',
        borderWidth: 0,
        borderRadius: 0,
        shadow: false,

        plotBackgroundColor:null,
        plotBackgroundImage:null,
        plotBorderColor:  '#CCCCCC',
        plotBorderWidth: 0,
        plotBorderRadius: 0,
        plotShadow: false,

        drag:false
    };

    return config;
});
/**
 * Created by eason on 15/6/17.
 */
define('VanChart',['require','./utils/BaseUtils','./utils/QueryUtils','./utils/Class','./utils/BoundsManager','./ComponentLibrary','./ChartLibrary','./Constants','./HammerHandler','./vector/SvgRenderer','./vector/VmlRenderer','./theme/options','./theme/config','./theme/default'],function(require){

    var BaseUtils = require('./utils/BaseUtils');
    var QueryUtils = require('./utils/QueryUtils');
    var Class = require('./utils/Class');
    var BoundsManager = require('./utils/BoundsManager');
    var ComponentLibrary = require('./ComponentLibrary');
    var ChartLibrary = require('./ChartLibrary');

    var Constants = require('./Constants');
    var Handler = require('./HammerHandler');

    var SvgRenderer = require('./vector/SvgRenderer');
    var VmlRenderer = require('./vector/VmlRenderer');

    //只有在直角坐标系里才会出现的组件
    var R_SYSTEM = [ComponentLibrary.X_AXIS_COMPONENT, ComponentLibrary.Y_AXIS_COMPONENT, ComponentLibrary.DATA_SHEET_COMPONENT, ComponentLibrary.ZOOM_COMPONENT, ComponentLibrary.RADIUS_AXIS_COMPONENT, ComponentLibrary.ANGLE_AXIS_COMPONENT];

    var INIT_MORE_LABEL_ANIMATION_TIME = 250;
    var KEEP_MORE_LABEL_ANIMATION_TIME = 500;
    var EXIT_MORE_LABEL_ANIMATION_TIME = 250;

    var VanChart = Class.extend({
        vanChartType:'vanChart',
        initialize:function(option, dom, vancharts){
            //组件
            this.width = this._getDomWidth(dom);
            this.height = this._getDomHeight(dom);

            dom = this._initLeafLet(dom, option);

            this.dom = dom;
            this.dom.style.cssText += ';overflow:hidden;-ms-user-select:none;-webkit-user-select:none;-moz-user-select:none;-o-user-select:none;user-select:none;';
            this.dom.onselectstart = this.dom.ondrag = function(){
                return false;
            };

            this.vancharts = vancharts;
            this.handler = new Handler(this, dom);
            this.renderer = BaseUtils.isSupportSVG() ? new SvgRenderer(dom, this) : new VmlRenderer(dom, this);

            this.series = {};
            this.seriesOrder = [];//记录系列的顺序
            this.components = {};
            this.colorMap = {};
            this.orderMap = {};
            this.cateMap = {};
            this.timeQueue = {};

            this._startLoading(option);

            this.refresh(option);
        },

        componentType:Constants.VANCHART,

        _startLoading: function (option) {
            if(option && BaseUtils.hasDefined(option.startLoading) && !option.startLoading){
                //只有设置了loading为false才return
                return;
            }
            var startLoading = option.startLoading;
            if(typeof startLoading == 'function'){//startloading函数
                startLoading();
            } else {
                this.vancharts.startLoading();
            }
        },

        _endLoading: function (option) {
            if(option && BaseUtils.hasDefined(option.endLoading) && !option.endLoading){
                //只有设置了loading为false才return
                return;
            }

            var endLoading = option.endLoading;
            if(typeof endLoading == 'function'){//endloading函数
                endLoading();
            } else {
                this.vancharts.endLoading();
            }
        },

        _getAllMoreLabelAnimationTime:function(){
            return INIT_MORE_LABEL_ANIMATION_TIME + KEEP_MORE_LABEL_ANIMATION_TIME + EXIT_MORE_LABEL_ANIMATION_TIME;
        },


        getShowMoreLabelTime: function () {
            return this._changeDataState == true && BaseUtils.hasDefined(this.currentOption.moreLabel)
                ? this._getAllMoreLabelAnimationTime() : 0;
        },

        setChangeDataState: function () {
            this._changeDataState = true;
        },

        _removeChangeDataState: function (series) {
            if(this._changeDataState) {
                this._changeDataSeries = this._changeDataSeries || [];
                this._changeDataSeries.push(series);

                var sumS = 0, chart = this;
                Object.keys(this.series).map(function (chartType) {
                    var chartSeries = chart.series[chartType];
                    sumS += chartSeries.length;
                });

                if (this._changeDataSeries.length >= sumS) {
                    //所有系列的动画完成,changeData的状态给改回来
                    this._changeDataState = null;
                    this._changeDataSeries = [];
                }
            }
        },

        _initLeafLet:function(dom){
            return dom;
        },

        //外部调用接口，传入新的配置
        refresh:function(options){
            if(!options || !options.plotOptions){
                return;
            }
            //ie下面默认禁用所有的动画
            options.animation = options.plotOptions.animation && BaseUtils.isSupportSVG();

            this._init(options);

            this._originSeries();

            this._refreshOptions();
        },

        _originSeries: function () {
        },

        //刷新按钮在两个情况下会出现,1.排序以后 2.坐标轴缩放的时候
        //所以刷新要做的是两件事,1.重新按照原来的顺序排布 2.使所有系列可见,并且刷新坐标轴
        refreshRestore:function(){

            //排序是按照分类总值排序,在一个分类上的柱子和折线应该是一起排序的
            if(this.components[ComponentLibrary.X_AXIS_COMPONENT]){
                this._restoreCategoryAxisBasedSeries(this.components[ComponentLibrary.X_AXIS_COMPONENT]);
            }

            if(this.components[ComponentLibrary.Y_AXIS_COMPONENT]){
                this._restoreCategoryAxisBasedSeries(this.components[ComponentLibrary.Y_AXIS_COMPONENT]);
            }

            //仪表盘恢复
            var gaugeSeries = this.series[Constants.GAUGE_CHART] || [];
            gaugeSeries.sort(function(a, b){
                return a.index - b.index;
            });

            //饼图的排序恢复
            var pieSeries = this.series[Constants.PIE_CHART] || [];
            pieSeries.forEach(function(sery){

                var map = sery.points.map(function(point){
                    return point.graphic;
                });

                var orderMap = {};
                sery.options.data.forEach(function(datum, i){
                    orderMap[datum.x] = i;
                });

                sery.points.sort(function(sliceA, sliceB){
                    return  orderMap[sliceA.x] - orderMap[sliceB.x];
                });

                sery.points.forEach(function(point, index){
                    point.graphic = map[index];
                });
            });

            this._refreshOptions();
        },

        //实现的思路应该是point的graphic的排序,而不应该去刷新属性
        orderData:function(){
            //排序是按照分类总值排序,在一个分类上的柱子和折线应该是一起排序的
            if(this.components[ComponentLibrary.X_AXIS_COMPONENT]){
                this._orderCategoryAxisBasedSeries(this.components[ComponentLibrary.X_AXIS_COMPONENT]);
            }

            if(this.components[ComponentLibrary.Y_AXIS_COMPONENT]){
                this._orderCategoryAxisBasedSeries(this.components[ComponentLibrary.Y_AXIS_COMPONENT]);
            }

            var increaseOrder = this.orderType == Constants.ASCENDING;
            var para = increaseOrder ? 1 : -1;

            //仪表盘的排序
            var gaugeSeries = this.series[Constants.GAUGE_CHART] || [];

            gaugeSeries.sort(function(seryA, seryB){
                var totalA = seryA.getSeryTotalValue();
                var totalB = seryB.getSeryTotalValue();
                return (totalA - totalB) * para;
            });


            //饼图的排序
            var pieSeries = this.series[Constants.PIE_CHART] || [];
            pieSeries.forEach(function(sery){

                var map = sery.points.map(function(point){
                    return point.graphic;
                });

                sery.points.sort(function(sliceA, sliceB){
                    return  increaseOrder ? sliceA.y - sliceB.y : sliceB.y - sliceA.y;
                });

                sery.points.forEach(function(point, index){
                    point.graphic = map[index];
                });
            });

            var multipie = this.series[Constants.MULTIPIE_CHART];
            if(multipie && multipie.length){
                multipie[0].orderData(increaseOrder)
            }

            var dataSheet = this.getComponent(ComponentLibrary.DATA_SHEET_COMPONENT);
            dataSheet && dataSheet.render();

            this.reRenderSeries();
        },

        _restoreCategoryAxisBasedSeries:function(axisComponent){
            for(var axisIndex = 0, count = axisComponent.getAxisCount(); axisIndex < count; axisIndex++){

                var axis = axisComponent.getAxis(axisIndex), series = axis.series;

                //缩放之后刷新，没有orderMap
                if(axis._isBaseAxis() && axis.type == ComponentLibrary.CATEGORY_AXIS_COMPONENT && this.orderMap && Object.keys(this.orderMap).length){

                    var order = this.orderMap[axis.componentType][axisIndex];
                    var keyIndexMap = {};
                    order.forEach(function(p, i){
                        keyIndexMap[p] = i;
                    });

                    var lastOrder = axis.categories;
                    for(var i = 0, len = series.length; i < len; i++){
                        var lastOrderMap = [], sery = series[i];

                        sery.points.forEach(function(point){
                            lastOrderMap[BaseUtils.indexInArray(lastOrder, point.category)] = point.graphic;
                        });

                        sery.points.forEach(function(point){
                            point.graphic = lastOrderMap[keyIndexMap[point.category]]
                        });
                    }

                    axis.setCategories(order);
                }
            }
        },

        _orderCategoryAxisBasedSeries:function(axisComponent, increaseOrder){
            var increaseOrder = this.orderType == Constants.ASCENDING;
            var para = increaseOrder ? 1 : -1;

            for(var axisIndex = 0, count = axisComponent.getAxisCount(); axisIndex < count; axisIndex++){

                var axis = axisComponent.getAxis(axisIndex);

                this.orderMap[axis.componentType] = this.orderMap[axis.componentType] || [];

                if(!this.orderMap[axis.componentType][axisIndex]){
                    this.orderMap[axis.componentType][axisIndex] = axis.categories;
                }

                if(axis._isBaseAxis() && axis.type == ComponentLibrary.CATEGORY_AXIS_COMPONENT){

                    var series = axis.series;
                    var valueMap = [], points = series[0].points;

                    for(var i = 0, len = points.length; i < len; i++){
                        var point = points[i];
                        var total = 0;
                        point.points.forEach(function(point){
                            total += Math.abs(point.getTargetValue());
                        });

                        valueMap.push({key:point.category, value:total});
                    }

                    valueMap.sort(function(a, b){return (a.value - b.value) * para});

                    var keyIndexMap = {}, newCategories = [];
                    valueMap.forEach(function(p, i){
                        keyIndexMap[p.key] = i;
                        newCategories.push(p.key);
                    });

                    var lastOrder = axis.categories;
                    for(var i = 0, len = series.length; i < len; i++){
                        var lastOrderMap = [], sery = series[i];

                        sery.points.forEach(function(point){
                            lastOrderMap[BaseUtils.indexInArray(lastOrder, point.category)] = point.graphic;
                        });

                        sery.points.forEach(function(point){
                            point.graphic = lastOrderMap[keyIndexMap[point.category]]
                        });
                    }

                    axis.setCategories(newCategories);
                    axis._calculateTickData();
                    axis.render();
                }
            }
        },

        //图表整个的属性有改变的时候,至上而下的刷新所有组件.图表的属性.
        _refreshOptions:function(){

            //需要清空的临时变量
            this.colorMap = {};
            this.orderMap = {};
            this.cateMap = {};
            this.seriesOrder = [];

            var option = this.currentOption, vanchart = this,
                seriesData = option.series, chartType = option.chartType;
            var name, Class;

            //构建坐标轴,范围图例等组件
            var Components = ComponentLibrary.getRegisteredComponents(), ComponentsOrder = ComponentLibrary.ComponentsOrder;

            for(var index = 0, cCount = ComponentsOrder.length; index < cCount; index++){
                var name = ComponentsOrder[index], Class = Components[name];
                if(Class){
                    var enabled = option[name] && (BaseUtils.hasNotDefined(option[name].enabled) || option[name].enabled);
                    if(option[name] && enabled){

                        if(this.components[name]){
                            this.components[name].refresh(option[name], vanchart);
                        }else{
                            this.components[name] = new Class(option[name], name, vanchart);
                        }

                    }else if(this.components[name]){
                        this.components[name].remove();
                        this.components[name] = null;
                        delete this.components[name];
                    }
                }
            }

            seriesData.forEach(function(sery){
                var type = sery.type || chartType;

                var constructed = false;
                for(var orderIndex = 0, orderCount = vanchart.seriesOrder.length; orderIndex < orderCount; orderIndex++){
                    if(vanchart.seriesOrder[orderIndex] == type){
                        constructed = true;
                        break;
                    }
                }

                if(!constructed){
                    vanchart.seriesOrder.push(type);
                }
            });

            //构建图表的类型,然后根据组件,修改属性
            vanchart.seriesOrder.forEach(function(name){
                var oldSeries = vanchart.series[name] || [];
                Class = ChartLibrary.get(name);
                var newSeries = [];
                
                seriesData.forEach(function(seriesData, index){
                    if((seriesData.type || chartType) == name){

                        var refresh = false;
                        oldSeries.forEach(function (sery) {
                            if(sery.name == seriesData.name){
                                sery.refresh(seriesData, index);
                                newSeries.push(sery);
                                refresh = true;
                            }
                        });

                        if(!refresh){
                            newSeries.push(new Class(seriesData, vanchart, index));
                        }
                    }
                });


                for(var i = 0, len = oldSeries.length; i < len; i++) {

                    if(BaseUtils.arrayIndexOf(newSeries, oldSeries[i]) == -1) {
                        oldSeries[i].remove();
                    }
                }

                vanchart.series[name] = newSeries;
            });

            this.bounds = BaseUtils.makeBounds(0, 0, this.width, this.height);

            var vanchart = this;
            //组件的布局只有在刷新属性的时候会发生
            ComponentLibrary.ComponentsOrder.map(function (c) {
                if (c in this.components) {
                    this.components[c].doLayout();
                }
            }, this);

            //对于直角坐标系的图,有些组件需要和绘图区域对齐
            R_SYSTEM.forEach(function(cName){
                vanchart.components[cName] && vanchart.components[cName].fixBoundsByPlot();
            });

            [ComponentLibrary.X_AXIS_COMPONENT, ComponentLibrary.Y_AXIS_COMPONENT]
                .forEach(function(cName){
                    vanchart.components[cName] && vanchart.components[cName].dealOnZero && vanchart.components[cName].dealOnZero();
                });

            this.initLayerInfo && this.initLayerInfo();

            this.calculatePlotShapes();

            this.render();
        },

        dealAxisZoom:function(downPos, upPos){
            var zoomType = this.currentOption.zoom.zoomType;
            if(this.components.xAxis && zoomType.indexOf('x') != -1){
                this.components.xAxis.axisZoom(downPos, upPos);
                this.components.xAxis.render();
            }

            if(this.components.yAxis && zoomType.indexOf('y') != -1){
                this.components.yAxis.axisZoom(downPos, upPos);
                this.components.yAxis.render();
            }

            this.reRenderSeries();
        },

        //坐标轴缩放,拖拽缩放,点击图例等任何会导致绘图区图形变化的操作由这步完成
        calculatePlotShapes:function(){

            this.hoverPoint = null;
            this.hoverSeries = null;

            var cateMap = this.cateMap = {};

            var manager = new BoundsManager();
            Object.keys(this.series).map(function (chartType) {

                var chartSeries = this.series[chartType];

                if (this.isTreeSeries(chartType)) {

                    chartSeries.map(function (chartItem) {
                        chartItem.doLayout();
                    });

                } else {

                    //这里注意顺序,要先算百分比,.points属性才能算标签和数据点提示
                    this._buildStacked(chartSeries, chartType, cateMap);

                    this._calculateDataLabelsAndTooltip(chartSeries);

                    this._calculateDelayTime(chartType, chartSeries);

                    this._calculateSeriesMinMaxValue(chartType, chartSeries);

                    for (var i = 0, len = chartSeries.length; i < len; i++) {
                        if (chartSeries[i].visible) {
                            chartSeries[i].doLayout();
                            chartSeries[i]._calculateLabelPos(manager);
                        }
                    }
                }
            }, this);
        },

        reRenderSeries:function(){
            this.calculatePlotShapes();
            this.renderSeries();
        },

        isSupportAnimation:function(){
            return this.currentOption.animation;
        },

        _calculateDelayTime: function (type, series) {
            if(this.isSupportAnimation()) {

                var sortFunc, easeFunc;

                if(type == Constants.BUBBLE_CHART){
                    easeFunc = 'swing';
                    sortFunc = function (pointA, pointB) {
                        return pointB.radius - pointA.radius;
                    }
                } else if(type == Constants.SCATTER_CHART){
                    var isInverted = this.isInverted();
                    easeFunc = 'exp-in-out';
                    sortFunc = function (pA, pB) {
                        return isInverted ? pA.posY - pB.posY : pA.posX - pB.posX;
                    }
                } else {
                    return;
                }

                var allPoints = [];

                series.forEach(function(sery){
                    allPoints = allPoints.concat(sery.points);
                });

                allPoints.sort(sortFunc);

                var len = allPoints.length;
                if (len > 0) {

                    allPoints.forEach(function (point, i) {

                        point.delayTime = d3.ease(easeFunc)(i/len) * 800;

                    });
                }
            }
        },

        _calculateSeriesMinMaxValue: function (type, series) {
            if(this._seriesNeedMinMaxValue(type)){

                series.forEach(function(sery) {
                    if (sery.points.length > 0) {
                        var seriesMinSize = Number.MAX_VALUE;//当前系列数据的最大最小值
                        var seriesMaxSize = -seriesMinSize;

                        for(var index = 0, len = sery.points.length; index < len; index++){
                            var point = sery.points[index];
                            if(!point.isNull){

                                var value = sery.getPointValue4MinMax(point);

                                if(BaseUtils.hasDefined(value)) {
                                    seriesMaxSize = Math.max(seriesMaxSize, value);
                                    seriesMinSize = Math.min(seriesMinSize, value);
                                }
                            }
                        }

                        sery.seriesMinValue = seriesMinSize;
                        sery.seriesMaxValue = seriesMaxSize;
                    }
                });
            }
        },


        //按照系列来集聚的图表
        isSeriesAccumulated:function(type){
            return [
                Constants.PIE_CHART,
                Constants.GAUGE_CHART,
                Constants.MULTIPIE_CHART,
                Constants.TREEMAP_CHART
            ].indexOf(type) !== -1;
        },

        isTreeSeries: function (type) {
            return [
                Constants.MULTIPIE_CHART,
                Constants.TREEMAP_CHART
            ].indexOf(type) !== -1;
        },

        _seriesNeedMinMaxValue: function (type) {
            return [
                    Constants.BUBBLE_CHART,
                    Constants.FORCE_BUBBLE_CHART
                ].indexOf(type) !== -1;
        },

        _calculateDataLabelsAndTooltip:function(series){
            for(var i = 0, len = series.length; i < len; i++){
                var sery = series[i];
                sery.points.forEach(function(p){
                    sery.calculateLabelInfo(p);
                });
            }
        },

        //跟堆积有关的属性的计算,百分比和堆积值
        _buildStacked: function (series, type, cateMap) {
            var vanchart = this;

            if(this.isSeriesAccumulated(type)){
                series.forEach(function(sery){
                    var key = sery.getTargetKey();
                    vanchart._calculatePercentage(sery.points, key, cateMap);
                    vanchart._calculateStackedValue(sery.points, type, key);
                });
            }else{
                var stackMap = {};
                series.map(function (ser) {

                    if(ser.visible){
                        ser.points.map(function (p) {
                            var stackKey = [ser.stack, p.category].join('-');
                            stackMap[stackKey] || (stackMap[stackKey] = []);
                            stackMap[stackKey].push(p);

                            cateMap[p.category] = cateMap[p.category] || [];
                            cateMap[p.category].push(p);
                        });
                    }
                });

                for (var stackKey in stackMap) {
                    var points = stackMap[stackKey];
                    var key = points[0].series.getTargetKey();

                    this._calculatePercentage(points, key, cateMap);

                    this._calculateStackedValue(points, type, key);
                }
            }
        },

        _calculatePercentage:function(points, key, cateMap){
            var total = 0;
            points.filter(function (d) {return !d.isNull;})
                .forEach(function(d){
                    total += Math.abs(d[key]);
                });

            total = total > 0 ? total : 1;

            points.forEach(function(point){
                var series = point.series, key = series.getTargetKey(), baseAxis = series[series.getBaseAxisType()];
                var temp = !series.stack && baseAxis && baseAxis.type != ComponentLibrary.CATEGORY_AXIS_COMPONENT;
                //不堆积，双值轴，百分比为1
                point.percentage = temp ? 1 : Math.abs(point[key]) / total;

                //设置points的参数
                point.points = cateMap[point.category];
            });
        },

        _calculateStackedValue:function(points, chartType, key){
            if(points && points.length){

                var series = points[0].series;
                var byPercent = series.stackByPercent;
                var stack = series.stack || byPercent;

                var preSumP = 0, preSumN = 0;

                for(var i = 0, count = points.length; i < count; i++){
                    var point = points[i];
                    if(stack){
                        var usedValue = byPercent ? point.percentage : point.getTargetValue();
                        if(usedValue >= 0){
                            point[key + '0'] = preSumP;
                            preSumP += usedValue;
                        }else{
                            point[key + '0'] = preSumN;
                            preSumN += usedValue;
                        }
                    }else{
                        point[key + '0'] = 0;
                    }
                }
            }
        },

        _init:function(option){

            option.series = (option.series && option.series.length) ? option.series : [{}];//保证series不为空

            option.series.forEach(function(sery){
                sery.data = sery.data || [];
            });

            //坐标轴可能是数组
            this.themeConfig = this._mergeThemeConfig(option);

            this.restoreOption = QueryUtils.merge(BaseUtils.clone(option), this.themeConfig, false);

            if(this.restoreOption.chartType == Constants.SCATTER_CHART
                || this.restoreOption.chartType == Constants.BUBBLE_CHART){

                var sort = this.restoreOption.tools.sort || {};
                sort.enabled = false;
            }
            
            if (this.restoreOption.inverted) {
                if (this.restoreOption.zoom && this.restoreOption.zoom.zoomTool) {
                    this.restoreOption.zoom.zoomTool.enabled = false;
                }
                if (this.restoreOption.dataSheet) {
                    this.restoreOption.dataSheet = false;
                }
            }

            this.currentOption = BaseUtils.clone(this.restoreOption);
        },

        _getDomWidth:function(root){
            var stl = root.currentStyle || document.defaultView.getComputedStyle(root);
            return ((root.clientWidth || parseInt(stl.width, 10)) - parseInt(stl.paddingLeft, 10) - parseInt(stl.paddingRight, 10)).toFixed(0) - 0;
        },

        _getDomHeight:function(root){
            var stl = root.currentStyle || document.defaultView.getComputedStyle(root);
            return ((root.clientHeight || parseInt(stl.height, 10)) - parseInt(stl.paddingTop, 10) - parseInt(stl.paddingBottom, 10)).toFixed(0) - 0;
        },

        //默认配置，主题配置的组合
        _mergeThemeConfig:function(option){
            var optionsConfig = require('./theme/options');//plotOptions里某个图表对象特有的
            var defaultConfig = require('./theme/config');//具体某个图表特有的
            var themeConfig = require('./theme/default');//所有图表通用的

            var chartTypes = [];
            var result = {};
            
            QueryUtils.merge(result, themeConfig, true);

            if(option.chartType) {
                chartTypes.push(option.chartType);
                QueryUtils.merge(result, defaultConfig[option.chartType], true);
            }

            option.series.map(function (item) {
                var type = item.type;
                if (type && chartTypes.indexOf(type) === -1) {
                    chartTypes.push(item);
                    QueryUtils.merge(result, optionsConfig[type], true);
                }
            });

            if (chartTypes.length === 0) {
                QueryUtils.merge(result, defaultConfig[Constants.LINE_CHART], true);
            }

            return result;
        },

        getPlotBackgroundOption:function(){
            var option = this.currentOption;
            return {
                backgroundColor:option.plotBackgroundColor,
                backgroundImage:option.plotBackgroundImage,
                borderColor:option.plotBorderColor,
                borderWidth:option.plotBorderWidth,
                borderRadius:option.plotBorderRadius,
                shadow:option.plotShadow
            }
        },

        getChartBackgroundOption:function(){
            var option = this.currentOption;
            var geo = this.restoreOption.geo;
            return {
                backgroundColor:geo ? '' : option.backgroundColor,
                backgroundImage:geo ? '' : option.backgroundImage,
                borderColor:option.borderColor,
                borderWidth:geo ? 0 : option.borderWidth,
                borderRadius:option.borderRadius,
                shadow:option.shadow
            }
        },

        getTrendLineOption:function(){
            var trendLines = [], series = this.series, vanchart = this;

            Object.keys(series).map(function (chartType) {
                var chartSeries = series[chartType];
                for(var i = 0, len = chartSeries.length; i < len; i++){
                    var sery = chartSeries[i], trendLine = sery.trendLine;
                    //堆积的系列用趋势线没意义吧
                    if(!trendLine || !sery.visible){
                        continue;
                    }

                    var XY = sery.getTrendLineXYValues(sery);
                    var xValues = XY[0], yValues = XY[1], location = XY[2];
                    var x1,x2,y1,y2;

                    if(location == Constants.TOP || location == Constants.BOTTOM){
                        if(xValues.length <= 1){
                            continue;
                        }
                        var leastSquaresCoeff = vanchart._leastSquares(XY[0], XY[1]);
                        x1 = xValues[0];
                        y1 = leastSquaresCoeff[0] * x1 + leastSquaresCoeff[1];
                        x2 = xValues[xValues.length - 1];
                        y2 = leastSquaresCoeff[0] * x2 + leastSquaresCoeff[1];
                    }else{
                        if(yValues.length <= 1){
                            continue;
                        }
                        var leastSquaresCoeff = vanchart._leastSquares(XY[1], XY[0]);
                        y1 = yValues[0];
                        x1 = leastSquaresCoeff[0] * y1 + leastSquaresCoeff[1];
                        y2 = yValues[yValues.length - 1];
                        x2 = leastSquaresCoeff[0] * y2 + leastSquaresCoeff[1];
                    }

                    trendLines.push({
                        x1:x1,
                        y1:y1,
                        x2:x2,
                        y2:y2,
                        trendLine:trendLine
                    })
                }
            });
            return trendLines;
        },

        _leastSquares:function(xValues, yValues){
            var reduceSumFunc = function(prev, cur) { return prev + cur; };

            var xBar = xValues.reduce(reduceSumFunc) * 1.0 / xValues.length;
            var yBar = yValues.reduce(reduceSumFunc) * 1.0 / yValues.length;

            var ssXX = xValues.map(function(d) { return Math.pow(d - xBar, 2); })
                .reduce(reduceSumFunc);

            var ssYY = yValues.map(function(d) { return Math.pow(d - yBar, 2); })
                .reduce(reduceSumFunc);

            var ssXY = xValues.map(function(d, i) { return (d - xBar) * (yValues[i] - yBar); })
                .reduce(reduceSumFunc);

            var slope = ssXY / ssXX;
            var intercept = yBar - (xBar * slope);

            return [slope, intercept];
        },

        //地图和别的图表类型不一样,而且这个计算
        getMinMaxFromSeries:function(){

            var options = this.currentOption;
            var accountPoints = [], series = options.series, chartType = options.chartType;
            if(options.geo){
                var validArea = {}, validPoint = {}, geo = this.components[ComponentLibrary.GEO_COMPONENT];

                for(var i = 0, len = series.length; i < len; i++){
                    var sery = series[i], type = sery.type || chartType;

                    if(!sery.data || !sery.data.length){
                        continue;
                    }

                    if(type == Constants.AREA_MAP){//面积类型的地图计算第一个有效的系列,考虑到多系列的情况
                        var points = sery.data;
                        for(var pIndex = points.length - 1; pIndex >= 0; pIndex--){
                            var point = points[pIndex];
                            if(point){
                                if(validArea[point.name] || !point.value){
                                    continue;
                                }
                                validArea[point.name] = true;
                                accountPoints.push(point);
                            }
                        }
                    }else{
                        sery.data.forEach(function(point){
                            var key = point.lnglat ? point.lnglat.join(',') : point.name;
                            //对于同一种类型的点,并且经纬度一样的时候,只取当前的第一个有效点
                            if((validPoint[type] && validPoint[type][key]) || (!point.size && !point.value)){
                                return;
                            }
                            validPoint[type] = validPoint[type] || {};
                            validPoint[type][key] = true;
                            accountPoints.push(point);
                        });
                    }
                }
            }else{
                var plotOptions = options.plotOptions, plotDisplayNegative = plotOptions && plotOptions.displayNegative;
                for(var i = series.length - 1; i >= 0; i--){
                    var sery = series[i], type = sery.type || chartType, seriesDisplayNegative = sery.displayNegative;
                    sery.data.forEach(function(point){

                        var displayNegative = BaseUtils.hasDefined(plotDisplayNegative) ? plotDisplayNegative : true;
                        displayNegative = BaseUtils.hasDefined(seriesDisplayNegative) ? seriesDisplayNegative : displayNegative;
                        displayNegative = BaseUtils.hasDefined(point.displayNegative) ? point.displayNegative : displayNegative;

                        if(type != Constants.BUBBLE_CHART || !(point.size < 0 && !displayNegative)) {
                            accountPoints.push(point)
                        }
                    });
                }
            }

            return this._getMinMaxFromPoints(accountPoints);
        },

        _getMinMaxFromPoints:function(points){

            if(!points.length){
                return [0, 0];
            }

            var isForceBubble =  this.currentOption.plotOptions.force;
            var min = Number.MAX_VALUE, max = -min;
            points.forEach(function (point) {
                //到现在为止用来当作指标的有size,和value
                var value = BaseUtils.hasDefined(point.size) ? point.size : point.value;
                if(isForceBubble){
                    value = point.y;
                }

                if(!isNaN(parseFloat(value))){
                    min = Math.min(value, min);
                    max = Math.max(value, max);
                }
            });

            if(isNaN(min) || isNaN(max) || max < min){
                min = 0; max = 100;
            }

            return [min, max]
        },

        getParentDom:function(){
            return this.dom;
        },

        getDivParentDom:function(){
            return this.vancharts.dom;
        },

        isInverted: function () {
            return !!this.getOptions().plotOptions.inverted;
        },

        setPlotBounds:function(newBounds){
            this.bounds = newBounds;
        },

        getPlotClipBounds:function(){
            var x = 0,  y = 0, width = this.bounds.width, height = this.bounds.height;
            var locationMap = {}, all = [];
            if(this.components.xAxis){
                all = all.concat(this.components.xAxis._axisList);
            }

            if(this.components.yAxis){
                all = all.concat(this.components.yAxis._axisList);
            }

            all.forEach(function(axis){
                var position = axis.getPosition();
                if(!axis.isOnZero() && !locationMap[position]){
                    locationMap[position] = axis.getLineWidth();
                }
            });

            y = locationMap[Constants.TOP] ? Math.ceil(locationMap[Constants.TOP]/2) : 0;
            height -= y;
            height = locationMap[Constants.BOTTOM] ? height - Math.ceil(locationMap[Constants.BOTTOM]/2 - 0.5) : height;

            x = locationMap[Constants.LEFT] ? Math.ceil(locationMap[Constants.LEFT]/2) : 0;
            width -= x;
            width = locationMap[Constants.RIGHT] ? width - Math.ceil(locationMap[Constants.RIGHT]/2) : width;

            return {
                x:x + this.bounds.x,
                y:y + this.bounds.y,
                width:Math.max(width, 0),
                height:Math.max(height, 0)
            };
        },

        getPlotBounds:function(){
            return this.bounds;
        },

        getChartBounds:function(){
            return BaseUtils.makeBounds(0, 0, this.width, this.height);
        },

        xAxis:function(axisIndex){
            if(!axisIndex){
                axisIndex = 0;
            }
            var axis = this.components.xAxis;
            return axis ? axis.getAxis(axisIndex) : null;
        },

        yAxis:function(axisIndex){
            if(!axisIndex){
                axisIndex = 0;
            }
            var axis = this.components.yAxis;
            return axis ? axis.getAxis(axisIndex) : null;
        },

        polar:function(axisIndex){
            if(!axisIndex){
                axisIndex = 0;
            }
            var axis = this.components.polar;
            return axis ? axis.getAxis(axisIndex) : null;
        },

        angleAxis: function (axisIndex) {
            if(!axisIndex){
                axisIndex = 0;
            }
            var axis = this.components.angleAxis;
            return axis ? axis.getAxis(axisIndex) : null;
        },

        radiusAxis: function (axisIndex) {
            if(!axisIndex){
                axisIndex = 0;
            }
            var axis = this.components.radiusAxis;
            return axis ? axis.getAxis(axisIndex) : null;
        },

        gaugeAxis: function (axisIndex) {
            if(!axisIndex){
                axisIndex = 0;
            }
            var axis = this.components.gaugeAxis;
            return axis ? axis.getAxis(axisIndex) : null;
        },

        getSharedAxis: function () {
            var axes = [this.xAxis(), this.yAxis(), this.angleAxis()];
            for (var i = 0; i < axes.length; i++) {
                var axis = axes[i];
                if (axis && axis.type == ComponentLibrary.CATEGORY_AXIS_COMPONENT) {
                    return axis;
                }
            }
            return null;
        },

        getTooltip:function(){
            return this.components.tooltip;
        },

        getComponent:function(type){
            return this.components[type];
        },

        getOptions:function(){
            return this.currentOption;
        },

        /**
         * return color of previous name
         * or set new color and return
         * @param {string} [name] series item (or pie point) name
         * @returns {*}
         */
        getDefaultSeriesColor: function (name) {
            name += '';
            if (!this.colorMap[name]) {
                var colors = this.currentOption.colors;
                var length = 0;
                for (var item in this.colorMap) {
                    ++length;
                }
                // return next color
                this.colorMap[name] = colors[length % colors.length];
            }

            return this.colorMap[name];
        },

        render:function(){
            this._endLoading(this.currentOption);

            var vanchart = this, renderer = this.renderer;

            var clipBounds = this.getPlotClipBounds();
            if(!this.plotClip){
                this.plotClip = renderer.createClip(clipBounds);
            }else{
                this.plotClip.rect && this.plotClip.rect.attr(clipBounds);
            }

            this._renderBackground();

            this.renderComponents(ComponentLibrary.ComponentsOrder, function (comp) {return !comp.isFloat;});

            if(!vanchart.clipSeriesGroup){
                renderer.clip(vanchart.clipSeriesGroup = renderer.group().add(), vanchart.plotClip);
            }

            if(!vanchart.seriesGroup){
                vanchart.seriesGroup = renderer.group().add();
            }

            if(!vanchart.seriesTextRenderGroup){
                renderer.clip(vanchart.seriesTextRenderGroup = renderer.group().add(), vanchart.plotClip);
            }

            if (!vanchart.seriesTextDivGroup) {
                vanchart.seriesTextDivGroup = renderer.div().add();
                // clip: rect(<top>, <right>, <bottom>, <left>);
                vanchart.seriesTextDivGroup.style({
                    clip: 'rect(' + [
                        clipBounds.y,
                        clipBounds.x + clipBounds.width,
                        clipBounds.y + clipBounds.height,
                        clipBounds.x
                    ].join('px ') + 'px)'
                });
            }

            this.renderSeries();

            this.renderComponents(ComponentLibrary.ComponentsOrder, function (comp) {return comp.isFloat;});

            // phantomjs test
            window.console && console.log('done');
        },

        renderComponents: function (compArray, filterFunc) {
            filterFunc = filterFunc || function () {return true;};
            compArray.map(function (c) {
                if (c in this.components) {
                    var comp = this.components[c];
                    filterFunc(comp) && comp.render();
                }
            }, this);

            compArray.map(function (c) {
                if (c in this.components) {
                    var comp = this.components[c];
                    filterFunc(comp) && comp.renderSpecial && comp.renderSpecial();
                }
            }, this);
        },

        renderSeries:function(){
            for(var chartType in this.series){
                var chartSeries = this.series[chartType];

                for(var i = chartSeries.length - 1; i >= 0; i--){
                    chartSeries[i].render();
                }
            }

            this._renderTrendLine();

            this._updateSeriesState();
        },

        _renderBackground:function(){
            var chartBounds = BaseUtils.makeBounds(0,0,this.width, this.height);
            var chartBackground = this.getChartBackgroundOption();

            var plotBounds = this.getPlotBounds();
            var plotBackground = this.getPlotBackgroundOption();

            if(!this.chartBackgroundGroup){
                this.chartBackgroundGroup = this.renderer.group().add();
                this.plotBackgroundGroup = this.renderer.group().add();
            }

            this._renderRectangleBackground(this.chartBackgroundGroup, chartBackground, chartBounds);
            this._renderRectangleBackground(this.plotBackgroundGroup, plotBackground, plotBounds);
        },

        _renderTrendLine:function(){
            var trendLineOptions = this.getTrendLineOption(), plotBounds = this.getPlotBounds(), renderer = this.renderer;
            var detX = plotBounds.x, detY = plotBounds.y;

            if(!this.trendLineGroup){
                this.trendLineGroup = this.renderer.group().add();
                renderer.clip(this.trendLineGroup, this.plotClip);
            }
            this.trendLineGroup.trendLines = this.trendLineGroup.trendLines || [];
            var trendLines = this.trendLineGroup.trendLines;

            for(var i = 0, len = trendLineOptions.length; i < len; i++){
                var options = trendLineOptions[i], attrs = {'x1': options.x1 + detX, 'y1':options.y1 + detY, 'x2':options.x2 + detX, 'y2':options.y2 + detY},
                    style = {'stroke':options.trendLine.color, 'stroke-width':options.trendLine.width, 'stroke-dasharray':Constants.DASH_TYPE[options.trendLine.dashStyle]};
                if(trendLines[i]){
                    trendLines[i].attr(attrs).style(style);
                }else{
                    trendLines[i] = renderer.line(attrs).style(style).addTo(this.trendLineGroup);
                }
            }

            for(var i = trendLineOptions.length; i < trendLines.length; i++){
                trendLines[i].remove(); trendLines[i] = null;
            }

            trendLines.length = trendLineOptions.length;
        },

        _renderRectangleBackground:function(backgroundGroup, option, bounds){

            var borderWidth = option.borderWidth || 0, renderer = this.renderer;
            var borderBounds = BaseUtils.rectSubPixelOpt(bounds.x, bounds.y, bounds.width - borderWidth, bounds.height - borderWidth, borderWidth);
            borderBounds.rx = borderBounds.ry = option.borderRadius;

            if(option.shadow){
                var shadowBounds = BaseUtils.rectSubPixelOpt(bounds, 1);
                var width = [5, 3, 1];
                var opacity = [0.05, 0.1, 0.15];
                width.forEach(function(w, i){
                    var key = 'shadowRect' + i;
                    backgroundGroup[key] = backgroundGroup[key] || renderer.rect().style({'fill':'none', 'stroke': 'black', 'stroke-width':width[i], 'stroke-opacity':opacity[i]}).addTo(backgroundGroup);

                    backgroundGroup[key].attr(shadowBounds).attr({'rx':option.borderRadius, 'ry':option.borderRadius,'transform':'translate(1, 1)'});
                });
            }

            if(option.backgroundColor && typeof option.backgroundColor == 'object'){
                var gradualOption = option.backgroundColor;
                var attrs = {'x1':gradualOption.x1, 'y1':gradualOption.y1, 'x2':gradualOption.x2, 'y2':gradualOption.y2};
                var stop1 = {'offset':'0%', 'stop-color':gradualOption.startColor};
                var stop2 = {'offset':'100%', 'stop-color':gradualOption.endColor};

                if(backgroundGroup.gradientFill){
                    renderer.updateColorGradient(backgroundGroup.gradientFill, attrs, [stop1,stop2]);
                }else{
                    backgroundGroup.gradientFill = renderer.colorGradient(attrs, [stop1, stop2]);
                }
            }

            if(option.backgroundColor || option.borderWidth){
                backgroundGroup.backgroundColor = backgroundGroup.backgroundColor || renderer.rect().addTo(backgroundGroup);
                backgroundGroup.backgroundColor.attr(borderBounds)
                    .style({'fill':option.backgroundColor ? (typeof option.backgroundColor == 'string' ? option.backgroundColor : "url(#" + BaseUtils.stamp(backgroundGroup.gradientFill) + ")") : 'none',
                        'stroke':option.borderColor, 'stroke-width':option.borderWidth});
            }

            if(option.backgroundImage){
                backgroundGroup.backgroundImage = backgroundGroup.backgroundImage || renderer.image().addTo(backgroundGroup);
                backgroundGroup.backgroundImage.attr(bounds).attr('preserveAspectRatio', 'none').attr('href', option.backgroundImage);
            }
        },

        //渐变色图例，直接过滤，不用计算布局什么的
        filterRender: function () {
            for(var chartType in this.series){
                var chartSeries = this.series[chartType];
                for(var i = 0, len = chartSeries.length; i < len; i++){
                    chartSeries[i].filterRender();
                }
            }
        },

        showTooltip:function(point, event){
            this.components[ComponentLibrary.TOOLTIP_COMPONENT].showWithPoint(point, event)
        },

        hideTooltip:function(){
            this.hoverPoint = null;
            this.components[ComponentLibrary.TOOLTIP_COMPONENT].hide();
        },

        //show to-drop,dropped,to-show几个状态之间切换
        _updateSeriesState:function(){
            for(var chartType in this.series){
                var chartSeries = this.series[chartType];
                for(var i = 0, len = chartSeries.length; i < len; i++){
                    chartSeries[i].state = chartSeries[i].state == Constants.STATE_TO_DROP ?  Constants.STATE_DROPPED : chartSeries[i].state;
                    chartSeries[i].state = chartSeries[i].state == Constants.STATE_TO_SHOW ?  Constants.STATE_SHOW : chartSeries[i].state;
                }
            }
        },

        // ussage:
        // vanchart.setTimeout('foo', bar, 100);
        // setting new func for the same key will flush the previous func
        // vanchart.setTimeout('foo'); cancel the func
        //
        // attention: this function fire the delay=0 immediately, no setTimeout(fun, 0)
        //
        setTimeout: function (key, func, delay) {
            if (this.timeQueue[key]) {
                window.clearTimeout(this.timeQueue[key]);
            }
            if (delay) {
                this.timeQueue[key] = window.setTimeout(func, delay);
            } else {
                func && func();
                this.timeQueue[key] = null;
            }
        },

        // should remove all in the end
        clearTimeQueue: function () {
            var timeQueue = this.timeQueue;
            Object.keys(timeQueue).map(function (key) {
                window.clearTimeout(timeQueue[key]);
            });
            this.timeQueue = {};
        },

        remove:function(){
            this.clearTimeQueue();
            this.renderer.remove();
            this.renderer = this.plotClip
                = this.chartBackgroundGroup
                = this.trendLineGroup
                = this.seriesGroup
                = this.clipSeriesGroup
                = this.seriesTextGroup = null;
            this.handler.destroy();
        },

        resize:function(){
            var dom = this.dom;
            this.width = this._getDomWidth(dom);
            this.height = this._getDomHeight(dom);

            //resize的时候工具栏要删掉
            var toolbar = this.getComponent(ComponentLibrary.TOOLBAR_COMPONENT);
            toolbar && toolbar.remove();

            this._refreshOptions();
        }
    });

    return VanChart;
});
/**
 * Created by eason on 15/9/7.
 */

define('utils/Formatter',['require','./BaseUtils'],function(require){

    var BaseUtils = require('./BaseUtils');

    function format(cv, fmt){

        fmt = BaseUtils.getFormatterFunction(fmt);

        return fmt ? fmt.bind(cv)(cv) : cv;
    }

    return {
        format:format
    }

});
/**
 * Created by eason on 16/8/25.
 */

define('VanChartMap',['require','./VanChart','./utils/BaseUtils','./ComponentLibrary','./ChartLibrary','./Constants','./utils/Formatter','./utils/BoundsManager','./utils/ColorUtils'],function(require){

    var NAME = 'NAME';
    var SERIES = 'SERIES';
    var VALUE = 'VALUE';
    var PERCENT = 'PERCENT';

    var VanChart = require('./VanChart');
    var BaseUtils = require('./utils/BaseUtils');
    var ComponentLibrary = require('./ComponentLibrary');
    var ChartLibrary = require('./ChartLibrary');
    var Constants = require('./Constants');
    var Formatter = require('./utils/Formatter');
    var BoundsManager = require('./utils/BoundsManager');
    var ColorUtils = require('./utils/ColorUtils');

    function labelFilter(point){
        return point && point.dataLabels && point.labelContent && point.labelPos;
    }

    function validLabelFilter(point){
        return point && point.dataLabels && point.labelContent;
    }

    function areaKeyFunc(point){
        return point.properties.id;
    }

    function pointKeyFunc(point){
        return point.className;
    }

    var VanChartMap = VanChart.extend({
        vanChartType:'vanChartMap',
        _initLeafLet:function(dom, option){
            var vanchartMap = this;

            function viewreset(){

                var hoverPoint = vanchartMap.hoverPoint;
                var zoomLevel = vanchartMap._leaflet.getZoom();
                var layerIndex = vanchartMap.layerIndex;

                //检查是否要做自动下钻,如果下钻成功,则直接返回
                if(hoverPoint && hoverPoint.drilldown){
                    if(!hoverPoint.geo){
                        hoverPoint = vanchartMap._createDrillDownWhenLoaded(hoverPoint);
                    }
                    var zoomListener = hoverPoint.geo.getZoomListener();
                    if(zoomListener && zoomListener <= zoomLevel){
                        vanchartMap.drillDown(hoverPoint);
                        return ;
                    }
                }

                //检查是否做自动上钻,上钻则返回
                var lastData = vanchartMap.lastIconData && vanchartMap.lastIconData[layerIndex - 1];
                if(lastData && lastData.zoomListener > zoomLevel){
                    vanchartMap.drillUp(lastData);
                    return ;
                }

                //没有自动上下钻取,则在当前地图上更新标签等内容
                vanchartMap.viewreset();
            };

            var options = {zoomControl:false, doubleClickZoom:false};

            this._leaflet = this._leaflet || L.map(dom, options);
            this._leaflet.on('zoom', viewreset, this._leaflet);
            this._leaflet.vanchart = this;

            BaseUtils.setDomBackground(dom, {
                backgroundColor:option.backgroundColor,
                borderColor:option.borderColor,
                borderWidth:option.borderWidth,
                borderRadius:option.borderRadius,
                shadow:option.shadow
            });

            var root = document.createElement('div');
            root.setAttribute('class', 'leaflet-pane leaflet-map-pane');

            dom.appendChild(root);

            return this._leaflet._controlContainer.getElementsByTagName('div')[0];
        },

        _refreshComponents:function(){

            for(var cp in this.components){
                this.components[cp].refresh();
            }

            this.bounds = BaseUtils.makeBounds(0, 0, this.width, this.height);

            ComponentLibrary.ComponentsOrder.map(function (c) {
                if (c in this.components) {
                    this.components[c].doLayout();
                }
            }, this);

            this.calculatePlotShapes();
        },

        iconDataOfMap:function(series){
            for(var i = this.layerMap.length - 1; i >= 0; i--){
                var layerArray = this.layerMap[i];

                for(var j = layerArray.length - 1; j >= 0; j--){
                    if(layerArray[j].series == series){
                        return layerArray[j];
                    }
                }
            }
        },

        _originSeries: function () {
            if(this.layerIndex == 0){
                return;
            }
            if(this.layerMap && this.layerMap[0] && this.layerMap[0][0]){
                this.series = this.layerMap[0][0].series;
            }
        },

        initLayerInfo:function(){
            this.layerMap = [];
            this.layerIndex = 0;

            var geo = this.getComponent(ComponentLibrary.GEO_COMPONENT);
            var series = this.series;
            var seriesOptions = this.currentOption.series;
            geo.originSeries = seriesOptions;

            this.layerMap[0] = [];
            this.layerMap[0][0] = {series:series, geo:geo, layerIndex:this.layerIndex};

            var drillTools = this.getComponent(ComponentLibrary.DRILL_TOOLS);

            if(drillTools){
                drillTools.remove();
                drillTools.initIconData(this.layerMap[0][0]);
            }

            this._setNewGeo(geo);

            geo.fitMapBounds();
        },

        _setNewGeo:function(geo, lastGeo){

            var lastTileLayer, lastAttribution, lastImageLayer;
            if(lastGeo){
                lastTileLayer = lastGeo._tileLayer || lastGeo._wmsLayer;
                lastAttribution = lastGeo._attribution;
                lastImageLayer = lastGeo._imageBackgroundLayer;
            }

            if(geo){
                geo.loadGeo();
                var currentImageLayer = geo._imageBackgroundLayer;
                var currentTileLayer = geo._tileLayer || geo._wmsLayer;
                var currentAttribution = geo._attribution;

                var leaflet = this._leaflet;
                if(currentImageLayer){
                    lastTileLayer && lastTileLayer.remove();
                    lastAttribution && lastAttribution.remove();
                    L.setOptions(leaflet, {crs:L.CRS.Simple});
                    if(lastImageLayer != currentImageLayer){
                        lastImageLayer && leaflet.removeLayer(lastImageLayer);
                        currentImageLayer.addTo(leaflet);
                    }
                }else if(currentTileLayer){
                    lastImageLayer && leaflet.removeLayer(lastImageLayer);
                    L.setOptions(leaflet, {crs:L.CRS.EPSG3857});
                    if(lastTileLayer != currentTileLayer){
                        lastTileLayer && lastTileLayer.remove();
                        currentTileLayer.addTo(leaflet);

                        lastAttribution && lastAttribution.remove();
                        currentAttribution.addTo(leaflet);
                    }
                }
            }
        },

        _createDrillDownWhenLoaded:function(point){

            var Geo = ComponentLibrary.get(ComponentLibrary.GEO_COMPONENT);

            point = point.originPoint || point;

            var drilldown = point.drilldown, vanchartMap = this;
            var drillSeries = {}, drillGeo;

            var rangeLegend = this.getComponent(ComponentLibrary.RANGE_LEGEND_COMPONENT);
            var lastGeo = this.getComponent(ComponentLibrary.GEO_COMPONENT);

            if(rangeLegend){
                vanchartMap.currentOption.series = drilldown.series;
                rangeLegend.refresh();
            }

            drillGeo = new Geo(drilldown.geo, ComponentLibrary.GEO_COMPONENT, vanchartMap);

            drilldown.series.forEach(function(sery, index){
                var classType = sery.type || vanchartMap.currentOption.chartType;
                var Class = ChartLibrary.get(classType);

                drillSeries[classType] = drillSeries[classType] || [];
                drillSeries[classType].push(new Class(sery, vanchartMap, index));
            });

            //has been initialized
            point.geo = drillGeo;
            point.drillSeries = drillSeries;
            drillGeo.originSeries = drilldown.series;

            var nextLayerIndex = this.layerIndex + 1;

            this.layerMap[nextLayerIndex] = this.layerMap[nextLayerIndex] || [];
            this.layerMap[nextLayerIndex].push({geo:point.geo, series:drillSeries, layerIndex:nextLayerIndex});

            vanchartMap.components.geo = lastGeo;

            return point;
        },

        drillDown:function(dataPoint){
            if(dataPoint.drilldown){

                if(!dataPoint.geo){
                    dataPoint = this._createDrillDownWhenLoaded(dataPoint);
                }

                var vanchart = this;

                vanchart.lastIconData = vanchart.lastIconData || [];
                vanchart.lastIconData[this.layerIndex] = {
                    zoomListener:dataPoint.geo.getZoomListener(),
                    series:vanchart.series,
                    geo:vanchart.getComponent(ComponentLibrary.GEO_COMPONENT)
                };

                this._setNewGeo(dataPoint.geo, vanchart.components.geo);

                this._showVanMap(dataPoint.geo, dataPoint.drillSeries, true);
            }
        },

        drillUp:function(iconData){
            var vanchart = this;

            if(iconData.geo == vanchart.components.geo){
                return;
            }

            this._setNewGeo(iconData.geo, vanchart.components.geo);

            this._showVanMap(iconData.geo, iconData.series, false);
        },

        _showVanMap:function(geo, series, isDrillDown){
            var vanchart = this;
            vanchart.series = series;
            vanchart.components.geo = geo;
            vanchart.currentOption.series = geo.originSeries;
            vanchart.hoverPoint = null;

            Object.keys(vanchart.series).forEach(function(name){
                vanchart.series[name].forEach(function(sery){
                    var points = sery.points;
                    sery.visible = true;
                    for(var i = 0, len = points.length; i <len; i++){
                        if(points[i].color){
                            points[i].visible = true;
                        }
                    }
                });
            });

            geo.fitMapBounds();

            var drillTools = vanchart.getComponent(ComponentLibrary.DRILL_TOOLS);

            if(isDrillDown){
                var iconData = this.iconDataOfMap(series);
                if(drillTools && iconData){
                    drillTools.addIconData(iconData);
                }
                this.layerIndex++;
            }else{
                if(drillTools){
                    drillTools.deleteIconData(series);
                    //工具栏向上钻取的时候可能有两次
                    this.layerIndex = drillTools.getIconData().length - 1;
                }else{
                    this.layerIndex--;
                }
            }

            this._refreshComponents();

            this.render();
        },

        filterRender:function(){
            this.render();
        },

        //重新计算标签
        viewreset:function(){
            //缩放以后重叠的标签重新计算
            var vanchart = this;
            clearTimeout(this.labelRelaoutTimeOut);
            this.labelRelaoutTimeOut = setTimeout(function(){
                vanchart.updateLabel();
            }, 200);//避免过快的操作
        },

        calculatePlotShapes:function(){

            this.hoverPoint = null;
            this.hoverSeries = null;

            //百分比,标签,数据提示
            this._calculateTextRelated(this.series[Constants.AREA_MAP] || []);

            var bubbleSeries = this.series[Constants.BUBBLE_CHART] || [];
            var scatterSeries = this.series[Constants.SCATTER_CHART] || [];
            var pointMap = this.series[Constants.POINT_MAP] || [];
            var pointSeries = bubbleSeries.concat(scatterSeries, pointMap);

            this._calculateSeriesMinMaxValue(Constants.BUBBLE_CHART, bubbleSeries);
            
            bubbleSeries.forEach(function(sery){
                sery._calculateBubbleRadius();
            });

            this._calculateTextRelated(pointSeries);
        },

        _calculateTextRelated:function(series){

            var nameMap = {};
            var geo = this.getComponent(ComponentLibrary.GEO_COMPONENT);

            //计算百分比
            for(var i = 0, count = series.length; i < count; i++){
                var total = 0;
                var points = series[i].points.filter(function(p){return !p.isNull;});
                var isAreaMap = series[i].type == Constants.AREA_MAP;

                points.forEach(function(point){
                    total = BaseUtils.accAdd(total, Math.abs(point.getTargetValue()));
                });

                points.forEach(function(point){
                    point.percentage = Math.abs(BaseUtils.accDiv(point.getTargetValue(), total));
                    point.percentage  = isNaN(point.percentage) ? 0 : point.percentage;

                    var key = isAreaMap ? point.name : geo.getDataPointLatLng(point).join('-');

                    nameMap[key] = nameMap[key] || [];
                    nameMap[key].push(point);
                });
            }

            var map = this;
            for(var name in nameMap){
                var points = nameMap[name];
                points.forEach(function(point){
                    point.points = points;
                    //标签
                    if(point.dataLabels && point.dataLabels.enabled){
                        BaseUtils.extend(point, map.calculateMapLabel(point, point.dataLabels, point.series.type));
                    }
                });
            }
        },

        calculateMapLabel:function(point, labelInfo, chartType){

            var dataLabels = labelInfo || {};
            var formatter =  dataLabels.formatter;
            var useHtml = dataLabels.useHtml;

            var labelPosition = (chartType == Constants.SCATTER_CHART || chartType == Constants.POINT_MAP) ? Constants.OUTSIDE : Constants.INSIDE;

            var content = [];

            if(typeof formatter == 'object'){

                var label = formatter.identifier;

                if(label.indexOf(NAME) != -1){
                    var text = Formatter.format(point.name, formatter.nameFormat);
                    var style = point.series.getCategorySeriesStyle(dataLabels, labelPosition, point);
                    var dim = BaseUtils.getTextDimension(text, style, useHtml);
                    content.push({text:text, style:style, dim:dim});
                }

                var line = '';
                var hasSeries = label.indexOf(SERIES) != -1, hasValue = label.indexOf(VALUE) != -1, hasPercent = label.indexOf(PERCENT) != -1;
                var seriesLabel = Formatter.format(point.seriesName, formatter.seriesFormat);
                var valueLabel = Formatter.format(point.getTargetValue(), formatter.valueFormat);
                var percentLabel = Formatter.format(point.percentage, formatter.percentFormat);
                if(hasSeries){
                    line += seriesLabel;
                    if(hasValue || hasPercent){
                        line += ':'
                    }
                }

                if(hasValue){
                    line += valueLabel;
                    if(hasPercent){
                        line += ' '
                    }
                }

                if(hasPercent){
                    line += percentLabel;
                }

                if(line){
                    var style = point.series.getValuePercentageStyle(dataLabels, labelPosition, point);
                    var dim = BaseUtils.getTextDimension(line, style, useHtml);
                    content.push({text:line, style:style, dim:dim});
                }

            }else{
                point.series.pushCustomLabelContent(point, formatter, dataLabels, useHtml, content, labelPosition);
            }

            var labelDim = point.series.calculateTextDim(content);

            return {
                labelContent:content,
                labelDim:labelDim
            };
        },

        _createDropShadowFilter:function(defs, dx, dy, alpha, deviation){
            var dropFilter = defs.append('filter').attr('x', '-50%').attr('y', '-50%').attr('width', '200%').attr('height', '200%');
            var id = BaseUtils.stamp(dropFilter); dropFilter.attr('id', id);
            dropFilter.append('feOffset').attr('in', 'SourceAlpha').attr('dx', dx).attr('dy', dy).attr('result', 'offOut');
            dropFilter.append('feColorMatrix').attr('in', 'offOut').attr('type', 'matrix').attr('values', '0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 '+alpha+' 0').attr('result', 'matrixOut');
            dropFilter.append('feGaussianBlur').attr('in', 'matrixOut').attr('stdDeviation', deviation).attr('result', 'blurOut');
            dropFilter.append('feBlend').attr('in', 'SourceGraphic').attr('in2', 'blurOut').attr('mode', 'normal');
            return dropFilter;
        },

        renderSeries:function(){
            var geo = this.getComponent(ComponentLibrary.GEO_COMPONENT);
            var featureMap = geo.getFeatureMap(this.series);
            this._updateShape(featureMap);
            this.updateLabel(featureMap);
        },

        _updateShape:function(featureMap){
            var area = featureMap.areaFeatures, bubble = featureMap.bubbleFeatures, scatter = featureMap.scatterFeatures, image = featureMap.imageFeatures;
            var leaflet = this._leaflet;
            this._updateAreaMap(area, leaflet);
            this._updateBubbleMap(bubble, leaflet);
            this._updateScatterMap(scatter, leaflet);
            this._updateImageMap(image, leaflet);
            if(!this._dropShadow && BaseUtils.isSupportSVG()){
                this._dropShadow = this._createDropShadowFilter(d3.select(this._leaflet._renderer._container).append('defs'), 0, 1, 0.5, 2);
            }
        },

        updateLabel:function(featureMap){
            var vanchart = this, geo = vanchart.getComponent(ComponentLibrary.GEO_COMPONENT);
            var leaflet = vanchart._leaflet;

            featureMap = featureMap || geo.getFeatureMap(vanchart.series);

            var area = featureMap.areaFeatures, bubble = featureMap.bubbleFeatures, scatter = featureMap.scatterFeatures, image = featureMap.imageFeatures;

            this._fixConflictLabel(area, bubble, scatter, image);

            var moreLabelTime = vanchart.getShowMoreLabelTime();

            vanchart._invisibleNormalLabel(moreLabelTime);

            if (vanchart._moreLabelTimeOut) {
                clearTimeout(vanchart._moreLabelTimeOut);
            }

            vanchart._moreLabelTimeOut = setTimeout(function () {
                vanchart._changeDataState = false;

                vanchart._clearMoreLabels(area, bubble, scatter, image);

                vanchart._visibleNormalLabel(moreLabelTime);

                vanchart.updateNormalLabel(area, bubble, scatter, image, leaflet);
            }, moreLabelTime);

            vanchart._updateMoreLabel(area, bubble, scatter, image, moreLabelTime);
        },

        _updateMoreLabel: function (areaText, bubbleText, scatterText, imageText, moreLabelTime) {
            if(moreLabelTime <= 0){
                return;
            }
            var pointsText = areaText.concat(bubbleText, scatterText, imageText);

            var geo = this.getComponent(ComponentLibrary.GEO_COMPONENT);
            var leaflet = this._leaflet;

            pointsText.forEach(function(point){

                if(point.visible) {
                    var latlng = geo.getDataPointLatLng(point);
                    var pixels = leaflet.latLngToContainerPoint(latlng);
                    point.series._showAndExitMoreLabel(point, pixels.x, pixels.y);
                }
            });
        },

        _clearMoreLabels: function (areaText, bubbleText, scatterText, imageText) {
            var pointsText = areaText.concat(bubbleText, scatterText, imageText);

            pointsText.forEach(function(point){
                point.moreLabelG && point.moreLabelG.remove();
                point.moreLabelG = null;
            });
        },

        updateNormalLabel:function(area, bubble, scatter, image, leaflet){
            var areaText = area.filter(labelFilter), bubbleText = bubble.filter(labelFilter), scatterText = scatter.filter(labelFilter), imageText = image.filter(labelFilter);

            this._areaLabelLayer = this._areaLabelLayer || L.layerGroup().addTo(leaflet);
            this._updatePointLayerGroup(this._areaLabelLayer, L.text, areaText, null, pointKeyFunc);

            this._bubbleLabelLayer = this._bubbleLabelLayer || L.layerGroup().addTo(leaflet);
            this._updatePointLayerGroup(this._bubbleLabelLayer, L.text, bubbleText, null, pointKeyFunc);

            this._scatterLabelLayer = this._scatterLabelLayer || L.layerGroup().addTo(leaflet);
            this._updatePointLayerGroup(this._scatterLabelLayer, L.text, scatterText, null, pointKeyFunc);

            this._imageLabelLayer = this._imageLabelLayer || L.layerGroup().addTo(leaflet);
            this._updatePointLayerGroup(this._imageLabelLayer, L.text, imageText, null, pointKeyFunc);
        },

        //自动刷新,显示值变化的标签,需要先去掉常规标签
        _invisibleNormalLabel: function (moreLabelTime) {
            if(moreLabelTime == 0) {
                return;
            }

            function invisibleFunc(labelLayer) {
                labelLayer && labelLayer.getLayers().forEach(function (layer){
                    if(layer._text && layer._text.style){
                        layer._text.style.fillOpacity = 0;
                    }
                });
            }

            invisibleFunc(this._areaLabelLayer);
            invisibleFunc(this._bubbleLabelLayer);
            invisibleFunc(this._scatterLabelLayer);
            invisibleFunc(this._imageLabelLayer);

        },

        _visibleNormalLabel: function (moreLabelTime) {
            if(moreLabelTime == 0) {
                return;
            }

            function visibleFunc(labelLayer) {
                labelLayer && labelLayer.getLayers().forEach(function (layer){
                    if(layer._text && layer._text.style){
                        layer._text.style.fillOpacity = 1;
                    }
                });
            }

            visibleFunc(this._areaLabelLayer);
            visibleFunc(this._bubbleLabelLayer);
            visibleFunc(this._scatterLabelLayer);
            visibleFunc(this._imageLabelLayer);
        },

        //重新计算每个标签的位置
        _fixConflictLabel:function(areaText, bubbleText, scatterText, imageText){
            var vanchart = this, leaflet = vanchart._leaflet;
            var geo = vanchart.getComponent(ComponentLibrary.GEO_COMPONENT);

            var pointsText = areaText.concat(bubbleText, scatterText, imageText);

            pointsText = pointsText.filter(validLabelFilter);

            var manager = new BoundsManager();

            pointsText.forEach(function(point){
                if(point.dataLabels && point.feature && point.feature.properties.center){
                    var latlng = geo.getDataPointLatLng(point);
                    var pixels = leaflet.latLngToContainerPoint(latlng);
                    var labelBounds = BaseUtils.makeBounds(pixels, point.labelDim);
                    point.labelPos = labelBounds;
                    manager.addBounds(labelBounds);
                }
            });

            pointsText.forEach(function(point){
                if(point.dataLabels && ((point.feature && !point.feature.properties.center) || point.lnglat)){
                    var latlng = geo.getDataPointLatLng(point);
                    var pixels = leaflet.latLngToContainerPoint(latlng);
                    var labelBounds = BaseUtils.makeBounds(pixels, point.labelDim);
                    if(!manager.isOverlapped(labelBounds)){
                        point.labelPos = labelBounds;
                        manager.addBounds(labelBounds);
                    }else{
                        point.labelPos = null;
                    }
                }
            });
        },

        _updateAreaMap:function(area, leaflet){
            var renderer = this;
            var areaOptions = {
                style:function(feature){
                    return {
                        fillColor:feature.color,
                        fillOpacity:feature.opacity,
                        color:feature.borderColor,
                        weight:feature.borderWidth,
                        opacity:feature.borderOpacity
                    }
                },
                onEachFeature:function(feature, layer){
                    layer.on(renderer._areaMapHandler(layer))
                }
            };
            this._areaLayer = this._areaLayer || L.geoJson([], areaOptions).addTo(leaflet);
            this._updateAreaLayerGroup(this._areaLayer, area);
        },

        _updateBubbleMap:function(bubble, leaflet){
            //气泡地图
            var renderer = this;
            var bubbleOptions = {
                style:function(data){
                    return {
                        radius:data.radius,
                        fillColor:data.color,
                        fillOpacity:data.opacity,
                        weight:0,
                        stroke:false
                    }
                },
                onEachLayer:function(layer){
                    layer.on(renderer._bubbleMapHandler(layer))
                }
            };
            this._bubbleLayer = this._bubbleLayer || L.layerGroup().addTo(leaflet);
            this._updatePointLayerGroup(this._bubbleLayer, L.circleMarker, bubble, bubbleOptions);
        },

        _updateScatterMap:function(scatter, leaflet){
            //散点地图
            var renderer = this;
            var scatterOptions = {
                style:function(feature){
                    var isHollow = feature.series._isHollowMarker(feature.marker.symbol);

                    return isHollow ? {
                        fill:false,
                        stroke:true,
                        color:feature.marker.fillColor,
                        weight:2,
                        opacity:feature.opacity,
                        markerType:feature.marker.symbol,
                        radius:feature.marker.radius
                    }:
                    {
                        fill:true,
                        stroke:false,
                        fillColor:feature.marker.fillColor,
                        fillOpacity:feature.opacity,
                        markerType:feature.marker.symbol,
                        radius:feature.marker.radius
                    }
                },

                onEachLayer:function(layer){
                    layer.on(renderer._scatterMapHandler(layer))
                }
            };
            this._scatterLayer = this._scatterLayer || L.layerGroup().addTo(leaflet);
            this._updatePointLayerGroup(this._scatterLayer, L.scatterMarker, scatter, scatterOptions);
        },

        _updateImageMap:function(image, leaflet){
            //图片类型的标记点
            var renderer = this;
            var imageOptions = {
                style:function(feature){
                    return {icon:L.icon(feature.icon)}
                },

                onEachLayer:function(layer){
                    layer.on(renderer._imageMapHandler(layer))
                }
            };

            this._imageLayer = this._imageLayer || L.layerGroup().addTo(leaflet);
            this._updatePointLayerGroup(this._imageLayer, L.marker, image, imageOptions);
        },

        _updatePointLayerGroup:function(layerGroup, layerFunc, features, options){

            var layers = layerGroup.getLayers();
            var selection = this._rebindLayers(layers, features, pointKeyFunc);
            var geo = this.getComponent(ComponentLibrary.GEO_COMPONENT);

            for(var i = selection.enter.length - 1; i >= 0; i--){
                var point = selection.enter[i];
                var latlng = geo.getDataPointLatLng(point);

                var layer = layerFunc(latlng, options && options.style.call(null, point), point, this);
                options && options.onEachLayer.call(null, layer);
                layerGroup.addLayer(layer);
            }

            selection.exit.forEach(function(layer){layerGroup.removeLayer(layer);});

            layerGroup.getLayers().forEach(function(layer){
                layer.updateWithData && layer.updateWithData();
            });

        },

        _updateAreaLayerGroup:function(layerGroup, features){

            var layers = layerGroup.getLayers();
            var selection = this._rebindLayers(layers, features, areaKeyFunc);

            layerGroup.addData(selection.enter);
            selection.exit.forEach(function(layer){layerGroup.removeLayer(layer);});
            layers.forEach(function(layer){layerGroup.resetStyle(layer);});
        },

        //参考d3的selection的实现
        _rebindLayers:function(layers, dataArray, keyFunction){
            var i, n = layers.length, m = dataArray.length, enterFeatures = [], exitLayers = [];
            var nodeByKeyValue = {}, keyValues = new Array(n), keyValue, layer, data;
            for (i = -1; ++i < n; ) {
                layer = layers[i];
                keyValue = keyFunction(layer._data);
                nodeByKeyValue[keyValue] = layer;
                keyValues[i] = keyValue;
            }
            for (i = -1; ++i < m; ) {
                data = dataArray[i];
                keyValue = keyFunction(data);
                layer = nodeByKeyValue[keyValue];
                if (!layer) {
                    enterFeatures.push(data);
                }else if(layer !== true){
                    layer._data = data;
                    layer.feature = data;//兼容
                }
                nodeByKeyValue[keyValue] = true;
            }

            for (i = -1; ++i < n; ) {
                if (nodeByKeyValue[keyValues[i]] !== true) {
                    exitLayers[i] = layers[i];
                }
            }

            return {
                enter:enterFeatures,
                exit:exitLayers
            }
        },

        _areaMapHandler:function(layer){
            var vanchart = this, tooltip = vanchart.getComponent(ComponentLibrary.TOOLTIP_COMPONENT);
            return {
                click:function(e){
                    var feature = layer._data;
                    vanchart.drillDown(feature);
                    feature.onClick && feature.onClick(e.originalEvent);
                },

                mouseover:function(){
                    if(!layer._data.name){
                        return;
                    }

                    vanchart.hoverPoint = layer._data;

                    var areaLayers = vanchart._areaLayer.getLayers(), feature = layer._data;
                    for(var i = 0, len = areaLayers.length; i < len; i++){
                        if(areaLayers[i]._data.name == layer._data.name){
                            areaLayers[i].setStyle({
                                fillColor:feature.mouseOverColor,
                                weight:2,
                                'filter':'url(#' + vanchart._dropShadow + ')'
                            });
                        }
                    }
                },
                mouseout:function(){
                    tooltip.hide();
                    var areaLayers = vanchart._areaLayer.getLayers();
                    for(var i = 0, len = areaLayers.length; i < len; i++){
                        if(areaLayers[i]._data.name == layer._data.name){
                            var feature = areaLayers[i]._data;
                            areaLayers[i].setStyle({
                                fillColor:feature.color,
                                weight: feature.borderWidth,
                                'filter':''
                            });
                        }
                    }
                },

                mousemove:function(){
                    var feature = layer._data;
                    tooltip.showWithPoint(feature);
                }
            }
        },

        _bubbleMapHandler:function(layer){
            var vanchart = this, renderer = this;
            var tooltip = vanchart.getComponent(ComponentLibrary.TOOLTIP_COMPONENT);
            return {
                click:function(e){
                    var feature = layer._data;
                    vanchart.drillDown(feature);
                    feature.onClick && feature.onClick(e.originalEvent);
                },

                mouseover:function(){
                    var feature = layer._data;
                    var areaLayers = renderer._bubbleLayer.getLayers();
                    for(var i = 0, len = areaLayers.length; i < len; i++){
                        if(areaLayers[i]._data.name == layer._data.name){
                            if(BaseUtils.isSupportSVG()){
                                d3.select(areaLayers[i]._path)
                                    .style({
                                        'stroke':feature.mouseOverColor,
                                        'stroke-width':0,
                                        'stroke-opacity':0.35,
                                        'fill':feature.mouseOverColor
                                    })
                                    .interrupt(Constants.SELECT_ANIMATION).transition(Constants.SELECT_ANIMATION)
                                    .duration(200).ease('back-out').style('stroke-width', 6)
                            }else{
                                areaLayers[i].setStyle({
                                    fillColor:feature.mouseOverColor,
                                    opacity:0.35,
                                    stroke:feature.mouseOverColor,
                                    weight:6,
                                    stroke:true
                                });
                            }

                        }
                    }
                },

                mouseout:function(){
                    tooltip.hide();

                    var areaLayers = renderer._bubbleLayer.getLayers();
                    var feature = layer._data;
                    for(var i = 0, len = areaLayers.length; i < len; i++){
                        if(areaLayers[i]._data.name == layer._data.name){
                            if(BaseUtils.isSupportSVG()){
                                d3.select(areaLayers[i]._path)
                                    .style('fill', feature.color)
                                    .style('fill-opacity', feature.opacity)
                                    .interrupt(Constants.SELECT_ANIMATION)
                                    .transition(Constants.SELECT_ANIMATION);
                                d3.select(areaLayers[i]._path)
                                    .style('stroke-width', 0);
                            }else{
                                areaLayers[i].setStyle({
                                    fillColor:feature.color,
                                    fillOpacity:feature.fillColorOpacity,
                                    weight:0
                                });
                            }
                        }
                    }
                },

                mousemove:function(){
                    var feature = layer._data;
                    tooltip.showWithPoint(feature);
                }
            }
        },

        _scatterMapHandler:function(layer){
            var vanchart = this, renderer = this;
            var tooltip = vanchart.getComponent(ComponentLibrary.TOOLTIP_COMPONENT);

            return {
                click:function(e){
                    var feature = layer._data;
                    vanchart.drillDown(feature);
                    feature.onClick && feature.onClick(e.originalEvent);
                },

                mouseover:function(){
                    var feature = layer._data;
                    var markerType = feature.marker.symbol;
                    var radius =  feature.marker.radius || map.getDefaultMarkerRadius();
                    var markerHighlightColor = feature.mouseOverColor || ColorUtils.getHighLightColor(feature.marker.fillColor);
                    var isHollow = feature.series._isHollowMarker(feature.marker.symbol);

                    var areaLayers = renderer._scatterLayer.getLayers();
                    for(var i = 0, len = areaLayers.length; i < len; i++){
                        if(areaLayers[i]._data.name == layer._data.name){
                            if(BaseUtils.isSupportSVG()){
                                d3.select(areaLayers[i]._path)
                                    .style(isHollow ? 'stroke':'fill', markerHighlightColor)
                                    .interrupt(Constants.SELECT_ANIMATION)
                                    .transition(Constants.SELECT_ANIMATION)
                                    .ease('ease-out-expo')
                                    .attr('d', feature.series._getMarkerPath(markerType, radius + 2))
                            }
                        }
                    }

                },

                mouseout:function(){
                    tooltip.hide();

                    var feature = layer._data;
                    var markerType = feature.marker.symbol;
                    var radius =  feature.marker.radius || map.getDefaultMarkerRadius();
                    var areaLayers = renderer._scatterLayer.getLayers();
                    var isHollow = feature.series._isHollowMarker(feature.marker.symbol);
                    for(var i = 0, len = areaLayers.length; i < len; i++){
                        if(areaLayers[i]._data.name == layer._data.name){
                            if(BaseUtils.isSupportSVG()){
                                d3.select(areaLayers[i]._path)
                                    .interrupt(Constants.SELECT_ANIMATION)
                                    .style(isHollow ? 'stroke':'fill', feature.marker.fillColor)
                                    .attr('d', feature.series._getMarkerPath(markerType, radius));
                            }
                        }
                    }
                },

                mousemove:function(){
                    var feature = layer._data;
                    tooltip.showWithPoint(feature);
                }
            }
        },

        _imageMapHandler:function(layer){
            var vanchart = this, renderer = this;
            var tooltip = vanchart.getComponent(ComponentLibrary.TOOLTIP_COMPONENT);
            return {
                click:function(e){
                    var feature = layer._data;
                    vanchart.drillDown(feature);
                    feature.onClick && feature.onClick(e.originalEvent);
                },

                mouseover:function(){

                },

                mouseout:function(){
                    tooltip.hide();
                },

                mousemove:function(){
                    var feature = layer._data;
                    tooltip.showWithPoint(feature);
                }
            }
        }


    });

    return VanChartMap;
});
/**
 * Created by eason on 16/8/29.
 */

define('VanChartForceBubble',['require','./VanChart','./utils/BaseUtils','./ComponentLibrary','./ChartLibrary','./Constants','./utils/Formatter'],function(require){

    var VanChart = require('./VanChart');
    var BaseUtils = require('./utils/BaseUtils');
    var ComponentLibrary = require('./ComponentLibrary');
    var ChartLibrary = require('./ChartLibrary');
    var Constants = require('./Constants');
    var Formatter = require('./utils/Formatter');

    var padding = 2, clusterPadding = 4;

    var BUBBLE_UPDATE_TIME = 500;

    var VanChartForceBubble = VanChart.extend({

        vanChartType:'vanChartForceBubble',

        dealAxisZoom:function(downPos, upPos){

            this.force && this.force.stop();

            var plotBounds = this.getPlotBounds();
            var minX = Math.min(downPos[0], upPos[0]) - plotBounds.x;
            var minY = Math.min(downPos[1], upPos[1]) - plotBounds.y;

            var detX = Math.abs(downPos[0] - upPos[0]);
            var detY = Math.abs(downPos[1] - upPos[1]);

            var scale = Math.min(plotBounds.width/detX, plotBounds.height/detY);

            var wWidth = plotBounds.width / scale;
            var wHeight = plotBounds.height / scale;

            var shiftX = (plotBounds.width - wWidth)/2 - minX;
            var shiftY = (plotBounds.height - wHeight)/2 - minY;

            this.forceBubbleNodes.forEach(function(node){

                node.radius *= scale;

                var x = node.x + shiftX;
                var y = node.y + shiftY;

                x -= plotBounds.width/2;
                y -= plotBounds.height/2;

                node.x = x * scale + plotBounds.width/2 - shiftX;
                node.y = y * scale + plotBounds.height/2 - shiftY;

                if(node.labelContent && node.labelDim){
                    var radius = node.radius;
                    if((node.labelDim.width > 2 * radius) || (node.labelDim.height > 2 * radius)){
                        node.labelPos = null;
                    }else{
                        node.labelPos = {
                            x:-node.labelDim.width/2 + node.posX,
                            y:-node.labelDim.height/2 + node.posY
                        }
                    }
                }

                var point = node.originalPoint;
                point.radius = node.radius;
                point.labelPos = node.labelPos;
            });

            this.scale = scale * BaseUtils.pick(this.scale, 1);
            this.scaleRender();
        },

        orderData:function(){

        },

        refreshRestore:function(){
            this.scale = 1;

            this.reRenderSeries();
        },

        scaleRender:function(){

            for(var i = 0, len = this.forceBubbleNodes.length; i < len; i++){
                var node = this.forceBubbleNodes[i], point = node.originalPoint, series = point.series;
                var attrs = series.getAttrs(node), animation = series.animation;
                if(animation){
                    d3.select(point.graphic.node()).transition()
                        .duration(BUBBLE_UPDATE_TIME).ease('back-out')
                        .attr('transform', BaseUtils.makeTranslate(node))
                        .attr('r', attrs.r);
                }else{
                    point.graphic.attr(attrs);
                }
            }
        },

        renderSeries:function(){

            var vanchart = this, renderer = vanchart.renderer, plotBounds = this.getPlotBounds();
            var bubbleData = vanchart.series[Constants.FORCE_BUBBLE_CHART];
            var series = bubbleData[0], animation = series.animation;
            var cX = plotBounds.width/2, cY = plotBounds.height/2;

            if(!this.group){
                this.group = renderer.group().addTo(vanchart.clipSeriesGroup);
            }
            this.group.attr('transform', BaseUtils.makeTranslate(plotBounds));
            var nodes = [], visibleNodes = [], maxRadius = 0;

            bubbleData.forEach(function(sery){
                var cluster;
                sery.points.forEach(function(point){
                    var shadow = BaseUtils.extend({originalPoint:point}, point);
                    point.shadow = shadow;
                    if(point.graphic && animation){
                        var translate = d3.transform(d3.select(point.graphic.node()).attr('transform')).translate;
                        shadow.x = translate[0];
                        shadow.y = translate[1];
                    }else{
                        shadow.x = shadow.y = undefined;
                    }

                    if(!shadow.isNull){
                        nodes.push(shadow);
                    }

                    if(shadow.visible && shadow.series.visible && !shadow.isNull){
                        visibleNodes.push(shadow);
                        maxRadius = Math.max(maxRadius, point.radius);
                        cluster = cluster || shadow;
                        cluster = shadow.radius > cluster.radius ? shadow : cluster;
                    }
                });

                sery.cluster = cluster;
            });

            //每次渲染之后要的结果
            vanchart.forceBubbleNodes = visibleNodes;

            if(!animation){
                this._simulateForce();
            }

            for(var i = 0, len = nodes.length; i < len; i++){
                var node = nodes[i], visible = node.visible && node.series.visible;
                var originalPoint = node.originalPoint || node, style = series.getStyle(node), attrs = series.getAttrs(node);

                if(visible && originalPoint.graphic){//update
                    originalPoint.graphic.style(style);
                    if(animation){
                        d3.select(originalPoint.graphic.node()).datum(node)
                            .transition().duration(750).attr("r", node.radius)
                    }else{
                        originalPoint.graphic.attr(attrs);
                    }
                }else if(visible && !originalPoint.graphic){//create
                    if(animation){
                        originalPoint.graphic = renderer.circle().style(style).addTo(this.group);
                        d3.select(originalPoint.graphic.node()).datum(node)
                            .attr("r", 0).transition().duration(750).attr("r", node.radius);
                    }else{
                        originalPoint.graphic = renderer.circle(attrs).style(style).addTo(this.group);
                    }
                }else if(!visible && originalPoint.graphic){//drop
                    d3.select(originalPoint.graphic.node()).transition()
                        .duration(300).ease('back-in').attr('r', 0).remove();
                    originalPoint.graphic = null;
                }

                originalPoint.graphic && renderer.registerInteractiveTarget(originalPoint, originalPoint.graphic);
            }

            animation && this._updateWithForce();
        },

        _simulateForce:function(){
            var visibleNodes = this.forceBubbleNodes, plotBounds = this.getPlotBounds();
            var size = [plotBounds.width, plotBounds.height];

            d3.layout.pack().sort(null).size(size)
                .children(function(d) {
                    return d.values;
                })
                .value(function(d) {
                    return d.radius * d.radius;
                })
                .nodes({values: d3.nest()
                    .key(function(d) { return d.category + d.seriesName; })
                    .entries(visibleNodes)});


            //模拟集聚的过程
            var start = 0.1, end = 0.005;
            var padding = 2, clusterPadding = 2;
            var paddingAlpha = 0.5;
            var gravity = 0.02;
            var friction = 0.9;

            //set px,py
            visibleNodes.forEach(function(point){
                point.px = point.x;
                point.py = point.y;
            });

            for(var alpha = start; alpha >= end; alpha -= (alpha > 0.07 ? 0.001 : 0.0005)){

                var n = visibleNodes.length, i, o, k, x, y;

                if (k = alpha * gravity) {
                    x = size[0] / 2;
                    y = size[1] / 2;
                    i = -1;
                    if (k) while (++i < n) {
                        o = visibleNodes[i];
                        o.x += (x - o.x) * k;
                        o.y += (y - o.y) * k;
                    }
                }
                i = -1;
                while (++i < n) {
                    o = visibleNodes[i];
                    o.x -= (o.px - (o.px = o.x)) * friction;
                    o.y -= (o.py - (o.py = o.y)) * friction;
                }

                visibleNodes.forEach(function(d){
                    //集聚
                    var cluster = d.series.cluster;

                    if (cluster && cluster != d){
                        var x = d.x - cluster.x,
                            y = d.y - cluster.y,
                            l = Math.sqrt(x * x + y * y),
                            r = d.radius + cluster.radius;
                        if (l != r) {
                            l = (l - r) / l * alpha;
                            d.x -= x *= l;
                            d.y -= y *= l;
                            cluster.x += x;
                            cluster.y += y;
                        }
                    }});

                for(var i = 0; i < n; i++){
                    var d = visibleNodes[i];

                    for(var j = 0; j < n; j++){
                        var point = visibleNodes[j];

                        if (point !== d) {
                            var x = d.x - point.x,
                                y = d.y - point.y,
                                l = Math.sqrt(x * x + y * y),
                                r = d.radius + point.radius + (d.series.cluster === point.series.cluster ? padding : clusterPadding);
                            if (l < r) {
                                l = (l - r) / l * paddingAlpha;
                                d.x -= x *= l;
                                d.y -= y *= l;
                                point.x += x;
                                point.y += y;
                            }
                        }
                    }
                }
            }
        },

        _updateWithForce:function(maxRadius){

            var vanchart = this, visibleNodes = vanchart.forceBubbleNodes, plotBounds = vanchart.getPlotBounds();

            this.force && this.force.stop();
            this.force = d3.layout.force().nodes(visibleNodes)
                .size([plotBounds.width, plotBounds.height])
                .gravity(.05).charge(0).on("tick", tick)
                .on('end', function(){

                }).start();


            var bubbleS = d3.select(this.group.node()).selectAll('circle').filter(function(node){
                d3.select(this).call(vanchart.force.drag)
                var point = node.originalPoint;
                return point.visible && point.series.visible;
            });

            function tick(e) {
                bubbleS
                    .each(cluster(10 * e.alpha * e.alpha))
                    .each(collide(.5));

                bubbleS.each(function(){
                    d3.select(this).attr('transform', function(d){

                        if(d.originalPoint.textGraphic){
                            var x = -d.labelDim.width/2 + d.x;
                            var y = -d.labelDim.height/2 + d.y;
                            d.originalPoint.textGraphic.attr('transform', BaseUtils.makeTranslate([x, y]))
                        };

                        return BaseUtils.makeTranslate([d.x, d.y]);
                    })
                });
            }

            // Move d to be adjacent to the cluster node.
            function cluster(alpha) {
                return function(d) {
                    var cluster = d.series.cluster;
                    if (!cluster || cluster === d) return;
                    var x = d.x - cluster.x,
                        y = d.y - cluster.y,
                        l = Math.sqrt(x * x + y * y),
                        r = d.radius + cluster.radius;
                    if (l != r) {
                        l = (l - r) / l * alpha;
                        d.x -= x *= l;
                        d.y -= y *= l;
                        cluster.x += x;
                        cluster.y += y;
                    }
                };
            }

            // Resolves collisions between d and all other circles.
            function collide(alpha) {
                var quadtree = d3.geom.quadtree(visibleNodes);
                return function(d) {
                    var r = d.radius + maxRadius + Math.max(padding, clusterPadding),
                        nx1 = d.x - r,
                        nx2 = d.x + r,
                        ny1 = d.y - r,
                        ny2 = d.y + r;
                    quadtree.visit(function(quad, x1, y1, x2, y2) {
                        if (quad.point && (quad.point !== d)) {
                            var x = d.x - quad.point.x,
                                y = d.y - quad.point.y,
                                l = Math.sqrt(x * x + y * y),
                                r = d.radius + quad.point.radius + (d.series.cluster === quad.point.series.cluster ? padding : clusterPadding);
                            if (l < r) {
                                l = (l - r) / l * alpha;
                                d.x -= x *= l;
                                d.y -= y *= l;
                                quad.point.x += x;
                                quad.point.y += y;
                            }
                        }
                        return x1 > nx2 || x2 < nx1 || y1 > ny2 || y2 < ny1;
                    });
                };
            }
        }

    });

    return VanChartForceBubble;
});
/**
 * Created by Mitisky on 16/7/28.
 */
define('utils/LoadingManager',[],function(){
    var loadingMap = {};

    function startLoading(dom, id) {
        id = id || 'loading-div-id';
        id = id + ' loading-div-id';
        if(loadingMap[id] || document.getElementById(id)){
            return;
        }

        var background_div = document.createElement('div');
        var inner_div = document.createElement('div');

        background_div.id = id;
        background_div.style.backgroundColor = 'white';
        background_div.style.opacity = 0.75;
        background_div.style.position = 'absolute';
        background_div.style.width = '100%';
        background_div.style.height = '100%';
        background_div.style.left = 0;
        background_div.style.top = 0;
        background_div.style.zIndex = 9999;

        if(inner_div.style.animation != undefined || inner_div.style.webkitAnimation != undefined) {
            inner_div.style.left = '50%';
            inner_div.style.top = '50%';
            inner_div.className = 'loader-inner ball-scale-ripple-multiple';
            inner_div.innerHTML = '<div></div><div></div><div></div>';
        }

        background_div.appendChild(inner_div);
        dom.appendChild(background_div);
        loadingMap[id] = background_div;
    }

    function endLoading(dom, id) {
        id = id || 'loading-div-id';
        id = id + ' loading-div-id';

        if(loadingMap[id]) {
            dom.removeChild(loadingMap[id]);
            loadingMap[id] = null;
        } else {
            var loadingDiv = document.getElementById(id);
            if(loadingDiv) {
                dom.removeChild(loadingDiv);
            }
        }
    }

    return {
        startLoading:startLoading,
        endLoading:endLoading
    };
});

/**
 * Created by eason on 15/5/15.
 * 管里当前产生的所有
 */
define('VanCharts',['require','./utils/BaseUtils','./Constants','./VanChart','./VanChartMap','./VanChartForceBubble','./utils/LoadingManager'],function(require){

    var BaseUtils = require('./utils/BaseUtils');
    var Constants = require('./Constants');
    var VanChart = require('./VanChart');
    var VanChartMap = require('./VanChartMap');
    var VanChartForceBubble = require('./VanChartForceBubble');
    var LoadingManager = require('./utils/LoadingManager');

    var _baseIndex = 0;

    var _instances = Object.create(null);

    function init(dom){
        BaseUtils.initConst();
        var instanceKey = dom.getAttribute(Constants.INSTANCES_KEY);
        if(!instanceKey){
            instanceKey = Constants.INSTANCES_KEY + _baseIndex++;
            dom.setAttribute(Constants.INSTANCES_KEY, instanceKey);
        }

        if(_instances[instanceKey]){
            //key对应的实例已经存在的话先删掉
            var svgRoot = _instances[instanceKey].svgRoot;
            if(svgRoot){
                svgRoot.remove();
            }
        }else{
            var vanCharts = new VanCharts(dom);
            _instances[instanceKey] = vanCharts;
        }

        return _instances[instanceKey];
    }

    function VanCharts(dom){
        this.dom = dom;
        this.charts = [];
    }

    VanCharts.prototype = {
        constructor:VanCharts,

        setOptions:function(options){
            window.console && console.log(JSON.stringify(options));
            if(!BaseUtils.isArray(options)){
                options = [options];
            }
            this.options = options;

            //最终生成的坐标轴数应该和新的option一样
            var len = options.length;

            for(var index = len; index < this.charts.length; index++){
                this.charts[index].remove();
                this.charts[index] = null;
            }

            this.charts.length = len;

            for(var index = 0; index < len; index++){

                var option = this.options[index], chart = this.charts[index], ChartClass, chart;

                if(option.geo){
                    ChartClass = VanChartMap;
                }else if(option.chartType == Constants.FORCE_BUBBLE_CHART){
                    ChartClass = VanChartForceBubble;
                }else{
                    ChartClass = VanChart;
                }

                if(chart && chart.vanChartType != ChartClass.prototype.vanChartType){
                    chart.remove();
                    chart = null;
                }

                if(chart){
                    chart.setChangeDataState();
                    chart.refresh(option);
                }else{
                    this.charts[index] = new ChartClass(option, this.dom, this)
                }
            }
        },

        setData:function(options){
            this.setOptions(options);
        },

        resize:function(){
            this.charts.forEach(function(chart){
                chart.resize();
            });
        },

        clear:function(){
            for(var i = 0, len = this.charts.length; i < len; i++){
                this.charts[i].remove();
                this.charts[i] = null;
            }
        },

        startLoading: function () {
            LoadingManager.startLoading(this.dom, this.dom.getAttribute(Constants.INSTANCES_KEY));
        },

        endLoading: function () {
            LoadingManager.endLoading(this.dom, this.dom.getAttribute(Constants.INSTANCES_KEY));
        }
    };

    return {
        init:init
    };
});
/**
 * Created by eason on 15/6/24.
 */
//
//Copyright (c) 2014 Ga?tan Renaudeau
//
//Permission is hereby granted, free of charge, to any person
//obtaining a copy of this software and associated documentation
//files (the "Software"), to deal in the Software without
//restriction, including without limitation the rights to use,
//    copy, modify, merge, publish, distribute, sublicense, and/or sell
//copies of the Software, and to permit persons to whom the
//Software is furnished to do so, subject to the following
//conditions:
//
//    The above copyright notice and this permission notice shall be
//included in all copies or substantial portions of the Software.
//
//    THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
//    EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES
//OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
//NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT
//HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY,
//    WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
//FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR
//OTHER DEALINGS IN THE SOFTWARE.

define('utils/BezierEasing',[],function(){
    var global = this;

    // These values are established by empiricism with tests (tradeoff: performance VS precision)
    var NEWTON_ITERATIONS = 4;
    var NEWTON_MIN_SLOPE = 0.001;
    var SUBDIVISION_PRECISION = 0.0000001;
    var SUBDIVISION_MAX_ITERATIONS = 10;

    var kSplineTableSize = 11;
    var kSampleStepSize = 1.0 / (kSplineTableSize - 1.0);

    var float32ArraySupported = 'Float32Array' in global;

    function A (aA1, aA2) { return 1.0 - 3.0 * aA2 + 3.0 * aA1; }
    function B (aA1, aA2) { return 3.0 * aA2 - 6.0 * aA1; }
    function C (aA1)      { return 3.0 * aA1; }

    // Returns x(t) given t, x1, and x2, or y(t) given t, y1, and y2.
    function calcBezier (aT, aA1, aA2) {
        return ((A(aA1, aA2)*aT + B(aA1, aA2))*aT + C(aA1))*aT;
    }

    // Returns dx/dt given t, x1, and x2, or dy/dt given t, y1, and y2.
    function getSlope (aT, aA1, aA2) {
        return 3.0 * A(aA1, aA2)*aT*aT + 2.0 * B(aA1, aA2) * aT + C(aA1);
    }

    function binarySubdivide (aX, aA, aB, mX1, mX2) {
        var currentX, currentT, i = 0;
        do {
            currentT = aA + (aB - aA) / 2.0;
            currentX = calcBezier(currentT, mX1, mX2) - aX;
            if (currentX > 0.0) {
                aB = currentT;
            } else {
                aA = currentT;
            }
        } while (Math.abs(currentX) > SUBDIVISION_PRECISION && ++i < SUBDIVISION_MAX_ITERATIONS);
        return currentT;
    }

    function BezierEasing (mX1, mY1, mX2, mY2) {
        // Validate arguments
        if (arguments.length !== 4) {
            throw new Error("BezierEasing requires 4 arguments.");
        }
        for (var i=0; i<4; ++i) {
            if (typeof arguments[i] !== "number" || isNaN(arguments[i]) || !isFinite(arguments[i])) {
                throw new Error("BezierEasing arguments should be integers.");
            }
        }
        if (mX1 < 0 || mX1 > 1 || mX2 < 0 || mX2 > 1) {
            throw new Error("BezierEasing x values must be in [0, 1] range.");
        }

        var mSampleValues = float32ArraySupported ? new Float32Array(kSplineTableSize) : new Array(kSplineTableSize);

        function newtonRaphsonIterate (aX, aGuessT) {
            for (var i = 0; i < NEWTON_ITERATIONS; ++i) {
                var currentSlope = getSlope(aGuessT, mX1, mX2);
                if (currentSlope === 0.0) return aGuessT;
                var currentX = calcBezier(aGuessT, mX1, mX2) - aX;
                aGuessT -= currentX / currentSlope;
            }
            return aGuessT;
        }

        function calcSampleValues () {
            for (var i = 0; i < kSplineTableSize; ++i) {
                mSampleValues[i] = calcBezier(i * kSampleStepSize, mX1, mX2);
            }
        }

        function getTForX (aX) {
            var intervalStart = 0.0;
            var currentSample = 1;
            var lastSample = kSplineTableSize - 1;

            for (; currentSample != lastSample && mSampleValues[currentSample] <= aX; ++currentSample) {
                intervalStart += kSampleStepSize;
            }
            --currentSample;

            // Interpolate to provide an initial guess for t
            var dist = (aX - mSampleValues[currentSample]) / (mSampleValues[currentSample+1] - mSampleValues[currentSample]);
            var guessForT = intervalStart + dist * kSampleStepSize;

            var initialSlope = getSlope(guessForT, mX1, mX2);
            if (initialSlope >= NEWTON_MIN_SLOPE) {
                return newtonRaphsonIterate(aX, guessForT);
            } else if (initialSlope === 0.0) {
                return guessForT;
            } else {
                return binarySubdivide(aX, intervalStart, intervalStart + kSampleStepSize, mX1, mX2);
            }
        }

        var _precomputed = false;
        function precompute() {
            _precomputed = true;
            if (mX1 != mY1 || mX2 != mY2)
                calcSampleValues();
        }

        var f = function (aX) {
            if (!_precomputed) precompute();
            if (mX1 === mY1 && mX2 === mY2) return aX; // linear
            // Because JavaScript number are imprecise, we should guarantee the extremes are right.
            if (aX === 0) return 0;
            if (1 - aX  < 0.001) return 1;
            return calcBezier(getTForX(aX), mY1, mY2);
        };

        f.getControlPoints = function() { return [{ x: mX1, y: mY1 }, { x: mX2, y: mY2 }]; };

        var args = [mX1, mY1, mX2, mY2];
        var str = "BezierEasing("+args+")";
        f.toString = function () { return str; };

        //var css = "cubic-bezier("+args+")";
        //f.toCSS = function () {?return css; };

        return f;
    }

    // CSS mapping
    BezierEasing.css = {
        "ease":        BezierEasing(0.25, 0.1, 0.25, 1.0),
        "linear":      BezierEasing(0.00, 0.0, 1.00, 1.0),
        "ease-in":     BezierEasing(0.42, 0.0, 1.00, 1.0),
        "ease-out":    BezierEasing(0.00, 0.0, 0.58, 1.0),
        "ease-in-out": BezierEasing(0.42, 0.0, 0.58, 1.0),
        "swing":       BezierEasing(0.02, 0.01,0.47, 1.0),
        "ease-in-quart":BezierEasing(0.895, 0.03, 0.685, 0.22),
        "ease-out-back":BezierEasing(0.175, 0.885, 0.32, 1.275)
    };

    return BezierEasing;
});
/**
 * Created by eason on 16/2/19.
 * 数据点的抽象
 */
define('chart/Point',['require','../utils/QueryUtils','../utils/BaseUtils','../utils/ColorUtils','../utils/Formatter','../Constants','../ComponentLibrary','../dom/Evented'],function(require){

    var QueryUtils = require('../utils/QueryUtils');
    var BaseUtils = require('../utils/BaseUtils');
    var ColorUtils = require('../utils/ColorUtils');
    var Formatter = require('../utils/Formatter');
    var Constants = require('../Constants');
    var ComponentLibrary = require('../ComponentLibrary');

    var Evented = require('../dom/Evented');

    var CATEGORY = 'CATEGORY';
    var SERIES = 'SERIES';
    var VALUE = 'VALUE';
    var PERCENT = 'PERCENT';
    var NAME = 'NAME';

    var Point = Evented.extend({

        initialize:function(options, series){

            this.series = series;

            this.refresh(options || {});
        },

        refresh:function(options){
            this.options = options;
            var queryList = this._getQueryList(), series = this.series, vanchart = series.vanchart;
            var category = this.series.type == Constants.BAR_CHART ? options.y : options.x;
            var seriesName = this.series.name;
            var isSeriesAccumulated = this.series.vanchart.isSeriesAccumulated(this.series.type);

            var borderColor = QueryUtils.queryList(queryList, 'borderColor');
            var borderOpacity = QueryUtils.queryList(queryList, 'borderOpacity');
            if(borderColor) {
                var hexAlpha = ColorUtils.getStandardColorAndOpacity(borderColor, borderOpacity);
                borderColor = hexAlpha.hex;
                borderOpacity = hexAlpha.alpha;
            }

            var lnglat = QueryUtils.queryList(queryList, 'lnglat');

            BaseUtils.extend(this, {

                //这部分属性的指定存在不确定性
                x:options.x,
                y:options.y,
                size:options.size,
                value:options[this.series.getTargetKey()],
                category:isSeriesAccumulated ? seriesName : category,
                seriesName:isSeriesAccumulated ? category : seriesName,
                name: options.name,

                //暂时只有地图用了这个属性
                className:options.name + seriesName + (lnglat || []).join('-'),
                
                visible : QueryUtils.queryList(queryList, 'visible') || true,
                hyperlink:QueryUtils.queryList(queryList, 'hyperlink'),
                jsonHyperlink:QueryUtils.queryList(queryList, 'jsonHyperlink'),
                click:QueryUtils.queryList(queryList, 'click'),
                drilldown:QueryUtils.queryList(queryList, 'drilldown'),

                shadow: QueryUtils.queryList(queryList, 'shadow'),
                displayNegative: QueryUtils.queryList(queryList, 'displayNegative'),
                maxSize: options.maxSize,
                minSize: options.minSize,
                sizeBy: QueryUtils.queryList(queryList, 'sizeBy'),
                lnglat:lnglat,

                borderWidth:QueryUtils.queryList(queryList, 'borderWidth'),
                borderRadius:QueryUtils.queryList(queryList, 'borderRadius'),
                borderColor:borderColor,
                borderOpacity:borderOpacity,

                image:QueryUtils.queryList(queryList, 'image'),
                imageWidth:QueryUtils.queryList(queryList, 'imageWidth'),
                imageHeight:QueryUtils.queryList(queryList, 'imageHeight'),

                dataLabels:QueryUtils.queryList(queryList, 'dataLabels'),
                tooltip:QueryUtils.queryList(queryList.concat([vanchart.currentOption]), 'tooltip'),
                style:QueryUtils.queryList(queryList, 'style') || vanchart.currentOption.style
            });

            if(series.isNullValue){
                this.isNull = series.isNullValue(this);
            } else {
                //只有'-'才表示空
                var targetValue = this[series.getTargetKey()];
                this.isNull = (targetValue == '-' || BaseUtils.hasNotDefined(targetValue));
            }

            // color problems
            // delay tree series chart's color init
            if (!vanchart.isTreeSeries(series.type)) {

                var colors = this._getColorAndMarkerColor(series, vanchart, QueryUtils.queryList(queryList, 'opacity'));
                var marker = BaseUtils.clone(QueryUtils.queryList(queryList, 'marker'));

                if(BaseUtils.hasDefined(marker)) {
                    marker.fillColor = colors.markerColor;
                    marker.fillColorOpacity = colors.markerOpacity;
                    marker.radius = isNaN(marker.radius) ? 4.5 : marker.radius;
                    marker.symbol = marker.symbol || (series.marker && series.marker.symbol) || '';
                }

                var color = colors.color;
                var mouseOverColor = QueryUtils.queryList(queryList, 'mouseOverColor');
                var clickColor, clickOpacity;
                
                if(BaseUtils.hasNotDefined(color)){//不在范围图例之内
                    this.visible = false;
                } else {
                    mouseOverColor = mouseOverColor || ColorUtils.getHighLightColor(color);
                    clickColor = ColorUtils.getClickColor(color);
                    clickOpacity = colors.opacity * 0.95;
                }

                BaseUtils.extend(this, {
                    marker:marker,
                    mouseOverColor:mouseOverColor,

                    clickColor:clickColor,
                    clickOpacity:clickOpacity,

                    color: color,
                    opacity: colors.opacity
                });
            }

            series._refreshPoint && series._refreshPoint(this);
        },

        //点的颜色：colors，范围图例，系列条件属性配色，点条件属性配色
        //标记点的颜色取的顺序：colors配色、plotOptions的标记点的颜色、范围图例、条件属性系列配色、条件属性系列标记点颜色、条件属性数据点的配色、条件属性数据点的标记点的配色
        _getColorAndMarkerColor: function (series, vanchart, opacity) {
            var _opacity = opacity, _markerOpacity = opacity;

            var colorKey = vanchart.isSeriesAccumulated(series.type) ?
                (this.options.x || this.options.name) : series.name;

            //默认配色
            var _color = vanchart.getDefaultSeriesColor(colorKey);
            var _markerColor = _color;
            var plotOptions = vanchart.currentOption.plotOptions, _options = plotOptions[series.type];
            var plotOptionsMarker = (_options && _options.marker) || plotOptions.marker;
            if(BaseUtils.hasDefined(plotOptionsMarker)){
                _markerColor = plotOptionsMarker.fillColor || _markerColor;
            }

            //空值颜色
            if(series.type == Constants.AREA_MAP && this.isNull) {
                _color = plotOptions.color;
            }

            //范围图例
            var rangeLegend = vanchart.getComponent(ComponentLibrary.RANGE_LEGEND_COMPONENT);
            if (rangeLegend) {
                _color = rangeLegend.getColorWithSize(this[series.getTargetKey()]);
                _markerColor = _color;
            }

            //系列条件属性配色
            _color = series.options.color || _color;
            _markerColor = series.options.color || _markerColor;
            var seriesMarker = series.options.marker;
            if(BaseUtils.hasDefined(seriesMarker)) {
                _markerColor = seriesMarker.fillColor || _markerColor;
            }

            //点条件属性配色
            _color = this.options.color || _color;
            _markerColor = this.options.color || _markerColor;
            var pointMarker = this.options.marker;
            if(BaseUtils.hasDefined(pointMarker)) {
                _markerColor = pointMarker.fillColor || _markerColor;
            }

            //负气泡、bands等特殊的。
            if(series._refreshPointColor) {
                _color = series._refreshPointColor(this, _color);
            }

            if(BaseUtils.hasDefined(_color)){
                var hexAlpha = ColorUtils.getStandardColorAndOpacity(_color, opacity);
                _color = hexAlpha.hex;
                _opacity = hexAlpha.alpha;
            }

            if(BaseUtils.hasDefined(_markerColor)){
                var hexAlpha = ColorUtils.getStandardColorAndOpacity(_markerColor, opacity);
                _markerColor = hexAlpha.hex;
                _markerOpacity = hexAlpha.alpha;
            }

            return{
                color:_color,
                opacity:_opacity,
                markerColor:_markerColor,
                markerOpacity:_markerOpacity
            }
        },

        getTargetValue:function(){
            //兼容值可能是字符串的情况
            var value = this[this.series.getTargetKey()];
            if(!isNaN(+value)){
                value = +value;
            }
            return this.isNull ? 0 : value;
        },

        remove:function(){
            this.graphic && this.graphic.remove();
            this.graphic = null;
            this.textGraphic && this.textGraphic.remove();
            this.textGraphic = null;
        },

        _getQueryList:function(){
            return [this.options].concat(this.series._getQueryList());
        },

        //如果有图形特殊，就拿到series里面判断
        _hasEvents: function (point) {
            return point && point.visible && !point.isNull;
        },

        _onPointMouseOver: function (ev) {

            var point = this, series = this.series, vanchart = series.vanchart;
            var hoverPoint = vanchart.hoverPoint, hoverSeries = vanchart.hoverSeries;

            if (hoverPoint === point || !point._hasEvents(point)) {
                return;
            }

            if (hoverPoint) {
                hoverPoint._onPointMouseOut.call(hoverPoint, ev);
            }

            if (point.tooltip && point.tooltip.shared && point.points && point.points.length) {
                var max = point.points
                    .filter(point._hasEvents)
                    .filter(function (p) { return p.tooltip && p.tooltip.shared })
                    .reduce(function (prev, curr) {
                        curr.series.onPointMouseOver.call(curr, ev);
                        if (!prev) {
                            return curr;
                        }
                        return (prev.getTargetValue() > curr.getTargetValue()) ? prev : curr;
                    }, 0);
                series.vanchart.showTooltip(max, ev);
                vanchart.hoverSeries = max.series;
                vanchart.hoverPoint = max;
            } else {
                series.onPointMouseOver.call(point, ev);
                series.vanchart.showTooltip(point, ev);
                vanchart.hoverSeries = point.series;
                vanchart.hoverPoint = point;
            }

            if(hoverSeries != point.series){
                hoverSeries && hoverSeries.fire('seriesUnChosen', ev);
                point.series.fire('mouseover', ev);
            }
        },

        _onPointMouseOut: function (ev) {
            var point = this;
            var series = this.series;

            if(!point._hasEvents(point)){
                return;
            }

            if (point.tooltip && point.tooltip.shared && point.points && point.points.length) {
                point.points.map(function (point) {
                    if(point.graphic) {
                        point.series.onPointMouseOut.call(point, ev);
                    }
                });
            } else {
                series.onPointMouseOut.call(point, ev);
            }

            series.vanchart.hideTooltip();
        },

        _onPointTap: function (ev) {

            var point = this, series = this.series;

            if(!point._hasEvents(point)){
                return;
            }

            series.onPointTap.call(point, ev);

            //触发超链
            point.onClick(ev.srcEvent);

            //移动端的时候触发选中效果
            if(BaseUtils.hasTouch()){
                point.fire('mouseover', ev);
            }
        },

        _onPointPress:function(ev){
            var point = this, series = this.series, vanchart = series.vanchart;
            var hoverPoint = vanchart.hoverPoint;

            if(hoverPoint){
                series.onPointPress.call(point, ev);
            }
        },

        _onPointPressUp:function(ev){
            var point = this, series = this.series, vanchart = series.vanchart;
            var hoverPoint = vanchart.hoverPoint;

            if(hoverPoint){
                series.onPointPressUp.call(point, ev);
            }
        },

        onClick:function(event){
            var point = this;
            if(point.click){
                point.click.call(point, event);
            }else if(point.hyperlink){
                event = event.touches ?  (event.touches.length ? event.touches.item(0) : event.changedTouches[0]) : event;
                var hyperlink = point.hyperlink;
                if(hyperlink && window.FR){
                    FR.doHyperlink(event, (new Function("return " + hyperlink))(), true);
                }
            }
        },

        getEvents: function(){
            return this.series.pointEvents ? this.series.pointEvents() :
            {
                'mouseover':this._onPointMouseOver,
                'mouseout':this._onPointMouseOut,
                'mousemove':this.series.onPointMouseMove,
                'tap':this._onPointTap,
                'press':this._onPointPress,
                'pressup':this._onPointPressUp
            }
        }

    });

    return Point;
});

/**
 * Created by eason on 16/6/1.
 */

define('vector/CanvasRenderer',['require','./Renderer','../Constants'],function(require){

    var Renderer = require('./Renderer');
    var Constants = require('../Constants');

    var Canvas = Renderer.extend({

        _initContainerDom:function(dom, vanchart){
            var plotBounds = vanchart.getPlotBounds();
            this.width = plotBounds.width;
            this.height = plotBounds.height;

            this.dom = this._createCanvas(dom, plotBounds);
            this.ctx = this.dom.getContext("2d");
        },

        style:function(){

        },

        _createCanvas:function(dom, plotBounds){

            var canvas = document.createElement('canvas');
            var width = plotBounds.width, height = plotBounds.height;

            canvas.style.position = 'absolute';
            canvas.style.left = plotBounds.x + 'px';
            canvas.style.top = plotBounds.y + 'px';
            canvas.style.width = width + 'px';
            canvas.style.height = height + 'px';
            canvas.width = width;
            canvas.height = height;

            canvas.onselectstart = function(){return false};
            canvas.style['-webkit-user-select'] = 'none';
            canvas.style['user-select'] = 'none';
            canvas.style['-webkit-touch-callout'] = 'none';

            dom.appendChild(canvas);

            //excanvas
            window.vmlCanvasManager && vmlCanvasManager.initElement(canvas);

            return canvas;
        },

        clearAll:function(){
            this.ctx.clearRect(0, 0, this.width, this.height);
        },

        addBubbleSeries:function(series){
            var ctx = this.ctx;
            ctx.save();

            for(var i = 0, len = series.points.length; i < len; i++){
                var point = series.points[i];

                if(point.visible){

                    ctx.fillStyle = point.color;
                    ctx.globalAlpha = point.opacity;

                    ctx.beginPath();
                    ctx.arc(point.posX, point.posY, point.radius, 0, 2 * Math.PI);
                    ctx.fill();
                }
            }

            ctx.restore();
        },

        addScatterSeries:function(series){
            var ctx = this.ctx;
            ctx.save();
            for(var i = 0, len = series.points.length; i < len; i++){
                var point = series.points[i];
                if(point.visible){
                    var markerType = point.marker.symbol;
                    var radius = isNaN(point.marker.radius) ? 4.5 : point.marker.radius;
                    var color = point.marker.fillColor || point.color;

                    ctx.translate(point.posX, point.posY);
                    ctx.fillStyle = color;
                    ctx.strokeStyle = color;
                    ctx.globalAlpha = point.opacity;

                    this._drawMarker(ctx, markerType, radius);

                    ctx.translate(-point.posX, -point.posY);
                }
            }
            ctx.restore();
        },

        addSeries:function(series){
            if(series.visible){
                series.type == Constants.SCATTER_CHART ?
                    this.addScatterSeries(series) : this.addBubbleSeries(series);
            }

        },

        _drawMarker:function(ctx, markerType, R){

            if(markerType.indexOf(Constants.CIRCLE) != -1){

                ctx.beginPath();
                ctx.arc(0, 0, R, 0, 2 * Math.PI);

            }else if(markerType.indexOf(Constants.SQUARE) != -1){

                ctx.beginPath();
                ctx.moveTo(-R, -R);
                ctx.lineTo(R, -R);
                ctx.lineTo(R, R);
                ctx.lineTo(-R, R);
                ctx.closePath();

            }else if(markerType.indexOf(Constants.DIAMOND) != -1){

                R = R * 2 / Math.sqrt(2);
                ctx.beginPath();
                ctx.moveTo(-R, 0);
                ctx.lineTo(0, -R);
                ctx.lineTo(R, 0);
                ctx.lineTo(0, R);
                ctx.closePath();

            }else if(markerType.indexOf(Constants.TRIANGLE) != -1){

                ctx.beginPath();
                ctx.moveTo(-R, R/Math.sqrt(3));
                ctx.lineTo(0, -(2 * Math.sqrt(3) / 3) * R);
                ctx.lineTo(R, R/Math.sqrt(3));
                ctx.closePath();

            }else{
                ctx.beginPath();
                ctx.arc(0, 0, R, 0, 2 * Math.PI);
            }
            if(markerType.indexOf('hollow') == -1){
                //满填充
                ctx.fill();
            }else{
                ctx.fillStyle = 'white';
                ctx.lineWidth = 2;

                ctx.fill();
                ctx.stroke();
            }
        }
    });

    return Canvas;
});
/**
 * Created by eason on 16/2/19.
 * 系列的抽象
 */
define('chart/Series',['require','../utils/BaseUtils','../utils/QueryUtils','../utils/ColorUtils','../Constants','./Point','../dom/Evented','../utils/Formatter','../utils/BezierEasing','../ComponentLibrary','../vector/CanvasRenderer'],function(require){

    var BaseUtils = require('../utils/BaseUtils');
    var QueryUtils = require('../utils/QueryUtils');
    var ColorUtils = require('../utils/ColorUtils');
    var Constants = require('../Constants');
    var Point = require('./Point');
    var Evented = require('../dom/Evented');
    var Formatter = require('../utils/Formatter');
    var BezierEasing = require('../utils/BezierEasing');
    var ComponentLibrary = require('../ComponentLibrary');
    var CanvasRenderer = require('../vector/CanvasRenderer');

    var SERIES = '{SERIES}';
    var X = '{X}';
    var Y = '{Y}';
    var SIZE = '{SIZE}';

    var NAME = '{NAME}';
    var CATEGORY = '{CATEGORY}';
    var VALUE = '{VALUE}';
    var PERCENT = '{PERCENT}';

    var LABEL_GAP = 2;

    var INIT_MORE_LABEL_ANIMATION_TIME = 250;
    var KEEP_MORE_LABEL_ANIMATION_TIME = 500;
    var EXIT_MORE_LABEL_ANIMATION_TIME = 250;
    var DECREASE = [0.9, 0.85, 0.8, 0.75, 0.7, 0.65, 0.6, 0.55, 0.5];
    var RIGHT_TOP = 'right-top';
    var RIGHT_BOTTOM = 'right-bottom';
    var LEFT_TOP = 'left-top';
    var LEFT_BOTTOM = 'left-bottom';
    var CIRCLE = 2 * Math.PI;
    var STEP = Math.PI / 180;

    var ANIMATION_TIME = 600;
    var EASE_TYPE = 'quad-out';

    var Series = Evented.extend({

        initialize:function(options, vanchart, index){

            this.vanchart = vanchart;

            this.points = [];

            this.refresh(options, index);
        },

        refresh:function(options, index){
            this.options = options;

            var vanchart = this.vanchart;
            var type = options.type || vanchart.currentOption.chartType;

            var name = BaseUtils.pick(options.name, 'Series' + type + index);

            var queryList = this._getQueryList(type);

            var visible = QueryUtils.queryList(queryList, 'visible');

            if (!vanchart.isSeriesAccumulated(type)) {

                var color = this.options.color || vanchart.getDefaultSeriesColor(name);
                var opacity = QueryUtils.queryList(queryList, 'opacity');
                if (BaseUtils.hasDefined(color)) {
                    var hexAlpha = ColorUtils.getStandardColorAndOpacity(color, opacity);
                    color = hexAlpha.hex;
                    opacity = hexAlpha.alpha;
                }

                var fillColor = QueryUtils.queryList(queryList, 'fillColor');
                fillColor = fillColor == true ? color : fillColor;
                var fillColorOpacity = QueryUtils.queryList(queryList, 'fillColorOpacity');
                fillColorOpacity = !isNaN(fillColorOpacity) ? fillColorOpacity : this._getDefaultFillColorOpacity();
                if (fillColor) {//false
                    var hexAlpha = ColorUtils.getStandardColorAndOpacity(fillColor, fillColorOpacity);
                    fillColor = hexAlpha.hex;
                    fillColorOpacity = hexAlpha.alpha;
                }

                var marker = BaseUtils.clone(QueryUtils.queryList(queryList, 'marker'));
                if (BaseUtils.hasDefined(marker)) {
                    var colorAlpha = this._getMarkerColorAlpha(vanchart, type, name, QueryUtils.queryList(queryList, 'opacity'));
                    marker.fillColor = colorAlpha.markerColor;
                    marker.fillColorOpacity = colorAlpha.markerOpacity;
                }
            }

            BaseUtils.extend(this, {

                type:type,

                name:name,

                index:index,

                className:'vancharts-series-' + index,

                visible:visible,

                state:visible ? Constants.STATE_SHOW : Constants.STATE_DROPPED,

                stack:QueryUtils.queryList(queryList, 'stack'),
                stackByPercent:QueryUtils.queryList(queryList, 'stackByPercent'),

                style:QueryUtils.queryList(queryList, 'style'),

                large:QueryUtils.queryList(queryList, 'large'),

                trendLine:QueryUtils.queryList(queryList, 'trendLine'),

                bands:QueryUtils.queryList(queryList, 'bands'),

                image:QueryUtils.queryList(queryList, 'image'),

                animation:QueryUtils.queryList(queryList, 'animation') && vanchart.currentOption.animation,

                marker:marker,
                icon:QueryUtils.queryList(queryList, 'icon'),

                color:color,
                opacity:opacity,

                fillColor: fillColor,
                fillColorOpacity: fillColorOpacity
            });

            //bind Axis
            this._bindAxis();

            //chart type specific attributes
            this._refresh(index);

            var data = options.data || [];

            var newPoints = [];
            var series = this;
            for(var i = 0, len = data.length; i < len; i++){

                var refresh = false;
                this.points.forEach(function(point){
                    var pointkey = series._getPointKey(point);

                    if(BaseUtils.hasDefined(pointkey) && (pointkey == series._getPointKey(data[i]))){
                        point._lastValue = point[series.getTargetKey()];
                        point.drillSeries = null;
                        point.geo = null;
                        point.refresh(data[i]);
                        refresh = true;
                        newPoints.push(point);
                    }
                });

                if(!refresh){
                    newPoints.push(new Point(data[i], this));
                }
            }

            for(var j = 0, size = this.points.length; j < size; j++) {

                if(BaseUtils.arrayIndexOf(newPoints, this.points[j]) == -1) {
                    this.points[j].remove();
                }
            }

            this.points = newPoints;
        },

        _getPointKey: function (point) {
            return point.x;
        },

        //不在options的原因：radar和columnRadar不同
        _getDefaultFillColorOpacity: function () {
            return 1;
        },

        _getMarkerColorAlpha: function (vanchart, type, name, opacity) {

            var plotOptions = vanchart.currentOption.plotOptions, _options = plotOptions[type];
            var plotOptionsMarker = (_options && _options.marker) || plotOptions.marker;
            var seriesMarker = this.options.marker;

            var _markerColor = (seriesMarker && seriesMarker.fillColor) ||
                this.options.color ||
                (plotOptionsMarker && plotOptionsMarker.fillColor) ||
                vanchart.getDefaultSeriesColor(name);

            var _markerOpacity = opacity;

            if(BaseUtils.hasDefined(_markerColor)){
                var hexAlpha = ColorUtils.getStandardColorAndOpacity(_markerColor, opacity);
                _markerColor = hexAlpha.hex;
                _markerOpacity = hexAlpha.alpha;
            }

            return{
                markerColor:_markerColor,
                markerOpacity:_markerOpacity
            }
        },

        _bindAxis:function(){
            var series = this,
                seriesOptions = series.options,
                vanchart = series.vanchart;

            series._getAxisTypes().forEach(function(axisType){

                if(vanchart[axisType]){
                    var targetAxis = vanchart[axisType](seriesOptions[axisType]);
                    if(targetAxis){
                        targetAxis.series.push(series);
                        series[axisType] = targetAxis;
                    }
                }

            });
        },

        _getAxisTypes:function(){
            return ['xAxis', 'yAxis'];
        },

        isLargeMode:function(){
            return this.vanchart.currentOption.plotOptions.large;
        },

        //用来计算百分比的指标的名字,相当于value的含义
        getTargetKey:function(){
            return 'y';
        },

        //图形坐在的那个坐标轴的key
        getBaseAxisType: function () {
            return 'xAxis';
        },

        getPointValue4MinMax: function (point) {
            return point[this.getTargetKey()]
        },

        _getQueryList:function(type){

            type = type || this.type;

            var plotOptions = this.vanchart.currentOption.plotOptions;

            return [
                this.options,
                plotOptions[type],
                plotOptions
            ];

        },

        //根据bands的定义获取颜色
        _getBandsColor:function(point){

            var bands = this.bands;

            var valueKey = this.getTargetKey();

            if(bands){
                bands = BaseUtils.isArray(bands) ? bands : [bands];

                for(var i = 0, count = bands.length; i < count; i++){

                    var band = bands[i];

                    if(band.axis){

                        var axis = band.axis == 'x' ? this.xAxis : this.yAxis;
                        var value = axis.getValueFromData(point.options);
                        var from = band.from;
                        var to = band.to;

                        if(axis.type == ComponentLibrary.CATEGORY_AXIS_COMPONENT){
                            value = axis.indexOfLabel(value);
                            from = from ? axis.indexOfLabel(from) : from;
                            to = to ? axis.indexOfLabel(from) : to;
                        }

                        var largerThanFrom = BaseUtils.hasDefined(from) ? value >= from : true;
                        var smallerThanTo = BaseUtils.hasDefined(to) ? value <= to : true;

                        if(largerThanFrom && smallerThanTo){
                            return band.color;
                        }

                    }else{

                        var from = Math.min(band.from, band.to);
                        var to = Math.max(band.from, band.to);

                        if(point[valueKey] >= from && point[valueKey] <= to){
                            return band.color;
                        }

                    }
                }

                //走到这边说明没找到
                band = bands[0];
                if(band){
                    if(point[valueKey] <= Math.min(band.from, band.to)){
                        return band.color;
                    }
                }
                band = bands[bands.length - 1];
                if(band){
                    if(point[valueKey] >= Math.max(band.from, band.to)){
                        return band.color;
                    }
                }
            }
        },

        getTooltipPos:function(point, divDim, event){
            var leftTopPos;
            if(point.tooltip.follow){
                var pos = event.containerPoint;
                leftTopPos = [pos[0] + 10, pos[1] + 10];
            }else{
                leftTopPos = this._getFixedPos(point, divDim);
            }
            //调整位置
            var chartBounds = this.vanchart.getChartBounds();
            var top = chartBounds.y, left = chartBounds.x;
            var bottom = chartBounds.y + chartBounds.height;
            var right = chartBounds.x + chartBounds.width;
            var x = leftTopPos[0], y = leftTopPos[1];

            if(x < left){
                x += (left - x);
            }else if(x + divDim.width > right){
                x -= (x + divDim.width - right);
            }

            if(y < top){
                y += (top - y);
            }else if(y + divDim.height > bottom){
                y -= (y + divDim.height - bottom);
            }

            return [x, y];
        },

        _getArcPoint:function(r, radian){
            return [r * Math.sin(radian), -r * Math.cos(radian)]
        },

        _getNormalTrendLineXYValues:function(sery){

            var xValues = [];
            var yValues = [];
            var key = this.vanchart.isInverted() ? 'posY' : 'posX';
            var location = this.vanchart.isInverted() ? Constants.LEFT : Constants.BOTTOM;

            sery.points.sort(function(p1, p2){
                return p1[key] - p2[key];
            });

            sery.points.forEach(function(point){

                if(!point.isNull){
                    xValues.push(point.posX);
                    yValues.push(point.posY);
                }

            });

            return [xValues, yValues, location];
        },

        _getSeriesInterpolate: function(queryList){
            var step = QueryUtils.queryList(queryList, 'step');
            var curve = QueryUtils.queryList(queryList, 'curve');
            var interpolate = 'linear';
            if(step){
                interpolate = 'step-after'
            }else if(curve){
                interpolate = 'cardinal';
            }
            return interpolate;
        },

        calculateLabelInfo:function(point){

            var dataLabels = point.dataLabels, content = this.calculateFormatterContent(point, dataLabels);

            BaseUtils.extend(point, {
                labelContent:content,
                labelDim:this.calculateTextDim(content)
            });
        },

        calculateFormatterContent:function(point, dataLabels){
            if(!point || point.isNull || !dataLabels || !dataLabels.enabled){
                return [];
            }

            var formatter = dataLabels.formatter, useHtml = dataLabels.useHtml, content = [];

            if(typeof formatter == 'object'){
                this.pushNormalLabelContent(point, formatter, dataLabels, useHtml, content)
            }else{
                this.pushCustomLabelContent(point, formatter, dataLabels, useHtml, content);
            }

            return content;
        },

        _createMultiLineLabelContent:function(formatter, data){
            if(!formatter){
                return [];
            }

            if(typeof formatter == 'object'){
                var content = [];

                var label = formatter.identifier;
                var categoryString = Formatter.format(data.category, formatter.categoryFormat);
                var seriesString = Formatter.format(data.seriesName, formatter.seriesFormat);
                var valueString = Formatter.format(data[this.getTargetKey()], formatter.valueFormat);
                var percentString = Formatter.format(data.percentage, formatter.percentFormat);

                if(label.indexOf(CATEGORY) != -1){
                    content.push(categoryString);
                }

                if(label.indexOf(SERIES) != -1){
                    content.push(seriesString)
                }

                if(label.indexOf(VALUE) != -1){
                    content.push(valueString);
                }

                if(label.indexOf(PERCENT) != -1){
                    content.push(percentString);
                }

                return content;
            }else{
                return [BaseUtils.getFormatterFunction(formatter).call(data)];
            }

        },

        pushNormalLabelContent: function (point, formatter, dataLabels, useHtml, content) {
            var series = this;
            var label = formatter.identifier;
            var propMap = {};
            propMap[NAME] = ['name', 'nameFormat'];
            propMap[CATEGORY] = ['category', 'categoryFormat'];
            propMap[SERIES] = ['seriesName', 'seriesFormat'];
            propMap[VALUE] = [this.getTargetKey(), 'valueFormat'];
            propMap[PERCENT] = ['percentage', 'percentFormat'];

            var names = [NAME, CATEGORY, SERIES], values = [VALUE, PERCENT];

            var cateStyleFun = series.getCategorySeriesStyle,
                valueStyleFun = series.getValuePercentageStyle;

            // adjust the sequence and style here
            if (this.type === Constants.TREEMAP_CHART) {
                values.unshift(names.shift());
                valueStyleFun = cateStyleFun;
            }

            addContent(content, getContentItems(names), cateStyleFun);
            addContent(content, getContentItems(values), valueStyleFun);

            function getContentItems(items) {
                return items.map(fmtStr).filter(clean);
            }

            function fmtStr(item) {
                return label.indexOf(item) !== -1 ?
                    Formatter.format(point[propMap[item][0]], formatter[propMap[item][1]]) :
                    null;
            }

            function clean(item) { return item !== null; }

            function addContent(content, items, styleFun) {
                if (!items.length) {
                    return;
                }
                var text = items.join(' ');
                var style = styleFun(dataLabels, null, point);
                var dim = BaseUtils.getTextDimension(text, style, useHtml);
                content.push({
                    text: text,
                    style: style,
                    dim: dim
                });
            }
        },

        pushCustomLabelContent:function(point, formatter, dataLabels, useHtml, content, defaultPosition){
            var text = BaseUtils.getFormatterFunction(formatter).call(point);
            var style = this.getValuePercentageStyle(dataLabels, defaultPosition, point);
            var dim = BaseUtils.getTextDimension(text, style, useHtml);

            if(dataLabels.useHtml){
                dim.width = isNaN(parseFloat(dataLabels.labelWidth)) ? dim.width : parseFloat(dataLabels.labelWidth);
                dim.height = isNaN(parseFloat(dataLabels.labelHeight)) ? dim.height : parseFloat(dataLabels.labelHeight);
            }

            content.push({
                text:text,
                style:style,
                dim:dim
            });
        },

        calculateTextDim:function(labelContent){

            var width = 0;
            var height = 0;

            if(labelContent && labelContent.length){

                for(var i = 0, count = labelContent.length; i < count; i++){
                    var dim = labelContent[i].dim;

                    width = Math.max(width, dim.width);

                    height += dim.height;
                }

                height += (count - 1) * LABEL_GAP;
            }

            return {
                width:width,
                height:height
            };
        },

        _labelUseSeriesColor:function (position) {
            return position == Constants.OUTSIDE || position == Constants.TOP || position == Constants.BOTTOM
        },

        getCategorySeriesStyle:function(dataLabels, defaultPosition, point){
            point = point || this;

            if(dataLabels && dataLabels.style){
                return dataLabels.style;
            }

            var position = defaultPosition ||
                (point.series && point.series.columnType ? Constants.INSIDE : (dataLabels.align || Constants.OUTSIDE));

            var shadowOpacity = position === Constants.OUTSIDE ? 0.1 : 0.15;

            return {
                color: point.series._labelUseSeriesColor(position) ? (point.marker && point.marker.fillColor || point.color) : '#ffffff',
                fontSize:'12px',
                fontFamily:'Verdana',
                textShadow:'1px 1px 1px rgba(0,0,0,' + shadowOpacity + ')',
                fontWeight:'bold'
            }

        },

        getValuePercentageStyle:function(dataLabels, defaultPosition, point){
            point = point || this;

            if(dataLabels && dataLabels.style){
                return dataLabels.style;
            }

            var position = defaultPosition ||
                (point.series && point.series.columnType ? Constants.INSIDE : (dataLabels.align || Constants.OUTSIDE));

            return {
                fontSize:'12px',
                fontFamily:'Verdana',
                textShadow:'1px 1px 1px rgba(0,0,0,0.15)',
                color:point.series._labelUseSeriesColor(position) ? (point.marker && point.marker.fillColor || point.color) : '#ffffff'
            };
        },

        pushBubbleNormalLabelContent: function (point, formatter, dataLabels, useHtml, content, defaultPosition) {
            var identifier = formatter.identifier;

            if(identifier.indexOf(SERIES) != -1){
                var seriesString = Formatter.format(point.seriesName, formatter.seriesFormat);
                var seriesStyle = this.getCategorySeriesStyle(dataLabels, defaultPosition, point);
                var seriesDim = BaseUtils.getTextDimension(seriesString, seriesStyle, useHtml);

                content.push({
                    text:seriesString,
                    style:seriesStyle,
                    dim:seriesDim
                });
            }

            if(identifier.indexOf(X) != -1 || identifier.indexOf(Y) != -1 || identifier.indexOf(SIZE) != -1){
                var text = this._getXYSizeString(point, formatter, identifier);
                var style = this.getValuePercentageStyle(dataLabels, defaultPosition, point);
                var dim = BaseUtils.getTextDimension(text, style, useHtml);

                content.push({
                    text:text,
                    style:style,
                    dim:dim
                });
            }
        },

        _getXYSizeString:function(point, formatter, identifier) {
            var xString = Formatter.format(point.x, formatter.XFormat);
            var yString = Formatter.format(point.y, formatter.YFormat);
            var sizeString = point.size == '-' ? '-' : Formatter.format(point.size, formatter.sizeFormat);

            var text = '';

            if(identifier.indexOf(X) != -1 || identifier.indexOf(Y) != -1){
                text = '(';
                if(identifier.indexOf(X) != -1){
                    text += xString;
                    if(identifier.indexOf(Y) != -1){
                        text = text + ',' + yString;
                    }
                    text += ')';
                } else {
                    text += yString;
                    text += ')';
                }
                text += ' ';
            }

            if(identifier.indexOf(SIZE) != -1 && sizeString != '-'){
                text += sizeString;
            }
            return text;
        },

        calculateTooltipContent:function(point){
            return this._calculateTooltipContent(point);
        },

        _calculateTooltipContent:function(point){
            var tooltip = point.tooltip, series = this, points = point.points;
            if(!tooltip || !tooltip.enabled){
                return;
            }
            var formatter = tooltip.formatter, content = '';
            if(typeof formatter == 'object'){
                var style = tooltip.style, label = formatter.identifier;
                var hasMap = this.vanchart.vanChartType == 'vanChartMap', hasRangeLegend = this.vanchart.getComponent(ComponentLibrary.RANGE_LEGEND_COMPONENT);
                if(tooltip.shared && points && points.length){

                    content += this._createCategoryLine(point, label, style, formatter);
                    points
                        .filter(function (p) { return p.visible && !p.isNull && p.tooltip && p.tooltip.shared })
                        .forEach(function(point){
                        var dotColor = (hasMap && hasRangeLegend) ? points[0].color : point.color;

                        content += '<span style="font-size:12px;font-style:normal; color: ' + dotColor + ';opacity:' + point.opacity + '">'+'&#9679  '+'</span>';

                        content += series._createSeriesLine(point, label, style, formatter);

                        content += '<br />';
                    });
                }else{
                    content += series._createCategoryLine(point, label, style, formatter);
                    content += series._createSeriesLine(point, label, style, formatter);
                }
            }else{
                content = BaseUtils.getFormatterFunction(formatter).call(point);
            }

            return content;
        },

        _createCategoryLine:function(point, label, style, formatter){
            var content = '', type = point.series.type, hasMap = this.vanchart.vanChartType == 'vanChartMap';

            if(type == Constants.SCATTER_CHART && !hasMap){
                return this._createBubbleTooltipSeriesLine(data, label, style, formatter);
            }

            if (type === Constants.MULTIPIE_CHART) {
                if (label.indexOf(SERIES) != -1) {
                    content = Formatter.format(point.seriesName, formatter.seriesFormat);
                }
            }else{
                if (label.indexOf(CATEGORY) != -1) {
                    content = Formatter.format(point.category, formatter.categoryFormat);
                }

                if (label.indexOf(NAME) != -1) {
                    content = Formatter.format(point.name, formatter.nameFormat);
                }
            }

            if(content){
                content = (style ? '<span>' : Constants.TOOLTIP_CATEGORY_STYLE) + content +'</span>';
                content += '<br />';
            }

            return content;
        },

        _createSeriesLine:function(point, label, style, formatter){
            var content = '', type = point.series.type, hasMap = this.vanchart.vanChartType == 'vanChartMap';
            var valueString = Formatter.format(point[this.getTargetKey()], formatter.valueFormat);
            var percentString = Formatter.format(point.percentage, formatter.percentFormat);
            var textString;

            if(type == Constants.SCATTER_CHART && !hasMap) {
                return this._createBubbleTooltipXYSizeLine(data, label, style, formatter);
            }

            if (type === Constants.MULTIPIE_CHART) {
                if (label.indexOf(NAME) != -1) {
                    textString = Formatter.format(point.name, formatter.nameFormat);
                }
            }else {
                if (label.indexOf(SERIES) != -1) {
                    textString = Formatter.format(point.seriesName, formatter.seriesFormat);
                }
            }

            if (textString) {
                if (label.indexOf(VALUE) != -1 || label.indexOf(PERCENT) != -1) {
                    textString += ':';
                }
                content += (style ? '<span >' : Constants.TOOLTIP_SERIES_STYLE) + textString +'</span>';
            }

            if(label.indexOf(VALUE) != -1 && label.indexOf(PERCENT) != -1){
                content += (style ? '<span>' : Constants.TOOLTIP_VALUE_STYLE) + valueString + '  ' + percentString + '</span>';
            }else if(label.indexOf(VALUE) != -1){
                content += (style ? '<span>' : Constants.TOOLTIP_VALUE_STYLE) + valueString + '</span>';
            }else if(label.indexOf(PERCENT) != -1){
                content += (style ? '<span>' : Constants.TOOLTIP_VALUE_STYLE) + percentString +'</span>';
            }

            return content;
        },

        //提示的第一行：气泡的系列
        _createBubbleTooltipSeriesLine:function(data, label, style, formatter){
            var content = '';

            if(label.indexOf(SERIES) != -1){

                var seriesString = Formatter.format(data.seriesName, formatter.seriesFormat);

                content += (style ? '<span >' : Constants.TOOLTIP_SERIES_STYLE) + seriesString +'</span>';

                content += '<br />';
            }

            return content;
        },

        //提示的第二行：气泡的X、Y、SIZE
        _createBubbleTooltipXYSizeLine:function(data, label, style, formatter){
            var content = '';
            if(label.indexOf(X) != -1 || label.indexOf(Y) != -1 || label.indexOf(SIZE) != -1) {
                var text = this._getXYSizeString(data, formatter, label);
                content += (style ? '<span>' : Constants.TOOLTIP_VALUE_STYLE) + text + '</span>';
            }

            return content;
        },

        //每种类型都在一行
        _calculateSingleLineLabelContent:function(formatter, data){

            if(!formatter){
                return '';
            }

            if(typeof formatter == 'object'){
                var content = '';
                var label = formatter.identifier;
                var categoryString = Formatter.format(data.category, formatter.categoryFormat);
                var seriesString = Formatter.format(data.seriesName, formatter.seriesFormat);

                if(label.indexOf(CATEGORY) != -1 || label.indexOf(SERIES) != -1){
                    if(label.indexOf(CATEGORY) != -1 && label.indexOf(SERIES) != -1){
                        content += (categoryString + ' ' + seriesString);
                    }else if(label.indexOf(CATEGORY) != -1){
                        content += categoryString;
                    }else{
                        content += seriesString;
                    }
                }

                if(!data.isNull && label.indexOf(VALUE) != -1 || label.indexOf(PERCENT) != -1){

                    if(!BaseUtils.isEmpty(content)){
                        content += ':';
                    }

                    var valueString = Formatter.format(data[data.series.getTargetKey()], formatter.valueFormat);
                    var percentString = Formatter.format(data.percentage, formatter.percentFormat);

                    if(label.indexOf(VALUE) != -1 && label.indexOf(PERCENT) != -1){
                        content += (valueString + ' ' + percentString);
                    }else if(label.indexOf(VALUE) != -1){
                        content += valueString;
                    }else{
                        content += percentString;
                    }
                }
                return content;
            }else{
                return BaseUtils.getFormatterFunction(formatter).call(data);
            }
        },

        _getAngle:function(current, center){
            return Math.atan2(current[1] - center[1], current[0] - center[0]) / (Math.PI / 180);
        },

        _getBackgroundColor:function(){

            var opt = this.vanchart.currentOption;

            var plotColor = (typeof opt.plotBackgroundColor == 'string');

            var chartColor = (typeof opt.backgroundColor == 'string');

            var color =  plotColor ? opt.plotBackgroundColor : (chartColor ? opt.backgroundColor : 'white');

            return ColorUtils.colorToHex(color);
        },

        _getMarkerPath:function(markerType, radius){
            switch(markerType){
                case Constants.CIRCLE:
                case Constants.CIRCLE_HOLLOW:
                    return d3.svg.arc().outerRadius(radius)({startAngle:0, endAngle:2 * Math.PI});

                case Constants.SQUARE:
                case Constants.SQUARE_HOLLOW:
                    var leftTop = -radius + ',' + -radius;
                    var rightTop = radius + ',' + -radius;
                    var rightBottom = radius + ',' + radius;
                    var leftBottom = -radius + ',' + radius;
                    return 'M' + leftTop + 'L' + rightTop + 'L' + rightBottom + 'L' + leftBottom + 'Z';

                case Constants.DIAMOND:
                case Constants.DIAMOND_HOLLOW:
                    radius = radius * 2 / Math.sqrt(2);
                    var left = -radius + ',' + 0;
                    var top = 0 + ',' + -radius;
                    var right = radius + ',' + 0;
                    var bottom = 0 + ',' + radius;
                    return 'M' + left + 'L' + top + 'L' + right + 'L' + bottom + 'Z';

                case Constants.TRIANGLE:
                case Constants.TRIANGLE_HOLLOW:
                    var left = -radius + ',' + radius/Math.sqrt(3);
                    var top = 0 + ',' + -(2 * Math.sqrt(3) / 3) * radius;
                    var right = radius + ',' + radius/Math.sqrt(3);
                    return 'M' + left + 'L' + top + 'L' + right + 'Z';
            }
        },

        //统一处理渐变色,图片填充,阴影等情况,默认就返回颜色
        getFillFilter:function(color, p){
            return color;
        },

        filterRender: function () {
            this.large ? this._canvasRender() : this._svgFilterRender();
        },

        render:function(){
            (this.large && (this.type == Constants.BUBBLE_CHART || this.type == Constants.SCATTER_CHART)) ? this._canvasRender() : this._svgRender();
        },

        _createGroup: function (renderer, vanchart) {
            return renderer.group().addTo(vanchart.clipSeriesGroup);
        },

        getSeryTotalValue:function(){
            var total = 0;

            this.points.forEach(function(point){
                total += point.getTargetValue();
            });

            return total;
        },

        _svgRender:function(){
            var vanchart = this.vanchart, renderer = vanchart.renderer, plotBounds = vanchart.getPlotBounds();

            this.initialAnimationMoving = !this.group;

            if(!this.group){
                this.group = this._createGroup(renderer, vanchart).attr('transform', BaseUtils.makeTranslate(this._getTranslate()));
                this.additionalClip && this.additionalClip(this.group);
            }

            //对于可以自定义位置的如雷达图,仪表盘这边的translate不是绘图取
            if(this.animation){
                d3.select(this.group.node()).transition().duration(ANIMATION_TIME).ease(EASE_TYPE)
                    .attr('transform', BaseUtils.makeTranslate(this._getTranslate()));
            }else{
                this.group.attr('transform', BaseUtils.makeTranslate(this._getTranslate()));
            }

            if(this._isSeriesInteractive()){
                renderer.registerInteractiveTarget(this, this.group);
            }

            this.drawSeries && this.drawSeries();

            this.drawPoints();

            // this._drawLabels();

            //
            this._removeDataLabels();

            var series = this;
            vanchart.setTimeout(series.className + 'point_animate', function () {
                series._animateEnd();
            }, series.animation ? series._getAnimationTime() : 0);
        },

        _isSeriesInteractive:function(){
            return false;
        },

        _svgFilterRender:function(){
            var visible = this.visible;

            this.getDataToDraw().forEach(function(point) {

                if(visible && point.visible){
                    point.graphic && point.graphic.style({'display':'inline'});
                    point.textGraphic && point.textGraphic.style({'display':'inline'});
                } else {
                    point.graphic && point.graphic.style({'display':'none'});
                    point.textGraphic && point.textGraphic.style({'display':'none'});
                }

            });
        },

        _canvasRender:function(){
            if(!this._canvas){
                this._canvas = new CanvasRenderer(this.vanchart.dom, this.vanchart);
            }
            this._canvas.clearAll();
            this._canvas.addSeries(this);
        },

        getEvents:function(){
            return {
                'mouseover':this.onSeriesMouseOver,
                'seriesUnChosen':this.onSeriesUnChosen
            }
        },

        onSeriesMouseOver:function(ev){

            var series = this, vanchart = series.vanchart, hoverSeries = vanchart.hoverSeries;
            var hoverPoint = vanchart.hoverPoint;

            if(hoverSeries != series){
                hoverSeries && hoverSeries.fire('seriesUnChosen', ev);
                //当前系列的选中效果...
                vanchart.hoverSeries = series;
                series._onSeriesMouseOver && series._onSeriesMouseOver();
            }

            var closestPoint = series.getClosestPoint(ev.containerPoint);

            if(hoverPoint && (hoverPoint.series != series || hoverPoint != closestPoint)){
                hoverPoint.fire('mouseout', ev);
            }

            if(closestPoint && closestPoint != hoverPoint){
                closestPoint.fire('mouseover', ev);
            }
        },

        onSeriesUnChosen:function(ev){
            this.vanchart.hoverSeries = null;
            this._onSeriesUnChosen && this._onSeriesUnChosen(ev);
        },

        _getAnimationTime: function () {
            switch (this.state){
                case Constants.STATE_SHOW:
                    return this.getInitShowTime();
                case Constants.STATE_TO_SHOW:
                    return this.getReAppearTime();
                case Constants.STATE_TO_DROP:
                    return this.getDropTime();
                default:
                    return 0;
            }
        },

        getInitShowTime: function () {
            return 0;
        },

        getReAppearTime: function () {
            return 0;
        },

        getDropTime: function () {
            return 0;
        },

        getDataToDraw: function () {
            return this.points;
        },

        getTextDataToDraw: function () {
            return this.getDataToDraw();
        },

        // 现在的处理方式是全部重新写一遍
        drawPoints:function(){
            var series = this, vanchart = series.vanchart, renderer = vanchart.renderer;
            var options = series.options, visible = this.visible, animation = series.animation;

            var delay = this._calculateAnimationDelay && this._calculateAnimationDelay() || 0;
            var graphicGroup = this._getPointGraphicGroup();

            if(graphicGroup != this.group && !this._isSeriesInteractive()){
                renderer.registerInteractiveTarget(this, graphicGroup);
            }

            series.getDataToDraw().forEach(function(point){
                var attrs = series.getAttrs(point);
                var pointVisible = visible && point.visible && !point.isNull;

                if(pointVisible && point.graphic){//update

                    series._updatePointGraphicStyle(point);

                    animation ? point.graphic.animate(series, series.updateAnimation, point, delay) : point.graphic.attr(attrs);

                }else if(pointVisible && !point.graphic){//create

                    series._createPointGraphic(point).addTo(graphicGroup);

                    series._updatePointGraphicStyle(point);

                    if(animation){
                        point.graphic.animate(series, series.createAnimation, point, delay);
                    }else{
                        point.graphic.attr(attrs);
                    }

                }else if(!pointVisible && point.graphic){//drop

                    animation ? point.graphic.animate(series, series.dropAnimation, point, delay) :  point.graphic.remove();

                    point.graphic = null;
                }

                point.graphic && renderer.registerInteractiveTarget(point, point.graphic);
            });
        },

        _createPointGraphic:function(point){
            var graphicKey = this.getPointGraphicKey(point), renderer = this.vanchart.renderer;
            point.graphic = renderer[graphicKey]();
            return point.graphic;
        },

        _updatePointGraphicStyle:function(point){
            var style = this.getStyle(point);
            point.graphic && point.graphic.style(style);//update style
        },

        _createMarker:function(marker){
            var markerType = marker.symbol, radius = marker.radius;
            var renderer = this.vanchart.renderer, group = renderer.group();

            if(BaseUtils.isImageMarker(markerType)){
                var w = marker.width, h = marker.height;
                renderer.image({
                    'preserveAspectRatio':'none', 'href':markerType, 'x':-w/2, 'y':-h/2, 'width':w, 'height':h
                }).addTo(group);
            }else{
                //只有当折线图,并且是中空的标记点的时候需要最外面的描边
                var isHollow = this._isHollowMarker(markerType), isLine = this.type == Constants.LINE_CHART;
                if(isHollow && isLine){
                    group.strokePath = renderer.path({'d':this._getMarkerPath(markerType, radius + 2)}).addTo(group);
                    group.fillPath = renderer.path({'d':this._getMarkerPath(markerType, radius - 1)}).addTo(group);
                }else{
                    group.markerPath = renderer.path({'d':this._getMarkerPath(markerType, radius)}).addTo(group);
                }
            }

            return group;
        },

        _updateMarker:function(group, marker){

            var opacity = marker.fillColorOpacity;

            var markerType = marker.symbol, backgroundColor = this._getBackgroundColor();

            if(BaseUtils.isImageMarker(markerType)){

            }else{
                //只有当折线图,并且是中空的标记点的时候需要最外面的描边
                var isHollow = this._isHollowMarker(markerType), isLine = this.type == Constants.LINE_CHART;
                if(isHollow && isLine){
                    group.strokePath.style({'fill':marker.fillColor, 'fill-opacity':opacity,'stroke':backgroundColor, 'stroke-width':2});
                    group.fillPath.style({'fill':backgroundColor});
                }else if(isHollow){
                    group.markerPath.style({'stroke':marker.fillColor,'stroke-opacity':opacity,'stroke-width':2, 'fill':backgroundColor})
                }else{
                    isLine ? group.markerPath.style({'fill':marker.fillColor,'fill-opacity':opacity, 'stroke-width':2, 'stroke':backgroundColor})
                                                                            : group.markerPath.style({'fill':marker.fillColor, 'fill-opacity':opacity});
                }
            }
        },

        _onMarkerPressed:function(point){
            if(point.graphic){
                var marker = point.marker, markerType = marker.symbol, series = point.series;
                var style = {'fill':point.clickColor, 'fill-opacity': point.clickOpacity};
                if(!BaseUtils.isImageMarker(markerType)){
                    //只有当折线图,并且是中空的标记点的时候需要最外面的描边
                    var isHollow = this._isHollowMarker(markerType), isLine = this.type == Constants.LINE_CHART;
                    if(isHollow && isLine){
                        point.graphic.strokePath.style(style);
                    }else{
                        point.graphic.markerPath.attr(style);
                    }
                }
            }
        },

        _onMarkerMouseOver:function(point){
            if(point.graphic){
                var marker = point.marker, markerType = marker.symbol, animation = point.series.animation, radius = marker.radius + 2;

                if(BaseUtils.isImageMarker(markerType)){

                }else{
                    //只有当折线图,并且是中空的标记点的时候需要最外面的描边
                    var isHollow = this._isHollowMarker(markerType), isLine = this.type == Constants.LINE_CHART;
                    if(isHollow && isLine){
                        point.graphic.strokePath.attr({'d':this._getMarkerPath(markerType, radius + 2)});
                        point.graphic.fillPath.attr({'d':this._getMarkerPath(markerType, radius - 1)})
                    }else{
                        point.graphic.markerPath.attr({'d':this._getMarkerPath(markerType, radius)});
                    }
                }

            }else{
                var marker = this._getDefaultMarker(point);
                point.series.defaultMarker = point.series.defaultMarker || this._createMarker(marker).addTo(this.group);

                point.series.defaultMarker.attr('transform', BaseUtils.makeTranslate([point.posX, point.posY]));

                this._updateMarker(point.series.defaultMarker, marker);
            }
        },

        _onMarkerMouseOut:function(point){
            var marker = point.marker, markerType = marker.symbol, animation = point.series.animation, radius = marker.radius;

            if(point.graphic){
                if(BaseUtils.isImageMarker(markerType)){

                }else{
                    //只有当折线图,并且是中空的标记点的时候需要最外面的描边
                    var isHollow = this._isHollowMarker(markerType), isLine = this.type == Constants.LINE_CHART;
                    if(isHollow && isLine){
                        point.graphic.strokePath.attr({'d':this._getMarkerPath(markerType, radius + 2)});
                        point.graphic.fillPath.attr({'d':this._getMarkerPath(markerType, radius - 1)})
                    }else{
                        point.graphic.markerPath.attr({'d':this._getMarkerPath(markerType, radius)});
                    }
                }
            }
        },

        //当没有marker的时候默认加一个marker
        _getDefaultMarker:function(point){
            return {
                'symbol':Constants.CIRCLE,
                'fillColor': point.marker.fillColor,
                'fillColorOpacity':point.marker.fillColorOpacity,
                "radius": 4.5,
                "enabled": true
            }
        },

        _isHollowMarker:function(markerType) {
            return markerType && markerType.indexOf('hollow') != -1;
        },

        _animateEnd: function () {
            this._showLabels();
        },

        // move, instead of repainting
        _drawLabels: function () {
            var series = this, vanchart = series.vanchart;
            var visible = this.visible, animation = series.animation;

            series.getTextDataToDraw().forEach(function(point){
                var labelVisible = visible && point.visible && !point.isNull && point.labelPos;

                if(labelVisible && point.textGraphic){//update

                    var startX = point.labelPos.x, startY = point.labelPos.y;
                    if (point.dataLabels.useHtml) {

                        if (animation) {
                            d3.select(point.textGraphic)
                                .transition()
                                .ease(BezierEasing.css.swing)
                                .duration(250)
                                .style({
                                    'left': startX + 'px',
                                    'top': startY + 'px'
                                });
                        } else {
                            point.textGraphic.style.left = startX + 'px';
                            point.textGraphic.style.top = startY + 'px';
                        }

                    } else {

                        if (animation) {
                            d3.select(point.textGraphic.node())
                                .transition()
                                .ease(BezierEasing.css.swing)
                                .duration(250)
                                .attr('transform', BaseUtils.makeTranslate([startX, startY]));
                        } else {
                            point.textGraphic.attr('transform', BaseUtils.makeTranslate([startX, startY]));
                        }

                    }

                    if(point.labelPos.startPos){
                        if(point.leadLine){
                            point.leadLine.attr('d', series._getLeadLinePath(point));
                        }else{
                            point.leadLine = series._getLeadLine(point);
                        }
                    }

                }else if(labelVisible && !point.textGraphic){//create

                    series._createTextGraphic(point);

                }else if(!labelVisible && point.textGraphic){//drop
                    // div label's remove() function needs polyfill;
                    point.textGraphic.remove();
                    point.leadLine && point.leadLine.remove();
                    point.textGraphic = null;
                    point.leadLine = null;
                }

            });
        },

        _showLabels: function () {
            var series = this, vanchart = series.vanchart;

            vanchart.setTimeout(series.className + 'more_label_animate', function () {
                vanchart._removeChangeDataState(series);

                series._clearMoreLabels();

                series._removeDataLabels();

                series._updateDataLabels();

            }, vanchart.getShowMoreLabelTime());

            series._updateMoreLabels();
        },

        _updateMoreLabels: function () {
            var series = this, vanchart = series.vanchart;

            if(vanchart.getShowMoreLabelTime() == 0 || !series.visible){
                return;
            }

            series.getTextDataToDraw().forEach(function(point){
                if(point.visible) {
                    series._showAndExitMoreLabel(point);
                }
            });
        },

        _clearMoreLabels: function () {
            this.getTextDataToDraw().forEach(function(point){
                point.moreLabelG && point.moreLabelG.remove();
                point.moreLabelG = null;
            });
        },

        _getMoreLabelStyle: function () {
            var moreLabel = this.vanchart.currentOption.moreLabel;
            return moreLabel.style || {"fontFamily": "verdana", "fontSize": "9pt"};
        },

        _showAndExitMoreLabel:function(d, centerX, centerY, centerXFunc, centerYFunc){
            if(d.depth == 0){//多层饼图
                return;
            }

            var series = this, vanchart = series.vanchart, renderer = vanchart.renderer, animation = series.animation;

            var textLabelGroup = series.group;

            var lastValue = d._lastValue || 0;

            var moreText = BaseUtils.accAdd(d[series.getTargetKey()], -lastValue);

            var moreLabel = vanchart.currentOption.moreLabel;
            var textColor = moreText < 0 ? (moreLabel.minusColor || '#f4b145') : (moreLabel.plusColor || '#52d1b8');

            if(moreText == 0){
                return;
            } else if(moreText > 0){
                moreText = "+" + moreText;
            }

            var style = series._getMoreLabelStyle();

            var moreLabelDim = BaseUtils.getTextDimension(moreText, style);

            if(BaseUtils.hasNotDefined(centerX) || BaseUtils.hasNotDefined(centerY)) {

                var pos = series._getMoreLabelDefaultCenter(d, moreLabelDim);
                centerX = pos.centerX; centerY = pos.centerY;

                if (BaseUtils.hasDefined(d.labelPos) && BaseUtils.hasDefined(d.labelDim)) {
                    centerX = d.labelPos.x + d.labelDim.width/2;
                    centerY = d.labelPos.y + d.labelDim.height/2;
                }
            }

            if(centerXFunc){
                centerX = centerXFunc(centerX, moreLabelDim.width);
            }

            if(centerYFunc){
                centerY = centerYFunc(centerY, moreLabelDim.height);
            }

            d.moreLabelG = renderer.text().addTo(textLabelGroup);

            if(animation){
                d3.select(d.moreLabelG.node())
                    .attr('dy', '.32em')
                    .attr("text-anchor", "middle")
                    .text(moreText)
                    .call(BaseUtils.setTextStyle, style)
                    .style({'fill': textColor})
                    .attr('opacity', 0)
                    .attr('x', centerX)
                    .attr('y', centerY + 5)
                    .transition()
                    .duration(INIT_MORE_LABEL_ANIMATION_TIME)
                    .ease('back-out')
                    .attr('y', centerY)
                    .attrTween('opacity', function () {
                        return function (t) {
                            return BezierEasing.css.swing(t);
                        }
                    })
                    .transition()
                    .delay(KEEP_MORE_LABEL_ANIMATION_TIME)
                    .duration(EXIT_MORE_LABEL_ANIMATION_TIME)
                    .ease('back-in')
                    .attr('y', centerY + 5)
                    .attrTween('opacity', function () {
                        return function (t) {
                            return 1 - BezierEasing.css.swing(t);
                        }
                    })

            } else {
                d.moreLabelG.textContent(moreText)
                    .attr('dy', '.32em')
                    .attr('text-anchor', 'middle')
                    .attr('x', centerX).attr('y', centerY)
                    .style(style)
                    .style({'fill': textColor})
            }
        },

        _getMoreLabelDefaultCenter:function(d, moreLabelDim){

            return {
                centerX: d.x + d.width/2,
                centerY: d.y - moreLabelDim.height/2
            }
        },

        _updateDataLabels:function(){
            var series = this;
            series.getTextDataToDraw().forEach(function(point){
                series._createTextGraphic(point);
            });
        },

        _removeDataLabels: function () {
            var series = this;
            series.getTextDataToDraw().forEach(function(point){
                if(point.textGraphic){
                    point.textGraphic.remove();
                    point.textGraphic = null;
                }
                if (point.leadLine) {
                    point.leadLine.remove();
                    point.leadLine = null;
                }
            });
        },

        //labelPos是整个标签左上角
        _createTextGraphic:function(point){
            var series = this;

            var hasText = function(d){return series.visible && !d.isNull && d.visible && d.labelPos && !isNaN(d.labelPos.x) && !isNaN(d.labelPos.y) && d.dataLabels && d.dataLabels.enabled};
            if(hasText(point)){
                var vanchart = series.vanchart, renderer = vanchart.renderer;
                var labelContent = point.labelContent, startX = point.labelPos.x, startY = point.labelPos.y, dataLabels = point.dataLabels, useHtml = dataLabels.useHtml;

                var textLabelGroup = this._getPointTextLabelGroup();

                var text = renderer.vtext(useHtml).attr('transform', BaseUtils.makeTranslate([startX, startY])).style({'pointer-events': 'none'});
                startY = 0;
                for (var i = 0, count = labelContent.length; i < count; i++) {
                    var label = labelContent[i], labelDim = label.dim, labelText = label.text, labelStyle = label.style, dx;

                    switch (point.dataLabels._align) {
                        case Constants.LEFT:
                            dx = 0;
                            break;
                        case Constants.RIGHT:
                            dx = point.labelDim.width - labelDim.width;
                            break;
                        case Constants.CENTER:
                        default:
                            dx = (point.labelDim.width - labelDim.width)/2;
                    }
                    renderer.vtspan(useHtml)
                        .style({'width': dataLabels.labelWidth + 'px', height:dataLabels.labelHeight + 'px'})
                        .attr('y', startY)
                        .attr('x', 0)
                        .attr('dy', labelDim.height * .85)
                        .attr('dx', dx)
                        .textContent(labelText).style(labelStyle)
                        .addTo(text);

                    startY += (labelDim.height + 2);
                }

                point.textGraphic = textLabelGroup.append(text);

                if (point.labelPos.startPos) {//leadLine
                    point.leadLine = textLabelGroup.append(this._getLeadLine(point));
                }
                
                // todo 应该全都画完了再买动画
                // if(series.animation){
                //     d3.select(textLabelGroup.node()).style('opacity', 0).transition('linear').duration(400).style('opacity', 1);
                // }
            }
        },

        _getLeadLine:function(point){
            return this.vanchart.renderer.path().attr('d', this._getLeadLinePath(point))
                .style({
                    'fill':'none', 'stroke': point.dataLabels.connectorColor || point.color,
                    'stroke-width':point.dataLabels.connectorWidth || 0
                })
        },

        _getLeadLinePath:function (point) {
            var startPos = point.labelPos.startPos, midPos = point.labelPos.midPos, endPos = point.labelPos.endPos;
            var F = this._dealWithFloat;
            return  'M' + F(startPos.x) + ',' + F(startPos.y) + 'L' + F(midPos.x) + ',' + F(midPos.y) + 'L' + F(endPos.x) + ',' + F(endPos.y);
        },

        _dealWithFloat:function(v){
            return Math.abs(v) < 1e-6 ? 0 : v;
        },

        _getPointGraphicGroup:function(){
            return this.group;
        },

        _getPointTextLabelGroup:function(){

            if(!this.textGraphicGroup){
                var vanchart = this.vanchart,
                    textRenderGroup = vanchart.seriesTextRenderGroup,
                    textDivGroup = vanchart.seriesTextDivGroup;

                this.textGraphicGroup = vanchart.renderer.vgroup();
                textRenderGroup.append(this.textGraphicGroup.renderG);
                textDivGroup.append(this.textGraphicGroup.divG);

            }
            this.textGraphicGroup.attr('transform', BaseUtils.makeTranslate(this._getTranslate()));

            return this.textGraphicGroup;
        },

        _getTranslate:function(){
            return this.vanchart.getPlotBounds();
        },

        //onPointXXX的方法,this 指向的是Point
        onPointTap:function(){

        },

        onPointMouseMove:function(ev){
            var vanchart = this.series.vanchart;
            vanchart.showTooltip(vanchart.hoverPoint, ev);
        },

        // calculate pie/multiPie label position
        // 3 things: outside labels pos,
        //           inside labels pos,
        //           lead lines;
        //
        // outside labels may adjust the chart's radius
        // 3 steps for outside labels:
        // 1. ignore minimal arc labels to content each part's height (4 parts);
        // 2. place labels, no overlap (regardless of part bounds)
        // 3. (when not fixed) test if all labels' bounds are within this chart's bounds.
        //    if not, decrease the radius, return to step 1.

        /**
         * place outside labels, get new radius if needed
         * @param {Array} outPoints
         * @param {object} bounds
         * @param {Array} center
         * @param {number} [radius]
         * @returns {number} radius Original radius or new radius
         */
        calcOutsideLabel: function (outPoints, bounds, center, radius) {
            var series = this;

            var pointsGroups = {};

            outPoints.map(function (p) {
                var loc = series.getLocByArc(series.getCenterAngle(p));
                pointsGroups[loc] = pointsGroups[loc] || [];
                pointsGroups[loc].push(p);
            });

            if (radius) {
                pointsGroups = series.ignoreMin(pointsGroups, radius);// step 1
                series.placeOutSideLabels(pointsGroups, radius);// step 2
                return radius;

            } else {
                radius = Math.min(
                    center[0] - bounds.x,
                    bounds.x + bounds.width - center[0],
                    center[1] - bounds.y,
                    bounds.y + bounds.height - center[1]
                );

                for (var i = 0, len = DECREASE.length; i < len; i++) {
                    var usedR = radius * DECREASE[i];
                    var usedPointsG = series.ignoreMin(pointsGroups, radius);// step 1
                    series.placeOutSideLabels(usedPointsG, usedR);// step 2

                    if (series.testWithinBounds(usedPointsG, center, bounds)) {// step 3
                        break;
                    }
                }
                return usedR;
            }
        },

        calculateInsideLabelBounds:function(inPoints){
            var series = this;
            inPoints.map(function (a,i) {
                var node = inPoints[i];
                var centerArc = series.getCenterAngle(node);

                var innerRadius = series._getInnerRadius(node),
                    outerRadius = series._getOuterRadius(node);
                var tmpR = innerRadius + (outerRadius - innerRadius) / 2;

                var center = series._getArcPoint(tmpR, centerArc);

                var x = center[0] - node.labelDim.width/2;
                var y = center[1] - node.labelDim.height/2;

                node.labelPos = {x:x, y:y};
            });
        },

        calculateLeadLineStartPos:function(outPoints){
            var series = this;
            outPoints.map(function(arcPoint){
                var radius = series._getOuterRadius(arcPoint);
                var centerArc = series.getCenterAngle(arcPoint);

                if(arcPoint.labelPos){
                    arcPoint.labelPos.startPos = {
                        x: (radius + 1) * Math.sin(centerArc),
                        y: (radius + 1) * Math.cos(centerArc + Math.PI)
                    }
                }
            });
        },

        getCenterAngle:function(node){
            var rotate = this.chartInfo.rotate || 0;
            var centerAngle = rotate + (this._getStartAngle(node) + this._getEndAngle(node)) / 2 ;
            return BaseUtils.makeValueInRange(0, 2 * Math.PI, centerAngle);
        },

        getLocByArc: function (arc) {
            arc = arc % (2 * Math.PI);
            if(arc < Math.PI / 2){
                return RIGHT_TOP;
            }else if(arc < Math.PI){
                return RIGHT_BOTTOM;
            }else if(arc < 3 * Math.PI / 2){
                return LEFT_BOTTOM;
            }else{
                return LEFT_TOP;
            }
        },

        // ignore min for 4 parts
        ignoreMin: function (pointsGroups, radius) {
            var result = {};
            for (var i in pointsGroups) {
                pointsGroups[i].map(function (p) { p.labelPos = null; });
                result[i] = this._ignoreMinArcLabel(radius, pointsGroups[i]);
            }
            return result;
        },

        // ignore 1 part
        _ignoreMinArcLabel:function(radius, arcs){

            var totalHeight = 0;

            for(var i = 0, len = arcs.length; i < len; i++){
                var labelDim = arcs[i].labelDim;
                totalHeight += labelDim.height;
            }

            //高度不够，需要省略一些标签
            if(radius * 1.2 < totalHeight){

                var det = totalHeight - radius;

                arcs.sort(function(a, b){
                    return a.value - b.value;
                });

                for(var i = 0, len = arcs.length; i < len; i++){
                    if(det < 0){
                        break;
                    }
                    var labelHeight = arcs[i].labelDim.height;
                    det -= labelHeight;
                }

                arcs = arcs.slice(i, arcs.length);
            }

            var series = this;
            arcs.sort(function(a, b){
                return series.getCenterAngle(a) - series.getCenterAngle(b);
            });

            return arcs;
        },

        placeOutSideLabels: function (pointsGroups, radius) {
            var series = this;
            Object.keys(pointsGroups).map(function (key) {
                series.findNiceBounds(true, pointsGroups[key], radius, key) ||
                series.findNiceBounds(false, pointsGroups[key], radius, key)
            });
            // here MUST be true.
            // for we have ignored min arcs, the problem is how to place them.
            // the solution now is incomplete though.
            // return true;
        },

        findNiceBounds:function(isAngleIncrease, arcPoints, usedR, location){

            var outerR = usedR * 1.2;
            var hWidth = usedR * 0.1;

            var angleRange = this._getStartAndEndAngle(location);

            var searchEnd = isAngleIncrease ? angleRange.endAngle : angleRange.startAngle;
            var step = isAngleIncrease ? STEP : -STEP;

            var preBounds;
            var preArc;

            arcPoints.map(function (p) {
                p.labelPos = null;
            });

            for(var i = 0, len = arcPoints.length; i < len; i++){

                var pointIndex = isAngleIncrease ? i : len - i - 1;

                var compare = isAngleIncrease ? Math.max : Math.min;

                var point = arcPoints[pointIndex];

                var labelDim = point.labelDim;

                var centerArc = this.getCenterAngle(point);

                centerArc = preArc ? compare(centerArc, preArc) : centerArc;

                var found = false;
                for(var arc = centerArc; (isAngleIncrease ? arc < searchEnd : arc > searchEnd); arc += step){

                    var centerX = outerR * Math.sin(arc);
                    var centerY = outerR * Math.cos(arc + Math.PI);

                    var bounds = this._getLabelBounds(location, centerX, centerY, hWidth, labelDim);
                    if ((preBounds ? !this._isOverlapOrShadow(preBounds, bounds) : true)
                    ) {
                        found = true;
                        preArc = arc;
                        break;
                    }
                }

                if (!found) {
                    return false;
                }

                var midPos = {x:centerX, y:centerY};
                var endPos;
                if(location == RIGHT_TOP || location == RIGHT_BOTTOM){
                    endPos = {x:centerX + hWidth, y:centerY};
                }else{
                    endPos = {x:centerX - hWidth, y:centerY};
                }

                preBounds = bounds;
                point.labelPos = {
                    x:bounds.x,
                    y:bounds.y,

                    midPos:midPos,
                    endPos:endPos
                };
            }

            return true;
        },

        _getStartAndEndAngle:function(location){
            switch (location){
                case RIGHT_TOP:
                    return {startAngle:0, endAngle:Math.PI/2};
                case RIGHT_BOTTOM:
                    return {startAngle:Math.PI/2, endAngle:Math.PI};
                case LEFT_BOTTOM:
                    return {startAngle:Math.PI, endAngle:3 * Math.PI / 2};
                case LEFT_TOP:
                    return {startAngle:3 * Math.PI / 2, endAngle: 2 * Math.PI};
            }
        },

        _getLabelBounds:function(location, centerX, centerY, hWidth, labelDim){
            var x,y;
            if(location == RIGHT_TOP || location == RIGHT_BOTTOM){
                x = centerX + hWidth + LABEL_GAP;
            }else{
                x = centerX - hWidth - LABEL_GAP - labelDim.width;
            }

            y = centerY - labelDim.height/2;

            return {x:x, y:y, width:labelDim.width, height:labelDim.height};
        },

        // 1. judge overlapped
        // 2. the Y pos should not exceed the previous's half
        _isOverlapOrShadow: function (a, b) {
            var topHalfMinY = Math.max(a.y, b.y);
            var topHalfMaxY = Math.min(a.y + a.height / 2, b.y + b.height / 2);
            var bottomHalfMinY = Math.max(a.y + a.height / 2 , b.y + b.height / 2);
            var bottomHalfMaxY = Math.min(a.y + a.height, b.y + b.height);

            return BaseUtils.rectangleOverlapped(a, b) ||
                topHalfMinY <= topHalfMaxY || bottomHalfMinY <= bottomHalfMaxY;
        },

        testWithinBounds: function (pointsGroups, center, wholeBounds) {
            for (var i in pointsGroups) {
                var bounds, x, y, width, height;
                x = y = 0;
                switch (i) {
                    case RIGHT_TOP:
                    case RIGHT_BOTTOM:
                        y = wholeBounds.y - center[1];
                        width = wholeBounds.width + wholeBounds.x - center[0];
                        height = wholeBounds.height;
                        break;
                    case LEFT_BOTTOM:
                    case LEFT_TOP:
                        x = wholeBounds.x - center[0];
                        y = wholeBounds.y - center[1];
                        width = -x;
                        height = wholeBounds.height;
                        break;
                }
                bounds = {x: x, y: y, width: width, height: height};

                for (var j = 0; j < pointsGroups[i].length; j++) {
                    var p = pointsGroups[i][j];
                    if (!p.labelPos) {
                        continue;
                    }
                    var pBounds = {
                        x: p.labelPos.x,
                        y: p.labelPos.y,
                        width: p.labelDim.width,
                        height: p.labelDim.height
                    };
                    if (!BaseUtils.containsRect(bounds, pBounds)) {
                        return false;
                    }
                }
            }
            return true;
        },

        _getInnerRadius: function (d) {
            return d.innerRadius;
        },

        _getOuterRadius: function (d) {
            return d.outerRadius;
        },

        _getStartAngle: function (d) {
            return d.startAngle;
        },

        _getEndAngle: function (d) {
            return d.endAngle;
        },

        _getPercentValue:function(value, total){
            if(value){
                value += '';
                if(value.indexOf('%') != -1){
                    value = parseFloat(value) * total / 100;
                }
                return parseFloat(value);
            }
            return 0;
        },

        remove:function(){

            this._canvas && this._canvas.remove();
            this.textGraphicGroup && this.textGraphicGroup.remove();
            this.group && this.group.remove();

            this.textGraphicGroup = this._canvas = this.group = null;
        },

        getPressedStyle:function(){
            return null;
        },

        onPointPress:function(){
            var point = this, series = point.series, style = series.getPressedStyle(point);
            if(style){
                point.graphic.style(style);
            }
        },

        onPointPressUp:function(){
            var point = this, series = point.series, style = series.getHighLightStyle(point);
            if(style){
                point.graphic.style(style);
            }
        },

        //默认鼠标悬浮到数据点上的时候没有效果
        onPointMouseOver:function(){

        },

        onPointMouseOut:function(){

        },

        getClosestPoint:function(){
            return null;
        }
    });

    return Series;
});

/**
 * Created by eason on 15/5/4.
 */
define('chart/Bar',['require','../utils/BaseUtils','../utils/ColorUtils','../Constants','../utils/QueryUtils','../utils/BezierEasing','./Series','../ComponentLibrary','../ChartLibrary','../ChartLibrary'],function(require){

    var BaseUtils = require('../utils/BaseUtils');
    var ColorUtils = require('../utils/ColorUtils');
    var Constants = require('../Constants');
    var QueryUtils = require('../utils/QueryUtils');
    var BezierEasing = require('../utils/BezierEasing');
    var Series = require('./Series');
    var ComponentLibrary = require('../ComponentLibrary');

    var INIT_ANIMATION_TIME = 400;
    var EXIT_ANIMATION_TIME = 150;
    var UPDATE_ANIMATION_TIME = 250;

    var CHOSEN_STROKE_WIDTH = 6;
    var CHOSEN_STROKE_OPACITY = 0.35;

    var TOOLTIP_GAP = 1;
    var LABEL_GAP = 3;
    var MIN_BAR_SIZE = 2;

    var Bar = Series.extend({

        _refresh:function(){
            var queryList = this._getQueryList();
            BaseUtils.extend(this, {
                width:QueryUtils.queryList(queryList, 'width'),
                categoryGap:QueryUtils.queryList(queryList, 'categoryGap') || '20%',
                gap:QueryUtils.queryList(queryList, 'gap') || '20%'
            });
        },

        doLayout:function(){

            var ow = this.getSeriesOffsetAndWidth();
            var series = this, vanchart = series.vanchart;
            var isColumn = series.type == Constants.COLUMN_CHART, inverted = vanchart.isInverted();
            var startKey = 'x', stackKey = 'y';
            if(!isColumn){
                startKey = 'y'; stackKey = 'x';
            }

            var showAsColumn = (isColumn && !inverted) || (!isColumn && inverted);

            var baseAxis = series[startKey + 'Axis'];
            var stackAxis = series[stackKey + 'Axis'];

            this.points.forEach(function(point){
                var strokeWidth = point.borderWidth;

                var startPos = baseAxis.scale(baseAxis.getAxisValue(point[startKey], point));
                var stackPrePos = stackAxis.scale(point[stackKey + '0']);
                var stackCurrentPos = stackAxis.scale(stackAxis.getAxisValue(point[stackKey], point) + point[stackKey + '0']);

                if (stackPrePos === Infinity) {
                    stackPrePos = stackAxis.scale.range()[0];
                }

                var rectX, rectY, rectWidth, rectHeight;
                rectX = startPos + ow.offset - ow.width/2;
                rectY = Math.min(stackPrePos, stackCurrentPos);
                rectWidth = ow.width;
                rectHeight = Math.abs(stackPrePos - stackCurrentPos);

                var rect = {};
                if(showAsColumn){
                    rect.x = rectX; rect.y = rectY; rect.width = rectWidth; rect.height = rectHeight;
                }else{
                    rect.x = rectY; rect.y = rectX; rect.width = rectHeight; rect.height = rectWidth;
                }

                point.rect = BaseUtils.rectSubPixelOpt(rect, strokeWidth);
                point.rect.rx = point.rect.ry = point.borderRadius;

                series._calculateAnimationInitRect(point, isColumn, inverted);
            });

        },

        getSeriesOffsetAndWidth:function(){
            var series = this;
            var columnCount = 0, stackedMap = {};
            var columnIndex = 0;//start from 0
            var allPointsCount = 0;

            var chartSeries = this.vanchart.series[this.type];

            var baseAxisType = this.getBaseAxisType();

            chartSeries.forEach(function(otherSeries){

                if(otherSeries[baseAxisType] == series[baseAxisType] && otherSeries.visible){

                    if(otherSeries.stack && !stackedMap[otherSeries.stack]){
                        columnCount++;
                        stackedMap[otherSeries.stack] = true;
                    }else if(!otherSeries.stack){
                        columnCount++;
                    }

                    if(series == otherSeries){
                        columnIndex = columnCount - 1;
                    }
                }

                if(otherSeries[baseAxisType] == series[baseAxisType]){
                    allPointsCount += otherSeries.points.length;
                }
            });

            var categoryAxis = series[baseAxisType];

            var tickLength = categoryAxis.getTickLength();//分类轴是一个分类的宽度，值轴日期轴是整个坐标轴的宽度

            var width = 0, offset = 0;

            if(categoryAxis.type == ComponentLibrary.CATEGORY_AXIS_COMPONENT) {

                var categoryGap = series.categoryGap;
                var gap = series.gap;

                categoryGap = BaseUtils.getPercentValue(categoryGap, tickLength);

                width = (tickLength - categoryGap) / columnCount;

                offset = categoryGap / 2 + width * (columnIndex + 0.5);

                gap = BaseUtils.getPercentValue(gap, width);

                width -= gap;
            } else {
                width = tickLength/allPointsCount/3;
                offset = 0;
            }

            return {
                width:BaseUtils.hasDefined(series.width) ? series.width : Math.max(width, MIN_BAR_SIZE),
                offset:offset
            }
        },

        _getPointKey: function (point) {
            return this.type == Constants.BAR_CHART ? point.y : point.x;
        },

        getTargetKey:function(){
            return this.type == Constants.BAR_CHART  ? 'x' : 'y';
        },

        //图形坐在的那个坐标轴的key
        getBaseAxisType: function () {
            return this.type == Constants.COLUMN_CHART ? 'xAxis' : 'yAxis';
        },

        getTrendLineXYValues:function(sery){

            var xValues = [];
            var yValues = [];

            var points = sery.points;
            var valueAxis = sery.type == Constants.COLUMN_CHART ? sery.yAxis : sery.xAxis;
            var baseAxis = sery.type == Constants.COLUMN_CHART ? sery.xAxis : sery.yAxis;
            var isHorizontal = baseAxis.isHorizontal(), isAxisReversed = valueAxis.isAxisReversed();

            var bars = [];

            for(var i = 0, len = points.length; i < len; i++){
                var point = points[i];
                if(!point.isNull && point.rect){
                    bars.push(point.rect);
                }
            }

            bars.sort(function(a, b){
                return isHorizontal ? a.x - b.x : a.y - b.y;
            });

            bars.forEach(function(barShape){
                var x, y;

                if(isHorizontal){
                    x = barShape.x + barShape.width / 2;
                    y = isAxisReversed ? barShape.y + barShape.height : barShape.y;
                }else{
                    x = isAxisReversed ? barShape.x : barShape.x + barShape.width;
                    y = barShape.y + barShape.height/2;
                }

                xValues.push(x);
                yValues.push(y);
            });

            return [xValues, yValues, baseAxis.getPosition()];
        },

        _calculateAnimationInitRect:function(point, isColumn, inverted){

            var key = isColumn ? 'y' : 'x';
            var valueAxis = point.series[key + 'Axis'], value = valueAxis.getAxisValue(point[key], point);
            var startPos = valueAxis.getStartPos(), isPositive = value >= 0;
            var showAsColumn = (isColumn && !inverted) || (!isColumn && inverted);
            var location, initRect;

            if(showAsColumn){
                if(isPositive ^ valueAxis.isAxisReversed()){
                    location = Constants.BOTTOM_TO_TOP;
                    initRect = {
                        x:point.rect.x,
                        y:startPos,
                        width:point.rect.width,
                        height:0
                    };
                }else{
                    location = Constants.TOP_TO_BOTTOM;
                    initRect = {
                        x:point.rect.x,
                        y:point.rect.y,
                        width:point.rect.width,
                        height:0
                    };
                }
            }else{
                if(isPositive ^ valueAxis.isAxisReversed()){
                    location = Constants.LEFT_TO_RIGHT;
                    initRect = {
                        x:point.rect.x,
                        y:point.rect.y,
                        width:0,
                        height:point.rect.height
                    };
                }else{
                    location = Constants.RIGHT_TO_LEFT;
                    initRect = {
                        x:point.rect.x + point.rect.width,
                        y:point.rect.y,
                        width:0,
                        height:point.rect.height
                    };
                }
            }

            point.location = location; point.initRect = initRect;
        },

        _getFixedPos:function(point, divDim){

            var plotBounds = this.vanchart.getPlotBounds();
            var x,y, rect = point.rect;
            if(point.initRect.height == 0){
                //柱形图
                x = plotBounds.x + rect.x + rect.width + TOOLTIP_GAP;
                y = plotBounds.y + rect.y;
            }else{
                //条形图
                x = plotBounds.x + rect.x + rect.width - divDim.width;
                y = plotBounds.y + rect.y + rect.height + TOOLTIP_GAP;
            }
            return [x, y];
        },

        //计算标签的位置
        _calculateLabelPos:function(manager){

            var series = this;

            series.points.forEach(function(point){
                var dataLabels = point.dataLabels;
                if(dataLabels && dataLabels.enabled){
                    var pos;
                    if(dataLabels.align){
                        pos = series._calculateAlignLabelPos(point, dataLabels.align);
                    }
                    //如果没有设置对齐方式,就按照自动调整
                    if(dataLabels.autoAdjust){
                        pos = series._calculateAutoLabelPos(point, pos, manager);
                    }

                    if(pos){
                        point.labelPos = pos;
                        manager.addBounds(BaseUtils.makeBounds(point.labelPos, point.labelDim));
                    }

                }
            });
        },

        _calculateAutoLabelPos:function(point, pos, manager){

            var step = 3; //自动调整的时候每次3px
            //先测试一下从上往下的效果
            var labelDim = point.labelDim, rect = point.rect;
            var centerX = rect.x + rect.width/2, centerY = rect.y + rect.height/2;
            var plotBounds = this.vanchart.getPlotBounds();

            var isVertical = point.location == Constants.TOP_TO_BOTTOM || point.location == Constants.BOTTOM_TO_TOP;
            var isPositive = point.location == Constants.BOTTOM_TO_TOP || point.location == Constants.LEFT_TO_RIGHT;

            function verticalPosFix(start, end, step, labelDim){
                for(var y = start; (step < 0 ? y > end : y < end); y += step){
                    var labelPos = {x: centerX - labelDim.width/2, y: y};
                    var heightFix = (y + labelDim.height) < plotBounds.height;
                    if(!manager.isOverlapped(BaseUtils.makeBounds(labelPos, labelDim)) && heightFix){
                        return labelPos;
                    }
                }
            }

            function horizontalFix(start, end, step, labelDim){
                for(var x = startX; (step < 0 ? x > end : x < end); x += step){
                    var labelPos = {x:x, y: centerY - labelDim.height/2};
                    var widthFix = x + labelDim.width < plotBounds.width;
                    if(!manager.isOverlapped(BaseUtils.makeBounds(labelPos, labelDim)) && widthFix){
                        return labelPos;
                    }
                }
            }

            var testPos;
            if(isVertical){
                var startY, endY;

                //往下
                startY = Math.max(0, (pos && pos.y) || rect.y);
                endY = (isPositive ? rect.y + rect.height : plotBounds.height);
                testPos = verticalPosFix(startY, endY, step, labelDim);

                //往上
                if(!testPos){
                    endY = isPositive ? 0 : rect.y;
                    testPos = verticalPosFix(startY, endY, -step, labelDim);
                }

            }else{
                var startX, endX;

                //往右
                startX = Math.max(0, (pos && pos.x) || rect.x);
                endX = isPositive ? plotBounds.width : (rect.x + rect.width);
                testPos = horizontalFix(startX, endX, step, labelDim);

                //往左
                if(!testPos){
                    endX = isPositive ? rect.x : 0;
                    testPos = horizontalFix(startX, endX, -step, labelDim);
                }
            }

            return testPos ? testPos : pos;
        },

        _calculateAlignLabelPos:function(point, align){

            var labelDim = point.labelDim, rect = point.rect, plotBounds = this.vanchart.getPlotBounds();
            var plotWidth = plotBounds.width, plotHeight = plotBounds.height;

            var isVertical = point.location == Constants.TOP_TO_BOTTOM || point.location == Constants.BOTTOM_TO_TOP;
            var isPositive = point.location == Constants.BOTTOM_TO_TOP || point.location == Constants.LEFT_TO_RIGHT;
            var centerX = rect.x + rect.width/2, centerY = rect.y + rect.height/2;

            var x,y;

            switch (align){
                case Constants.CENTER:

                    x = centerX - labelDim.width/2;
                    y = centerY - labelDim.height/2;

                    break;
                case Constants.INSIDE:

                    if(isVertical){
                        x = centerX - labelDim.width/2;
                        y = isPositive ? rect.y + LABEL_GAP : rect.y + rect.height - LABEL_GAP - labelDim.height;
                    }else{
                        y = centerY - labelDim.height/2;
                        x = isPositive ?  rect.x + rect.width - LABEL_GAP - labelDim.width : rect.x + LABEL_GAP;
                    }

                    break;
                case Constants.OUTSIDE:

                    if(isVertical){
                        x = centerX - labelDim.width/2;
                        y = isPositive ? rect.y - LABEL_GAP - labelDim.height : rect.y + rect.height + LABEL_GAP;
                    }else{
                        y = centerY - labelDim.height/2;
                        x = isPositive ? rect.x + rect.width + LABEL_GAP : rect.x - LABEL_GAP - labelDim.width;
                    }

                    break;
            }

            return {
                x:x,
                y:y
            }
        },

        _getMoreLabelDefaultCenter:function(d, moreLabelDim) {
            var isColumn = this.type == Constants.COLUMN_CHART, inverted = this.vanchart.isInverted();

            if((isColumn && !inverted) || (!isColumn && inverted)){
                return {
                    centerX: d.rect.x + d.rect.width / 2,
                    centerY: d.rect.y - moreLabelDim.height / 2
                }

            } else {
                return {
                    centerX: d.rect.x + d.rect.width + moreLabelDim.width / 2,
                    centerY: d.rect.y + d.rect.height / 2
                }
            }
        },

        getInitShowTime: function () {
            return INIT_ANIMATION_TIME;
        },

        getReAppearTime: function () {
            return INIT_ANIMATION_TIME + EXIT_ANIMATION_TIME;
        },

        getDropTime: function () {
            return EXIT_ANIMATION_TIME;
        },

        getStyle:function(p){
            return {
                'fill':p.series.getFillFilter(p.color, p),
                'fill-opacity': p.image ? 1 : p.opacity,
                'stroke':p.borderColor,
                'stroke-opacity': p.borderOpacity,
                'stroke-width':p.borderWidth
            }
        },

        getAttrs:function(p){
            return p.rect;
        },

        getPointGraphicKey:function(){
            return 'rect';
        },

        getHighLightStyle:function(p){
            return {
                'stroke':p.mouseOverColor || p.color,
                'fill':p.series.getFillFilter(p.mouseOverColor || p.color, p),
                'fill-opacity': p.opacity,
                'stroke-width':CHOSEN_STROKE_WIDTH,
                'stroke-opacity':  p.opacity == 0 ? 0 : CHOSEN_STROKE_OPACITY
            }
        },

        getPressedStyle:function(p){
            return {
                'fill':p.series.getFillFilter(p.clickColor, p),
                'fill-opacity': p.clickOpacity
            }
        },

        getFillFilter:function(color, p){

            if(BaseUtils.isSupportSVG()){
                var series = this, vanchart = series.vanchart, renderer = vanchart.renderer;

                if(p.image){

                    var imageX, imageY, rect = p.rect;
                    switch (p.location){
                        case Constants.BOTTOM_TO_TOP:
                            imageX = rect.x;
                            imageY = rect.y + rect.height % p.imageHeight;
                            break;

                        case Constants.TOP_TO_BOTTOM:
                        case Constants.LEFT_TO_RIGHT:
                            imageX = rect.x;
                            imageY = rect.y;
                            break;

                        case Constants.RIGHT_TO_LEFT:
                            imageX = rect.x + rect.width % p.imageWidth;
                            imageY = rect.y;
                            break;
                    }

                    var patterAttr = {
                        'x':imageX, 'y':imageX, 'width':p.imageWidth, 'height':p.imageHeight,'patternUnits':'userSpaceOnUse'
                    };

                    var imageAttr = {
                        'x':0, 'y':0, 'width':p.imageWidth, 'height':p.imageHeight, 'href':p.image
                    };

                    if(!p.imagePattern){
                        p.imagePattern = renderer.imagePattern(patterAttr, imageAttr);
                    }else{
                        renderer.updateImagePattern( p.imagePattern, patterAttr, imageAttr);
                    }

                    return "url(#" + BaseUtils.stamp(p.imagePattern) +")";

                }else if(p.style == Constants.STYLE_GRADUAL){
                    var x1, y1, x2, y2;
                    x1 = y1 = x2 = y2 = '0%';
                    switch (p.location){
                        case Constants.BOTTOM_TO_TOP:
                            y1 = '100%';
                            break;
                        case Constants.TOP_TO_BOTTOM:
                            y2 = '100%';
                            break;
                        case Constants.LEFT_TO_RIGHT:
                            x2 = '100%';
                            break;
                        case Constants.RIGHT_TO_LEFT:
                            x1 = '100%';
                            break;
                    }

                    var attrs = {'x1':x1, 'y1':y1, 'x2':x2, 'y2':y2};
                    var stop1 = {'offset':'0%', 'stop-color':color};
                    var stop2 = {'offset':'100%', 'stop-color':ColorUtils.getColorWithDivider(color, 0.9)};

                    if(p.colorGradient){
                        renderer.updateColorGradient(p.colorGradient, attrs, [stop1, stop2])
                    }else{
                        p.colorGradient = renderer.colorGradient(attrs, [stop1, stop2]);
                    }

                    return "url(#" + BaseUtils.stamp(p.colorGradient) +")";
                }
            }

            return color;
        },

        _calculateAnimationDelay:function(){
            if(this.stack){
                return 0;
            }

            if(this.state == Constants.STATE_SHOW){
                var chartSeries = this.vanchart.series[this.type];
                for(var i = 0, len = chartSeries.length; i < len; i++){
                    if(chartSeries[i].state == Constants.STATE_TO_DROP){
                        return EXIT_ANIMATION_TIME;
                    }
                }
            }else if(this.state == Constants.STATE_TO_SHOW){
                return UPDATE_ANIMATION_TIME;
            }
            return 0;
        },

        //onPointXXX的方法,this 指向的是Point
        onPointMouseOver:function(ev){
            var point = this, series = point.series, animation = series.animation, style = series.getHighLightStyle(point);
            if(animation){
                d3.select(point.graphic.rawElement)
                    .style({'stroke': point.mouseOverColor || point.color})
                    .interrupt(Constants.SELECT_ANIMATION)
                    .transition(Constants.SELECT_ANIMATION)
                    .duration(100).ease('ease-out-in').style(style);
            }else{
                point.graphic.style(style)
            }
        },

        onPointMouseOut:function(ev){
            var point = this, series = point.series, animation = series.animation, style = series.getStyle(point);
            if(animation){
                d3.select(point.graphic.rawElement)
                    .interrupt(Constants.SELECT_ANIMATION)
                    .transition(Constants.SELECT_ANIMATION)
                    .duration(100).ease('ease-out-in').style(style);
            }else{
                point.graphic.style(style)
            }
        },

        updateAnimation:function(dom, point, delay){
            var rect = point.rect;
            dom._current_ = rect;
            d3.select(dom)
                .transition().ease(BezierEasing.css.swing).duration(UPDATE_ANIMATION_TIME).delay(delay)
                .attr('x', rect.x).attr('y', rect.y)
                .attr('width', rect.width).attr('height', rect.height);
        },

        createAnimation:function(dom, point, delay){
            var rect = point.rect, initRect = point.initRect;
            dom._current_ = rect;
            d3.select(dom)
                .attr('rx', point.borderRadius)
                .attr('ry', point.borderRadius)
                .attr('x', initRect.x).attr('y', initRect.y)
                .attr('width', initRect.width).attr('height', initRect.height)
                .transition()
                .ease(BezierEasing.css.swing)
                .duration(INIT_ANIMATION_TIME).delay(delay)
                .attr('x', rect.x).attr('y', rect.y)
                .attr('width', rect.width).attr('height', rect.height)
        },

        dropAnimation:function(dom, point, delay){
            var rect = point.initRect;
            d3.select(dom).transition().duration(EXIT_ANIMATION_TIME).delay(delay)
                .ease(BezierEasing.css.swing)
                .attr('x', rect.x).attr('y', rect.y)
                .attr('width', rect.width).attr('height', 0)
                .remove();
        }

    });

    require('../ChartLibrary').register(Constants.BAR_CHART, Bar);
    require('../ChartLibrary').register(Constants.COLUMN_CHART, Bar);

    return Bar;
});
/**
 * Created by eason on 15/7/13.
 */

define('chart/Pie',['require','../Constants','../utils/BaseUtils','../utils/ColorUtils','./Series','../utils/QueryUtils','../utils/BoundsManager','../utils/BezierEasing','../ChartLibrary'],function(require){

    var Constants = require('../Constants');
    var BaseUtils = require('../utils/BaseUtils');
    var ColorUtils = require('../utils/ColorUtils');
    var Series = require('./Series');
    var QueryUtils = require('../utils/QueryUtils');
    var BoundsManager = require('../utils/BoundsManager');
    var Bezier = require('../utils/BezierEasing');

    var CIRCLE = 2 * Math.PI;
    var HOVER_PERCENT = 1.1;
    var MAGIC_DET = 3;//很奇怪的3px
    
    var ANIMATION_TIME = 1000;
    var EASE = 'bounce';

    var SORT_EASE = Bezier.css.swing;
    var SORT_TIME = 400;

    var Pie = Series.extend({
        _refresh:function(){
            var queryList = this._getQueryList();
            var startAngle = QueryUtils.queryList(queryList, 'startAngle') || 0;
            var endAngle = QueryUtils.queryList(queryList, 'endAngle') || 360;
            if(startAngle > endAngle){
                startAngle -= 360;
            }else if(startAngle == endAngle){
                startAngle = 0;
                endAngle = 360;
            }
            
            var center = QueryUtils.queryList(queryList, 'center');
            if(center){
                center[0] = this._getPercentValue(center[0], this.vanchart.width);
                center[1] = this._getPercentValue(center[1], this.vanchart.height);
            }

            BaseUtils.extend(this, {
                startAngle:BaseUtils.toRadian(startAngle),
                endAngle:BaseUtils.toRadian(endAngle),
                center:center,
                radius:QueryUtils.queryList(queryList, 'radius'),
                innerRadius:QueryUtils.queryList(queryList, 'innerRadius') || 0,
                roseType:QueryUtils.queryList(queryList, 'roseType'),
                rotatable:QueryUtils.queryList(queryList, 'rotatable'),
                style:this.vanchart.currentOption.style
            });
        },

        _getAxisTypes:function(){
            return [];
        },

        doLayout:function(){

            //计算整个圆的位置和大小
            var seriesBounds = this._calculateSeriesBounds(), pie = this;
            if(!seriesBounds && (!this.radius && !this.center)){
                throw new Error('pie has no bounds');
            }
            var centerX, centerY, radius;
            if(seriesBounds){
                radius = Math.min(seriesBounds.width/2, seriesBounds.height/2);
                centerX = seriesBounds.x + seriesBounds.width/2;
                centerY = seriesBounds.y + seriesBounds.height/2;
                this.bounds = seriesBounds;
            }else{
                radius = this.radius; centerX = this.center[0]; centerY = this.center[1];
            }
            var rotate = this.chartInfo && this.chartInfo.rotate || 0;
            this.chartInfo = {radius:radius, centerX:centerX, centerY:centerY, rotate:rotate};

            //计算每个扇形的大小
            var pieLayout = d3.layout.pie()
                .value(function(d){
                    return pie.roseType == Constants.SAME_ARC ? 1 : Math.abs(d.getTargetValue());
                })
                .startAngle(pie.startAngle).endAngle(pie.endAngle).sort(null);

            var points = this.points.filter(function(p){return p.visible});
            var series = this;

            points.forEach(function(point){
                point.lastShape = series._getArcData(point);
            });

            var pieData = pieLayout(points);
            pieData.forEach(function(slice){
                var point = slice.data;
                point.startAngle = isNaN(slice.startAngle) ? 0 : slice.startAngle;
                point.endAngle = isNaN(slice.endAngle) ? 0: slice.endAngle;
            });
        },

        _getFixedPos:function(datum, divDim){

            var plotBounds = this.vanchart.getPlotBounds();

            var pieConfig = datum.series.chartInfo;

            var translateX = pieConfig.centerX;
            var translateY = pieConfig.centerY;

            var centerAngle = this.getCenterAngle(datum);
            var radius = datum.outerRadius * HOVER_PERCENT;

            var centerX = radius * Math.sin(centerAngle) + translateX;
            var centerY = radius * Math.cos(centerAngle + Math.PI) + translateY;

            if(centerAngle < Math.PI / 2){
                centerY -= divDim.height;
            }else if(centerAngle >= Math.PI && centerAngle < 3 * Math.PI / 2){
                centerX -= divDim.width;
            }else if(centerAngle >= 3 * Math.PI / 2 && centerAngle < CIRCLE){
                centerY -= divDim.height;
                centerX -= divDim.width;
            }

            return [centerX, centerY];
        },

        _calculateLabelPos:function(){
            var roseType = this.roseType, points = this.points.filter(function(d){return d.visible});
            var outPoints = [], inPoints = [];
            for(var i = 0, len = points.length; i < len; i++){
                var point = points[i];
                var dataLabels = point.dataLabels;
                if(point.visible && dataLabels && dataLabels.enabled){
                    dataLabels.align == Constants.OUTSIDE ? outPoints.push(point) : inPoints.push(point);
                }
            }

            //这步会改变半径
            this._calculateOutsideLabelBounds(outPoints);

            if (!this.radius) {
                //有标签在里面,没有标签在外面或者不显示标签
                if ((inPoints.length && !outPoints.length) || (!inPoints.length && !outPoints.length)) {
                    this.chartInfo.radius = this.chartInfo.radius / HOVER_PERCENT - MAGIC_DET;
                }
            }


            //内径可能是半径的占比
            var innerRadius = 0, radius = this.chartInfo.radius;

            if(this.innerRadius){
                if(typeof this.innerRadius == 'string' && this.innerRadius.indexOf('%') != -1){
                    innerRadius = parseFloat(this.innerRadius) * radius / 100;
                }else{
                    innerRadius = parseFloat(this.innerRadius);
                }
            }

            this.chartInfo.innerRadius = innerRadius;

            this.points.forEach(function(d){
                d.innerRadius = innerRadius;
            });

            //玫瑰图根据最后的半径值来确定不同扇形的半径
            if(roseType){
                var radiusGap = radius - innerRadius;
                var maxValue = 0;
                points.forEach(function(d){
                    maxValue = Math.max(maxValue, Math.abs(d.getTargetValue()));
                });
                var sizePerValue = radiusGap / maxValue;
                //maxValue为0之类的情况
                if(isNaN(sizePerValue) || !isFinite(sizePerValue)){
                    sizePerValue = 0;
                }
                points.forEach(function(d){
                    d.outerRadius = innerRadius + sizePerValue * Math.abs(d.getTargetValue());
                })
            }else{
                points.forEach(function(d){d.outerRadius = radius;});
            }

            this.calculateLeadLineStartPos(outPoints);

            //确定半径以后计算标签在内的标签
            this.calculateInsideLabelBounds(inPoints);
        },

        _calculateLabelPosWhenRadiusFixed:function(){
            var points = this.points.filter(function(d){return d.visible});
            var outPoints = [], inPoints = [];
            for(var i = 0, len = points.length; i < len; i++){
                var point = points[i];
                var dataLabels = point.dataLabels;
                if(dataLabels && dataLabels.enabled){
                    dataLabels.align == Constants.OUTSIDE ? outPoints.push(point) : inPoints.push(point);
                }
            }

            this._calculateLabelBoundsForFixed([this.chartInfo.centerX, this.chartInfo.centerY], this.chartInfo.radius, outPoints);

            this.calculateLeadLineStartPos(outPoints);

            //确定半径以后计算标签在内的标签
            this.calculateInsideLabelBounds(inPoints);
        },

        _calculateOutsideLabelBounds:function(outPoints){
            if(!outPoints.length){
                return ;
            }

            //清空计算结果
            outPoints.forEach(function(arc){arc.labelPos = null;});

            var chartInfo = this.chartInfo;
            var radius = chartInfo.radius;
            var center = [chartInfo.centerX, chartInfo.centerY];

            if (this.center && this.radius) {
                this.calcOutsideLabel(outPoints, this.bounds, center, radius);
            } else {
                this.chartInfo.radius = this.calcOutsideLabel(outPoints, this.bounds, center);
            }
        },

        //对于固定半径和圆心,计算牵引线的位置
        _calculateLabelBoundsForFixed:function(center, radius, outPoints){
            var chartInfo = this.chartInfo;
            var radius = chartInfo.radius;
            var center = [chartInfo.centerX, chartInfo.centerY];

            this.calcOutsideLabel(outPoints, this.bounds, center, radius);
        },

        //计算每个系列的边界,要么定义了圆心和半径,作为悬浮元素处理,要么两者都不定义,自定平分区域
        //只定义半径没定义圆心,或者只定义了圆心没有定义半径,效果都是未知的
        _calculateSeriesBounds:function(){
            var series = this.vanchart.series[Constants.PIE_CHART];
            var plotBounds = this.vanchart.getPlotBounds();
            var fixedSize = 0;

            for(var i = 0, len = series.length; i < len; i++){
                if(series[i].center && series[i].radius){
                    fixedSize++;
                }
            }

            //平均半径
            var averageSize = plotBounds.width / Math.max(1, series.length - fixedSize);

            for(var i = 0, len = series.length; i < len; i++){
                if(series[i] == this){
                    if(!this.center && !this.radius){
                        return {
                            x:plotBounds.x + i * averageSize,
                            y:plotBounds.y,
                            width:averageSize,
                            height:plotBounds.height
                        }
                    }
                }
            }
        },

        _getTranslate:function(){
            return [this.chartInfo.centerX, this.chartInfo.centerY];
        },

        _getArcData:function(d){
            if(BaseUtils.hasDefined(d.startAngle)){
                return {
                    startAngle: d.startAngle,
                    endAngle: d.endAngle,
                    outerRadius:d.outerRadius
                };
            }
        },

        _getMoreLabelDefaultCenter:function(d, moreLabelDim) {
            var centerAngle = this.getCenterAngle(d);
            var tmpR = d.series.chartInfo.innerRadius + (d.outerRadius - d.series.chartInfo.innerRadius) / 2;
            var pos = this._getArcPoint(tmpR, centerAngle);
            return {
                centerX: pos[0],
                centerY: pos[1]
            }
        },

        getStyle:function(p){
            return {
                'fill':p.series.getFillFilter(p.color, p),
                'fill-opacity':p.opacity,
                'stroke':p.borderColor,
                'stroke-opacity':p.borderOpacity,
                'stroke-width':p.borderWidth
            }
        },

        getPressedStyle:function(p){
            return {
                'fill':p.clickColor,
                'fill-opacity': p.clickOpacity
            }
        },

        getAttrs:function(p){
            var arc = d3.svg.arc().innerRadius(p.innerRadius);
            return {'d':arc(this._getArcData(p))};
        },

        getPointGraphicKey:function(){
            return 'path';
        },

        _getPositionInPie:function(absPos){

            var x = absPos[0] - this.chartInfo.centerX;

            var y = absPos[1] - this.chartInfo.centerY;

            return [x, y];
        },

        _rotateLabels:function(){
            var series = this, vanchart = series.vanchart, renderer = vanchart.renderer, group = this.textLabelGroup;
            series.points.forEach(function(point){

                if(point.textGraphic && !point.labelPos){
                    point.textGraphic.remove();
                    point.leadLine && point.leadLine.remove();
                    point.textGraphic = null, point.leadLine = null;
                }else if(point.textGraphic && point.labelPos){

                    point.textGraphic.attr('transform', BaseUtils.makeTranslate(point.labelPos));

                    if(point.labelPos.startPos){
                        if(point.leadLine){
                            point.leadLine.attr('d', series._getLeadLinePath(point));
                        }else{
                            point.leadLine = series._getLeadLine(point);
                        }
                    }
                }else if(!point.textGraphic && point.labelPos){
                    series._createTextGraphic(point);
                }
            });
        },

        _calculateAnimationDelay:function(){

            var visiblePoint = 0, graphicCount = 0;
            for(var i = 0, len = this.points.length; i < len; i++){
                var point = this.points[i];
                if(point.visible && point.series.visible){
                    visiblePoint++;
                }

                if(point.graphic){
                    graphicCount++;
                }
            }

            return graphicCount == visiblePoint ? 0 : 1;
        },

        _createGroup: function (renderer, vanchart) {
            return renderer.group().addTo(vanchart.seriesGroup);
        },

        updateAnimation:function(dom, point, delay){
            var series = point.series, startAngle = series.startAngle, endAngle = series.endAngle;
            var arc = d3.svg.arc().innerRadius(series.chartInfo.innerRadius);
            var easeFunc = EASE, animationTime = ANIMATION_TIME;

            if(!delay){//排序的动画
                easeFunc = SORT_EASE, animationTime = SORT_TIME;
            }

            d3.select(dom).transition().ease(easeFunc).duration(animationTime)
                .attrTween("d", function () {

                    var arcData = series._getArcData(point), currentArc = this._current_ || arcData;

                    var interpolate = d3.interpolate(currentArc, arcData);

                    this._current_ = interpolate(1);

                    return function (t) {
                        return arc(interpolate(t));
                    };
                });

        },

        createAnimation:function(dom, point){
            var series = point.series, startAngle = series.startAngle, endAngle = series.endAngle;
            var arc = d3.svg.arc().innerRadius(series.chartInfo.innerRadius);

            d3.select(dom).transition().ease(EASE).duration(ANIMATION_TIME)
                .attrTween("d", function () {

                    var currentArc = {startAngle: startAngle, endAngle: startAngle, outerRadius:point.outerRadius};

                    if(!series.initialAnimationMoving){
                        var prePoint = series.getPreVisiblePoint(point);
                        if(prePoint != 'first' && prePoint.lastShape){
                            var preGap = Math.abs(prePoint.lastShape.endAngle - prePoint.endAngle);
                            var sliceStart = point.startAngle + preGap;
                            currentArc = {startAngle: sliceStart, endAngle: sliceStart, outerRadius: point.outerRadius};
                        }
                    }

                    var interpolate = d3.interpolate(currentArc, series._getArcData(point));
                    this._current_ = interpolate(1);

                    return function (t) {
                        return arc(interpolate(t));
                    };
                });
        },


        dropAnimation:function(dom, point){
            var series = point.series, startAngle = series.startAngle, endAngle = series.endAngle;
            var arc = d3.svg.arc().innerRadius(series.chartInfo.innerRadius);

            d3.select(dom).transition().ease(EASE).duration(ANIMATION_TIME)
                .attrTween("d", function () {

                    var current = this._current_;

                    var prePoint = series.getPreVisiblePoint(point);

                    var terminateAngle = startAngle;

                    if(prePoint != 'first' && prePoint.lastShape){
                        var preGap = Math.abs(prePoint.lastShape.endAngle - prePoint.endAngle);
                        terminateAngle = point.startAngle + preGap;
                    }

                    var end = {startAngle: terminateAngle, endAngle: terminateAngle, outerRadius: current.outerRadius};

                    var interpolate = d3.interpolate(current , end);

                    return function (t) {
                        return arc(interpolate(t));
                    };
                })
                .remove();
        },

        getPreVisiblePoint:function(point){
            var points = point.series.points, prePoint = 'first';
            for(var i = 0, len = points.length; i < len; i++){
                if(points[i] != point){
                    if(points[i].visible){
                        prePoint = points[i];
                    }
                }else{
                    return prePoint;
                }
            }
            return prePoint;
        },

        getFillFilter:function(color, p){
            if(p.style == Constants.STYLE_GRADUAL && BaseUtils.isSupportSVG()){

                var series = this, vanchart = series.vanchart, renderer = vanchart.renderer;

                var attrs = {'cx':"0%", 'cy':"0%", 'r':Math.max(p.outerRadius, 0) + 'px', "gradientUnits":"userSpaceOnUse"};
                var stop1 = {'offset':(p.innerRadius / Math.max(p.outerRadius, 1)) * 100 + '%', 'stop-color':ColorUtils.getColorWithDivider(p.color, 0.8)};
                var stop2 = {'offset':'100%', 'stop-color':p.color};

                if(p.colorGradient){
                    renderer.updateColorGradient(p.colorGradient, attrs, [stop1, stop2])
                }else{
                    p.colorGradient = renderer.colorGradient(attrs, [stop1, stop2], 'radialGradient');
                }

                return "url(#" + BaseUtils.stamp(p.colorGradient) +")";
            }

            return color;
        },

        onPanStart:function(ev){
            if(!this.rotatable){
                return;
            }

            this.initPos = ev.containerPoint;

            this.initRotate = BaseUtils.toDegree(this.chartInfo.rotate);
        },

        onPanMove:function(ev){
            if(!this.rotatable){
                return;
            }

            var startAngle = this._getAngle(this._getPositionInPie(this.initPos), [0,0]);

            var newAngle = this._getAngle(this._getPositionInPie(ev.containerPoint), [0,0]);

            var rotate = newAngle - startAngle + this.initRotate;

            this.pathGroup.attr("transform", "rotate(" + rotate + ")");

            this.chartInfo.rotate = BaseUtils.toRadian(rotate);

            this._calculateLabelPosWhenRadiusFixed();

            this._rotateLabels();
        },

        //onPointXXX的方法,this 指向的是Point
        onPointMouseOver:function(){
            var point = this;
            point.series._onState.call(point, true);
        },

        onPointMouseOut:function(){
            var point = this;
            point.series._onState.call(point, false);
        },

        _onState:function(isChosen){
            var point = this, series = point.series, animation = series.animation;
            var arc = d3.svg.arc().innerRadius(point.innerRadius);
            var style = isChosen ? {'fill':point.mouseOverColor} : {'fill':point.color};
            var startRadius = point.outerRadius * HOVER_PERCENT, endRadius = point.outerRadius;
            if(isChosen){
                startRadius = point.outerRadius;endRadius = point.outerRadius * HOVER_PERCENT;
            }
            var interpolate = d3.interpolate(startRadius, endRadius), arcData = {startAngle:point.startAngle, endAngle:point.endAngle};
            if(animation){
                d3.select(point.graphic.style(style).rawElement)
                    .interrupt(Constants.SELECT_ANIMATION)
                    .transition(Constants.SELECT_ANIMATION)
                    .ease("elastic").duration(800)
                    .attrTween("d", function () {
                        return function (t) {
                            return arc.outerRadius(interpolate(t))(arcData);
                        };
                    });
            }else{
                point.graphic.style(style).attr('d', arc.outerRadius(endRadius)(arcData));
            }
        },

        _getPointGraphicGroup:function(){
            if(!this.pathGroup){
                this.pathGroup = this.vanchart.renderer.group().addTo(this.group);
            }
            return this.pathGroup;
        },

        _getPointTextLabelGroup:function(){

            if(!this.textLabelGroup){
                this.textLabelGroup = this.vanchart.renderer.vgroup().add();
                this.group.append(this.textLabelGroup.renderG);

                this.textLabelGroup.divG.attr('transform', BaseUtils.makeTranslate(this._getTranslate()));
            }

            return this.textLabelGroup;
        },

        onPanEnd:function(ev){
            this.vanchart.handler.panTarget = null;
        },

        getEvents:function(){
            return {
                'panstart':this.onPanStart,
                'panmove':this.onPanMove,
                'panend':this.onPanEnd
            }
        }

    });

    require('../ChartLibrary').register(Constants.PIE_CHART, Pie);

    return Pie;
});
/**
 * Created by eason on 15/7/17.
 */

define('chart/Line',['require','../Constants','../utils/BaseUtils','../utils/QueryUtils','./Series','../utils/Class','../utils/BezierEasing','../utils/ColorUtils','../ChartLibrary','../ChartLibrary'],function(require){

    var Constants = require('../Constants');
    var BaseUtils = require('../utils/BaseUtils');
    var QueryUtils = require('../utils/QueryUtils');
    var Series = require('./Series');
    var Class = require('../utils/Class');
    var Bezier = require('../utils/BezierEasing');
    var ColorUtils = require('../utils/ColorUtils');

    var LABEL_GAP = 2;
    var LINE_SHOW_TIME = 800;
    var LINE_UPDATE_TIME = 250;

    var CHOSEN_AREA_ALPHA = 0.65;

    var INIT_EASE = 'quad-in-out';
    var UPDATE_EASE = Bezier.css.swing;

    var calculateT = function(point){
        var det = point.indexFromLeft / point.series.points.length;
        return LINE_SHOW_TIME * (det < 0.5 ? Math.sqrt(det/2) : 1 - Math.sqrt(2 - 2*det)/2);
    };


    var Line = Series.extend({

        type:Constants.LINE_CHART,

        _refresh:function(){
            //系列的一些属性
            var queryList = this._getQueryList();
            BaseUtils.extend(this,
                {
                    lineWidth: QueryUtils.queryList(queryList, 'lineWidth'),
                    interpolate: this._getSeriesInterpolate(queryList),
                    connectNulls:QueryUtils.queryList(queryList, 'connectNulls'),
                    bands:QueryUtils.queryList(queryList, 'bands'),
                    inverted: QueryUtils.queryList(queryList, 'inverted')
                }
            );
        },

        doLayout:function(){

            var series = this, vanchart = series.vanchart;

            var xAxis = series.xAxis, yAxis = series.yAxis, connectNulls = series.connectNulls;
            var det = xAxis.scale.rangeBand ? xAxis.scale.rangeBand()/2 : 0;

            var validPoints = [];
            if(this.large){
                var xMap = {}, yMap = {};
                series.points.forEach(function(point){
                    var x = xAxis.scale(xAxis.getAxisValue(point.x, point)) + det;
                    var y = yAxis.scale(yAxis.getAxisValue(point.y, point) + point.y0), y0 = yAxis.scale(point.y0);
                    if (this.inverted) {
                        point.posX = y;
                        point.posY = x;
                        point.posY0 = y0;
                    } else {
                        point.posX = x;
                        point.posY = y;
                        point.posY0 = y0;
                    }
                    if(!xMap[point.posX] || !yMap[point.posY]){
                        xMap[point.posX] = true;
                        yMap[point.posY] = true;
                        validPoints.push(point);
                    }
                }, this);
            }else{
                validPoints = series.points;
            }

            var inOrder = true, points = [];

            validPoints.forEach(function(point, i){

                if(this.large){
                    x = point.posX, y = point.posY;
                }else{
                    var x = xAxis.scale(xAxis.getAxisValue(point.x, point)) + det;
                    var y = yAxis.scale(yAxis.getAxisValue(point.y, point) + point.y0), y0 = yAxis.scale(point.y0);
                    if (this.inverted) {
                        point.posX = y;
                        point.posY = x;
                        point.posY0 = y0;
                    } else {
                        point.posX = x;
                        point.posY = y;
                        point.posY0 = y0;
                    }
                }

                if(point.dataLabels && point.dataLabels.enabled){
                    point.labelPos = {
                        x: x - point.labelDim.width/2,
                        y:y  - LABEL_GAP - point.labelDim.height
                    };
                }

                point.indexFromLeft = i;//用来计算delay

                if(!connectNulls || (connectNulls && !point.isNull)){
                    if(points.length > 0){
                        inOrder = inOrder && points[points.length - 1].posX <= x;
                    }
                    points.push(point);
                }
            }, this);

            if(!inOrder){
                points.sort(function(p1, p2){return p1.posX - p2.posX;});
                points.forEach(function(point, i){
                    point.indexFromLeft = i;
                });
            }

            var lineGenerator = d3.svg.line().interpolate(series.interpolate)
                .x(function (d) {return d.posX;}).y(function (d) {return d.posY;})
                .defined(function (d) {return !d.isNull;});

            var areaGenerator =  d3.svg.area().interpolate(series.interpolate);
            if (this.inverted) {
                areaGenerator = areaGenerator
                    .y(function (d) { return d.posY })
                    .x0(function (d) { return d.posY0 })
                    .x1(function (d) { return d.posX })
            } else {
                areaGenerator = areaGenerator
                    .x(function (d) { return d.posX })
                    .y0(function (d) { return d.posY0 })
                    .y1(function (d) { return d.posY })
            }

            areaGenerator = areaGenerator.defined(function (d) {return !d.isNull;});

            this.linePath = lineGenerator(points); this.areaPath = areaGenerator(points);

            this.dataBands = this._calculateDataBands();
        },

        _calculateDataBands:function(){
            var plotBounds = this.vanchart.getPlotBounds(), series = this, bands = this.bands || [];
            var dColor = series.color, dFillColor = series.fillColor, dFillColorOpacity = series.fillColorOpacity;
            var yAxis = series.yAxis, domain = yAxis.scale.domain();
            var x = 0, y = 0, width = plotBounds.width, height = plotBounds.height;

            var resultRanges = [];
            resultRanges.push({
                clipBounds:{x:0, y:0, width:width, height:height},
                color:dColor, fillColor:dFillColor, fillColorOpacity:dFillColorOpacity
            });

            if(!bands || !bands.length){
                return resultRanges;
            }

            for(var i = 0, len = bands.length; i < len; i++){
                var from = Math.max(domain[0], bands[i].from);
                var to = Math.min(domain[1], bands[i].to);
                from = yAxis.scale(from); to = yAxis.scale(to);

                var color = bands[i].color || dColor;
                var fillColor = bands[i].fillColor || dFillColor;
                var fillColorOpacity = bands[i].fillColorOpacity || dFillColorOpacity;

                resultRanges.push({
                    clipBounds:{
                        x:x,
                        y:Math.min(from, to),
                        height:Math.abs(from - to),
                        width:width
                    },
                    color:color,
                    fillColor:fillColor,
                    fillColorOpacity:fillColorOpacity
                });
            }

            return resultRanges;
        },

        _getFixedPos:function(datum){

            var radius = datum.marker.radius || 4.5;

            var plotBounds = this.vanchart.getPlotBounds();

            var x = plotBounds.x + datum.posX + radius;
            var y = plotBounds.y + datum.posY + radius;

            return [x, y];
        },

        //计算点的位置的时候就能确定标签的位置
        _calculateLabelPos:function(){

        },

        getTrendLineXYValues:function(sery){
            return this._getNormalTrendLineXYValues(sery);
        },

        getAttrs:function(point){
            return {'transform':BaseUtils.makeTranslate([point.posX, point.posY])};
        },

        _getMoreLabelDefaultCenter:function(d, moreLabelDim) {
            return {
                centerX: d.posX + d.marker.radius/2,
                centerY: d.posY - moreLabelDim.height/2 - d.marker.radius/2
            }
        },

        getStyle:function(){
            return {};
        },

        getHighLightStyle:function(){

        },

        getDataToDraw: function () {
            return this.points.filter(function(p){return p.marker && p.marker.symbol});
        },

        getTextDataToDraw: function () {
            return this.points;
        },

        _updatePointGraphicStyle:function(point){
            this._updateMarker(point.graphic, point.marker);
        },

        _createPointGraphic:function(point){
            return point.graphic = this._createMarker(point.marker);
        },

        onPointPress:function(){
            var point = this, series = point.series;
            series._onMarkerPressed(point);
        },

        onPointPressUp:function(){
            var point = this, series = point.series;
            series._updateMarker(point.graphic, point.marker);
        },

        //onPointXXX的方法,this 指向的是Point
        onPointMouseOver:function(){
            var point = this, series = point.series;
            series._onMarkerMouseOver(point);
        },

        onPointMouseOut:function(){
            var point = this, series = point.series;
            series._onMarkerMouseOut(point);
        },

        createAnimation:function(dom, point){
            d3.select(dom)
                .attr('transform', 'translate('+ point.posX +','+ point.posY +') scale(0.01)')
                .transition().delay(calculateT(point)).duration(150).ease('ease-out-in')
                .attr('transform', 'translate('+ point.posX +','+ point.posY +') scale(1.5)')
                .transition().duration(150).ease('ease-out-in')
                .attr('transform', 'translate('+ point.posX +','+ point.posY +') scale(1)');
        },

        updateAnimation:function(dom, point){
            d3.select(dom).transition().ease(UPDATE_EASE).duration(LINE_UPDATE_TIME).
            attr('transform', 'translate(' + point.posX + ',' + point.posY + ')');
        },

        dropAnimation:function(dom){
            d3.select(dom).remove();
        },

        getClosestPoint:function(pos){
            var isInverted = this.vanchart.isInverted();
            var key = isInverted ? 'y' : 'x', posKey = isInverted ? 'posY' : 'posX';
            var selectedPoint, minDistance = Number.MAX_VALUE;

            var series = this.vanchart.hoverSeries, plotBounds = this.vanchart.getPlotBounds();
            var rePos = plotBounds[key] - (isInverted ? pos[1] : pos[0]);

            series.points.forEach(function(point){
                var dis = Math.abs(point[posKey] + rePos);
                if(dis < minDistance && !point.isNull){
                    selectedPoint = point;
                    minDistance = dis;
                }
            });

            return selectedPoint;
        },

        _onSeriesMouseOver:function(ev){
            this.dataBandsGraphic.forEach(function(band){
                band._onSeriesMouseOver();
            });

            BaseUtils.toFront(this.group.node());
        },

        _onSeriesUnChosen:function(ev){
            //这里只负责撤销系列的选中效果...
            this.dataBandsGraphic.forEach(function(band){
                band._onSeriesUnChosen();
            });

            this.defaultMarker && this.defaultMarker.remove();
            this.defaultMarker = null;
        },

        _isSeriesInteractive:function(){
            return true;
        },

        drawSeries:function(){

            var series = this, vanchart = this.vanchart, renderer = vanchart.renderer;
            var dataBands = this.dataBands, i, len;

            this.defaultMarker && this.defaultMarker.remove();
            this.defaultMarker = null;

            if(!this.dataBandsGraphic){
                this.dataBandsGraphic = [];
            }

            for(i = dataBands.length, len = this.dataBandsGraphic.length; i < len; i++){
                this.dataBandsGraphic[i].remove();
                this.dataBandsGraphic[i] = null;
            }

            for(i = 0, len = dataBands.length; i < len; i++){
                if(this.dataBandsGraphic[i]){
                    this.dataBandsGraphic[i].refresh(dataBands[i]);
                }else{
                    this.dataBandsGraphic[i] = new DataBand(dataBands[i], series);
                }
            }

            this.dataBandsGraphic.length = dataBands.length;
        }
    });

    //dataBand that draw part of the series
    var DataBand = Class.extend({

        initialize:function(options, series){
            this.series = series;
            this.refresh(options)
        },

        refresh:function(options){
            this.options = options;

            this.render();
        },

        render:function(){

            var options = this.options, series = this.series, animation = series.animation;
            var group = series.group, vanchart = series.vanchart, renderer = vanchart.renderer;

            var lineStyle = {'fill':'none','stroke':options.color, 'stroke-width':series.lineWidth};
            var style = {'fill':options.fillColor, 'fill-opacity':options.fillColorOpacity};

            var isInit = series.visible && !this.linePath;
            var isArea = series.type == Constants.AREA_CHART;
            var clipBounds = options.clipBounds;
            if(!this.clipRect){
                this.clipRect = renderer.createClip({x:clipBounds.x, y:clipBounds.y,width:clipBounds.width, height:clipBounds.height});
            }

            if(series.visible){

                if(isInit){
                    this.linePath = renderer.path().attr('d', series.linePath).addTo(group).style(lineStyle);
                    renderer.clip(this.linePath, this.clipRect);

                    if(isArea){
                        this.areaPath = renderer.path().addTo(group).attr('d', series.areaPath).style(style);
                        renderer.clip(this.areaPath, this.clipRect);
                    }

                    if(animation){
                        d3.select(this.clipRect.rect.rawElement).attr('width', 0)
                            .transition().ease(INIT_EASE).duration(LINE_SHOW_TIME)
                            .attr('x', clipBounds.x).attr('y', clipBounds.y)
                            .attr('width', clipBounds.width).attr('height', clipBounds.height);
                    }

                }else{
                    if(animation){

                        d3.select(this.linePath.node()).transition().ease(UPDATE_EASE).duration(LINE_UPDATE_TIME)
                            .attr('d', series.linePath).style(lineStyle);

                        if(isArea && this.areaPath){
                            d3.select(this.areaPath.node()).transition().ease(UPDATE_EASE).duration(LINE_UPDATE_TIME)
                                .attr('d', series.areaPath).style(style);
                        }

                        d3.select(this.clipRect.rect.rawElement).transition().ease(UPDATE_EASE).duration(LINE_UPDATE_TIME)
                            .attr('x', clipBounds.x).attr('y', clipBounds.y).attr('width', clipBounds.width).attr('height', clipBounds.height);

                    }else{
                        this.linePath.attr('d', series.linePath).style(lineStyle);
                        this.areaPath && this.areaPath.attr('d', series.areaPath).style(style);
                        this.clipRect.rect && this.clipRect.rect.attr(clipBounds);
                    }
                }

            }else{
                this.linePath && this.linePath.remove();
                this.linePath = null;

                this.areaPath && this.areaPath.remove();
                this.areaPath = null;
            }

        },

        _onSeriesMouseOver:function(){
            this.linePath.style({
                'stroke':ColorUtils.getHighLightColor(this.options.color),
                'stroke-width':this.series.lineWidth + 1
            });

            if(this.series.type == Constants.AREA_CHART){
                this.areaPath.style({
                    'fill':ColorUtils.getHighLightColor(this.options.fillColor),
                    'fill-opacity': this.options.fillColorOpacity == 0 ? 0 : CHOSEN_AREA_ALPHA
                });
            }
        },

        _onSeriesUnChosen:function(){
            this.linePath.style({
                'stroke':this.options.color,
                'stroke-width':this.series.lineWidth
            });

            if(this.series.type == Constants.AREA_CHART){
                this.areaPath.style({
                    'fill':this.options.fillColor,
                    'fill-opacity':this.options.fillColorOpacity
                });
            }
        },

        remove:function(){
            this.linePath && this.linePath.remove();
            this.areaPath && this.areaPath.remove();
            this.clipRect.remove();
            this.linePath = this.areaPath = null;
            this.clipRect = null;
        }
    });

    require('../ChartLibrary').register(Constants.LINE_CHART, Line);
    require('../ChartLibrary').register(Constants.AREA_CHART, Line);

    return Line;
});
/**
 * Created by Yuqian on 16/8/9.
 * 树状系列
 */

define('chart/TreeSeries',['require','./Series','../utils/BaseUtils','../utils/QueryUtils','../utils/ColorUtils','../Constants','./Point','../dom/Evented','../utils/Formatter'],function(require){

    var Series = require('./Series');
    var BaseUtils = require('../utils/BaseUtils');
    var QueryUtils = require('../utils/QueryUtils');
    var ColorUtils = require('../utils/ColorUtils');
    var Constants = require('../Constants');
    var Point = require('./Point');
    var Evented = require('../dom/Evented');
    var Formatter = require('../utils/Formatter');

    var X = '{X}';
    var Y = '{Y}';
    var SIZE = '{SIZE}';

    var NAME = 'NAME';
    var CATEGORY = 'CATEGORY';
    var SERIES = 'SERIES';
    var VALUE = 'VALUE';
    var PERCENT = 'PERCENT';

    var LABEL_GAP = 2;

    function clearChild(point){
        if(point.children) {
            point.children.forEach(function (child) {
                clearChild(child);
                child.remove();
            })
        }
        point.remove();
    }

    var TreeSeries = Series.extend({

        refresh: function (options, index) {
            this.options = options;

            var vanchart = this.vanchart;
            var type = options.type || vanchart.currentOption.chartType;

            var name = BaseUtils.pick(options.name, 'Series' + type + index);

            var queryList = this._getQueryList(type);

            var visible = QueryUtils.queryList(queryList, 'visible');

            BaseUtils.extend(this, {

                type:type,

                name:name,

                className:'vancharts-series-' + index,

                visible:visible,

                state:visible ? Constants.STATE_SHOW : Constants.STATE_DROPPED,

                animation:QueryUtils.queryList(queryList, 'animation') || vanchart.currentOption.animation

            });

            //chart type specific attributes
            this._refresh();

            this._initChildren();

        },

        // Tree data's key of children is varied,
        // so '_initChildren' may be varied;
        // 'visitBefore' is intended for initializing some property like colors;
        // 'visitAfter' for calculating.
        _initChildren: function () {

            this.traverseInitData(this.visitBefore, null);

            // make it as normal series
            this.points = this.root.children;
        },

        _getPointKey: function (point) {
            return point.name;
        },

        //用来计算百分比的指标的名字,相当于value的含义
        getTargetKey:function(){
            return 'value';
        },

        _getChildrenKey: function () {
            return 'children';
        },

        traverseData: function (root, visitBefore, visitAfter) {
            // get depth, parent, ancestor, height
            // 'ancestor' is depth 1 node (for legend).
            var series = this;
            function dfsData(node, depth, parent, ancestor) {
                if (!node.children) {
                    node.children = node.options[series._getChildrenKey()];
                }
                var c = node.children;

                node.parent = parent;
                node.depth = depth;
                node.height = 0;
                node.ancestor = ancestor;

                visitBefore && visitBefore.call(series, node);

                if (c && (n = c.length)) {
                    var i = -1, n;
                    while (++i < n) {

                        if ((c[i] instanceof  Point)) {
                            // c[i].refresh();
                        } else {
                            c[i] = new Point(c[i], root.series);
                        }

                        // ancestor's ancestor is itself
                        if (depth === 0) {
                            ancestor = c[i];
                        }

                        dfsData(c[i], depth + 1, node, ancestor);

                        node.height = Math.max(node.height, c[i].visible ? c[i].height + 1 : 0);
                    }
                }

                visitAfter && visitAfter.call(series, node);
            }

            dfsData(root, 0, null, null);
        },

        traverseInitData: function (visitBefore, visitAfter) {
            // get depth, parent, ancestor, height
            // 'ancestor' is depth 1 node (for legend).
            var series = this;
            var rootOptions = {children:this.options.data, name:this.name};
            if(this.root){
                this.root.refresh(rootOptions);
            } else {
                this.root = new Point(rootOptions, series);
            }
            function dfsData(node, nodeOptions, depth, parent, ancestor) {

                var data = nodeOptions[series._getChildrenKey()];

                node.parent = parent;
                node.depth = depth;
                node.height = 0;
                node.ancestor = ancestor;
                node.seriesName = series.name;

                node.children = node.children || [];

                visitBefore && visitBefore.call(series, node);


                if(BaseUtils.hasDefined(data)) {
                    var newChildrens = [];
                    for (var i = 0, len = data.length; i < len; i++) {

                        var refresh = false;
                        var child;
                        node.children.forEach(function (point) {

                            var pointkey = series._getPointKey(point);

                            if(BaseUtils.hasDefined(pointkey) && (pointkey == series._getPointKey(data[i]))){
                                point._lastValue = point[series.getTargetKey()];
                                point.refresh(data[i]);
                                refresh = true;
                                child = point;
                                newChildrens.push(point);
                            }
                        });

                        if (!refresh) {
                            child = new Point(data[i], series);
                            newChildrens.push(child);
                        }

                        // ancestor's ancestor is itself
                        if (depth === 0) {
                            ancestor = child;
                        }

                        dfsData(child, data[i], depth + 1, node, ancestor);

                        node.height = Math.max(node.height, child.visible ? child.height + 1 : 0);
                    }

                    for (var j = 0, size = node.children.length; j < size; j++) {

                        if (BaseUtils.arrayIndexOf(newChildrens, node.children[j]) == -1) {
                            clearChild(node.children[j]);
                        }
                    }

                    node.children = newChildrens;
                }

                visitAfter && visitAfter.call(series, node);
            }

            dfsData(this.root, rootOptions, 0,  null, null);
        },


        visitBefore: function (node) {
            if (node.depth === 1) {
                node.color = this.vanchart.getDefaultSeriesColor(node.name);
            }
        },

        visitAfter: function () {

        },

        _calculatePercentage:function(points, key){
            var total = 0;
            points.forEach(function(d){
                total += Math.abs(d[key]);
            });

            total = total > 0 ? total : 1;
            points.forEach(function(point){
                point.percentage = Math.abs(point[key]) / total;
            });
        },

        _onPointMouseOver: function (ev) {
            var point = this;
            var series = this.series;
            series.onPointMouseOver.call(point, ev);
            series.vanchart.showTooltip(point, ev);
            series.vanchart.hoverPoint = point;
        },

        _onPointMouseOut: function (ev) {
            var point = this;
            var series = this.series;
            series.onPointMouseOut.call(point, ev);
            series.vanchart.hideTooltip();
        },

        _onPointTap: function (ev) {
            this._onPointTap(ev); // called by point = this
        },

        pointEvents: function () {
            return {
                'mouseover':this._onPointMouseOver,
                'mousemove':this.onPointMouseMove,
                'mouseout':this._onPointMouseOut,

                'tap':this._onPointTap
            }
        }

    });

    return TreeSeries;
});
/**
 * Created by Yuqian on 16/7/19.
 */

define('chart/TreeMap',['require','../Constants','../utils/BaseUtils','./TreeSeries','../utils/QueryUtils','../utils/ColorUtils','../utils/BoundsManager','../theme/config','./Point','../ChartLibrary'],function(require){

    var Constants = require('../Constants');
    var BaseUtils = require('../utils/BaseUtils');
    var TreeSeries = require('./TreeSeries');
    var QueryUtils = require('../utils/QueryUtils');
    var ColorUtils = require('../utils/ColorUtils');
    var BoundsManager = require('../utils/BoundsManager');
    var Config = require('../theme/config');
    var Point = require('./Point');

    var TOPLABELGAP = Config[Constants.TREEMAP_CHART].topLabelGap;

    var ANIMATION_TIME = 800;
    var INIT_EASE = 'out-bounce';

    var CHANGE_TIME = 1000;

    var VANISH_TIME = 800;

    var CHOSEN_TIME = 100;

    var treeMap = TreeSeries.extend({

        nodes: [],

        root: null,

        zoomNow: null,

        sx: null,
        sy: null,

        zoom: null,

        _refresh: function () {
            this.sx = d3.scale.linear();
            this.sy = d3.scale.linear();
            var queryList = this._getQueryList();
            this.zoom = QueryUtils.queryList(queryList, 'zoom');
        },

        visitBefore: function (node) {
            this._setColor(node);
        },

        visitAfter: function (node) {
            var c = node.children;
            var _value = node.options.value;
            _value = isNaN(_value) ? 0 : _value;

            node.chSum = _value;

            if (c && (n = c.length)) {
                var chSum = 0, i = -1, n;

                this._calculatePercentage(c, 'value');

                while (++i < n) {
                    chSum += Math.abs(c[i].chSum);
                }

                node.chSum = chSum;
            }

            node.value = _value || node.chSum || 0;

            if (node.ancestor && !node.ancestor.visible) {
                node.value = 0;
            }
        },

        doLayout: function () {

            this.traverseData(this.root, null, this.visitAfter);

            var plotBounds = this.vanchart.getPlotBounds();

            this.sx.range([0, plotBounds.width]).domain([0, plotBounds.width]);
            this.sy.range([0, plotBounds.height]).domain([0, plotBounds.height]);

            var treeMap = d3.layout.treemap()
                .value(function (d) { return Math.abs(d.value) })
                .size([plotBounds.width, plotBounds.height]);

            this.nodes = treeMap.nodes(this.root)
                .filter(function(d) { return !d.children && d.depth; })
                .map(function (d) {
                    d.value = d.chSum; // for negative value
                    d.visible = d.ancestor.visible;

                    if (d.visible) {
                        this._setVanishPos(d, plotBounds);
                    }

                    this.calculateLabelInfo(d);

                    this._calculateLabelPos(d);

                    stash(d);

                    return d;
                }, this);

            function stash (d) {
                d._dx = d.dx;
                d._dy = d.dy;
                d._x = d.x;
                d._y = d.y;
            }
        },

        getDataToDraw: function () {
            return this.nodes;
        },

        _setVanishPos: function (d, plotBounds) {
            d.vanishPos = [
                Math.round((d.ancestor.x + d.ancestor.dx / 2) / plotBounds.width) * plotBounds.width,
                Math.round((d.ancestor.y + d.ancestor.dy / 2) / plotBounds.height) * plotBounds.height
            ];
        },

        _setColor: function (node) {
            if (node.depth === 1) {
                node.color = this.vanchart.getDefaultSeriesColor(node.name);
                node.mouseOverColor = ColorUtils.getHighLightColor(node.color);
                node.clickColor = ColorUtils.getClickColor(node.color);
            }
            if (node.depth > 1 && !node.options.children) {
                if (node.options.color) {
                    node.color = node.options.color;
                } else {
                    node.color = node.ancestor.color;
                }

                if (node.options.mouseOverColor) {
                    node.mouseOverColor = node.options.mouseOverColor;
                } else {
                    if (node.options.color) {
                        node.mouseOverColor = ColorUtils.getHighLightColor(node.options.color);
                    } else {
                        node.mouseOverColor = node.ancestor.mouseOverColor;
                    }
                }

                if (node.options.clickColor) {
                    node.clickColor = node.options.clickColor;
                } else {
                    if (node.options.color) {
                        node.clickColor = ColorUtils.getClickColor(node.options.color);
                    } else {
                        node.clickColor = node.ancestor.clickColor;
                    }
                }
            }
            var hexAlpha = ColorUtils.getStandardColorAndOpacity(node.color, node.options.opacity);
            node.color = hexAlpha.hex;
            node.opacity = hexAlpha.alpha;
        },

        _calculateLabelPos: function (d) {
            var lbl = d.dataLabels;
            if (lbl && lbl.enabled) {

                switch (lbl.align) {
                    case Constants.CENTER:
                        lbl._align = Constants.CENTER;
                        d.labelPos = {
                            x: d.x + (d.dx - d.labelDim.width) / 2,
                            y: d.y + (d.dy - d.labelDim.height) / 2
                        };
                        break;
                    case Constants.TOP:
                    default:
                        lbl._align = Constants.LEFT;
                        d.labelPos = {
                            x: d.x + TOPLABELGAP,
                            y: d.y + TOPLABELGAP
                        };
                }

                var rectBound = {x: d.x, y: d.y, width: d.dx, height: d.dy};
                var dataBound = {
                    x: d.labelPos.x,
                    y: d.labelPos.y,
                    width: d.labelDim.width,
                    height: d.labelDim.height
                };
                if (!BaseUtils.containsRect(rectBound, dataBound)) {
                    d.labelPos = null;
                }
            }
        },

        calculateTooltipContent: function (node) {
            var tooltip = node.tooltip;

            if (tooltip && tooltip.enabled && tooltip.formatter) {
                var formatter = tooltip.formatter;

                if (typeof formatter == 'object') {
                    var style = tooltip.style;
                    var label = formatter.identifier;

                    var content = '';

                    if (tooltip.shared) {
                        if (label.indexOf('NAME') != -1) {
                            var p, d = node, points = [node.name];
                            while ((p = d.parent) && p.depth) {
                                d = p;
                                points.unshift(p.name);
                            }
                            content += (style ? '<span>' : Constants.TOOLTIP_CATEGORY_STYLE) + points.join(' / ') + '</span><br>';
                        }
                        content += this._createSeriesLine(node, label, style, formatter);
                    } else {
                        content += this._createCategoryLine(node, label, style, formatter);
                        content += this._createSeriesLine(node, label, style, formatter);
                    }
                } else {
                    content = BaseUtils.getFormatterFunction(formatter).call(node);
                }

                return content;

            } else {
                return null;
            }
        },

        _getMoreLabelDefaultCenter:function(d, moreLabelDim) {
            return {
                centerX: d.x + d.dx/2,
                centerY: d.y + d.dy/2
            }
        },

        getStyle:function(p){
            return {
                'fill':p.color,
                'fill-opacity':p.opacity,
                'stroke': p.borderColor,
                'stroke-opacity':p.borderOpacity,
                'stroke-width':p.borderWidth
            }
        },

        getAttrs:function(p){
            return {
                'width': p.dx,
                'height': p.dy,
                'transform': "translate(" + p.x + "," + p.y + ")"
            };
        },

        getPointGraphicKey:function(){
            return 'rect';
        },

        _getFixedPos:function(datum){

            var plotBounds = this.vanchart.getPlotBounds();

            var x = plotBounds.x + datum.x + datum.dx;
            var y = plotBounds.y + datum.y;

            return [x, y];
        },

        zoomTo: function (d) {
            d = this.zoomNow == d.parent ? this.root : d.parent;
            var sx = this.sx.domain([d.x, d.x + d.dx]);
            var sy = this.sy.domain([d.y, d.y + d.dy]);

            var plotBounds = this.vanchart.getPlotBounds();
            var kx = plotBounds.width / d.dx, ky = plotBounds.height / d.dy;

            this.nodes.map(function (node) {
                node.dx = kx * node._dx;
                node.dy = ky * node._dy;
                node.x = sx(node._x);
                node.y = sy(node._y);
                this._calculateLabelPos(node);
            }, this);

            this.render();

            this.zoomNow = d;
        },

        getChartNodes: function () {
            return this.nodes;
        },
        
        getZoom: function () {
            return this.zoom;
        },

        _getPointGraphicGroup:function(){
            if(!this.pathGroup){
                this.pathGroup = this.group.append(this.vanchart.renderer.group());
            }
            return this.pathGroup;
        },

        _getAnimationTime: function () {
            return ANIMATION_TIME;
        },

        // animation
        initialAnimation: function () {
            var series = this;
            var node = this._getPointGraphicGroup().node();
            var plotBounds = this.vanchart.getPlotBounds();
            var cx = plotBounds.width / 2;
            var cy = plotBounds.height / 2;
            d3.select(node)
                .transition()
                .duration(ANIMATION_TIME)
                .ease(INIT_EASE)
                .attrTween('transform', function () {
                    var i = d3.interpolate(0, 1);
                    return function (t) {
                        var inter = i(t);
                        return 'matrix(' +
                            inter + ',' + 0 + ',' +
                            0 + ',' + inter + ',' +
                            (cx - inter * cx) + ',' + (cy - inter * cy) + ')';
                    };
                })
                .each('end', function () {
                    series.initialAnimationMoving = false;
                });
        },

        updateAnimation:function(dom, d, delay){
            if (d.visible) {
                d3.select(dom)
                    .transition()
                    .duration(this.initialAnimationMoving ? 0 : CHANGE_TIME)
                    .attr("width", d.dx)
                    .attr("height", d.dy)
                    .attr("transform", "translate(" + d.x + "," + d.y + ")");
            } else {
                this.dropAnimation(dom, d, delay);
            }
        },

        createAnimation:function(dom, d, delay){

            if (this.initialAnimationMoving) {
                this.initialAnimation();
            }

            d3.select(dom)
                .attr("width", 0)
                .attr("height", 0)
                .attr("transform", "translate(" + d.vanishPos[0] + "," + d.vanishPos[1] + ")");

            this.updateAnimation(dom, d, delay);
        },

        dropAnimation:function(dom, d, delay){
            d3.select(dom)
                .transition()
                .duration(VANISH_TIME)
                .attr("width", 0)
                .attr("height", 0)
                .attr("transform", "translate(" + d.vanishPos[0] + "," + d.vanishPos[1] + ")")
                .remove();
        },

        // event
        onPointMouseOver:function(ev){
            var point = this;
            point.series._onState.call(point, true);
        },

        onPointMouseOut:function(){
            var point = this;
            point.series._onState.call(point, false);
        },

        _onState:function(isChosen){
            var point = this, series = point.series, animation = series.animation;
            var style = {'fill': isChosen ? point.mouseOverColor : point.color};

            if(animation){
                d3.select(point.graphic.style(style).rawElement)
                    .interrupt(Constants.SELECT_ANIMATION)
                    .transition(Constants.SELECT_ANIMATION)
                    .duration(CHOSEN_TIME);
            }else{
                point.graphic.style(style);
            }
        },

        onPointTap: function () {
            if (this.series.getZoom()) {
                this.series.zoomTo(this);
            }
        },

        _labelUseSeriesColor:function () {
            return false;
        }

    });

    require('../ChartLibrary').register(Constants.TREEMAP_CHART, treeMap);
});
/**
 * Created by Mitisky on 16/3/14.
 */
define('chart/Bubble',['require','./Series','../utils/BaseUtils','../Constants','../utils/QueryUtils','../ComponentLibrary','../ChartLibrary'],function(require){
    var Series = require('./Series');
    var BaseUtils = require('../utils/BaseUtils');
    var Constants = require('../Constants');
    var QueryUtils = require('../utils/QueryUtils');
    var ComponentLibrary = require('../ComponentLibrary');

    var BUBBLE_INIT_TIME = 500;
    var BUBBLE_UPDATE_TIME = 500;
    var BUBBLE_EXIT_TIME = 300;
    var BUBBLE_RE_SHOW_TIME = 300;
    var NEGATIVE_COLOR = 'rgb(138, 138, 138)';

    var Bubble = Series.extend({
        _refresh:function(){
            //系列的一些属性
            var queryList = this._getQueryList();
            BaseUtils.extend(this,
                {
                    sizeBy: QueryUtils.queryList(queryList, 'sizeBy'),
                    maxSize: QueryUtils.queryList(queryList, 'maxSize'),
                    minSize: QueryUtils.queryList(queryList, 'minSize'),
                    shadow: QueryUtils.queryList(queryList, 'shadow'),
                    displayNegative: QueryUtils.queryList(queryList, 'displayNegative')
                }
            );
        },

        _refreshPointColor: function (point, color) {

            if(this.vanchart.getComponent(ComponentLibrary.RANGE_LEGEND_COMPONENT)){
                return color;
            }

            if(point.getTargetValue() < 0 && point.displayNegative){
                return NEGATIVE_COLOR;
            } else if(point.getTargetValue() < 0){
                return null;
            }
            return color;
        },

        doLayout:function(){
            this._calculateBubbleRadius();
            this._calculateBubblePosition();
        },

        //用来计算百分比的指标的名字,相当于value的含义
        getTargetKey:function(){
            return 'size';
        },

        isNullValue: function (point) {

            if(this.type == Constants.FORCE_BUBBLE_CHART){
                return point.x == '-' || point.y == '-';
            }else{
                return point.x == '-' || point.y == '-' || point.size == '-' || BaseUtils.hasNotDefined(point.size);
            }
        },

        _getPointKey: function (point) {
            return '' + point.x + point.y;
        },

        getPointValue4MinMax: function (point) {
            var pointS = point[this.getTargetKey()];
            if(pointS < 0 && !point.displayNegative){
                return null;
            }
            if(point.minSize || point.maxSize){
                return null;
            }
            return Math.abs(pointS);
        },

        pushNormalLabelContent: function (point, formatter, dataLabels, useHtml, content) {
            this.pushBubbleNormalLabelContent(point, formatter, dataLabels, useHtml, content, Constants.INSIDE);
        },

        calculateTooltipContent:function(point){
            var tooltip = point.tooltip, series = this;
            if(!tooltip || !tooltip.enabled){
                return;
            }
            var formatter = tooltip.formatter, content = '';
            if(typeof formatter == 'object'){
                var style = tooltip.style, label = formatter.identifier;
                content += series._createBubbleTooltipSeriesLine(point, label, style, formatter);
                content += series._createBubbleTooltipXYSizeLine(point, label, style, formatter);
            }else{
                content = BaseUtils.getFormatterFunction(formatter).call(point);
            }

            return content;
        },

        //计算位置的时候 顺道儿就给了
        _calculateLabelPos:function() {

        },

        _calculateBubbleRadius:function(){
            if (this.points.length > 0) {
                var seriesMaxDiameter = Math.max(this.maxSize, this.minSize);
                var seriesMinDiameter = Math.min(this.minSize, this.maxSize);
                var sizeByArea = this.sizeBy == Constants.SIZE_BY_AREA;

                //系列条件属性设置最大最小半径，则气泡半径根据该系列最大最小size计算
                var max = this.seriesMaxValue;
                var min = this.seriesMinValue;
                if(!this._sizeByCurrentSeries()){
                    var minMax = this._calculateBubbleChartMinMax();
                    max = minMax.max;
                    min = minMax.min;
                }

                var unit = 0;
                if(min != max){
                    unit = sizeByArea ? (seriesMaxDiameter * seriesMaxDiameter - seriesMinDiameter * seriesMinDiameter) / (max - min)
                        : (seriesMaxDiameter - seriesMinDiameter ) / (max - min);
                }

                var scale = BaseUtils.pick(this.vanchart.scale, 1);
                var targetKey = this.getTargetKey();

                this.points.forEach(function(point) {
                    var temp = unit * (Math.abs(point[targetKey]) - min);
                    var diameter = sizeByArea ? Math.sqrt(seriesMinDiameter * seriesMinDiameter + temp)
                        : seriesMinDiameter + temp;
                    if(point.minSize || point.maxSize){
                        var _tmp = isNaN(point.minSize) ? point.maxSize : point.minSize;
                        diameter = point.sizeBy == Constants.SIZE_BY_AREA ? Math.sqrt(_tmp) * 2 : _tmp;
                    }
                    diameter = (point[targetKey] < 0 && !point.displayNegative) ? 0 : diameter;
                    point.radius = (diameter/2) * scale;
                });
            }
        },

        //用options原因：this.minSize = this.minSize || this.vanchart.options.plotOptions.minSize
        _sizeByCurrentSeries: function () {
            return BaseUtils.hasDefined(this.options.minSize) && BaseUtils.hasDefined(this.options.maxSize);
        },

        _calculateBubbleChartMinMax: function () {
            var series = this.vanchart.series[this.type];

            var minSize = Number.MAX_VALUE;//所有数据的最大最小值
            var maxSize = -minSize;

            series.forEach(function(sery) {
                if(!sery._sizeByCurrentSeries()) {
                    minSize = Math.min(minSize, sery.seriesMinValue);
                    maxSize = Math.max(maxSize, sery.seriesMaxValue);
                }
            });

            return{
                min:minSize,
                max:maxSize
            }
        },

        _calculateBubblePosition:function(){
            var isInverted = this.vanchart.isInverted();

            var xAxis = this.xAxis, yAxis = this.yAxis;

            this.points.forEach(function(point){

                var det = xAxis.scale.rangeBand ? xAxis.scale.rangeBand()/2 : 0;
                var t1 = xAxis.scale(point.x) + det;
                var t2 = yAxis.scale(point.y);

                point.posX = isInverted ? t2 : t1;
                point.posY = isInverted ? t1 : t2;

                var visible = !point.isNull && point.visible && !(point.size < 0 && !point.displayNegative);

                if(visible && point.dataLabels && point.dataLabels.enabled){

                    point.labelPos = {
                        x: point.posX - point.labelDim.width/2,
                        y: point.posY - point.labelDim.height/2
                    };
                }
            });
        },

        getTrendLineXYValues:function(sery){
            return this._getNormalTrendLineXYValues(sery);
        },

        _getFixedPos:function(point){
            var vanchart = this.vanchart, plotBounds = vanchart.getPlotBounds(), radius = point.radius || 0;

            var pos;
            if(vanchart.vanChartType == 'vanChartMap'){
                var leaflet = vanchart._leaflet, geo = vanchart.getComponent(ComponentLibrary.GEO_COMPONENT);
                var latlng = geo.getDataPointLatLng(point);
                pos = leaflet.latLngToContainerPoint(latlng);
            }else{
                pos = {
                    x:plotBounds.x + point.posX,
                    y:plotBounds.y + point.posY
                }
            }

            radius = (radius + 1)/1.414;
            
            return [pos.x + radius, pos.y + radius];
        },

        getInitShowTime: function () {
            return BUBBLE_INIT_TIME + 800;
        },

        getReAppearTime: function () {
            return BUBBLE_UPDATE_TIME;
        },

        _getMoreLabelDefaultCenter:function(d, moreLabelDim) {
            return {
                centerX: d.posX,
                centerY: d.posY
            }
        },

        getStyle:function(p){
            var series = p.series, vanchart = series.vanchart, renderer = vanchart.renderer;
            vanchart.bubbleShadowFilter = vanchart.bubbleShadowFilter || renderer.createDropShadowFilter(0, 0, 0.2, 2);
            return {
                'fill':p.color,
                'fill-opacity':p.opacity,
                'stroke-width':0,
                'filter':'url(#'+ BaseUtils.stamp(vanchart.bubbleShadowFilter) +')'
            }
        },

        getAttrs:function(p){
            return {
                'r': p.radius,
                'transform': BaseUtils.makeTranslate({x:p.posX, y:p.posY})
            };
        },

        getPointGraphicKey:function(){
            return 'circle';
        },

        createAnimation:function(dom, d){
            d3.select(dom)
                .attr('transform', BaseUtils.makeTranslate({x:d.posX, y:d.posY}))
                .attr('r', 0)
                .transition()
                .delay(d.delayTime)
                .ease('bounce')
                .duration(this.state == Constants.STATE_TO_SHOW ? BUBBLE_RE_SHOW_TIME : BUBBLE_INIT_TIME)
                .attr('r', d.radius)

        },

        updateAnimation: function (dom, d) {
            d3.select(dom)
                .transition()
                .duration(BUBBLE_UPDATE_TIME)
                .ease('back-out')
                .attr('r', d.radius)
                .attr('transform', 'translate('+ d.posX+','+ d.posY+')')
        },

        dropAnimation: function (dom, d) {
            d3.select(dom)
                .transition()
                .duration(BUBBLE_EXIT_TIME)
                .ease('back-in')
                .attr('r', 0)
                .remove();
        },

        getHighLightStyle:function(d){
            return {
                'stroke':d.mouseOverColor,
                'stroke-opacity':0.35,
                'fill':d.mouseOverColor,
                'fill-opacity': 1,
                'stroke-width':6
            }
        },

        getPressedStyle:function(p){
            return {
                'fill':p.clickColor,
                'fill-opacity': p.clickOpacity
            }
        },

        onPointMouseOver:function(ev){

            var point = this, series = point.series, animation = series.animation, style = series.getHighLightStyle(point);

            if(series.isLargeMode()){
                return;
            }

            if(animation){
                d3.select(point.graphic.rawElement)
                    .interrupt(Constants.SELECT_ANIMATION)
                    .transition(Constants.SELECT_ANIMATION)
                    .duration(200).ease('back-out').style(style);
            }else{
                point.graphic.style(style)
            }

        },

        onPointMouseOut:function(ev){
            var point = this, series = point.series, animation = series.animation, style = series.getStyle(point);

            if(series.isLargeMode()){
                return;
            }

            if(animation){
                d3.select(point.graphic.rawElement)
                    .interrupt(Constants.SELECT_ANIMATION)
                    .style(style);
            } else {
                point.graphic.style(style);
            }

        }

    });

    require('../ChartLibrary').register(Constants.BUBBLE_CHART, Bubble);

    return Bubble;
});

/**
 * Created by eason on 16/8/16.
 */
define('chart/ForceBubble',['require','./Bubble','../Constants','../utils/BaseUtils','../ChartLibrary'],function(require){

    var Bubble = require('./Bubble');
    var Constants = require('../Constants');
    var BaseUtils = require('../utils/BaseUtils');

    var ForceBubble = Bubble.extend({

        _calculateBubblePosition:function(){

        },

        _getFixedPos:function(datum){
            var radius = datum.radius || 0;
            var node = datum.shadow;
            var plotBounds = this.vanchart.getPlotBounds();
            var x = plotBounds.x + node.x + radius;
            var y = plotBounds.y + node.y + radius;
            return [x, y];
        },

        calculateTooltipContent:function(point){
            return this._calculateTooltipContent(point);
        },
        
        _getAxisTypes:function(){
            return [];
        },
        
        getTargetKey:function(){
            return 'y';
        },

        getAttrs:function(node){
            return {
                'r': node.radius,
                'transform': BaseUtils.makeTranslate({x:node.x, y:node.y})
            };
        }

    });

    require('../ChartLibrary').register(Constants.FORCE_BUBBLE_CHART, ForceBubble);
    return ForceBubble;
});
/**
 * Created by Mitisky on 16/3/24.
 */
define('chart/Scatter',['require','./Series','../utils/BaseUtils','../Constants','../utils/QueryUtils','../ComponentLibrary','../ChartLibrary'],function (require) {

    var Series = require('./Series');
    var BaseUtils = require('../utils/BaseUtils');
    var Constants = require('../Constants');
    var QueryUtils = require('../utils/QueryUtils');
    var ComponentLibrary = require('../ComponentLibrary');

    var SCATTER_INIT_TIME = 300;
    var SCATTER_UPDATE_TIME = 500;
    var LABEL_GAP = 2;

    var Scatter = Series.extend({

        _refresh: function (index) {
            if (BaseUtils.isNullMarker(this.marker)) {
                this.marker.symbol = BaseUtils.getDefaultMarkerSymbol(index);
            }

            var queryList = this._getQueryList();
            BaseUtils.extend(this,
                {
                    lineWidth: QueryUtils.queryList(queryList, 'lineWidth') || 0,
                    interpolate: this._getSeriesInterpolate(queryList)
                }
            );
        },

        doLayout: function () {
            var isInverted = this.vanchart.isInverted();

            var xAxis = this.xAxis, yAxis = this.yAxis;

            this.points.forEach(function (point) {

                var det = xAxis.scale.rangeBand ? xAxis.scale.rangeBand()/2 : 0;
                var t1 = xAxis.scale(point.x) + det;
                var t2 = yAxis.scale(point.y);

                point.posX = isInverted ? t2 : t1;
                point.posY = isInverted ? t1 : t2;

                if (point.dataLabels && point.dataLabels.enabled) {
                    point.labelPos = {
                        x: point.posX - point.labelDim.width/2,
                        y: point.posY - point.marker.radius - LABEL_GAP - point.labelDim.height
                    };
                }

            });

            var series = this;

            var lineSvg = d3.svg.line()
                .interpolate(series.interpolate)
                .x(function (d) {
                    return d.posX;
                })
                .y(function (d) {
                    return d.posY;
                })
                .defined(function (d) {
                    return !d.isNull;
                });

            this.points.sort(function (pointA, pointB) {
                return pointA.x - pointB.x;
            });

            this.linePath = lineSvg(this.points);
        },

        //用来计算百分比的指标的名字,相当于value的含义
        getTargetKey:function(){
            return 'size';
        },

        isNullValue: function (point) {
            if(point.series.vanchart.vanChartType == 'vanChartMap'){
                return point.size == '-' || BaseUtils.hasNotDefined(point.size);
            }else{
                return point.x == '-' || point.y == '-' || BaseUtils.hasNotDefined(point.y);
            }
        },

        pushNormalLabelContent: function (point, formatter, dataLabels, useHtml, content) {
            this.pushBubbleNormalLabelContent(point, formatter, dataLabels, useHtml, content, Constants.OUTSIDE);
        },

        _calculateLabelPos: function (point) {

        },

        getTrendLineXYValues: function (sery) {
            return this._getNormalTrendLineXYValues(sery);
        },

        _getFixedPos:function (point) {
            var vanchart = this.vanchart, plotBounds = vanchart.getPlotBounds(), radius = (point.marker &&  point.marker.radius) || 0;

            var pos;
            if(vanchart.vanChartType == 'vanChartMap'){
                var leaflet = vanchart._leaflet, geo = vanchart.getComponent(ComponentLibrary.GEO_COMPONENT);
                var latlng = geo.getDataPointLatLng(point);
                pos = leaflet.latLngToContainerPoint(latlng);
            }else{
                pos = {
                    x:plotBounds.x + point.posX,
                    y:plotBounds.y + point.posY
                }
            }

            radius = (radius + 1)/1.414;

            return [pos.x + radius, pos.y + radius];
        },

        getInitShowTime: function () {
            return SCATTER_INIT_TIME + 800;
        },

        getReAppearTime: function () {
            return SCATTER_UPDATE_TIME;
        },

        _animateEnd: function () {
            this._showLabels();
            this._updateSeriesLine();
        },

        _getMoreLabelDefaultCenter:function(d, moreLabelDim) {
            return {
                centerX: d.posX + d.marker.radius/2,
                centerY: d.posY - moreLabelDim.height/2 - d.marker.radius/2
            }
        },

        getStyle:function(p){
            return {};
        },

        getAttrs:function(p){
            return {'transform': BaseUtils.makeTranslate({x:p.posX, y:p.posY})};
        },

        _updatePointGraphicStyle:function(point){
            this._updateMarker(point.graphic, point.marker);
        },

        _createPointGraphic:function(point){
            return point.graphic = this._createMarker(point.marker);
        },

        createAnimation: function (dom, d) {
            d3.select(dom)
                .attr('transform', 'translate('+ d.posX +','+ d.posY +') scale(0.01)')
                .transition()
                .delay(d.delayTime)
                .duration(SCATTER_INIT_TIME)
                .ease('back-out')
                .attr('transform', 'translate('+ d.posX +','+ d.posY +') scale(1)')
        },

        updateAnimation: function (dom, d) {
            d3.select(dom)
                .transition()
                .duration(SCATTER_UPDATE_TIME)
                .ease('back-out')
                .attr('transform', 'translate('+ d.posX +','+ d.posY +') scale(1)')
        },

        dropAnimation: function (dom, d) {
            d3.select(dom)
                .transition()
                .duration(SCATTER_INIT_TIME)
                .ease('back-in')
                .attr('transform', 'translate('+ d.posX +','+ d.posY +') scale(0)')
                .remove();
        },

        drawSeries: function () {
            var series = this;
            var group = series.group, vanchart = series.vanchart, renderer = vanchart.renderer;

            if (series.visible) {

                if (!series.lineGraphic) {
                    series.lineGraphic = renderer.path().addTo(group);
                } else {
                    d3.select(series.lineGraphic.node())
                        .transition()
                        .duration(SCATTER_UPDATE_TIME)
                        .ease('back-out')
                        .attr('d',  series.linePath)
                }
            }
        },

        _updateSeriesLine: function () {
            var series = this;

            series.lineGraphic &&
            series.lineGraphic
                .attr('d', series.linePath)
                .style({
                    'display': series.visible ? 'inline' : 'none',
                    'fill': 'none',
                    'stroke': series.color,
                    'pointer-events': 'none',
                    'stroke-width': series.lineWidth
                });

        },


        onPointMouseOver:function(ev){

            var point = this, series = point.series;

            if(series.isLargeMode()){
                return;
            }
            series._onMarkerMouseOver(point);
        },

        onPointMouseOut:function(ev){
            var point = this, series = point.series;

            if(series.isLargeMode()){
                return;
            }

            series._onMarkerMouseOut(point);
        }

    });

    require('../ChartLibrary').register(Constants.SCATTER_CHART, Scatter);
    
    return Scatter;
});

/**
 * Created by Jeffrey on 16/6/15.
 */

define('chart/MultiPie',['require','../Constants','../utils/BaseUtils','./TreeSeries','../utils/QueryUtils','../utils/ColorUtils','../utils/BoundsManager','../theme/config','./Point','../utils/BezierEasing','../ChartLibrary'],function(require){

    var Constants = require('../Constants');
    var BaseUtils = require('../utils/BaseUtils');
    var TreeSeries = require('./TreeSeries');
    var QueryUtils = require('../utils/QueryUtils');
    var ColorUtils = require('../utils/ColorUtils');
    var BoundsManager = require('../utils/BoundsManager');
    var Config = require('../theme/config');
    var Point = require('./Point');
    var Bezier = require('../utils/BezierEasing');

    var RIGHT_TOP = 'right-top';
    var RIGHT_BOTTOM = 'right-bottom';
    var LEFT_TOP = 'left-top';
    var LEFT_BOTTOM = 'left-bottom';

    var INNER_RADIUS_PCT = Config[Constants.MULTIPIE_CHART].innerRadiusPct;
    var INNER_RING_RADIUS = 15;
    var INNER_RING_STROKE_WIDTH = 5;

    var CIRCLE = 2 * Math.PI;
    var LINE_LABEL_GAP = 2;
    var STEP = Math.PI / 180;

    var VIS_MIN = 1E-10;

    var ANIMATION_TIME = 1000;
    var INNER_HOVER_TIME = 300;
    var SORT_TIME = 400;

    var EASE = 'bounce';
    var INNER_HOVER_EASE = Bezier.css.swing;
    var SORT_EASE = Bezier.css.swing;

    var multiPie = TreeSeries.extend({
        
        nodes: [],
        
        root: null,

        ordered: null,

        drilldownNow: null,

        // for convenient
        center: [],
        innerRadius: null,
        radius: null,
        startAngle: null,
        endAngle: null,
        drilldown: null,
        rotatable: null,

        chartInfo: {},

        arc: d3.svg.arc()
            .startAngle(function (d) { return d.x; })
            .endAngle(function (d) { return d.x + d.dx; })
            .innerRadius(function(d) { return d.y;})
            .outerRadius(function(d) { return d.y + d.dy;}),

        _refresh: function () {
            this.ordered = null;
            this.chartInfo = {rotate: 0};
            this.sx = d3.scale.linear();
            this.sy = d3.scale.linear();
            var queryList = this._getQueryList();

            var center = QueryUtils.queryList(queryList, 'center');
            var innerRadius = QueryUtils.queryList(queryList, 'innerRadius');
            var radius = QueryUtils.queryList(queryList, 'radius');
            var gradual = QueryUtils.queryList(queryList, 'gradual');
            var drilldown = QueryUtils.queryList(queryList, 'drilldown');
            var startAngle = QueryUtils.queryList(queryList, 'startAngle');
            var endAngle = QueryUtils.queryList(queryList, 'endAngle');
            var rotatable = QueryUtils.queryList(queryList, 'rotatable');

            if(startAngle > endAngle){
                startAngle -= 360;
            }else if(startAngle == endAngle){
                startAngle = 0;
                endAngle = 360;
            }

            startAngle = BaseUtils.toRadian(startAngle);
            endAngle = BaseUtils.toRadian(endAngle);

            BaseUtils.extend(this, {
                center: center,
                innerRadius: innerRadius,
                radius: radius,
                gradual: gradual,
                drilldown: drilldown,
                startAngle: startAngle,
                endAngle: endAngle,
                rotatable: rotatable
            }, true);

        },

        visitAfter: function (node) {
            var c = node.children;
            var _value = node.options.value;
            _value = isNaN(_value) ? 0 : _value;

            node.chSum = _value;

            if (c && (n = c.length)) {
                var chSum = 0, i = -1, n;

                this._calculatePercentage(c, 'value');

                while (++i < n) {
                    chSum += Math.abs(c[i].chSum);
                }

                var orderType = this.orderType;
                c.sort(function(a, b){
                    if (!a.value) {
                        return -1;
                    }
                    if (orderType) {
                        return orderType * (Math.abs(a.value) - Math.abs(b.value));
                    } else {
                        return a.index - b.index;
                    }
                });

                node.chSum = Math.max(chSum, Math.abs(_value || 0));
            }

            node.value = _value || node.chSum || 0;

            if (!node.visible) {
                // value is visible size
                // chSum is hold size(include blank)
                node.value = 0;
                node.chSum = 0;
            }
        },

        _visitBefore: function (node) {
            node.isNull = false;
            if (!node.depth) {
                return;
            }

            if (node.depth === 1) {
                node.points = [node];
            } else {
                node.points = node.parent.points.slice();
                node.points.push(node);
            }
        },

        doLayout: function () {

            var series = this;

            var center = [], radius, bounds;
            var plotBounds = this.vanchart.getPlotBounds();
            if (!series.center || series.center.length === 0) {
                center = [
                    plotBounds.width / 2 + plotBounds.x,
                    plotBounds.height / 2 + plotBounds.y
                ];
            } else {
                center[0] = this._getPercentValue(series.center[0], this.vanchart.width);
                center[1] = this._getPercentValue(series.center[1], this.vanchart.height);
            }

            bounds = {x: plotBounds.x, y: plotBounds.y, width: plotBounds.width, height: plotBounds.height};

            radius = series.radius ||
                Math.min(
                    center[0] - bounds.x,
                    bounds.x + bounds.width - center[0],
                    center[1] - bounds.y,
                    bounds.y + bounds.height - center[1]
                );

            series.chartInfo.innerRadius = series.innerRadius;
            series.chartInfo.radius = radius;
            series.chartInfo.center = center;
            series.chartInfo.bounds = bounds;

            this.traverseData(this.root, this._visitBefore, this.visitAfter);

            this._initData(series);

        },

        _initData: function (series) {

            series.nodes = series._bfsTraverseData(series.root);

            if (series.radius) {
                series._calcData(series.root);
                series._calculateLabelPos();
            } else {

                series._calcData(series.root);

                var outPoints = series.nodes.filter(function (node) {
                    return (node.depth &&
                        node.dx &&
                        node.dataLabels &&
                        node.dataLabels.enabled &&
                        node.dataLabels.align === Constants.OUTSIDE)
                });

                var chartInfo = series.chartInfo;

                chartInfo.radius = series.calcOutsideLabel(outPoints, chartInfo.bounds, chartInfo.center);

                series._calcData(series.root);

                series._calculateLabelPos();
            }

            series.sx = this.sx.range([this.startAngle, this.endAngle]).domain([this.startAngle, this.endAngle]);
            series.sy = this.sy.range([0, this.innerRadius, this.radius]).domain([0, this.innerRadius, this.radius]);

            // a log for different render ease functions
            // this.isChanged = this.ordered != this.option.orderType;
            // this.ordered = this.option.orderType;

        },

        getDataToDraw: function () {
            return this.nodes;
        },

        orderData: function (para) {
            //
            this.orderType = para;
        },

        _bfsTraverseData: function (root) {
            var queue = [];
            var stack = [];
            queue.push(root);

            while (node = queue.shift()) {
                var node;
                stack.push(node);
                var children = node.children;
                if (children && (n = children.length)) {
                    var i = -1, n;
                    while (++i < n) {
                        queue.push(children[i]);
                    }
                }
            }
            return stack;
        },

        _calcData: function (root) {
            var series = this;

            series.radius = series.chartInfo.radius;
            series.center = series.chartInfo.center;

            if (series.radius && series.chartInfo.innerRadius) {
                series.innerRadius = this._getPercentValue(series.chartInfo.innerRadius, series.radius);
            }

            var height = root.height;
            
            var radius = series.radius;
            var innerRadius = series.innerRadius;
            var gradual = series.gradual;
            var startAngle = series.startAngle;
            var endAngle = series.endAngle;

            var arc = endAngle - startAngle;

            var dRadius, innerPieR;

            if (innerRadius) {
                dRadius = height ? (radius - innerRadius) / height : 0;
                innerPieR = dRadius;
            } else {
                dRadius = (height > 1) ? radius * (1 - INNER_RADIUS_PCT) / (height - 1) : 0;
                innerPieR = (height > 1) ? radius * INNER_RADIUS_PCT : radius;
            }

            // hdx is 'hold dx', hdx >= dx, may leave blank.
            function dfsData(node, x, dx, hdx, dy, ir, iPr) {
                var children = node.children;

                node.x = x;
                node.y = (node.depth - 2) * dy + ir + iPr;
                node.dx = dx;
                node.hdx = hdx;
                node.dy = dy;

                if (node.depth) {

                    if (node.depth === 1 && !ir) {
                        node.y = 0;
                        node.dy = iPr;
                    }

                    series._setColor(node, gradual, height);
                    series.calculateLabelInfo(node);

                    // outside label may be revised to inside,
                    // otherwise do nothing
                    if (node.dataLabels && node.dataLabels.enabled) {
                        // clone once only
                        if (!node.dataLabels._align && node.dataLabels.align === Constants.OUTSIDE) {
                            node.dataLabels = BaseUtils.clone(node.dataLabels);
                            node.dataLabels._align = node.dataLabels._align || node.dataLabels.align;
                        }
                        if (node.dataLabels._align === Constants.OUTSIDE) {
                            if (node.depth === height) {
                                node.dataLabels.align = Constants.OUTSIDE;
                            } else {
                                node.dataLabels.align = Constants.INSIDE;
                            }
                        }
                    }

                } else {
                    // -1 to avoid dy=0, thus invalidate drill down scale
                    node.y = -1;
                    node.dy = ir + 1;
                }
                
                node._x = node.x;
                node._dx = node.dx;
                node._hdx = node.hdx;
                node._y = node.y;
                node._dy = node.dy;

                if (children && (n = children.length)) {
                    var i = -1, n, c, d, hd;
                    dx = node.value ? dx / node.value : 0;
                    hdx = node.chSum ? hdx / node.chSum : 0;
                    while (++i < n) {
                        c = children[i];
                        d = Math.abs(c.value) * dx;
                        hd = Math.abs(c.chSum) * hdx;
                        dfsData(c, x, d, hd, dy, ir, iPr);
                        x += hd;
                    }

                }
            }

            dfsData(root, startAngle, arc, arc, dRadius, innerRadius, innerPieR);
        },

        _setColor: function (node, gradual, height) {
            if (!(node && gradual && height)) {
                return;
            }
            if (node.options.color) {
                node.color = node.options.color;
            } else {
                var rgba = ColorUtils.getRGBAColorArray(node.ancestor.color);
                var hsb = ColorUtils.rgb2hsb(rgba[0], rgba[1], rgba[2]);
                var detS, detB;

                var ratio = (node.depth - 1) / height;

                if (gradual === Constants.GRADUAL_LIGHTER) {
                    detS = -hsb[1] * ratio;
                    detB = (1 - hsb[2]) * ratio;
                } else {
                    detS = (1 - hsb[1]) * ratio;
                    detB = -hsb[2] * ratio;
                }

                node.color = ColorUtils.mixColorWithHSB(node.ancestor.color, 0, detS, detB);
            }


            if (node.options.mouseOverColor) {
                node.mouseOverColor = node.options.mouseOverColor;
            } else {
                var detS, detB;
                if (gradual === Constants.GRADUAL_LIGHTER) {
                    detS = +0.1;
                    detB = -0.05
                } else {
                    detS = -0.1;
                    detB = +0.05;
                }
                
                node.mouseOverColor = ColorUtils.mixColorWithHSB(
                    (node.tooltip && node.tooltip.enabled && node.tooltip.shared) ?
                        node.ancestor.color :
                        node.color,
                    0, detS, detB);
            }
            var hexAlpha = ColorUtils.getStandardColorAndOpacity(node.color, node.options.opacity);
            node.color = hexAlpha.hex;
            node.opacity = hexAlpha.alpha;
        },

        _calculateLabelPos: function () {
            var series = this;
            var outPoints = [];
            var inPoints = [];

            series.nodes.map(function (node) {
                node.labelPos = null;
                if (node.dx < VIS_MIN) {
                    return;
                }

                if (node.name &&
                    node.depth &&
                    node.dx &&
                    node.dy &&
                    (series.drilldownNow ? node !== series.drilldownNow.parent : true) &&
                    node.dataLabels && node.dataLabels.enabled) {

                    if (node.dataLabels.align === Constants.OUTSIDE) {
                        outPoints.push(node);
                    } else {
                        inPoints.push(node);
                    }
                }
            }, series);

            var chartInfo = series.chartInfo;

            series.calcOutsideLabel(outPoints, chartInfo.bounds, chartInfo.center, chartInfo.radius);

            series.calculateLeadLineStartPos(outPoints);

            series.calculateInsideLabelBounds(inPoints);
        },

        _getInnerRadius: function (d) {
            return d.y;
        },

        _getOuterRadius: function (d) {
            return d.y + d.dy;
        },

        _getStartAngle: function (d) {
            return d.x;
        },

        _getEndAngle: function (d) {
            return d.x + d.dx;
        },

        _getFixedPos:function(datum, divDim){

            var translateX = this.center[0];
            var translateY = this.center[1];

            var centerAngle = this.getCenterAngle(datum);
            var radius = datum.y + datum.dy;

            var centerX = radius * Math.sin(centerAngle) + translateX;
            var centerY = radius * Math.cos(centerAngle + Math.PI) + translateY;

            if(centerAngle < Math.PI / 2){
                centerY -= divDim.height;
            }else if(centerAngle >= Math.PI && centerAngle < 3 * Math.PI / 2){
                centerX -= divDim.width;
            }else if(centerAngle >= 3 * Math.PI / 2 && centerAngle < CIRCLE){
                centerY -= divDim.height;
                centerX -= divDim.width;
            }

            return [centerX, centerY];
        },
        
        drillDown: function (d) {
            if (this.drilldownNow === d) {
                return;
            }

            var p, node = d;
            while ((p = node.parent) && p.depth) {
                node = p;
                if (!p.name) {
                    return;
                }
            }

            this.drilldownNow = d;

            var radius = this.radius;
            var innerRadius = this.innerRadius;

            function deepest(node) {
                var children = node.children;
                var dc = node;
                if (children && (n = children.length)) {
                    var i = -1, n;
                    while (++i < n) {
                        var c = deepest(children[i]);
                        if (c.depth > dc.depth) {
                            dc = c;
                        }
                    }
                }
                return dc;
            }

            var yDomain, yRange;

            if (d.depth) {
                var rootHeight = d.ancestor.parent.height;

                if (d.height == 0) {
                    // outer ring
                    yDomain = [d.parent._y, d._y, d._y + d._dy];
                    yRange = [0, INNER_RING_RADIUS, radius];

                } else if (d.height + d.depth !== rootHeight) {
                    // deepest child is not outer ring
                    var dc = deepest(d);
                    yDomain = [d.parent._y, d._y, d._y + d._dy, dc._y + dc._dy, radius];
                    yRange = [0, INNER_RING_RADIUS, radius / 2, radius, radius];

                } else {
                    yDomain = [d.parent._y, d._y, d._y + d._dy, radius];
                    yRange = [0, INNER_RING_RADIUS, radius / 2, radius];
                }

            } else {
                yDomain = [0, innerRadius, radius];
                yRange = [0, innerRadius, radius];
            }

            var h = d.depth + d.height;

            this.sx.domain([d._x, d._x + d._dx]);
            this.sy.domain(yDomain).range(yRange);

            this.nodes.map(function (node) {
                if (node.depth &&
                    node.dataLabels &&
                    node.dataLabels.enabled &&
                    node.dataLabels._align === Constants.OUTSIDE) {
                    if (node.depth === h) {
                        node.dataLabels.align = Constants.OUTSIDE;
                    } else {
                        node.dataLabels.align = Constants.INSIDE;
                    }
                    QueryUtils.merge(node, this.calculateLabelInfo(node), true)
                }
                node.x = this.safeAngle(node._x);
                node.dx = this.safeAngle(node._x + node._dx) - node.x;
                node.y = this.safeRadius(node._y);
                node.dy = this.safeRadius(node._y + node._dy) - node.y;

                if (node === this.drilldownNow.parent) {
                    node.dx = this.safeAngle(7);// to ensure inner pie fill the circle.
                }

            }, this);

            this._calculateLabelPos();
            
            this.drawDrillDown(d);
        },

        safeAngle: function (x) {
            return Math.max(this.startAngle, Math.min(this.endAngle, this.sx(x)));
        },

        safeRadius: function (y) {
            return Math.max(0, this.sy(y));
        },

        _getTranslate:function(){
            return this.center;
        },

        _getMoreLabelDefaultCenter:function(d, moreLabelDim) {
            var rotate = d.rotate || 0;
            var angle = rotate + d.x + d.dx / 2 ;
            var r = d.y + d.dy / 2;
            var center = this._getArcPoint(r, angle);
            return {
                centerX: center[0],
                centerY: center[1]
            }
        },

        getStyle:function(p){
            return {
                'fill':p.color,
                'fill-opacity':p.opacity,
                'stroke': p.borderColor,
                'stroke-opacity':p.borderOpacity,
                'stroke-width':p.borderWidth
            }
        },

        getAttrs:function(p){
            return {'d':this.arc(p)};
        },

        getPointGraphicKey:function(){
            return 'path';
        },
        
        getChartNodes: function () {
            return this.nodes;
        },

        getCenter: function () {
            return this.center;
        },

        getInnerRadius: function () {
            return this.innerRadius;
        },

        getRadius: function () {
            return this.radius;
        },
        
        getStartAngle: function () {
            return this.startAngle;
        },
        
        getEndAngle: function () {
            return this.endAngle;
        },
        
        getDrilldown: function () {
            return this.drilldown;
        },
        
        getRotatable: function () {
            return this.rotatable;
        },

        getIsChanged: function () {
            return this.isChanged;
        },

        _getPositionInPie:function(absPos){

            var x = absPos[0] - this.center[0];

            var y = absPos[1] - this.center[1];

            return [x, y];
        },

        _getPointGraphicGroup:function(){
            if (!this.wrapGroup) {
                this.wrapGroup = this.group.append(this.vanchart.renderer.group());
                this.pathGroup = this.wrapGroup.append(this.vanchart.renderer.group());
                this.drawRing();
            }
            return this.pathGroup;
        },

        _getPointTextLabelGroup:function(){
            if(!this.textLabelGroup){
                this.textLabelGroup = this.group.append(this.vanchart.renderer.group());
            }
            return this.textLabelGroup;
        },

        getAnimationTime: function () {
            return ANIMATION_TIME;
        },

        drawRing: function () {
            if (this.ringPath) {
                return;
            }
            this.ringPath = this.group.append(this.vanchart.renderer.path());
            this.ringPath
                .attr({
                    'd':d3.svg.arc()
                        .startAngle(0)
                        .endAngle(Math.PI * 2)
                        .innerRadius(INNER_RING_RADIUS)
                        .outerRadius(INNER_RING_RADIUS + INNER_RING_STROKE_WIDTH)(),
                    'display': 'none'
                })
                .style({
                    'fill': 'rgba(0,0,0,0.1)',
                    'pointer-events': 'none'
                })

        },

        drawDrillDown: function (target) {
            var series = this;
            var supportAnimation = series.animation;

            series._removeDataLabels();
            series._animateEnd();

            var arc = series.arc;
            if (supportAnimation) {
                series.nodes
                    .filter(function (node) {return node.graphic;})
                    .map(function (node) {
                    node.graphic.animate(series, function (dom, d) {
                        d3.select(dom)
                            .transition()
                            .duration(ANIMATION_TIME)
                            .style('fill', function(){
                                return d.color;
                            })
                            .attrTween("d", function () {
                                var self = this;
                                var i = d3.interpolate(
                                    {
                                        x: self.x1,
                                        y: self.y1,
                                        dx: self.dx1,
                                        dy: self.dy1
                                    }, d);
                                return function (t) {
                                    var b = i(t);
                                    self.x1 = b.x;
                                    self.y1 = b.y;
                                    self.dx1 = b.dx;
                                    self.dy1 = b.dy;
                                    return arc(b);
                                };
                            })
                            // following handle the small edge things,
                            // doesn't matter to the main animation...
                            .attrTween('opacity', function () {
                                var self = this;
                                return function (t) {
                                    return (d.depth && (self.y1 + self.dy1) >= INNER_RING_RADIUS) ? 1 : 0
                                }
                            })
                            .each('end', function () {
                                d3.select(this).attr('opacity', (d.depth && d.dx && (d.y + d.dy) > INNER_RING_RADIUS) ? 1 : 0)
                            });
                    }, node)
                });

                if (target.depth) {
                    d3.select(series.ringPath.node())
                        .transition()
                        .delay(ANIMATION_TIME)
                        .attr('display', '');
                } else {
                    d3.select(series.ringPath.node())
                        .transition()
                        .attr('display', 'none');
                }

            } else {

                series.nodes.map(function (d) {
                    d.graphic
                        .attr({
                            'd': arc(d),
                            'opacity': (d.depth && d.dx && (d.y + d.dy) > INNER_RING_RADIUS) ? 1 : 0
                        })
                });

                series.ringPath.attr('display', target.depth ? '' : 'none');

            }

        },

        // animation
        initialAnimation: function () {
            var series = this;
            d3.select(this.wrapGroup.node())
                .transition()
                .duration(550)
                .ease('linear')
                .attrTween('transform', function () {
                    var i = d3.interpolate(-180, 0);
                    return function (t) {
                        var inter = i(t);
                        return 'rotate(' + inter + ')';
                    };
                });

            d3.select(this.pathGroup.node())
                .transition()
                .duration(400)
                .ease('linear')
                .attrTween('transform', function () {
                    var i = d3.interpolate(0, 0.9);
                    return function (t) {
                        var inter = i(t);
                        return 'scale(' + inter + ')';
                    };
                })
                .transition()
                .duration(1000)
                .ease('elastic', 1.1, 0.3)
                .attrTween('transform', function () {
                    var i = d3.interpolate(0.9, 1);
                    return function (t) {
                        var inter = i(t);
                        return 'scale(' + inter + ')';
                    };
                })
                .each('end', function () {
                    series.initialAnimationMoving = false;
                });
        },

        updateAnimation:function(dom, d, delay, cb){
            var arc = this.arc;

            d3.select(dom)
                .attr("display", (d.name || !d.depth) ? '' : 'none')
                .attr("opacity", d.depth ? 1 : 0)// hide inner ring
                .transition()
                .ease(EASE)
                .duration(ANIMATION_TIME)
                .attrTween("d", function () {

                    var self = this;
                    var i = d3.interpolate(
                        {
                            x: self.x1,
                            y: self.y1,
                            dx: self.dx1,
                            dy: self.dy1
                        }, d);
                    return function (t) {
                        var b = i(t);
                        self.x1 = b.x;
                        self.y1 = b.y;
                        self.dx1 = b.dx;
                        self.dy1 = b.dy;
                        return arc(b);
                    };
                })
                .each('end', cb);
        },

        createAnimation:function(dom, d, delay){

            var arc, data;

            if (this.initialAnimationMoving) {
                this.initialAnimation();
                data = d;
            } else {
                data = {x:d.x, y:d.y, dx:0, dy:d.dy};
            }
            arc = this.arc(data);

            function stash() {
                dom.x1 = data.x;
                dom.y1 = data.y;
                dom.dx1 = data.dx;
                dom.dy1 = data.dy;
            }

            d3.select(dom)
                .attr("d", arc)
                .attr("display", (d.name || !d.depth) ? '' : 'none')
                .attr("opacity", d.depth ? 1 : 0)// hide inner ring
                .each(stash);

            if (!this.initialAnimationMoving) {
                this.updateAnimation(dom, d);
            }

        },

        dropAnimation:function(dom, d, delay){
            this.updateAnimation(dom, d, delay, function () {
                d3.select(dom).remove()
            });
        },

        // event
        onPointMouseOver:function(){
            this.series._onState.call(this, true);
        },

        onPointMouseOut:function(){
            this.series._onState.call(this, false);
        },

        _onState: function (isChosen) {
            var point = this;
            if (point.tooltip && point.tooltip.shared) {
                var p, node = point;
                while ((p = node.parent) && p.depth && p.y+p.dy !== INNER_RING_RADIUS) {
                    node = p;
                    p.series._onSingleState.call(p, isChosen);
                }
            }
            point.series._onSingleState.call(point, isChosen);
        },

        _onSingleState:function(isChosen){
            var point = this, series = point.series, animation = series.animation;
            var pathNode = point.graphic.rawElement;
            var style = {}, attr = {};
            if (point.depth && pathNode.y1+pathNode.dy1 === INNER_RING_RADIUS) {
                attr = {'opacity': isChosen ? 1 : 0};
            } else {
                style = {
                    'fill-opacity': isChosen ? 1 : point.opacity,
                    'fill': isChosen ? point.mouseOverColor : point.color
                };
            }

            if(animation){
                d3.select(point.graphic.style(style).rawElement)
                    .interrupt(Constants.SELECT_ANIMATION)
                    .transition(Constants.SELECT_ANIMATION)
                    .duration(INNER_HOVER_TIME)
                    .ease(INNER_HOVER_EASE)
                    .attr(attr);
            }else{
                point.graphic.attr(attr).style(style);
            }
        },

        onPanStart:function(ev){
            if(!this.rotatable){
                return;
            }

            this.initPos = ev.containerPoint;

            this.initRotate = BaseUtils.toDegree(this.chartInfo.rotate);
        },

        onPanMove:function(ev){
            if (!this.rotatable) {
                return;
            }

            var startAngle = this._getAngle(this._getPositionInPie(this.initPos), [0,0]);

            var newAngle = this._getAngle(this._getPositionInPie(ev.containerPoint), [0,0]);

            var rotate = newAngle - startAngle + this.initRotate;

            this.pathGroup.attr("transform", "rotate(" + rotate + ")");

            this.chartInfo.rotate = BaseUtils.toRadian(rotate);

            this._calculateLabelPos();

            this._rotateLabels();
        },

        onPointTap: function () {
            if (this.series.getDrilldown()) {
                this.series.drillDown(this);
            }
        },

        getEvents:function(){
            return {
                'panstart':this.onPanStart,
                'panmove':this.onPanMove,
                'panend':this.onPanEnd
            }
        },

        /////////
        _rotateLabels:function(){
            var series = this, vanchart = series.vanchart, renderer = vanchart.renderer, group = this.textLabelGroup;
            series.nodes.forEach(function(point){

                if(point.textGraphic && !point.labelPos){
                    point.textGraphic.remove();
                    point.leadLine && point.leadLine.remove();
                    point.textGraphic = null, point.leadLine = null;
                }else if(point.textGraphic && point.labelPos){

                    point.textGraphic.attr('transform', BaseUtils.makeTranslate(point.labelPos));

                    if(point.labelPos.startPos){
                        if(point.leadLine){
                            point.leadLine.attr('d', series._getLeadLinePath(point));
                        }else{
                            point.leadLine = series._getLeadLine(point);
                        }
                    }
                }else if(!point.textGraphic && point.labelPos){
                    series._createTextGraphic(point);
                }
            });
        }

    });
    
    require('../ChartLibrary').register(Constants.MULTIPIE_CHART, multiPie);
});
/**
 * Created by eason on 16/8/9.
 * 指针类型的仪表盘
 */


define('chart/PointerGauge',['require','../Constants','../utils/BaseUtils','../utils/ColorUtils','../utils/BoundsManager'],function(require){

    var Constants = require('../Constants');
    var BaseUtils = require('../utils/BaseUtils');
    var ColorUtils = require('../utils/ColorUtils');
    var BoundsManager = require('../utils/BoundsManager');

    var POINTER_ANGLE = 150;
    var POINTER_SEMI_ANGLE = 90;

    return {
        gaugeType:Constants.POINTER_GAUGE,

        _doLayout:function(){

            this._dealSeriesLabel();

            this._dealValueLabel();

            this.style == 'pointer' ? this._fixPointerCenter() : this._fixPointerSemiCenter();
        },

        //默认的是ring and slot 其他要重写这个方法
        _drawDiffMoreLabels: function () {
            var series = this, points = series.points;

            var singleLabelHeight = BaseUtils.getTextHeight(series._getMoreLabelStyle());
            var totalHeight = singleLabelHeight * points.length + singleLabelHeight / 2 * (points.length - 1);
            var gap = Math.max(0, (series.radius - totalHeight)/2);

            var startY = series.style == 'pointer' ?  gap : -series.radius + gap;

            points.forEach(function (point) {
                series._showAndExitMoreLabel(point, 0, startY + singleLabelHeight / 2);

                startY += singleLabelHeight + singleLabelHeight / 2;
            });
        },

        getDataToDraw:function(){
            return this.points;
        },

        _fixPointerCenter:function(){
            var gauge = this, radius = gauge.radius, center = gauge.center;
            var align = gauge.seriesLabel.align || Constants.BOTTOM;
            if (!center) {
                var bounds = gauge.bounds;
                var labelHeight = 20 + gauge.seriesLabelDim.height;

                var usedHeight = bounds.height - labelHeight;

                var centerX = bounds.x + bounds.width / 2;
                var centerY = bounds.y + bounds.height / 2;
                radius = Math.min(bounds.width, usedHeight) / 2 - gauge.DEFAULT_PADDING;

                if (align == Constants.BOTTOM) {

                    if (centerY + radius + labelHeight > bounds.y + bounds.height) {

                        var gap = bounds.height - (radius * 2 + labelHeight);

                        if (gap >= 0) {
                            centerY = bounds.y + radius + gap / 2;
                        }
                    }

                } else {

                    if (centerY - radius - labelHeight < bounds.y) {

                        var gap = bounds.height - (radius * 2 + labelHeight);

                        if (gap >= 0) {
                            centerY = bounds.y + radius + labelHeight + gap / 2;
                        }

                    }
                }

                gauge.centerX = centerX;
                gauge.centerY = centerY;
                gauge.radius = radius;
            } else {
                gauge.centerX = center[0];
                gauge.centerY = center[1];
                gauge.radius = radius;
            }

            if(gauge.seriesLabelContent){
                var dim = gauge.seriesLabelDim;

                gauge.seriesLabelPos = {
                    x: -dim.width/2,
                    y:align == Constants.BOTTOM ? (radius+20) : (-radius-20-dim.height)
                }
            }

            if(gauge.valueLabelContent){
                var gaugeAxis = gauge.gaugeAxis, axisOption = gaugeAxis.options;
                var domain = gaugeAxis.scale.domain();
                var scale = d3.scale.linear().domain(domain).range([BaseUtils.toRadian(-150), BaseUtils.toRadian(150)]);
                var tickHeight = BaseUtils.getTextHeight(axisOption.labelStyle);

                var startY = 0.16 * radius + tickHeight/2;
                var labelR = (1 - 0.05 - 0.1) * radius;
                var endY = labelR * Math.cos(Math.PI/6) - 2 * tickHeight;

                this._dealValueLabelContent(gauge, radius, scale, startY, endY);
            }
        },

        _fixPointerSemiCenter:function(){
            var gauge = this, radius = gauge.radius, align = gauge.seriesLabel.align;
            if (!gauge.center) {
                var bounds = gauge.bounds;
                var labelHeight = 20 + gauge.seriesLabelDim.height;

                var usedHeight = bounds.height - labelHeight;
                radius = Math.min(bounds.width / 2, usedHeight / 1.14) - gauge.DEFAULT_PADDING;

                var centerX = bounds.x + bounds.width / 2;
                var centerY = bounds.y + bounds.height / 2 + radius / 2;

                if (align == Constants.BOTTOM) {

                    if (centerY + 0.14 * radius + labelHeight > bounds.y + bounds.height) {

                        var gap = bounds.height - (radius * 1.14 + labelHeight);

                        if (gap >= 0) {
                            centerY = bounds.y + radius + gap / 2;
                        }
                    }

                } else {

                    if (centerY - radius - labelHeight < bounds.y) {

                        var gap = bounds.height - (radius * 1.14 + labelHeight);

                        if (gap >= 0) {
                            centerY = bounds.y + radius + labelHeight + gap / 2;
                        }

                    }
                }

                gauge.centerX = centerX;
                gauge.centerY = centerY;
                gauge.radius = radius;
            } else {
                gauge.centerX = gauge.center[0];
                gauge.centerY = gauge.center[1];
                gauge.radius = radius;
            }


            if(gauge.seriesLabelContent){
                var dim = gauge.seriesLabelDim;

                gauge.seriesLabelPos = {
                    x: -dim.width/2,
                    y:align == Constants.BOTTOM ? (radius * 0.14 + 20) : (-radius-20-dim.height)
                }
            }

            if(gauge.valueLabelContent){
                var gaugeAxis = gauge.gaugeAxis, axisOption = gaugeAxis.options;
                var domain = gaugeAxis.scale.domain();
                var scale = d3.scale.linear().domain(domain).range([BaseUtils.toRadian(-90), BaseUtils.toRadian(90)]);

                var tickHeight = BaseUtils.getTextHeight(axisOption.labelStyle);
                var labelR = (1 - 0.05 - 0.1) * radius;
                var startY = -(labelR  - 2 * tickHeight);
                var endY = -(0.11 * radius + tickHeight/2);

                this._dealValueLabelContent(gauge, radius, scale, startY, endY);
            }
        },

        _dealValueLabelContent:function(gauge, radius, scale, startY, endY){
            var gaugeAxis = gauge.gaugeAxis, axisOption = gaugeAxis.options;
            var tickHeight = BaseUtils.getTextHeight(axisOption.labelStyle);
            var valueLabelStyle = gauge.valueLabel.style;
            var useHtml = gauge.valueLabel.useHtml;
            var valueLabelHeight = BaseUtils.getTextHeight(valueLabelStyle);

            var boundsManager = this._getPointerTickBoundsManager(gaugeAxis, radius, scale, tickHeight);

            var count = gauge.valueLabelContent.length;

            var totalHeight = endY - startY;

            count = Math.min(Math.floor((totalHeight - valueLabelHeight/2)/(3 * valueLabelHeight/2)), count);
            count = Math.max(0, count);

            //只显示count个标签
            gauge.valueLabelContent.length = count;

            var totalHeight = valueLabelHeight * count + (count - 1) * valueLabelHeight/2;

            startY = (endY - startY - totalHeight)/2 + startY;

            var valueBackgroundY = startY - valueLabelHeight/2;
            var valueBackgroundX = Number.MAX_VALUE;

            for(var i = 0; i < count; i++){
                var singleLabel = gauge.valueLabelContent[i];

                var x = -singleLabel.labelDim.width/2;

                var tmpX = Math.min(x - valueLabelHeight/4, valueBackgroundX);

                var tmpBounds = {
                    x:tmpX,
                    y:valueBackgroundY,
                    width:2 * Math.abs(tmpX),
                    height:startY + valueLabelHeight * (1 + this.LINE_GAP) - valueBackgroundY
                };

                var singleLabelContent = singleLabel.labelContent;
                var hasClipped = false;
                while(boundsManager.isOverlapped(tmpBounds) && singleLabelContent.length){
                    singleLabelContent = singleLabelContent.substr(0, Math.floor(singleLabelContent.length * 0.9));
                    var tmpDim = BaseUtils.getTextDimension(singleLabelContent + '...', valueLabelStyle, useHtml);
                    x = -tmpDim.width/2;

                    tmpX = Math.min(x - valueLabelHeight/4, valueBackgroundX);

                    tmpBounds = {
                        x:tmpX,
                        y:valueBackgroundY,
                        width:2 * Math.abs(tmpX),
                        height:startY + valueLabelHeight * (1 + this.LINE_GAP) - valueBackgroundY
                    };

                    hasClipped = true;
                }

                if(hasClipped){
                    singleLabel.labelContent = singleLabelContent + '...';
                    singleLabel.labelDim = BaseUtils.getTextDimension(singleLabel.labelContent, valueLabelStyle, useHtml);
                    x = -singleLabel.labelDim.width/2;
                    tmpX = Math.min(x - valueLabelHeight/4, valueBackgroundX);
                }

                singleLabel.labelPos = {
                    x:x,
                    y:startY
                };

                startY += valueLabelHeight * (1 + this.LINE_GAP);

                valueBackgroundX = tmpX;
            }

            gauge.valueLabelBackground = {
                x:valueBackgroundX,
                y:valueBackgroundY,
                width:2 * Math.abs(valueBackgroundX),
                height:totalHeight + valueLabelHeight
            };
        },

        _getPointerTickBoundsManager:function(gaugeAxis, radius, scale, tickHeight){

            var manager = new BoundsManager();
            var labelR = (1 - 0.05 - 0.1 - 0.01) * radius;
            var tickData = gaugeAxis.tickData;
            var gauge = this, gap = tickHeight * 0.5;

            tickData.forEach(function(tick){

                var center = gauge._getPointerTickCenter(tick, labelR, scale);

                manager.addBounds({
                    x:center.x - tick.tickDim.width/2 - gap,
                    y:center.y - tick.tickDim.height/2 - gap,
                    width:tick.tickDim.width + gap,
                    height:tick.tickDim.height + gap
                })
            });

            var minorTickData = gaugeAxis.getMinorTickData() || [];

            var minorTickR = (1 - 0.05 - 0.1) * radius;
            var minorTickSize = 0.1 * radius;

            minorTickData.forEach(function(minorTickValue){

                var radian = scale(minorTickValue);

                var point = gauge._getArcPoint(minorTickR, radian);

                var x, y;
                if(radian < Math.PI){
                    //右边
                    x = point[0];
                    y = point[1];

                }else{
                    //左边
                    x = point[0] - minorTickSize;
                    y = point[1];
                }

                manager.addBounds({
                    x:x,
                    y:y,
                    width:minorTickSize,
                    height:minorTickSize
                });
            });

            return manager;
        },

        //指针仪表盘刻度标签相对于圆心的标签中心的位置
        _getPointerTickCenter:function(tick, labelR, scale){

            var radian = scale(tick.tickValue);

            var joinPoint = this._getArcPoint(labelR, radian);
            var x = joinPoint[0];
            var y = joinPoint[1];

            var tickDim = tick.tickDim;

            var angle = Math.atan(tickDim.width / tickDim.height);

            var labelCenterX, labelCenterY;
            if(Math.abs(radian) < angle){

                var gap = tickDim.height/2;
                labelCenterX = x + gap * x / y;
                labelCenterY = y + gap;

            }else if(radian >= angle && radian <= (Math.PI - angle)){//右

                var gap = tickDim.width/2;
                labelCenterX = x - gap;
                labelCenterY = y - gap * y / x;

            }else if(radian >= angle - Math.PI && radian <= -angle){//左

                var gap = tickDim.width/2;
                labelCenterX = x + gap;
                labelCenterY = y + gap * y / x;

            }else{
                //下
                var gap = tickDim.height/2;
                labelCenterX = x - gap * x / y;
                labelCenterY = y - gap;
            }

            return {
                x:labelCenterX,
                y:labelCenterY
            }
        },

        drawSeries:function(){
            var series = this, vanchart = series.vanchart, renderer = vanchart.renderer, group = series.group;
            if(!this.backgruondPath){
                this.backgruondPath = renderer.path().addTo(group);
                this.hingePath = renderer.path().addTo(group);

                this.labelGroup = this._getPointTextLabelGroup();

                this.axisGroup = renderer.group().addTo(group);
                this.needleGroup = renderer.group().addTo(group);
                this.pointerHingePath = renderer.path().addTo(group);
            }

            if(!this.dropFilter){
                this.dropFilter =  renderer.createDropShadowFilter(0, 2, 0.1, 2);
                this.innerFilter = renderer.createInnerShadowFilter(0, 2, 0.1, 2);
            }

            this.style == 'pointer' ? this._drawPointer(180,0.16,0.07) : this._drawPointer(98,0.11,0.055);
        },

        onSeriesPress:function(){

            var circle = d3.svg.arc().startAngle(0).endAngle(2 * Math.PI).innerRadius(0);

            var hBackground = this.style == 'pointer' ? 0.16 : 0.11;
            var hinge = this.style == 'pointer' ? 0.07 : 0.055;

            circle.outerRadius(hBackground * this.radius * 1.25);
            this.hingePath.attr('d', circle());

            //枢纽
            circle.outerRadius(hinge * this.radius * 1.25);
            this.pointerHingePath.attr('d', circle());
        },

        onSeriesPressUp:function(){

            var circle = d3.svg.arc().startAngle(0).endAngle(2 * Math.PI).innerRadius(0);

            var hBackground = this.style == 'pointer' ? 0.16 : 0.11;
            var hinge = this.style == 'pointer' ? 0.07 : 0.055;

            circle.outerRadius(hBackground * this.radius);
            this.hingePath.attr('d', circle());

            //枢纽
            circle.outerRadius(hinge * this.radius);
            this.pointerHingePath.attr('d', circle());
        },

        _getScale:function(){
            var series = this, style = series.style, scaleAngle = style == 'pointer' ? POINTER_ANGLE : POINTER_SEMI_ANGLE;
            var domain = series.gaugeAxis.scale.domain();
            return d3.scale.linear().domain(domain).range([BaseUtils.toRadian(-scaleAngle), BaseUtils.toRadian(scaleAngle)]);
        },

        getStyle:function(p){
            var series = p.series;
            return {
                'fill':series.needle,
                'fill-opacity':ColorUtils.getColorOpacity(series.needle)
            };
        },

        getAttrs:function(p){
            var scale = this._getScale(), series = p.series;
            return {'d':series._getArrowPath(scale(p.y))};
        },

        getPointGraphicKey:function(){
            return 'path';
        },

        _getPointGraphicGroup:function(){
            return this.needleGroup;
        },

        createAnimation:function(dom, point){
            var series = point.series, scale = series._getScale();
            var lastAngle = dom._current_ || scale(scale.domain()[0]);
            dom._current_ = scale(point.y);
            d3.select(dom).transition()
                .duration(series.ANIMATION_TIME).ease(series.EASE_TYPE)
                .attrTween('d', function(){
                    var interpolate = d3.interpolate(lastAngle, dom._current_);
                    return function(t){
                        return series._getArrowPath(interpolate(t));
                    }
                });
        },

        updateAnimation:function(dom, point){
            this.createAnimation(dom, point)
        },

        dropAnimation:function(dom){
            d3.select(dom).remove()
        },

        _getArrowPath:function(initRadian){
            var radius = this.radius;
            var p0 = this._getArcPoint(0.9 * radius, initRadian);
            var p1 = this._getArcPoint(0.02 * radius, initRadian + Math.PI/2);
            var p2 = this._getArcPoint(0.02 * radius, initRadian - Math.PI/2);
            return 'M' + p0[0] + ',' + p0[1] + 'L' + p1[0] + ',' + p1[1] + 'L' + p2[0] + ',' + p2[1] + 'Z';
        },

        _getArcPoint:function(r, radian){
            return [this._dealWithFloat(r * Math.sin(radian)), this._dealWithFloat(-r * Math.cos(radian))]
        },

        

        _drawPointer:function(baseAngle, hBackground, hinge){

            var series = this, radius = series.radius, renderer = series.vanchart.renderer;
            var circle = d3.svg.arc().startAngle(0).endAngle(2 * Math.PI).innerRadius(0);

            var arc = d3.svg.arc().startAngle(BaseUtils.toRadian(-baseAngle))
                .endAngle(BaseUtils.toRadian(baseAngle))
                .innerRadius(0).outerRadius(radius).toCenter(false);

            series.backgruondPath.attr('d', arc()).style({
                    'fill':series.paneBackgroundColor,
                    'fill-opacity':ColorUtils.getColorOpacity(series.paneBackgroundColor),
                    'filter':'url(#'+ BaseUtils.stamp(series.dropFilter) +')'
            });

            //枢纽背景
            circle.outerRadius(hBackground * radius);
            series.hingePath.attr('d', circle()).style({
                    'fill' : series.hingeBackgroundColor,
                    'fill-opacity':ColorUtils.getColorOpacity(series.hingeBackgroundColor),
                    'filter':'url(#'+ BaseUtils.stamp(series.innerFilter) +')'
                });

            this._drawPointerTicks();

            this._drawGaugeLabels(series.labelGroup);
            //枢纽
            circle.outerRadius(hinge * radius);
            series.pointerHingePath.attr('d', circle()).style({
                    'fill':series.hinge,
                    'fill-opacity':ColorUtils.getColorOpacity(series.hinge),
                    'filter':'url(#'+ BaseUtils.stamp(series.dropFilter) +')'
            });
        },

        _drawPointerTicks:function(){
            var series = this, bands = series.bands, vanchart = series.vanchart, gaugeAxis = series.gaugeAxis, renderer = vanchart.renderer;

            var axisG = this.labelGroup, tickData = gaugeAxis.getTickData(), minorTickData = gaugeAxis.getMinorTickData();

            var axisOption = gaugeAxis.options, labelStyle = axisOption.labelStyle, useHtml = axisOption.useHtml;

            var tickR = (1 - 0.05) * series.radius, labelR = (1 - 0.05 - 0.1 - 0.01) * series.radius;

            var scale = this._getScale();

            this.ticks = this.ticks || [];

            var selection = gaugeAxis._bindData(this.ticks, tickData, function(d){return scale(d.tickValue);});
            var currentTickLines = [], i, len;

            selection.exit.map(function (layer) {
                layer.text && layer.text.remove();
                layer.remove();
            });

            currentTickLines = selection.enter.map(function (d) {
                var line = axisG.append(renderer.line().datum(d));
                if (d.tickContent) {
                    line.text = axisG.append(renderer.vtext(useHtml));
                }
                return line;
            });

            this.ticks = currentTickLines = currentTickLines.concat(selection.update);

            for(i = 0, len = currentTickLines.length; i < len; i++){

                var tick = currentTickLines[i], tickD = tick.datum();

                var radian = scale(tickD.tickValue);
                var start = series._getArcPoint(tickR, radian);
                var end = series._getArcPoint(tickR - 0.1 * series.radius, radian);

                var color = series._getColorFromBands(tickD.tickValue, bands);

                tick.attr('x1', start[0]).attr('y1', start[1]).attr('x2', end[0]).attr('y2', end[1])
                    .style({'stroke':color, 'stroke-width':1});

                var center = series._getPointerTickCenter(tickD, labelR, scale);

                tick.text && tick.text.textContent(tickD.tickContent).style(labelStyle)
                    .attr({
                        x: center.x - tickD.tickDim.width/2,
                        y: center.y - tickD.tickDim.height/2,
                        dy: '.85em'
                    });
            }


            this.minorTics = this.minorTics || [];
            var selection = gaugeAxis._bindData(this.minorTics, minorTickData);
            var currentTickLines = [], i, len;
            for(i = 0, len = selection.exit.length; i < len; i++){
                selection.exit[i].remove();
            }

            for(i = 0, len = selection.enter.length; i < len; i++){
                currentTickLines.push(axisG.append(renderer.line().datum(selection.enter[i])));
            }

            this.minorTics = currentTickLines = currentTickLines.concat(selection.update);
            for(i = 0, len = currentTickLines.length; i < len; i++){
                var tickLine = currentTickLines[i], value = tickLine.datum();
                var radian = scale(value);
                var start = series._getArcPoint(tickR, radian);
                var end = series._getArcPoint(tickR - 0.05 * series.radius, radian);
                var color = series._getColorFromBands(value, bands);
                tickLine.attr('x1', start[0]).attr('y1', start[1])
                    .attr('x2', end[0]).attr('y2', end[1]).style({'stroke':color, 'stroke-width':1});
            }
        },

    };
});


/**
 * Created by eason on 16/8/9.
 * 刻度槽仪表盘
 */

define('chart/SlotGauge',['require','../Constants','../utils/Formatter','../utils/ColorUtils','../utils/BaseUtils'],function(require){

    var Constants = require('../Constants');
    var Formatter = require('../utils/Formatter');
    var ColorUtils = require('../utils/ColorUtils');
    var BaseUtils = require('../utils/BaseUtils');

    return {
        gaugeType:Constants.SLOT_GAUGE,

        _dealValueLabel:function(){
            var series = this, point = series.points[0], valueLabel = series.valueLabel, useHtml = valueLabel.useHtml, formatter = valueLabel.formatter;
            if(!point){
                return;
            }
            var labelContent = this._createMultiLineLabelContent(formatter, point);
            var labelStyle = valueLabel.style;
            var valueLabelContent = [];
            for(var i = 0, len = labelContent.length; i < len; i++){

                valueLabelContent.push({
                    labelContent:labelContent[i],
                    labelStyle:labelStyle,
                    labelDim:BaseUtils.getTextDimension(labelContent[i], labelStyle, useHtml)
                });
            }
            series.valueLabelContent = valueLabelContent;
        },

        _fixCenterAndRadius:function(){
            var gauge = this;
            if (!gauge.center) {
                var bounds = gauge.bounds;

                var radius = Math.min(bounds.width / 2, bounds.height / 2);

                //刻度槽的宽度是0.16倍的半径
                radius = radius / 1.08 - gauge.DEFAULT_PADDING;

                var centerX = bounds.x + bounds.width / 2;
                var centerY = bounds.y + bounds.height / 2;

                gauge.centerX = centerX;
                gauge.centerY = centerY;
                gauge.radius = radius;
            }else{
                gauge.centerX = gauge.center[0];
                gauge.centerY = gauge.center[1];
            }

            if(gauge.percentageLabelContent && gauge.valueLabelContent && gauge.valueLabelContent.length > 0){

                gauge.percentageLabelPos = {
                    x:-gauge.percentageLabelDim.width/2,
                    y:-gauge.percentageLabelDim.height * (1 + gauge.LINE_GAP)
                };

                var startY = 0;
                for(var i = 0, count = gauge.valueLabelContent.length; i < count; i++){

                    var valueLabel = gauge.valueLabelContent[i];

                    valueLabel.labelPos = {
                        x:-valueLabel.labelDim.width/2,
                        y:startY
                    };

                    startY += (valueLabel.labelDim.height * (1 + gauge.LINE_GAP))
                }

            }else if(gauge.percentageLabelContent){

                gauge.percentageLabelPos = {
                    x:-gauge.percentageLabelDim.width/2,
                    y:-gauge.percentageLabelDim.height/2
                };

            }else if(gauge.valueLabelContent && gauge.valueLabelContent.length > 0){

                var labelHeight = BaseUtils.getTextHeight(gauge.valueLabel.style);
                var labelCount = gauge.valueLabelContent.length;

                var totalHeight = labelHeight * labelCount + labelHeight * (labelCount - 1) / 2;

                var startY = - totalHeight / 2;

                for(var i = 0; i < labelCount; i++){

                    var valueLabel = gauge.valueLabelContent[i];

                    valueLabel.labelPos = {
                        x:-valueLabel.labelDim.width/2,
                        y:startY
                    };
                    startY += (labelHeight * (1 + gauge.LINE_GAP));
                }
            }
        },

        drawSeries:function(){
            var series = this, point = series.points[0], vanchart = series.vanchart, renderer = vanchart.renderer, group = series.group;

            if(!this.backgruondPath){
                this.backgruondPath = renderer.path().addTo(group);
                this.slotBackground = renderer.path().addTo(group);
                this.needlePath = renderer.circle().addTo(group);
                this.labelGroup = this._getPointTextLabelGroup();
            }

            if(!this.innderShadow){
                this.innderShadow = renderer.createInnerShadowFilter(0, 2, 0.05, 0);
                this.dropShadow = renderer.createDropShadowFilter(0, 2, 0.05, 0);
            }

            var arc = d3.svg.arc().startAngle(BaseUtils.toRadian(-135)).endAngle(BaseUtils.toRadian(135))
                .innerRadius(0).outerRadius(series.radius).toCenter(false).closePath(false);

            var circle = d3.svg.arc().startAngle(BaseUtils.toRadian(-135)).endAngle(BaseUtils.toRadian(135))
                .innerRadius(0).outerRadius(series.radius).toCenter(false).closePath(false);

            var domain = series.gaugeAxis.scale.domain();
            var scale = d3.scale.linear().domain(domain).range([BaseUtils.toRadian(-135), BaseUtils.toRadian(135)]);

            series.backgruondPath.attr('d', circle())
                .style({
                    'fill':'none',
                    'stroke': series.slotBackgroundColor,
                    'stroke-linecap':'round',
                    'stroke-width': series.radius * 0.16,
                    'filter':'url(#'+ BaseUtils.stamp(this.innderShadow) +')'
                });

            if(!point){
                return;
            }

            var initRadian = scale(domain[0]), endRadian = scale(BaseUtils.getValueInDomain(point.y, domain));
            var endDegree = BaseUtils.toDegree(endRadian - initRadian);
            var startStroke = series._getColorFromBands(domain[0], series.bands);
            var endStroke = point.color;

            series.slotBackground.style({
                    'fill':'none',
                    'stroke': ColorUtils.colorToHex(endStroke),
                    'stroke-linecap':'round',
                    'stroke-width': series.radius * 0.16
            });

            //白色指针
            var cP = this._getArcPoint(series.radius, initRadian);
            series.needlePath.attr('cx', cP[0]).attr('cy', cP[1])
                .attr('r', 0.048 * series.radius)
                .style({
                    'fill':series.needle,
                    'fill-opacity':ColorUtils.getColorOpacity(series.needle),
                    'filter':'url(#'+ BaseUtils.stamp(this.dropShadow) +')'
                });

            if(series.animation){
                d3.select(series.slotBackground.node())
                    .transition().duration(series.ANIMATION_TIME).ease(series.EASE_TYPE)
                    .attrTween('d', function(){
                        this._lastRadian_ = this._lastRadian_ || initRadian;
                        var interpolate = d3.interpolate(this._lastRadian_, endRadian);
                        this._lastRadian_ = endRadian;
                        return function(t){
                            return arc.endAngle(interpolate(t))();
                        }
                    });
                d3.select(series.needlePath.node())
                    .transition().duration(series.ANIMATION_TIME).ease(series.EASE_TYPE)
                    .attrTween('transform', function(){
                        this._lastRotate_ = this._lastRotate_ || 0;
                        var interpolate = d3.interpolate(this._lastRotate_, endDegree);
                        this._lastRotate_ = endDegree;
                        return function(t){
                            return "rotate(" + interpolate(t) + ")";
                        }
                    });
            }else{
                series.slotBackground.attr('d', arc.endAngle(endRadian)());
                series.needlePath.attr('transform',"rotate(" + endDegree + ")" )
            }

            this._drawGaugeLabels(this.labelGroup);
        },

        onSeriesPress:function(){
            var point = this.points[0];
            if(point){
                var backgroundColor = ColorUtils.getColorWithDivider(point.color, 1/0.95);
                var needleColor = ColorUtils.getColorWithDivider(this.needle, 1/0.95);

                this.slotBackground.style({'stroke':ColorUtils.colorToHex(backgroundColor)});

                this.needlePath.style({'fill':needleColor});
            }
        },

        onSeriesPressUp:function(){

        }
    }
});

/**
 * Created by eason on 16/8/9.
 * 环形仪表盘
 */

define('chart/RingGauge',['require','../Constants','../utils/ColorUtils','../utils/BaseUtils'],function(require){

    var Constants = require('../Constants');
    var ColorUtils = require('../utils/ColorUtils');
    var BaseUtils = require('../utils/BaseUtils');

    return {
        gaugeType:Constants.RING_GAUGE,

        _fixCenterAndRadius:function(){
            var gauge = this;
            if (!gauge.center) {
                var bounds = gauge.bounds;
                var radius = Math.min(bounds.width/2, bounds.height/2) - gauge.DEFAULT_PADDING;
                var centerX = bounds.x + bounds.width/2;
                var centerY = bounds.y + bounds.height/2;

                gauge.centerX = centerX;
                gauge.centerY = centerY;
                gauge.radius = radius;
            }else{
                gauge.centerX = gauge.center[0];
                gauge.centerY = gauge.center[1];
            }

            var totalHeight = 0;
            var valueLabel = gauge.valueLabelContent ? gauge.valueLabelContent[0] : null;
            if(gauge.percentageLabelContent && valueLabel){
                totalHeight = gauge.percentageLabelDim.height * (1 + gauge.LINE_GAP) + valueLabel.labelDim.height;
            }else if(gauge.percentageLabelContent){
                totalHeight = gauge.percentageLabelDim.height;
            }else if(valueLabel){
                totalHeight = valueLabel.labelDim.height;
            }

            var startY = -totalHeight/2;

            if(gauge.percentageLabelContent){
                gauge.percentageLabelPos = {
                    x: -gauge.percentageLabelDim.width/2,
                    y:startY
                };

                startY += gauge.percentageLabelDim.height * (1 + gauge.LINE_GAP);
            }

            if(valueLabel){
                valueLabel.labelPos = {
                    x:-valueLabel.labelDim.width/2,
                    y:startY
                };
            }
        },

        drawSeries:function(){
            var series = this, vanchart = series.vanchart, renderer = vanchart.renderer, group = series.group;
            if(!this.backgruondPath){
                this.backgruondPath = renderer.path().addTo(group);
                this.ringPath = renderer.path().addTo(group);
                this.innerBackgroundPath = renderer.path().addTo(group);
                this.innerStroke = renderer.path().addTo(group);
                this.outerStroke = renderer.path().addTo(group);
                this.labelGroup = this._getPointTextLabelGroup();
            }

            if(!this.colorGradient){
                var attrs = {'x1':'0%', 'y1':"0%", 'x2':"0%", 'y2':"100%"};
                var stop1 = {'offset':'0%', 'stop-color':'#ffffff'};
                var stop2 = {'offset':'100%', 'stop-color':'#dddddd'};
                this.colorGradient = renderer.colorGradient(attrs, [stop1, stop2]);


                stop1['stop-color'] = '#dddddd';
                stop2['stop-color'] = '#ffffff';
                this.clickedGradient = renderer.colorGradient(attrs, [stop1, stop2]);

                if(!BaseUtils.isSupportSVG()){
                    this.colorGradient = '#ffffff';
                    this.clickedGradient = '#dddddd';
                }
            }
            var circle = d3.svg.arc().startAngle(0).endAngle(2 * Math.PI).innerRadius(0).outerRadius(series.radius);
            var domain = series.gaugeAxis.scale.domain();
            var startFill = series._getColorFromBands(domain[0], series.bands);
            var innerR = series.radius * 0.8;
            var outerStrokeR = innerR + 2, innerStrokeR = innerR - 1.5;

            this.backgruondPath.attr('d', circle()).style({
                'fill':series.paneBackgroundColor,
                'fill-opacity':ColorUtils.getColorOpacity(series.paneBackgroundColor)
            });

            var point = series.points[0];
            if(point) {
                var arc = d3.svg.arc().startAngle(0).innerRadius(0).outerRadius(series.radius);
                var endFill = point.color, arcPercentage = Math.max(point.percentage, 0);
                var endRadian = 2 * Math.PI * arcPercentage * (series.clockwise ? 1 : -1);
                if (series.animation) {
                    this.ringPath.style({
                        'fill': ColorUtils.colorToHex(endFill),
                        'fill-opacity': ColorUtils.getColorOpacity(endFill)
                    });
                    d3.select(this.ringPath.node())
                        .transition().duration(series.ANIMATION_TIME).ease(series.EASE_TYPE)
                        .attrTween('d', function () {
                            this._lastRadian_ = this._lastRadian_ || 0;
                            var interpolate = d3.interpolate(this._lastRadian_, endRadian);
                            this._lastRadian_ = endRadian;

                            return function (t) {
                                return arc.endAngle(interpolate(t))();
                            }
                        });
                } else {
                    this.ringPath.attr('d', arc.endAngle(endRadian)()).style({
                        'fill': endFill, 'fill-opacity': ColorUtils.getColorOpacity(endFill)
                    });
                }
            }

            this.innerBackgroundPath.attr('d', circle.outerRadius(innerR)())
                .style({
                    'fill':series.innerPaneBackgroundColor,
                    'fill-opacity':ColorUtils.getColorOpacity(series.innerPaneBackgroundColor)
                });

           this.outerStroke.attr('d', circle.outerRadius(outerStrokeR)())
                .style({'fill': 'none', 'stroke':'#000000', 'stroke-opacity':0.05, 'stroke-width':4 });

            this.innerStroke.attr('d', circle.outerRadius(innerStrokeR)())
                .style({
                    'fill': 'none',
                    'stroke':this._getStroke(this.colorGradient),
                    'stroke-width':3
                });


            this._drawGaugeLabels(this.labelGroup);
        },

        onSeriesPress:function(){
            var point = this.points[0];
            if(point){
                this.innerStroke.style({'stroke':this._getStroke(this.clickedGradient)});
                this.ringPath.style({'fill': ColorUtils.getClickColor(point.color)});
            }
        },

        onSeriesPressUp:function(){

        }
    }
});
/**
 * Created by eason on 16/8/9.
 * 
 */

define('chart/ThermometerGauge',['require','../Constants','../utils/ColorUtils','../utils/BaseUtils'],function(require){

    var Constants = require('../Constants');
    var ColorUtils = require('../utils/ColorUtils');
    var BaseUtils = require('../utils/BaseUtils');

    var TICK_SIZE = 6;
    var TICK_LABEL_GAP = 4;
    var THERMOMETER_R = 5;
    var DEFAULT_RADIUS = 100;
    var MAGIC_DET = 0.001;

    return {
        gaugeType:Constants.THERMOMETER_GAUGE,

        //默认的是ring and slot 其他要重写这个方法
        _drawDiffMoreLabels: function () {
            var point = this.points[0];

            if(!point){
                return;
            }

            var domain = this.gaugeAxis.scale.domain();

            var vertical = this.thermometerLayout == Constants.VERTICAL_LAYOUT;
            var scale = d3.scale.linear().domain(domain).range(
                vertical ? [this.radius , -this.radius] : [ -this.radius , this.radius]);
            var index = scale(point.y);

            var centerX = vertical ? 0 - THERMOMETER_R * 2 : index;
            var centerY = vertical ? index : 0 - THERMOMETER_R * 2;

            function f(a, b) {
                return a - b/2;
            }

            this._showAndExitMoreLabel(point, centerX, centerY, f, f);
        },

        _fixCenterAndRadius:function(){
            var point = this.points[0];

            if(!point){
                this.centerX = this.centerY = this.radius = 0;
                return;
            }

            var gauge = this;
            var para = gauge.thermometerLayout == Constants.HORIZONTAL_LAYOUT ?
                this._fixHorizontalThermometerCenter() : this._fixVerticalThermometerCenter();

            var centerX = para.centerX;
            var centerY = para.centerY;
            var radius = para.radius;
            var showValueLabel = gauge.valueLabelContent ? gauge.valueLabelContent[0] : null;

            if(gauge.percentageLabelContent){
                gauge.percentageLabelPos.x -= centerX;
                gauge.percentageLabelPos.y -= centerY;

                //与底边对齐
                gauge.percentageLabelPos.y = Math.min(gauge.percentageLabelPos.y, radius - gauge.percentageLabelDim.height);
            }

            if(showValueLabel){
                showValueLabel.labelPos.x -= centerX;
                showValueLabel.labelPos.y -= centerY;

                var gap = (radius - showValueLabel.labelDim.height) - showValueLabel.labelPos.y;

                //与底边对齐
                if(gap < 0){
                    showValueLabel.labelPos.y += gap;

                    if(gauge.percentageLabelContent){
                        gauge.percentageLabelPos.y += gap;
                    }
                }
            }

            gauge.centerX = centerX;
            gauge.centerY = centerY;
            gauge.radius = radius;
        },

        _fixHorizontalThermometerCenter:function(){

            var centerX, centerY, radius;
            var gauge = this, gaugeAxis = gauge.gaugeAxis;
            var percentageLabel = gauge.percentageLabel, valueLabel = gauge.valueLabel;
            var showValueLabel = gauge.valueLabelContent ? gauge.valueLabelContent[0] : null;

            var totalHeight = this._getThermometerSize();
            var startY;

            if (gauge.center) {
                centerX = gauge.center[0];
                centerY = gauge.center[1];
                radius = gauge.radius;
                startY = centerY;

            } else {
                var bounds = gauge.bounds;
                startY = bounds.y + (bounds.height - totalHeight)/2;
                centerX = bounds.x + bounds.width/2;
                radius = bounds.width/2 - gaugeAxis.getMaxTickWidth() - gauge.DEFAULT_PADDING;
            }

            if(gauge.percentageLabelContent || showValueLabel){
                if(gauge.percentageLabelContent && showValueLabel
                    && percentageLabel.align == Constants.TOP && valueLabel.align == Constants.TOP){

                    if (gauge.center) {
                        startY -= (gauge.percentageLabelDim.height * (1 + gauge.LINE_GAP));
                        startY -= (showValueLabel.labelDim.height * (1 + gauge.HORIZONTAL_GAP));
                        startY -= (gaugeAxis.getTickHeight() + TICK_LABEL_GAP + TICK_SIZE + TICK_LABEL_GAP + THERMOMETER_R);
                    }

                    gauge.percentageLabelPos = {
                        x: -gauge.percentageLabelDim.width/2 + centerX,
                        y:startY
                    };

                    startY += (gauge.percentageLabelDim.height * (1 + gauge.LINE_GAP));

                    showValueLabel.labelPos = {
                        x: -showValueLabel.labelDim.width/2 + centerX,
                        y:startY
                    };

                    startY += (showValueLabel.labelDim.height * (1 + gauge.HORIZONTAL_GAP));


                }else{

                    if(gauge.percentageLabelContent && percentageLabel.align == Constants.TOP){

                        if (gauge.center) {
                            startY -= (gauge.percentageLabelDim.height * (1 + gauge.HORIZONTAL_GAP));
                            startY -= (gaugeAxis.getTickHeight() + TICK_LABEL_GAP + TICK_SIZE + TICK_LABEL_GAP + THERMOMETER_R);
                        }

                        gauge.percentageLabelPos = {
                            x: -gauge.percentageLabelDim.width/2 + centerX,
                            y:startY
                        };

                        startY += (gauge.percentageLabelDim.height * (1 + gauge.HORIZONTAL_GAP));
                    }

                    if(showValueLabel && valueLabel.align == Constants.TOP){

                        if (gauge.center) {
                            startY -= (showValueLabel.labelDim.height * (1 + gauge.HORIZONTAL_GAP));
                            startY -= (gaugeAxis.getTickHeight() + TICK_LABEL_GAP + TICK_SIZE + TICK_LABEL_GAP + THERMOMETER_R);
                        }

                        showValueLabel.labelPos = {
                            x: -showValueLabel.labelDim.width/2 + centerX,
                            y:startY
                        };

                        startY += (showValueLabel.labelDim.height * (1 + gauge.HORIZONTAL_GAP));
                    }
                }
            }

            if (gauge.center) {
                startY = centerY + 5;
            } else {
                startY += (gaugeAxis.getTickHeight() + TICK_LABEL_GAP + TICK_SIZE + TICK_LABEL_GAP + THERMOMETER_R * 2);
                centerY = startY - 5;
            }

            if(gauge.percentageLabelContent || showValueLabel){

                if(gauge.percentageLabelContent && showValueLabel
                    && percentageLabel.align == Constants.BOTTOM && valueLabel.align == Constants.BOTTOM){
                    startY += (gauge.percentageLabelDim.height * gauge.HORIZONTAL_GAP);

                    gauge.percentageLabelPos = {
                        x: -gauge.percentageLabelDim.width/2 + centerX,
                        y:startY
                    };

                    startY += (gauge.percentageLabelDim.height * (1 + gauge.LINE_GAP));

                    showValueLabel.labelPos = {
                        x: -showValueLabel.labelDim.width/2 + centerX,
                        y:startY
                    };

                }else{

                    if(gauge.percentageLabelContent && percentageLabel.align == Constants.BOTTOM){

                        startY += (gauge.percentageLabelDim.height * gauge.HORIZONTAL_GAP);

                        gauge.percentageLabelPos = {
                            x: -gauge.percentageLabelDim.width/2 + centerX,
                            y:startY
                        };

                    }

                    if(showValueLabel && valueLabel.align == Constants.BOTTOM){

                        startY += (showValueLabel.labelDim.height * gauge.HORIZONTAL_GAP);

                        showValueLabel.labelPos = {
                            x: -showValueLabel.labelDim.width/2 + centerX,
                            y:startY
                        };

                    }
                }

            }

            return {
                centerX:centerX,
                centerY:centerY,
                radius:radius
            }
        },

        _fixVerticalThermometerCenter:function(){
            var gauge = this, gaugeAxis = gauge.gaugeAxis;
            var percentageLabel = gauge.percentageLabel, valueLabel = gauge.valueLabel;
            var centerX, centerY, radius;

            var point = gauge.points[0];
            var domain = gaugeAxis.scale.domain();
            var showValueLabel = gauge.valueLabelContent ? gauge.valueLabelContent[0] : null;

            //纵向布局
            var totalWidth = this._getThermometerSize();
            var startX;

            if (gauge.center) {
                centerX = gauge.center[0];
                centerY = gauge.center[1];
                radius = gauge.radius;
                startX = centerX - THERMOMETER_R * 2;

            } else {
                var bounds = gauge.bounds;
                startX = bounds.x + (bounds.width - totalWidth)/2;
                centerY = bounds.y + bounds.height/2;
                radius = bounds.height/2 - gaugeAxis.getTickHeight() - gauge.DEFAULT_PADDING;
            }

            var scale = d3.scale.linear().domain(domain).range([radius, -radius]);
            var labelY = centerY + scale(BaseUtils.getValueInDomain(point.y, domain));

            if(gauge.percentageLabelDim){
                labelY -= gauge.percentageLabelDim.height/3;//差不多居中的位置
            }

            if(gauge.percentageLabelContent || showValueLabel){

                if(gauge.percentageLabelContent && showValueLabel
                    && percentageLabel.align == Constants.LEFT && valueLabel.align == Constants.LEFT){

                    if (!gauge.center) {
                        startX += Math.max(gauge.percentageLabelDim.width, showValueLabel.labelDim.width);
                        centerX = startX + THERMOMETER_R;
                    }

                    gauge.percentageLabelPos = {
                        x:startX - gauge.percentageLabelDim.width,
                        y:labelY
                    };

                    showValueLabel.labelPos = {
                        x:startX - showValueLabel.labelDim.width,
                        y:labelY + gauge.percentageLabelDim.height * (1 + gauge.LINE_GAP)
                    };

                    startX += gauge.LINE_GAP * Math.max(gauge.percentageLabelDim.height, showValueLabel.labelDim.height);

                }else{

                    if(gauge.percentageLabelContent && percentageLabel.align == Constants.LEFT){

                        if (gauge.center) {
                            startX -= (gauge.percentageLabelDim.width + gauge.LINE_GAP * gauge.percentageLabelDim.height);
                        }

                        gauge.percentageLabelPos = {
                            x:startX,
                            y:labelY
                        };

                        startX += (gauge.percentageLabelDim.width + gauge.LINE_GAP * gauge.percentageLabelDim.height);
                    }

                    if(showValueLabel && valueLabel.align == Constants.LEFT){

                        if (gauge.center) {
                            startX -= (showValueLabel.labelDim.width + gauge.LINE_GAP * showValueLabel.labelDim.height);
                        }

                        showValueLabel.labelPos = {
                            x:startX,
                            y:labelY
                        };

                        startX += (showValueLabel.labelDim.width + gauge.LINE_GAP * showValueLabel.labelDim.height);
                    }
                }
            }

            if (gauge.center) {
                startX = centerX - THERMOMETER_R;
            } else {
                centerX = startX + THERMOMETER_R;
            }

            startX += (THERMOMETER_R * 2 + TICK_LABEL_GAP + TICK_SIZE + TICK_LABEL_GAP + gaugeAxis.getMaxTickWidth());

            if(gauge.percentageLabelContent || showValueLabel){
                if(gauge.percentageLabelContent && showValueLabel
                    && percentageLabel.align == Constants.RIGHT && valueLabel.align == Constants.RIGHT){

                    startX += gauge.LINE_GAP * Math.max(gauge.percentageLabelDim.height, showValueLabel.labelDim.height);

                    gauge.percentageLabelPos = {
                        x:startX,
                        y:labelY
                    };

                    showValueLabel.labelPos = {
                        x:startX,
                        y:labelY + gauge.percentageLabelDim.height * (1 + gauge.LINE_GAP)
                    };

                }else{

                    if(gauge.percentageLabelContent && percentageLabel.align == Constants.RIGHT){
                        gauge.percentageLabelPos = {
                            x:startX + gauge.LINE_GAP * gauge.percentageLabelDim.height,
                            y:labelY
                        };
                    }

                    if(showValueLabel && valueLabel.align == Constants.RIGHT){

                        showValueLabel.labelPos = {
                            x:startX + gauge.LINE_GAP * showValueLabel.labelDim.height,
                            y:labelY
                        };
                    }
                }
            }

            return {
                centerX:centerX,
                centerY:centerY,
                radius:radius
            }
        },

        //试管仪表盘占据的大小,不算间隔
        _getThermometerSize:function(){

            var gauge = this, valueLabel = gauge.valueLabel, gaugeAxis = gauge.gaugeAxis;
            var showValueLabel = gauge.valueLabelContent ? gauge.valueLabelContent[0] : null;
            var percentageLabel = gauge.percentageLabel;

            if(gauge.thermometerLayout == Constants.HORIZONTAL_LAYOUT){

                var totalHeight = 0;

                if(gauge.percentageLabelContent && showValueLabel){
                    if(percentageLabel.align == valueLabel.align){
                        totalHeight += (gauge.percentageLabelDim.height + showValueLabel.labelDim.height);
                        totalHeight += gauge.LINE_GAP * gauge.percentageLabelDim.height;

                        totalHeight += gauge.HORIZONTAL_GAP * (valueLabel.align == Constants.TOP
                                ? showValueLabel.labelDim.height : gauge.percentageLabelDim.height);
                    }
                }else if(gauge.percentageLabelContent){
                    totalHeight += (1 + gauge.HORIZONTAL_GAP) * gauge.percentageLabelDim.height;
                }else if(showValueLabel){
                    totalHeight += (1 + gauge.HORIZONTAL_GAP) * showValueLabel.labelDim.height;
                }

                totalHeight += (THERMOMETER_R * 2 + TICK_LABEL_GAP + TICK_SIZE + TICK_LABEL_GAP + gaugeAxis.getTickHeight());

                return totalHeight;

            }else{

                var totalWidth = 0;
                if(gauge.percentageLabelContent && showValueLabel){
                    if(percentageLabel.align == valueLabel.align){
                        totalWidth += Math.max(gauge.percentageLabelDim.width, showValueLabel.labelDim.width);
                        totalWidth += gauge.VERTICAL_GAP * Math.max(gauge.percentageLabelDim.height, showValueLabel.labelDim.height);
                    }else{
                        totalWidth += (gauge.percentageLabelDim.width + showValueLabel.labelDim.width);
                        totalWidth += gauge.VERTICAL_GAP * (gauge.percentageLabelDim.height + showValueLabel.labelDim.height);
                    }
                }else if(gauge.percentageLabelContent){
                    totalWidth += (gauge.percentageLabelDim.width + gauge.VERTICAL_GAP * gauge.percentageLabelDim.height);
                }else if(showValueLabel){
                    totalWidth += (showValueLabel.labelDim.width + gauge.VERTICAL_GAP * showValueLabel.labelDim.height);
                }

                totalWidth += gaugeAxis.getMaxTickWidth();

                totalWidth += (THERMOMETER_R * 2 + TICK_LABEL_GAP + TICK_SIZE + TICK_LABEL_GAP);

                return totalWidth;
            }

            return DEFAULT_RADIUS;
        },

        drawSeries:function(){
            var series = this, point = series.points[0], vanchart = series.vanchart, renderer = vanchart.renderer, group = series.group;

            if(!point){
                return;
            }

            var gaugeAxis = series.gaugeAxis, domain = gaugeAxis.scale.domain(), isVertical = series.thermometerLayout == Constants.VERTICAL_LAYOUT;
            var valueInDomain = BaseUtils.getValueInDomain(point.y, domain), color = point.color, radius = series.radius;

            if(!this.backgruondLine){
                this.backgruondLine = renderer.line().addTo(group);
                this.thermometerLine = renderer.line().addTo(group);
                this.needlePath = renderer.circle().addTo(group);
                this.axisGroup = renderer.group().addTo(group);
                this.labelGroup = this._getPointTextLabelGroup();

                var endColor = color;
                var startColor = ColorUtils.mixColorWithHSB(endColor, 0, -0.1, 0.1);

                var  x2 = '0%', y2 = '0%';
                isVertical ? y2 = '100%': x2 = '100%';
                var stop1 = {'offset': '0%', 'stop-color': isVertical ? endColor : startColor};
                var stop2 = {'offset':'100%', 'stop-color': isVertical ? startColor : endColor};
                this.colorGradient = renderer.colorGradient({'x1':'0%', 'y1':'0%', 'x2':x2, 'y2':y2}, [stop1, stop2]);

                var endColorClicked = ColorUtils.getColorWithDivider(endColor, 1/0.95);
                var startColorClicked = ColorUtils.mixColorWithHSB(endColor, 0, -0.1, 0.1);
                stop1 = {'offset': '0%', 'stop-color': isVertical ? endColorClicked : startColorClicked};
                stop2 = {'offset':'100%', 'stop-color': isVertical ? startColorClicked : endColorClicked};
                this.clickedColorGradient = renderer.colorGradient({'x1':'0%', 'y1':'0%', 'x2':x2, 'y2':y2}, [stop1, stop2]);


                var endColorMouseOver = ColorUtils.getColorWithDivider(point.mouseOverColor, 1/0.95);
                var startColorMouseOver = ColorUtils.mixColorWithHSB(point.mouseOverColor, 0, -0.1, 0.1);
                stop1 = {'offset': '0%', 'stop-color': isVertical ? endColorMouseOver : startColorMouseOver};
                stop2 = {'offset':'100%', 'stop-color': isVertical ? startColorMouseOver : endColorMouseOver};
                this.mouseOverColorGradient = renderer.colorGradient({'x1':'0%', 'y1':'0%', 'x2':x2, 'y2':y2}, [stop1, stop2]);

                if(!BaseUtils.isSupportSVG()){
                    this.colorGradient = endColor;
                    this.clickedColorGradient = endColorClicked;
                    this.mouseOverColorGradient = endColorMouseOver;
                }
            }

            var scale = d3.scale.linear().domain(domain).range([-radius, radius]);
            var x1 = 'x1', y1 = 'y1', x2 = 'x2', y2 = 'y2', cx = 'cx', cy = 'cy';

            var endX = scale(valueInDomain);
            var initX = -radius;

            if(isVertical){
                x1 = 'y1'; y1 = 'x1'; x2 = 'y2'; y2 = 'x2';cx = 'cy'; cy = 'cx';
                initX = radius;
                endX = scale.range([radius, -radius])(valueInDomain);
            }

            var lastX = series.thermometerLine.node()._lastX_ || initX;
            series.thermometerLine.node()._lastX_ = endX;

            series.backgruondLine.attr(x1, -radius).attr(y1, 0).attr(x2, radius).attr(y2, MAGIC_DET)
                .style({'fill':'none', 'stroke': series.slotBackgroundColor,
                    'stroke-width':THERMOMETER_R * 2, 'stroke-linecap':'round'});

            series.thermometerLine.attr(x1, initX).attr(y1, 0).attr(y2, MAGIC_DET).attr(x2, lastX)
                .style({
                    'stroke':series._getStroke(series.colorGradient),
                    'stroke-width':THERMOMETER_R * 2,
                    'stroke-linecap':'round'
                });

            series.needlePath.attr('r', THERMOMETER_R * 0.9).attr(cx, lastX).attr(cy, 0)
                .style({
                    'fill': series.needle,
                    'fill-opacity':ColorUtils.getColorOpacity(series.needle),
                    'stroke-width': THERMOMETER_R * 0.6,
                    'stroke':ColorUtils.mixColorWithHSB(color, 0, 0.1, -0.1)
                });

            if(series.animation){

                d3.select(series.thermometerLine.node())
                    .transition().duration(series.ANIMATION_TIME).ease(series.EASE_TYPE).attr(x2, endX);

                d3.select(this.needlePath.node())
                    .transition().duration(series.ANIMATION_TIME).ease(series.EASE_TYPE).attr(cx, endX);
            }else{
                series.thermometerLine.attr(x2, endX);
                this.needlePath.attr(cx, endX).attr('r', THERMOMETER_R * 0.9)
            }

            this._drawGaugeLabels(this.labelGroup);
            this._drawThermometerTicks(scale);
        },

        _drawThermometerTicks:function(scale) {
            var series = this, bands = series.bands, vanchart = series.vanchart, gaugeAxis = series.gaugeAxis, renderer = vanchart.renderer;

            var axisG = this.labelGroup, tickData = gaugeAxis.getTickData(), minorTickData = gaugeAxis.getMinorTickData();

            var axisOption = gaugeAxis.options, labelStyle = axisOption.labelStyle, useHtml = axisOption.useHtml;

            var x1 = 'x1', y1 = 'y1', x2 = 'x2', y2 = 'y2';

            var startY = -9, endY = -15, endMinorY = -13;
            var textY = -19;

            var attrFunc = function (tickD, posX) {
                return {
                    x: posX - tickD.tickDim.width / 2,
                    y: textY - tickD.tickDim.height * 0.85,
                    dy: '0.85em'
                }
            };

            if (series.thermometerLayout == Constants.VERTICAL_LAYOUT) {
                x1 = 'y1'; y1 = 'x1'; x2 = 'y2'; y2 = 'x2';
                startY = 9; endY = 15; endMinorY = 13;
                textY = 19;
                attrFunc = function (tickD, posX) {
                    return {
                        x: textY,
                        y: posX - tickD.tickDim.height / 2,
                        dy: '.85em'
                    }
                }
            }

            this.ticks = this.ticks || [];

            var selection = gaugeAxis._bindData(this.ticks, tickData, function (d) {
                return scale(d.tickValue);
            });
            var currentTickLines = [], i, len;

            selection.exit.map(function (layer) {
                layer.text && layer.text.remove();
                layer.remove();
            });

            currentTickLines = selection.enter.map(function (d) {
                var line = axisG.append(renderer.line().datum(d));
                if (d.tickContent) {
                    line.text = axisG.append(renderer.vtext(useHtml));
                }
                return line;
            });

            this.ticks = currentTickLines = currentTickLines.concat(selection.update);

            for (i = 0, len = currentTickLines.length; i < len; i++) {
                var tick = currentTickLines[i], tickD = tick.datum();
                var posX = BaseUtils.lineSubPixelOpt(scale(tickD.tickValue), 1);

                tick.attr(x1, posX).attr(y1, startY).attr(x2, posX).attr(y2, endY)
                    .style({'stroke': axisOption.tickColor, 'stork-width': axisOption.tickWidth});

                tick.text && tick.text.textContent(tickD.tickContent).style(labelStyle).attr(attrFunc(tickD, posX));
            }


            this.minorTics = this.minorTics || [];
            var selection = gaugeAxis._bindData(this.minorTics, minorTickData);
            var currentTickLines = [], i, len;
            for (i = 0, len = selection.exit.length; i < len; i++) {
                selection.exit[i].remove();
            }

            for (i = 0, len = selection.enter.length; i < len; i++) {
                currentTickLines.push(axisG.append(renderer.line().datum(selection.enter[i])));
            }

            this.minorTics = currentTickLines = currentTickLines.concat(selection.update);
            for (i = 0, len = currentTickLines.length; i < len; i++) {
                var tickLine = currentTickLines[i], value = tickLine.datum();
                var posX = BaseUtils.lineSubPixelOpt(scale(value), 1);
                tickLine.attr(x1, posX).attr(y1, startY)
                    .attr(x2, posX).attr(y2, endMinorY).style({
                    'stroke': axisOption.minorTickColor,
                    'stork-width': axisOption.minorTickWidth
                });
            }
        },

        _getFixedPos:function(datum, divDim) {
            var gauge = datum.series, thermometerLayout = gauge.thermometerLayout;

            var x, y;

            if(thermometerLayout == Constants.HORIZONTAL_LAYOUT){
                x = gauge.centerX - divDim.width/2;
                var baseY = gauge.centerY;
                y = baseY + THERMOMETER_R + 10;

                if(gauge.percentageLabelContent && gauge.percentageLabel.align == Constants.BOTTOM){
                    y = baseY + gauge.percentageLabelPos.y + gauge.percentageLabelDim.height + 10;
                }

                if(gauge.valueLabelContent && gauge.valueLabel.align == Constants.BOTTOM){
                    var valueLabel = gauge.valueLabelContent[0];
                    y = baseY + valueLabel.labelPos.y + valueLabel.labelDim.height + 10;
                }

            }else{

                y = gauge.centerY - divDim.height/2;

                var tickWidth = gauge.gaugeAxis.getMaxTickWidth();

                var baseX = gauge.centerX;
                x = baseX + THERMOMETER_R + TICK_LABEL_GAP + TICK_SIZE + TICK_LABEL_GAP + tickWidth + 10;

                if(gauge.percentageLabelContent && gauge.percentageLabel.align == Constants.RIGHT){

                    x = baseX + gauge.percentageLabelPos.x + gauge.percentageLabelDim.width + 10;
                }

                if(gauge.valueLabelContent && gauge.valueLabel.align == Constants.RIGHT){
                    var valueLabel = gauge.valueLabelContent[0];
                    x = Math.max(x, baseX + valueLabel.labelPos.x + valueLabel.labelDim.width + 10)
                }
            }

            return [x, y];
        },

        onSeriesPress:function(){
            var point = this.points[0];
            if(point){
                this.thermometerLine.style('stroke', this._getStroke(this.clickedColorGradient));

                this.needlePath
                    .style({
                        'stroke':ColorUtils.getClickColor(point.color),
                        'fill': ColorUtils.getClickColor(this.needle)
                    });
            }
        },

        onSeriesPressUp:function(){

        }
    }
});
/**
 * Created by eason on 15/12/2.
 */
define('chart/Gauge',['require','../Constants','../utils/BaseUtils','./Series','../utils/QueryUtils','../utils/BoundsManager','../utils/Formatter','../theme/config','./PointerGauge','./SlotGauge','./RingGauge','./ThermometerGauge','../ChartLibrary'],function(require){

    var Constants = require('../Constants');
    var BaseUtils = require('../utils/BaseUtils');
    var Series = require('./Series');
    var QueryUtils = require('../utils/QueryUtils');
    var BoundsManager = require('../utils/BoundsManager');
    var Formatter = require('../utils/Formatter');
    var Config = require('../theme/config');

    var PointerGauge = require('./PointerGauge');
    var SlotGauge = require('./SlotGauge');
    var RingGauge = require('./RingGauge');
    var ThermometerGauge = require('./ThermometerGauge');
    var PROTOTYPES = {
        'pointer':PointerGauge,
        'slot':SlotGauge,
        'ring':RingGauge,
        'thermometer':ThermometerGauge
    };

    //默认半径大小
    var DEFAULT_RADIUS = 100;

    var TICK_SIZE = 6;
    var TICK_LABEL_GAP = 4;
    var THERMOMETER_R = 5;

    var Gauge = Series.extend({

        DEFAULT_PADDING:5,

        LINE_GAP:0.3,
        VERTICAL_GAP:0.3,
        HORIZONTAL_GAP:0.8,

        ANIMATION_TIME:1000,
        EASE_TYPE:'quad-out',

        _refresh:function(){
            var queryList = this._getQueryList();

            var gaugeType = QueryUtils.queryList(queryList, 'style');
            gaugeType = (gaugeType == 'pointer_semi') ? Constants.POINTER_GAUGE : gaugeType;

            var defaultConfig = Config[gaugeType];

            var seriesLabel =  QueryUtils.queryList(queryList, 'seriesLabel') || {},
                valueLabel  = QueryUtils.queryList(queryList, 'valueLabel') || {},
                percentageLabel = QueryUtils.queryList(queryList, 'percentageLabel') || {};

            QueryUtils.merge(seriesLabel, defaultConfig.seriesLabel, false);
            QueryUtils.merge(valueLabel, defaultConfig.valueLabel, false);
            QueryUtils.merge(percentageLabel, defaultConfig.percentageLabel, false);

            queryList = queryList.concat([defaultConfig]);

            var center = QueryUtils.queryList(queryList, 'center');
            if(center){
                center[0] = this._getPercentValue(center[0], this.vanchart.width);
                center[1] = this._getPercentValue(center[1], this.vanchart.height);
            }

            BaseUtils.extend(this, {
                layout:QueryUtils.queryList(queryList, 'layout') || Constants.HORIZONTAL_LAYOUT,
                radius:QueryUtils.queryList(queryList, 'radius'),
                center:center,
                style:QueryUtils.queryList(queryList, 'style'),

                bands:QueryUtils.queryList(queryList, 'bands'),

                seriesLabel:seriesLabel,
                valueLabel:valueLabel,
                percentageLabel:percentageLabel,

                needle : QueryUtils.queryList(queryList, 'needle'),
                hinge : QueryUtils.queryList(queryList, 'hinge'),
                thermometerLayout:QueryUtils.queryList(queryList, 'thermometerLayout'),
                clockwise:QueryUtils.queryList(queryList, 'clockwise'),
                hingeBackgroundColor : QueryUtils.queryList(queryList, 'hingeBackgroundColor'),
                paneBackgroundColor : QueryUtils.queryList(queryList, 'paneBackgroundColor'),
                slotBackgroundColor: QueryUtils.queryList(queryList, 'slotBackgroundColor'),
                innerPaneBackgroundColor: QueryUtils.queryList(queryList, 'innerPaneBackgroundColor')
            });

            if(this.gaugeType && this.gaugeType != gaugeType){
                this.remove();
                this.backgruondPath = null;
                this.backgruondLine = null;
            }

            this.gaugeType = gaugeType;

            BaseUtils.extend(this, PROTOTYPES[gaugeType]);
        },

        doLayout:function(){
            var seriesBounds = this._calculateGaugeBounds(), gauge = this;
            if(!seriesBounds && (!this.radius && !this.center)){
                throw new Error('gauge has no bounds');
            }

            this.bounds = seriesBounds;

            this._calculatePercentage();


            //bands和color这两个属性放在doLayout原因：default bands depend on gauge axis domain.
            var series = this;
            if(!series.bands){
                series.bands = series._getDefaultBands(series.gaugeAxis.scale.domain())
            }

            series.points.forEach(function (point) {
                point.color = series._getBandsColor(point) || point.color;
            });

            this._doLayout();
        },

        _doLayout:function(){
            this._dealPercentLabel();

            this._dealValueLabel();

            this._fixCenterAndRadius();
        },

        _createGroup: function (renderer, vanchart) {
            return renderer.group().addTo(vanchart.seriesGroup);
        },

        _getAxisTypes:function(){
            return ['gaugeAxis'];
        },

        getDataToDraw:function(){
            return [];
        },

        _calculatePercentage:function(){
            if(this.points.length){
                var gaugeAxis = this.gaugeAxis, minMax = gaugeAxis.scale.domain();
                this.points.forEach(function(point){
                    point.percentage = (point.y - minMax[0]) / (minMax[1] - minMax[0]);
                });
            }
        },

        _calculateLabelPos:function(){

        },

        _getTranslate:function(){
            return [this.centerX, this.centerY];
        },

        _dealSeriesLabel:function(){
            var series = this; series.seriesLabelContent = ''; series.seriesLabelDim = {width:0, height:0};

            if(series.seriesLabel && series.seriesLabel.enabled){
                var style = series.seriesLabel.style;
                var labelContent = series.calculateFormatterContent(series.points[0], series.seriesLabel);
                var labelDim = this.calculateTextDim(labelContent);

                series.seriesLabelContent = labelContent[0] ? labelContent[0].text : '';
                series.seriesLabelStyle = style;
                series.seriesLabelDim = labelDim;
            }
        },
        
        _dealPercentLabel:function () {
            var series = this;
            series.percentageLabelContent = ''; series.percentageLabelDim = {width:0, height:0};
            var point = series.points[0];

            if(!point){
                return;
            }

            if(series.percentageLabel && series.percentageLabel.enabled){

                var labelStyle = BaseUtils.clone(series.percentageLabel.style);

                if(!labelStyle.color){
                    labelStyle.color = point.color;
                }

                var labelContent = series.calculateFormatterContent(point, series.percentageLabel);
                var labelDim = this.calculateTextDim(labelContent);
                series.percentageLabelContent = labelContent[0] ? labelContent[0].text : '';
                series.percentageLabelStyle = labelStyle;
                series.percentageLabelDim = labelDim;
            }
        },

        _dealValueLabel:function(){
            var series = this, valueLabel = series.valueLabel, style = valueLabel.style, useHtml = valueLabel.useHtml, formatter = valueLabel.formatter;

            series.valueLabelContent = ''; series.valueLabelDim = {width:0, height:0};
            
            if(series.valueLabel && series.valueLabel.enabled){
                var valueLabelContent = [];
                for(var i = 0, len = series.points.length; i < len; i++){
                    var point = series.points[i];
                    if(point.isNull){
                        continue;
                    }
                    var labelContent = this._calculateSingleLineLabelContent(formatter, point);
                    var labelDim = BaseUtils.getTextDimension(labelContent, style, useHtml);
                    valueLabelContent.push({
                        labelContent:labelContent,
                        labelDim:labelDim,
                        labelStyle:style
                    });
                }

                series.valueLabelContent = valueLabelContent;
            }
        },

        _getDefaultBands:function(domain){
            var color = QueryUtils.queryList(this._getQueryList(), 'color'), bands = [];
            if(color){
                bands.push({
                    from:domain[0],
                    to:domain[1],
                    color:color
                });
            }else{
                var min = domain[0], max = domain[1];
                var band = BaseUtils.accDiv((max - min), 3);
                var fStop = BaseUtils.accAdd(min, band);
                var sStop = BaseUtils.accAdd(fStop, band);
                var colors = this.vanchart.currentOption.colors;

                bands = [
                    {
                        from:min,
                        to:fStop,
                        color:colors[0]
                    },
                    {
                        from:fStop,
                        to:sStop,
                        color:colors[1]
                    },
                    {
                        from:sStop,
                        to:max,
                        color:colors[2]
                    }];
            }

            return bands;
        },

        _getColorFromBands:function(value, bands){
            if(bands && bands.length){
                for(var i = 0, len = bands.length; i < len; i++){
                    var band = bands[i];
                    var min = Math.min(band.from, band.to);
                    var max = Math.max(band.from, band.to);
                    if(value >= min && value <= max){
                        return band.color;
                    }
                }
            }
        },

        //计算每个系列的边界,要么定义了圆心和半径,作为悬浮元素处理,要么两者都不定义,自定平分区域
        //只定义半径没定义圆心,或者只定义了圆心没有定义半径,效果都是未知的
        _calculateGaugeBounds:function(){
            var series = this.vanchart.series[Constants.GAUGE_CHART];
            var plotBounds = this.vanchart.getPlotBounds();
            var fixedSize = 0;

            for(var i = 0, len = series.length; i < len; i++){
                if(series[i].options.center && series[i].options.radius){
                    fixedSize++;
                }
            }

            //平均半径
            var isHorizontalLayout = this.layout == Constants.HORIZONTAL_LAYOUT;
            var divideDimKey =  isHorizontalLayout ? 'width' : 'height';
            var averageSize = plotBounds[divideDimKey] / Math.max(1, series.length - fixedSize);

            for(var i = 0, len = series.length; i < len; i++){
                if(series[i] == this){
                    if(!this.options.center && !this.options.radius){
                        if(isHorizontalLayout){
                            return {
                                x:plotBounds.x + i * averageSize,
                                y:plotBounds.y,
                                width:averageSize,
                                height:plotBounds.height
                            }
                        }else{
                            return {
                                x:plotBounds.x,
                                y:plotBounds.y + i * averageSize,
                                width:plotBounds.width,
                                height:averageSize
                            }
                        }
                    }
                }
            }

            return{x:0,y:0,width:0,height:0};
        },

        //试管的重写了
        _getFixedPos:function(datum, divDim){
            var gauge = datum.series, style = gauge.style;
            var x, y;
            if(style == 'pointer_semi'){
                x = gauge.centerX - divDim.width/2;
                y = gauge.centerY + 0.14 * gauge.radius + 10;
            }else{
                x = gauge.centerX + gauge.radius + 10;
                y = gauge.centerY - divDim.height/2;
            }
            return [x, y];
        },

        _animateEnd: function () {
            
        },

        _isSeriesInteractive:function(){
            return true;
        },

        _drawGaugeLabels: function (labelG) {
            var series = this, vanchart = series.vanchart;

            series._removeNormalLabels(labelG);

            vanchart.setTimeout(series.className + 'more_label_animate', function () {
                vanchart._removeChangeDataState(series);

                series._removeMoreLabels();

                series._drawNormalLabels(labelG);

            }, vanchart.getShowMoreLabelTime());

            series._drawMoreLabels();
        },

        _removeMoreLabels: function () {
            this.points.forEach(function(point){
                point.moreLabelG && point.moreLabelG.remove();
                point.moreLabelG = null;
            });
        },

        _drawMoreLabels: function () {
            var series = this, vanchart = series.vanchart;

            if(vanchart.getShowMoreLabelTime() != 0 && series.visible){
                series._drawDiffMoreLabels();
            }
        },

        //默认的是ring and slot 其他要重写这个方法
        _drawDiffMoreLabels: function () {
            var point = this.points[0];

            if(!point){
                return;
            }

            this._showAndExitMoreLabel(point, 0, 0);
        },

        _removeNormalLabels: function (labelG) {
            //简化代码,标签每次都重画
            var labels = labelG.labels || [];
            for(var i = 0, len =  labels.length; i < len; i++){
                labels[i] && labels[i].remove();
                labels[i] = null;
            }
        },
        
        _drawNormalLabels:function(labelG){
            var series = this, vanchart = series.vanchart, renderer = vanchart.renderer;

            labelG.labels = [];

            if (series.seriesLabelContent) {
                series._drawLabel(labelG, series.seriesLabelContent, series.seriesLabelPos, series.seriesLabelDim,
                    series.seriesLabelStyle, series.seriesLabel.useHtml);
            }

            if (series.percentageLabelContent) {
                series._drawLabel(labelG, series.percentageLabelContent, series.percentageLabelPos, series.percentageLabelDim,
                    series.percentageLabelStyle, series.percentageLabel.useHtml);
            }

            if (series.valueLabelContent && series.valueLabelContent.length) {
                //指针类型的仪表盘值标签后面有背景
                if (series.valueLabelBackground) {
                    var background = BaseUtils.rectSubPixelOpt(series.valueLabelBackground, 0);
                    background.rx = background.rx = series.radius * 0.02;
                    labelG.labels.push(
                        labelG.append(
                        renderer.rect(background).style({
                            'fill':series.valueLabel.backgroundColor,
                            'fill-opacity':ColorUtils.getColorOpacity(series.valueLabel.backgroundColor),
                            'filter':'url(#'+ BaseUtils.stamp(series.innerFilter) +')'
                        })
                        )
                    );
                }

                for (var i = 0, len = series.valueLabelContent.length; i < len; i++) {
                    var valueLabel = series.valueLabelContent[i];
                    series._drawLabel(labelG, valueLabel.labelContent, valueLabel.labelPos, valueLabel.labelDim, valueLabel.labelStyle, series.valueLabel.useHtml);
                }
            }
        },

        _drawLabel:function(labelG, labelContent, labelPos, labelDim, labelStyle, useHtml){
            if(!labelPos){
                return;
            }
            var series = this, vanchart = series.vanchart, renderer = vanchart.renderer, textHeight = BaseUtils.getTextHeight(labelStyle);

            labelG.labels.push(
                labelG.append(
                    renderer.vtext(useHtml)
                        .attr({
                            'x': labelPos.x,
                            'y': labelPos.y,
                            'dy': 0.85 * textHeight
                        }).textContent(labelContent).style(labelStyle)
                )
            );

            //
            // if(useHtml){
            //     var centerX = series.centerX, centerY = series.centerY;
            //
            //     labelPos = {
            //         x:labelPos.x + centerX,
            //         y:labelPos.y + centerY
            //     };
            //     vanchart.labelDivManager.addLabel(labelContent, labelPos, labelStyle);
            // }else{
            //     labelG.labels.push(
            //         renderer.text({
            //             'text-anchor':'middle',
            //             'x': labelPos.x + labelDim.width/2,
            //             'y':labelPos.y + 0.85 * textHeight
            //         }).textContent(labelContent).style(labelStyle).addTo(labelG.renderG)
            //     );
            // }
        },

        _onSinglePointerTap:function(ev){
            //单个指针的时候点击触发超链
            if(this.points && this.points.length == 1){
                this.points[0].fire('tap', ev);
            }
        },

        _onSinglePointerMouseMove:function(ev){
            if(this.points && this.points.length > 0){
                this.points[0].fire('mousemove', ev);
            }
        },

        getClosestPoint:function(){
            return this.points.length == 1 ? this.points[0] : null;
        },

        _getStroke:function(gradient){
            return BaseUtils.isSupportSVG() ? "url(#" + BaseUtils.stamp(gradient) + ")" : gradient;
        },

        //一个点一个系列
        getEvents:function(){
            return {
                'mousemove':this._onSinglePointerMouseMove,
                'mouseover':this.onSeriesMouseOver,
                'seriesUnChosen':this.onSeriesUnChosen,
                'tap':this._onSinglePointerTap,
                'press':this.onSeriesPress,
                'pressup':this.onSeriesPressUp
            }
        }
    });

    require('../ChartLibrary').register(Constants.GAUGE_CHART, Gauge);

    return Gauge;
});
/**
 * Created by eason on 16/8/22.
 */

define('chart/ColumnRadar',['require'],function(require){

    var ANIMATION_TIME = 500;
    var EASE = 'back-out';

    var UPDATE_TIME = 500;
    var UPDATE_EASE = 'exp-out';

    var CHOSEN_STROKE_WIDTH = 6;
    var CHOSEN_STROKE_OPACITY = 0.35;

    var TOP = 'radar-top';
    var BOTTOM = 'radar-bottom';
    var LEFT = 'radar-left';
    var RIGHT = 'radar-right';
    var LABEL_BORDER_GAP = 8;

    return {

        columnType:true,

        _calcLabelPos:function(point){

            var position = this.polar.angleAxis._getPolarPosition(point.category);
            var pos = this._getArcPoint(point.outerRadius - LABEL_BORDER_GAP, point.radian);
            var labelDim = point.labelDim;

            switch (position){
                case TOP:

                    point.labelPos = {
                        x:-labelDim.width/2,
                        y:pos[1]
                    };

                    break;

                case RIGHT:

                    point.labelPos = {
                        x:pos[0] - labelDim.width,
                        y:pos[1] - labelDim.height/2
                    };
                    break;

                case BOTTOM:

                    point.labelPos = {
                        x:-labelDim.width/2,
                        y:pos[1] - labelDim.height
                    };

                    break;

                case LEFT:

                    point.labelPos = {
                        x:pos[0],
                        y:pos[1] - labelDim.height/2
                    };

                    break
            }
        },

        _getMoreLabelDefaultCenter:function(d, moreLabelDim){
            var pos = this._getArcPoint(d.outerRadius/2, d.radian);

            return {
                centerX: pos[0],
                centerY: pos[1]
            }
        },

        getAttrs:function(p){
            return {'d':this._getRadarColumnPath(p.innerRadius, p.outerRadius, p.radian)};
        },

        getStyle:function(p){
            return {
                'fill':p.color,
                'fill-opacity':p.opacity,
                'stroke':p.borderColor,
                'stroke-width':p.borderWidth
            };
        },

        getHighLightStyle:function(p){
            return {
                'stroke':p.mouseOverColor || p.color,
                'fill':p.color,
                'fill-opacity': 1,
                'stroke-width':CHOSEN_STROKE_WIDTH,
                'stroke-opacity':CHOSEN_STROKE_OPACITY
            }
        },

        getPressedStyle:function(p){
            return {
                'fill':p.clickColor,
                'fill-opacity': p.clickOpacity
            }
        },

        getPointGraphicKey:function(){
            return 'path';
        },

        _getRadarColumnPath:function(innerRadius, radius, radian){

            var halfSize = this.polar.angleAxis.piece * 0.375;

            var startRadian = radian - halfSize;

            var endRadian = radian + halfSize;

            var arc = d3.svg.arc()
                .innerRadius(innerRadius).outerRadius(radius)
                .startAngle(startRadian).endAngle(endRadian);

            return arc();
        },

        createAnimation:function(dom, point){
            dom._innerRadius_ = point.innerRadius;
            dom._outerRadius_ = point.outerRadius;
            var series = this;

            d3.select(dom).transition().duration(ANIMATION_TIME).ease(EASE)
                .attrTween('d', function(){
                    var iInterpolate = d3.interpolate(point.animateInitRadius, point.innerRadius);
                    var oInterpolate = d3.interpolate(point.animateInitRadius, point.outerRadius);
                    return function(t){
                        return series._getRadarColumnPath(iInterpolate(t), oInterpolate(t), point.radian);
                    }
                });
        },

        updateAnimation:function(dom, point){
            var series = this;
            d3.select(dom).transition().duration(UPDATE_TIME).ease(UPDATE_EASE)
                .attrTween('d', function(){

                    var innerInterpolate = d3.interpolate(dom._innerRadius_, point.innerRadius);
                    var outerInterpolate = d3.interpolate(dom._outerRadius_, point.outerRadius);

                    dom._innerRadius_ = point.innerRadius;
                    dom._outerRadius_ = point.outerRadius;

                    return function(t){
                        return series._getRadarColumnPath(innerInterpolate(t), outerInterpolate(t), point.radian);
                    }
                });
        },

        dropAnimation:function(dom, point){

            var series = this;

            d3.select(dom).transition().duration(UPDATE_TIME).ease(UPDATE_EASE)
                .attrTween('d', function(){
                    var interpolate = d3.interpolate(point.outerRadius, point.innerRadius);

                    return function(t){
                        return series._getRadarColumnPath(point.innerRadius, interpolate(t), point.radian);
                    }
                })
                .remove();

        },

        //onPointXXX的方法,this 指向的是Point
        onPointMouseOver:function(){
            var point = this, series = point.series, animation = series.animation, style = series.getHighLightStyle(point);
            if(animation){
                d3.select(point.graphic.rawElement).transition()
                    .duration(100).ease('ease-out-in').style(style);
            }else{
                point.graphic.style(style)
            }
        },

        onPointMouseOut:function(){
            var point = this, series = point.series, animation = series.animation, style = series.getStyle(point);
            if(animation){
                d3.select(point.graphic.rawElement).transition()
                    .duration(100).ease('ease-out-in').style(style);
            }else{
                point.graphic.style(style)
            }
        },

        _getFixedPos:function(datum, divDim){

            var centerAngle = datum.radian, center = this.getCenter();

            var x = datum.posX + center[0];
            var y = datum.posY + center[1];

            if(centerAngle < Math.PI / 2){
                y -= divDim.height;
            }else if(centerAngle >= Math.PI && centerAngle < 3 * Math.PI / 2){
                x -= divDim.width;
            }else if(centerAngle >= 3 * Math.PI / 2 && centerAngle < Math.PI * 2){
                y -= divDim.height;
                x -= divDim.width;
            }

            return [x, y];
        }


    };
});
/**
 * Created by eason on 16/8/22.
 */

define('chart/LineRadar',['require','../utils/BaseUtils'],function(require){

    var BaseUtils  = require('../utils/BaseUtils');

    var ANIMATION_TIME = 500;
    var EASE = 'back-out';

    var EXIT_TIME = 500;
    var EXIT_EASE = 'exp-out';

    var TOP = 'radar-top';
    var BOTTOM = 'radar-bottom';
    var LEFT = 'radar-left';
    var RIGHT = 'radar-right';
    var LABEL_BORDER_GAP = 8;

    return {
        columnType:false,

        _calcLabelPos:function(point){

            var position = this.polar.angleAxis._getPolarPosition(point.category);
            var pos = this._getArcPoint(point.outerRadius + LABEL_BORDER_GAP, point.radian);
            var labelDim = point.labelDim;

            switch (position){
                case TOP:

                    point.labelPos = {
                        x:-labelDim.width/2,
                        y:pos[1] - labelDim.height
                    };

                    break;

                case RIGHT:

                    point.labelPos = {
                        x:pos[0],
                        y:pos[1] - labelDim.height/2
                    };
                    break;

                case BOTTOM:

                    point.labelPos = {
                        x:-labelDim.width/2,
                        y:pos[1]
                    };

                    break;

                case LEFT:

                    point.labelPos = {
                        x:pos[0] - labelDim.width,
                        y:pos[1] - labelDim.height/2
                    };

                    break
            }

        },


        _getMoreLabelDefaultCenter:function(d, moreLabelDim){
            return {
                centerX: d.posX + d.marker.radius/2,
                centerY: d.posY - moreLabelDim.height/2 - d.marker.radius/2
            }
        },

        _isSeriesInteractive:function(){
            return true;
        },

        drawSeries:function(){

            var series = this, vanchart = series.vanchart, renderer = vanchart.renderer;

            this.defaultMarker && this.defaultMarker.remove();
            this.defaultMarker = null;

            if(series.visible){
                if(!this.radarPath){
                    this.radarPath = renderer.path().addTo(series.group);
                }

                this.radarPath.style({
                    'fill': series.fillColor,
                    'fill-opacity': series.fillColor ? series.fillColorOpacity : 0,
                    'stroke': series.color,
                    'stroke-width': series.lineWidth
                });

                if(series.animation){
                    d3.select(this.radarPath.node()).transition().duration(ANIMATION_TIME).ease(EASE)
                        .attrTween('d', function(){
                            var useLastPathSeg = !!this._pathSegment_;
                            if(useLastPathSeg && this._pathSegment_.length == series.pathSegment.length){
                                var last = this._pathSegment_;
                                for(var i = 0, count = last.length; i < count && useLastPathSeg; i++){
                                    if(last[i].length != series.pathSegment[i].length){
                                        useLastPathSeg = false;
                                    }
                                }
                            }
                            var initPathSeg = useLastPathSeg ? this._pathSegment_ : series._getInitPathSegment(series.pathSegment);
                            var interpolate  = d3.interpolateArray(initPathSeg, series.pathSegment);
                            this._pathSegment_ = series.pathSegment;
                            return function(t){
                                return series._getRadarSeriesStrokePath(interpolate(t), series.connectNulls);
                            };
                        });
                }else{
                    this.radarPath.attr('d', series._getRadarSeriesStrokePath(series.pathSegment, series.connectNulls))
                }
            }else if(this.radarPath){
                if(series.animation){
                    d3.select(this.radarPath.node()).transition()
                        .duration(EXIT_TIME).ease(EXIT_EASE)
                        .attrTween('d', function(){
                            var initPathSeg = series._getInitPathSegment(series.pathSegment);
                            var interpolate  = d3.interpolateArray(series.pathSegment, initPathSeg);
                            return function(t){
                                return series._getRadarSeriesStrokePath(interpolate(t), series.connectNulls);
                            };
                        })
                        .remove();
                    this.radarPath = null;
                }else{
                    this.radarPath.remove();
                    this.radarPath = null;
                }
            }
        },

        getAttrs:function(point){
            return {'transform':BaseUtils.makeTranslate([point.posX, point.posY])};
        },

        getStyle:function(){
            return {};
        },

        _createPointGraphic:function(point){
            return point.graphic = this._createMarker(point.marker);
        },

        _updatePointGraphicStyle:function(point){
            this._updateMarker(point.graphic, point.marker);
        },

        getDataToDraw: function () {
            return this.points.filter(function(p){return p.marker && p.marker.symbol});
        },

        getTextDataToDraw: function () {
            return this.points;
        },

        onPointPress:function(){
            var point = this, series = point.series;
            series._onMarkerPressed(point);
        },

        onPointPressUp:function(){
            var point = this, series = point.series;
            series._updateMarker(point.graphic, point.marker);
        },

        //onPointXXX的方法,this 指向的是Point
        onPointMouseOver:function(){
            var point = this, series = point.series;
            series._onMarkerMouseOver(point);
        },

        onPointMouseOut:function(){
            var point = this, series = point.series;
            series._onMarkerMouseOut(point);
        },

        createAnimation:function(dom, point){
            d3.select(dom)
                .attr('transform', 'translate('+ 0 +','+ 0 +') scale(0.01)')
                .transition().duration(ANIMATION_TIME).ease(EASE)
                .attr('transform', 'translate('+ point.posX +','+ point.posY +') scale(1)');
        },

        updateAnimation:function(dom, point){
            d3.select(dom).transition().ease(EASE).duration(ANIMATION_TIME).
            attr('transform', 'translate(' + point.posX + ',' + point.posY + ') scale(1)');
        },

        dropAnimation:function(dom){
            d3.select(dom).remove();
        },

        _calculateLabelPos:function(){

        },

        _getFixedPos:function(datum){
            var radius = isNaN(datum.marker.radius) ? 4.5 : datum.marker.radius, center = this.getCenter();
            var x, y;
            x = center[0] + datum.posX + radius;
            y = center[1] + datum.posY + radius;

            return [x, y];
        },

        getClosestPoint:function(pos){


            var center = this.getCenter(), minDistance = Number.MAX_VALUE;
            var selectedPoint;
            
            this.points.forEach(function(point){
                var detX = point.posX + center[0] - pos[0];
                var detY = point.posY + center[1] - pos[1];
                var dis = Math.sqrt(detX * detX + detY * detY);
                if(dis < minDistance && !point.isNull){
                    selectedPoint = point;
                    minDistance = dis;
                }
            });

            return selectedPoint;
        }
    }

});
/**
 * Created by eason on 15/12/31.
 */
define('chart/Radar',['require','./Series','../utils/BaseUtils','../Constants','../utils/QueryUtils','../utils/BoundsManager','./ColumnRadar','./LineRadar','../ChartLibrary'],function(require){

    var Series = require('./Series');
    var BaseUtils = require('../utils/BaseUtils');
    var Constants = require('../Constants');
    var QueryUtils = require('../utils/QueryUtils');
    var BoundsManager = require('../utils/BoundsManager');
    var ColumnRadar = require('./ColumnRadar');
    var LineRadar = require('./LineRadar');

    var DELAY = 200;
    var PADDING_GAP = 10;
    var LABEL_BORDER_GAP = 8;

    var Radar = Series.extend({
        _refresh:function() {
            var queryList = this._getQueryList();
            var columnType = QueryUtils.queryList(queryList, 'columnType');

            var connectNulls = BaseUtils.pick(QueryUtils.queryList(queryList, 'connectNulls'), true);
            var lineWidth = QueryUtils.queryList(queryList, 'lineWidth') || 0;

            BaseUtils.extend(this,{
                marker:columnType ? null : this.marker,
                lineWidth:lineWidth,
                columnType:columnType,
                connectNulls:connectNulls
            });

            if(columnType != this.columnType){
                this.remove();
            }

            this.stack = this.columnType ? 'radar-column' : this.stack;

            BaseUtils.extend(this, columnType ? ColumnRadar : LineRadar);
        },

        _getAxisTypes:function(){
            return ['angleAxis', 'radiusAxis', 'polar'];
        },

        _getDefaultFillColorOpacity: function () {
            var queryList = this._getQueryList();
            var columnType = QueryUtils.queryList(queryList, 'columnType');

            return columnType ? 1 : 0.15;
        },

        _getTranslate:function(){
            return this.getCenter();
        },

        getCenter:function(){
            return this.polar && this.polar.center;
        },

        getRadius:function(){
            return this.polar && this.polar.radius;
        },
        
        doLayout:function(){
            var series = this, polar = series.polar, radiusAxis = polar.radiusAxis, angleAxis = polar.angleAxis;
            var center = this.getCenter(), radius = this.getRadius(), piece = angleAxis.piece, valueScale = radiusAxis.scale, cateScale = angleAxis.scale;

            //todo 先排序作用是
            // series.points.sort(function(pointA, pointB){
            //     return self.cateScale(pointA.category) - self.cateScale(pointB.category);
            // });

            series.points.forEach(function(point){

                point.innerRadius = valueScale(point.y0);

                point.outerRadius = valueScale(point.getTargetValue() + point.y0);

                point.animateInitRadius = radiusAxis.getStartPos();

                point.radian = cateScale(point.category) * piece;

                var pos = series._getArcPoint(point.outerRadius, point.radian);
                point.posX = pos[0];

                point.posY = pos[1];

                this._calcLabelPos(point);

            }, this);

            series.pathSegment = series._getPathSegment(series.points, series.connectNulls);
        },

        _calculateLabelPos:function () {

        },

        getTargetKey: function () {
            return 'y';
        },

        additionalClip: function (group) {
            this.vanchart.renderer.clip(group, this.polar.clip);
        },
        
        _getPathSegment:function(dataPoints, connectNulls){

            var pathSeg = [];

            var tmp = [];

            if(connectNulls){

                pathSeg.push(tmp);

                dataPoints.forEach(function(dataPoint){

                    if(!dataPoint.isNull){
                        tmp.push([dataPoint.posX, dataPoint.posY]);
                    }

                });
            }else{

                var startIndex = 0;
                var count = dataPoints.length;

                for(var index = count - 1; index > 0; index--){

                    var current = dataPoints[index];
                    var pre = dataPoints[index - 1];

                    if(!current.isNull && pre.isNull){
                        startIndex = index;
                    }
                }

                for(var index = 0; index < count; index++){

                    var dataPoint = dataPoints[(index + startIndex) % count];

                    if(dataPoint.isNull && tmp.length){

                        if(tmp.length > 1){
                            pathSeg.push(tmp)
                        };

                        tmp = [];
                    }else{
                        tmp.push([dataPoint.posX, dataPoint.posY]);
                    }

                }

                if(tmp.length){
                    pathSeg.push(tmp);
                }
            }

            return pathSeg;
        },

        _getRadarSeriesFillPath:function(pathSeg, connectNulls){
            return this._getRadarSeriesPath(pathSeg, connectNulls, true);
        },

        _getRadarSeriesStrokePath:function(pathSeg, connectNulls){
            return this._getRadarSeriesPath(pathSeg, connectNulls, false);
        },

        _getRadarSeriesPath:function(pathSeg, connectNulls, toCenter){

            var path = '';
            var tmp = [];
            if(pathSeg.length == 1){

                tmp = pathSeg[0];

                var fullShape = tmp.length == this.angleAxis.getCategoryCount() || connectNulls;

                toCenter = (!fullShape && toCenter);

                path = toCenter ? 'M0,0' : '';

                for(var i = 0, count = tmp.length; i < count; i++){

                    var mOrl = (i || toCenter) ? 'L' : 'M';

                    path += (mOrl + BaseUtils.dealFloatPrecision(tmp[i][0]) + "," + BaseUtils.dealFloatPrecision(tmp[i][1]));
                }

                path += (fullShape || toCenter) ? 'Z' : '';

            }else{
                pathSeg.forEach(function(tmp){

                    path += toCenter ? 'M0,0' : '';

                    tmp.forEach(function(pos){
                        path += ('L' + BaseUtils.dealFloatPrecision(pos[0]) + "," + BaseUtils.dealFloatPrecision(pos[1]));
                    });

                    path += toCenter ? 'Z' : '';
                });
            }

            return path;
        },

        _getInitPathSegment:function(pathSeg){
            var init = [];
            pathSeg.forEach(function(seg){
                var tmp = [];
                init.push(tmp);

                seg.forEach(function(){
                    tmp.push([0,0])
                })
            });
            return init;
        }
    });

    require('../ChartLibrary').register(Constants.RADAR_CHART, Radar);
    
    return Radar;
});
/**
 * Created by eason on 16/5/9.
 */
define('chart/Map',['require','../Constants','../utils/BaseUtils','../utils/QueryUtils','../ComponentLibrary','./Series','../ChartLibrary','../ChartLibrary'],function(require){
    var Constants = require('../Constants');
    var BaseUtils = require('../utils/BaseUtils');
    var QueryUtils = require('../utils/QueryUtils');
    var ComponentLibrary = require('../ComponentLibrary');
    var Series = require('./Series');

    var Map = Series.extend({
        
        _refresh:function(){
            var queryList = this._getQueryList();
            this.icon = QueryUtils.queryList(queryList, 'icon');
        },

        _refreshPoint:function(point){

            //点击图例以后是默认的属性,所以需要缓存一份
            BaseUtils.extend(point, {
                mapStyle:{
                    'color':point.color,
                    'opacity':point.opacity,
                    'borderWidth':point.borderWidth,
                    'borderColor':point.borderColor,
                    'borderOpacity':point.borderOpacity
                }
            });
        },

        getTargetKey:function(){
            return 'value';
        },

        _getPointKey:function(point){
            return point.name;
        },

        _getFixedPos:function(point){
            var vanchart = point.series.vanchart, leaflet = vanchart._leaflet;
            var geo = vanchart.getComponent(ComponentLibrary.GEO_COMPONENT);
            var type = point.series.type;

            var latlng = geo.getDataPointLatLng(point);
            var pos = leaflet.latLngToContainerPoint(latlng);

            if(type == Constants.AREA_MAP){
                var detX = 0, detY = 0;
                if(point.dataLabels && point.labelDim && point.labelPos){
                    detX = point.labelDim.width/2;
                    detY = point.labelDim.height/2;
                }
                return [pos.x + detX, pos.y + detY];
            }

            return [pos.x, pos.y];
        }

    });

    require('../ChartLibrary').register(Constants.POINT_MAP, Map);
    require('../ChartLibrary').register(Constants.AREA_MAP, Map);

    return Map;
});
/**
 * Created by eason on 15/8/17.
 */

define('component/LegendIconFactory',['require','../Constants'],function(require){

    var Constants = require('../Constants');

    var LegendPath = {};
    var LegendSize = {};

    LegendPath[Constants.PIE_ICON] = 'M15.795,7.943L7.909,12.5L0.205,8.052C1.756,5.333,4.68,3.5,8.032,3.5C11.338,3.5,14.23,5.287,15.795,7.943z';
    LegendSize[Constants.PIE_ICON] = {
        width:16,
        height:16
    };

    LegendPath[Constants.TREEMAP_ICON] = 'M9,12H3c-1.6,0-3-1.4-3-3l0-6c0-1.6,1.3-3,3-3l6,0c1.7,0,3,1.4,3,3v6C12,10.6,10.6,12,9,12z';
    LegendSize[Constants.TREEMAP_ICON] = {
        width:12,
        height:12
    };

    LegendPath[Constants.DONUT_ICON] = 'M8.945,11.107c1.671,0,3.181,0.684,4.269,1.786l4.271-4.271c-4.686-4.686-12.284-4.686-16.971,0l4.216,4.216C5.815,11.768,7.302,11.107,8.945,11.107z';
    LegendSize[Constants.DONUT_ICON] = {
        width:18,
        height:18
    };

    LegendPath[Constants.NORMAL_ICON] = 'M0,0L12,0L12,12L0,12Z';
    LegendSize[Constants.NORMAL_ICON] = {
        width:12,
        height:12
    };

    LegendPath[Constants.BUBBLE_ICON] = "M6,11.5c-1.47,0-2.851-0.572-3.889-1.611C1.072,8.851,0.5,7.47,0.5,6s0.572-2.851,1.611-3.889C3.149,1.072,4.53,0.5,6,0.5s2.851,0.572,3.889,1.611C10.928,3.149,11.5,4.53,11.5,6s-0.572,2.851-1.611,3.889C8.851,10.928,7.47,11.5,6,11.5z";
    LegendSize[Constants.BUBBLE_ICON] = {
        width:11,
        height:11
    };

    LegendPath[Constants.NULL_MARKER] = 'M1,8L1,8c0-0.552,0.448-1,1-1h12c0.552,0,1,0.448,1,1v0c0,0.552-0.448,1-1,1H2C1.448,9,1,8.552,1,8z';
    LegendSize[Constants.NULL_MARKER] = {
        width:16,
        height:16
    };

    LegendPath[Constants.CIRCLE] = 'M11,8c0,1.657-1.343,3-3,3S5,9.657,5,8s1.343-3,3-3S11,6.343,11,8z M14,7h-2.142C11.942,7.322,12,7.653,12,8s-0.058,0.678-0.142,1H14c0.552,0,1-0.448,1-1C15,7.448,14.552,7,14,7z M4,8c0-0.347,0.058-0.678,0.142-1H2C1.448,7,1,7.448,1,8c0,0.552,0.448,1,1,1h2.142C4.058,8.678,4,8.347,4,8z';
    LegendSize[Constants.CIRCLE] = {
        width:16,
        height:16
    };

    LegendPath[Constants.SCATTER_ICON + Constants.NULL_MARKER] = 'M0,0L12,0L12,12L0,12Z';
    LegendSize[Constants.SCATTER_ICON + Constants.NULL_MARKER] = {
        width:12,
        height:12
    };

    LegendPath[Constants.SCATTER_ICON + Constants.NORMAL_ICON] = 'M0,0L12,0L12,12L0,12Z';
    LegendSize[Constants.SCATTER_ICON + Constants.NORMAL_ICON] = {
        width:12,
        height:12
    };

    LegendPath[Constants.SCATTER_ICON + Constants.CIRCLE] = "M4,8C2.897,8,1.897,7.551,1.173,6.827S0,5.103,0,4s0.449-2.103,1.173-2.827S2.897,0,4,0s2.103,0.449,2.827,1.173S8,2.897,8,4S7.551,6.103,6.827,6.827S5.103,8,4,8";
    LegendSize[Constants.SCATTER_ICON + Constants.CIRCLE] = {
        width:8,
        height:8
    };

    LegendPath[Constants.SQUARE] = 'M11,11H5V5h6V11z M14,7h-2v2h2c0.552,0,1-0.448,1-1C15,7.448,14.552,7,14,7z M4,7H2C1.448,7,1,7.448,1,8c0,0.552,0.448,1,1,1h2V7z';
    LegendSize[Constants.SQUARE] = {
        width:16,
        height:16
    };
    LegendPath[Constants.SCATTER_ICON + Constants.SQUARE] = "M0,0h8c0,0,0,3.889,0,8C4,8,0,8,0,8V0z";
    LegendSize[Constants.SCATTER_ICON + Constants.SQUARE] = {
        width:8,
        height:8
    };

    LegendPath[Constants.DIAMOND] = 'M8,11L5,8l3-3l3,3L8,11z M14,7h-2.586l1,1l-1,1H14c0.552,0,1-0.448,1-1C15,7.448,14.552,7,14,7z M3.586,8l1-1H2C1.448,7,1,7.448,1,8c0,0.552,0.448,1,1,1h2.586L3.586,8z';
    LegendSize[Constants.DIAMOND] = {
        width:16,
        height:16
    };
    LegendPath[Constants.SCATTER_ICON + Constants.DIAMOND] = "M0,4.5L4.502,0l4.5,4.5c0,0,0,0-4.5,4.5C0,4.5,0,4.5,0,4.5z";
    LegendSize[Constants.SCATTER_ICON + Constants.DIAMOND] = {
        width:9,
        height:9
    };

    LegendPath[Constants.TRIANGLE] = 'M5,10l3-5.196L11,10H5z M14,7h-3.577l1.155,2H14c0.552,0,1-0.448,1-1C15,7.448,14.552,7,14,7z M5.577,7H2C1.448,7,1,7.448,1,8c0,0.552,0.448,1,1,1h2.423L5.577,7z';
    LegendSize[Constants.TRIANGLE] = {
        width:16,
        height:16
    };
    LegendPath[Constants.SCATTER_ICON + Constants.TRIANGLE] = "M4.5,0L9,8c0,0-4.617,0-9,0L4.5,0z";
    LegendSize[Constants.SCATTER_ICON + Constants.TRIANGLE] = {
        width:9,
        height:8
    };

    LegendPath[Constants.CIRCLE_HOLLOW] = 'M4.142,9H2C1.448,9,1,8.552,1,8c0-0.552,0.448-1,1-1h2.142C4.058,7.322,4,7.653,4,8S4.058,8.678,4.142,9zM14,7h-2.142C11.942,7.322,12,7.653,12,8s-0.058,0.678-0.142,1H14c0.552,0,1-0.448,1-1C15,7.448,14.552,7,14,7z M8,7C7.449,7,7,7.449,7,8s0.449,1,1,1s1-0.449,1-1S8.551,7,8,7 M8,5c1.657,0,3,1.343,3,3s-1.343,3-3,3S5,9.657,5,8S6.343,5,8,5L8,5z';
    LegendSize[Constants.CIRCLE_HOLLOW] = {
        width:16,
        height:16
    };
    LegendPath[Constants.SCATTER_ICON + Constants.CIRCLE_HOLLOW] = "M4,2c1.102,0,2,0.898,2,2S5.102,6,4,6S2,5.102,2,4S2.898,2,4,2 M4,0C1.791,0,0,1.791,0,4s1.791,4,4,4s4-1.791,4-4S6.209,0,4,0";
    LegendSize[Constants.SCATTER_ICON + Constants.CIRCLE_HOLLOW] = {
        width:8,
        height:8
    };

    LegendPath[Constants.SQUARE_HOLLOW] = 'M4,9H2C1.448,9,1,8.552,1,8c0-0.552,0.448-1,1-1h2V9z M14,7h-2v2h2c0.552,0,1-0.448,1-1C15,7.448,14.552,7,14,7z M9,7H7v2h2V7 M11,5v6H5V5H11L11,5z';
    LegendSize[Constants.SQUARE_HOLLOW] = {
        width:16,
        height:16
    };
    LegendPath[Constants.SCATTER_ICON + Constants.SQUARE_HOLLOW] = "M6,6H2V2h4V6z M8,0H0v8h8V0z";
    LegendSize[Constants.SCATTER_ICON + Constants.SQUARE_HOLLOW] = {
        width:8,
        height:8
    };

    LegendPath[Constants.DIAMOND_HOLLOW] = 'M4.157,9H2C1.448,9,1,8.552,1,8c0-0.552,0.448-1,1-1h2.157l-1,1L4.157,9z M14,7h-2.157l1,1l-1,1H14c0.552,0,1-0.448,1-1C15,7.448,14.552,7,14,7z M8,5.986L5.986,8L8,10.014L10.014,8L8,5.986 M8,4.571L11.429,8L8,11.429L4.571,8L8,4.571L8,4.571z';
    LegendSize[Constants.DIAMOND_HOLLOW] = {
        width:16,
        height:16
    };
    LegendPath[Constants.SCATTER_ICON + Constants.DIAMOND_HOLLOW] = "M2.121,4.999L5,2.121l2.878,2.878L5,7.879L2.121,4.999z M5,0L0,4.999L5,10l4.999-5.001L5,0z";
    LegendSize[Constants.SCATTER_ICON + Constants.DIAMOND_HOLLOW] = {
        width:10,
        height:10
    };

    LegendPath[Constants.TRIANGLE_HOLLOW] = 'M4.5,9H2C1.448,9,1,8.552,1,8s0.448-1,1-1h3.655L4.5,9z M14,7h-3.655L11.5,9H14c0.552,0,1-0.448,1-1S14.552,7,14,7z M8,6.938L6.232,10h3.536L8,6.938 M8,4.938L11.5,11h-7L8,4.938L8,4.938z';
    LegendSize[Constants.TRIANGLE_HOLLOW] = {
        width:16,
        height:16
    };
    LegendPath[Constants.SCATTER_ICON + Constants.TRIANGLE_HOLLOW] = "M5.001,3.34L7.402,7.5H2.598L5.001,3.34z M5.001,0.34L0,9h10L5.001,0.34z";
    LegendSize[Constants.SCATTER_ICON + Constants.TRIANGLE_HOLLOW] = {
        width:10,
        height:9
    };

    function getLegendIconPath(name){
        return LegendPath[name];
    }

    function getLegendIconSize(name){
        return LegendSize[name] ? LegendSize[name] : LegendSize[Constants.NORMAL_ICON];
    }

    function hasIcon(name){
        return LegendPath[name];
    }
    
    return {
        getLegendIconPath:getLegendIconPath,
        getLegendIconSize:getLegendIconSize,
        hasIcon:hasIcon
    }
});
/**
 * Created by eason on 15/5/4.
 * 图表中所有可以显现的内容都作为一个组件
 */
define('component/Base',['require','../utils/BaseUtils','../utils/ColorUtils','../Constants','../dom/Evented','../utils/QueryUtils','../utils/Formatter','./LegendIconFactory','../utils/Class'],function(require){
    var BaseUtils = require('../utils/BaseUtils');
    var ColorUtils = require('../utils/ColorUtils');
    var Constants = require('../Constants');
    var Evented = require('../dom/Evented');
    var QueryUtils = require('../utils/QueryUtils');
    var Formatter = require('../utils/Formatter');
    var LegendIconFactory = require('./LegendIconFactory');

    var Class = require('../utils/Class');

    var LABEL_GAP = 2;
    var CATEGORY = 'CATEGORY';
    var SERIES = 'SERIES';
    var VALUE = 'VALUE';
    var PERCENT = 'PERCENT';

    var DEFAULT_MARKER_RADIUS = 4.5;

    var Base = Evented.extend({

        initialize:function(options, componentType, vanchart){

            this.componentType = componentType;
            this.vanchart = vanchart;

            this.refresh(options);
        },

        refresh:function(options){

            this.options = options || this.options;
            
            options = this.options;

            BaseUtils.extend(this, {
                isFloat:options.floating,
                _floatX:this._getPercentValue(options.x, this.vanchart.width),
                _floatY:this._getPercentValue(options.y, this.vanchart.height)
            });

            this._refresh && this._refresh(options);
        },

        _getLegendType:function(sery){

            var marker = sery.marker;

            var icon = '';

            switch (sery.type) {
                case Constants.MULTIPIE_CHART:
                case Constants.PIE_CHART:
                    if (sery.innerRadius && parseFloat(sery.innerRadius) > 0) {
                        return Constants.DONUT_ICON;
                    }else{
                        return Constants.PIE_ICON;
                    }
                case Constants.RADAR_CHART:
                    if (sery.columnType) {
                        return Constants.NORMAL_ICON;
                    }
                    break;
                case Constants.FORCE_BUBBLE_CHART:
                case Constants.BUBBLE_CHART:
                    return Constants.BUBBLE_ICON;
                case Constants.TREEMAP_CHART:
                    return Constants.TREEMAP_ICON;
                default:
                    icon = Constants.NORMAL_ICON;
            }

            if(sery.type == Constants.POINT_MAP && sery.icon){
                return sery.icon.iconUrl;
            }

            //有marker的图例,跟marker的类型一致,跟具体的图表类型无关
            if(marker){
                icon = marker.symbol;
                if(sery.type == Constants.SCATTER_CHART && !BaseUtils.isImageMarker(icon)){
                    icon = Constants.SCATTER_ICON + marker.symbol;
                }
            } else if(sery.image){
                //图片类型的填充系列用图片作为图例标记
                icon = sery.image;
            }

            return icon;
        },

        //用百分比表示或者数字表示的值
        _getPercentValue:function(value, total){
            if(value){
                value += '';
                if(value.indexOf('%') != -1){
                    value = parseFloat(value) * total / 100;
                }
                return parseFloat(value);
            }
            return 0;
        },

        _setComponentBounds:function(position, usedSize){
            if(this.isFloat){
                this._updateFloatBounds(position, usedSize);
            }else{
                this._updateComponentBounds(position, usedSize);
            }
        },

        isHorizontal:function(){
            var position = this.getPosition();
            return position == Constants.TOP || position == Constants.BOTTOM;
        },

        getPosition:function(){
            return this.options.position;
        },

        _updateFloatBounds:function(position, usedSize){
            usedSize = Math.ceil(usedSize);

            var originBounds = this.vanchart.getPlotBounds();

            var x = this._floatX;
            var y = this._floatY;

            var width = originBounds.x + originBounds.width - x;
            var height = originBounds.y + originBounds.height - y;

            switch (position){
                case Constants.TOP:
                    this.bounds = {x:x, y:y, width:width, height:usedSize};
                    break;
                case Constants.BOTTOM:
                    this.bounds = {x:x, y:y, width:width, height:usedSize};
                    break;
                case Constants.LEFT:
                    this.bounds = {x:x, y:y, width:usedSize, height:height};
                    break;
                case Constants.RIGHT_TOP:
                case Constants.RIGHT:
                    this.bounds = {x:x, y:y, width:usedSize, height:height};
                    break
            }
        },

        /**
         * 从原始区域裁减出一块区域以后作为组件区域，并且更新原始区域
         * @param position{string} 位置
         * @para usedSize 占据的大小
         * @private
         */
        _updateComponentBounds:function(position, usedSize){
            usedSize = Math.ceil(usedSize);

            var originBounds = this.vanchart.getPlotBounds();
            var x = originBounds.x;
            var y = originBounds.y;
            var width = originBounds.width;
            var height = originBounds.height;

            switch (position){
                case Constants.TOP:
                    this.bounds = {x:x, y:y, width:width, height:usedSize};
                    break;
                case Constants.BOTTOM:
                    this.bounds = {x:x, y:y+height-usedSize, width:width, height:usedSize};
                    break;
                case Constants.LEFT:
                    this.bounds = {x:x, y:y, width:usedSize, height:height};
                    break;
                case Constants.RIGHT_TOP:
                case Constants.RIGHT:
                    this.bounds = {x:x+width-usedSize, y:y, width:usedSize, height:height};
                    break
            }
            this.vanchart.setPlotBounds(originBounds);

            this._clipPlotBounds(position, usedSize);
        },

        _clipPlotBounds:function(position, usedSize){

            usedSize = Math.ceil(usedSize);

            var originBounds = this.vanchart.getPlotBounds();
            var x = originBounds.x;
            var y = originBounds.y;
            var width = originBounds.width;
            var height = originBounds.height;

            switch (position){
                case Constants.TOP:
                    originBounds = {x:x, y:y+usedSize, width:width, height:height - usedSize};
                    break;
                case Constants.BOTTOM:
                    originBounds = {x:x, y:y, width:width, height:height - usedSize};
                    break;
                case Constants.LEFT:
                    originBounds = {x:x+usedSize, y:y, width:width-usedSize, height:height};
                    break;
                case Constants.RIGHT_TOP:
                case Constants.RIGHT:
                    originBounds = {x:x, y:y, width:width-usedSize, height:height};
                    break
            }
            this.vanchart.setPlotBounds(originBounds);
        },

        _getBackgroundColor:function(){

            var opt = this.option;

            var plotColor = (typeof opt.plotBackgroundColor == 'string');

            var chartColor = (typeof opt.backgroundColor == 'string');

            var color =  plotColor ? opt.plotBackgroundColor : (chartColor ? opt.backgroundColor : 'white');

            return ColorUtils.colorToHex(color);
        },

        getMousePos:function(event){
            var el = this.vanchart.getParentDom();
            return BaseUtils.getMousePos(event, el);
        },

        _maxHeight:function(max){
            var maxHeight = this.vanchart.height;

            if(max || this.options.maxHeight){
                return this._getPercentValue(this.options.maxHeight, maxHeight);
            }

            return maxHeight;
        },

        _maxWidth:function(max){
            var maxWidth = this.vanchart.width;

            if(max || this.options.maxWidth){
                return this._getPercentValue(this.options.maxWidth, maxWidth);
            }

            return maxWidth;
        },

        _getTickContent:function(tick, formatter){

            if(!formatter){
                return tick;
            }

            return Formatter.format(tick, formatter);
        },

        getLabelGap:function(){
            return LABEL_GAP;
        },

        getDefaultMarkerRadius:function(){
            return DEFAULT_MARKER_RADIUS;
        },

        getPlotBounds:function(){
            return this.vanchart.getPlotBounds();
        },

        getChartBounds:function(){
            return this.vanchart.getChartBounds();
        },

        getParentDom:function(){
            return this.vanchart.getParentDom();
        },

        getDivParentDom:function(){
            return this.vanchart.getDivParentDom();
        },

        getTooltipComponent:function(){
            return this.vanchart.components.tooltip;
        },

        remove:function(){

        },

        _bindData:function(layers, dataArray, keyFunction){
            var i, n = layers.length, m = dataArray.length, enterFeatures = [], exitLayers = [], updateLayers = [];
            var nodeByKeyValue = {}, keyValues = new Array(n), keyValue, layer, datum;
            for (i = -1; ++i < n; ) {
                layer = layers[i];
                keyValue = keyFunction ? keyFunction(layer.datum()) : i;
                nodeByKeyValue[keyValue] = layer;
                keyValues[i] = keyValue;
            }
            for (i = -1; ++i < m; ) {
                datum = dataArray[i];
                keyValue = keyFunction ? keyFunction(datum) : i;
                layer = nodeByKeyValue[keyValue];
                if (!layer) {
                    enterFeatures.push(datum);
                }else if(layer !== true){
                    layer.datum(datum);
                    updateLayers.push(layer);
                }
                nodeByKeyValue[keyValue] = true;
            }

            for (i = -1; ++i < n; ) {
                if (nodeByKeyValue[keyValues[i]] !== true) {
                    exitLayers.push(layers[i]);
                }
            }

            return {
                update:updateLayers,
                enter:enterFeatures,
                exit:exitLayers
            }
        },

        invisible:function(){
            return BaseUtils.hasDefined(this.options.visible) && (this.options.visible == false);
        },

        _innerClip: function (group) {
            var comp = this, bounds = comp.bounds, vanchart = comp.vanchart, renderer = vanchart.renderer;
            var innerBounds = BaseUtils.makeBounds(0, 0, bounds.width, bounds.height);

            if(!this._clip){
                this._clip = renderer.createClip(innerBounds);
            }else{
                // this._clip.rect.attr(innerBounds);
            }

            renderer.clip(group, this._clip);
        }
    });

    return Base;
});
/**
 * Created by eason on 15/7/3.
 * reused and modified tooltip component from echarts
 */
//Copyright (c) 2013, Baidu Inc.
//    All rights reserved.
//
//    Redistribution and use of this software in source and binary forms, with or
//    without modification, are permitted provided that the following conditions
//are met:
//
//    Redistributions of source code must retain the above copyright notice, this
//list of conditions and the following disclaimer.
//
//    Redistributions in binary form must reproduce the above copyright notice,
//    this list of conditions and the following disclaimer in the documentation
//and/or other materials provided with the distribution.
//
//    Neither the name of Baidu Inc. nor the names of its contributors may be used
//to endorse or promote products derived from this software without specific
//prior written permission of Baidu Inc.
//
//    THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
//AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
//IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
//DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR
//ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
//(INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
//LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON
//ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
//(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
//SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.

define('component/Tooltip',['require','./Base','../utils/BaseUtils','../Constants','../utils/ColorUtils','../ComponentLibrary'],function(require){

    var Base = require('./Base');
    var BaseUtils = require('../utils/BaseUtils');
    var Constants = require('../Constants');
    var ColorUtils = require('../utils/ColorUtils');
    var ComponentLibrary = require('../ComponentLibrary');

    var DEFAULT_DURATION = 0.4;

    var Tooltip = Base.extend({

        _gCssText: 'position:absolute;display:block;border-style:solid;white-space:nowrap;z-index:2000;-webkit-user-select:none;-moz-user-select:none;-o-user-select:none;user-select:none;pointer-events:none;',

        _style: function (opt) {
            if (!opt) {
                return '';
            }
            var cssText = [];
            if (opt.animation && !opt.follow) {
                var transitionText = 'left ' + DEFAULT_DURATION + 's,'
                    + 'top ' + DEFAULT_DURATION + 's';
                cssText.push(
                    'transition:' + transitionText
                );
                cssText.push(
                    '-moz-transition:' + transitionText
                );
                cssText.push(
                    '-webkit-transition:' + transitionText
                );
                cssText.push(
                    '-o-transition:' + transitionText
                );
            }

            if(opt.style){
                var fontStyle = BaseUtils.cssNormalization(opt.style);

                for(var styleName in fontStyle){
                    if(styleName == 'color'){
                        cssText.push(styleName + ':' + ColorUtils.colorToHex(fontStyle[styleName]));
                    }else{
                        cssText.push(styleName + ':' + fontStyle[styleName]);
                    }
                }
            }

            if (opt.backgroundColor) {
                if(typeof opt.backgroundColor == 'string'){
                    if(BaseUtils.isSupportSVG()){
                        cssText.push('background-Color:' + opt.backgroundColor);
                    }else{
                        var hexAlpha = ColorUtils.colorToHexAlpha(opt.backgroundColor);
                        cssText.push('background-Color:' + hexAlpha.hex);
                        cssText.push('filter:alpha(opacity=' + hexAlpha.alpha + ')')
                    }
                }else if(typeof opt.backgroundColor == 'object'){

                    var color = opt.backgroundColor;
                    var startColor = ColorUtils.colorToHex(color.startColor);
                    var endColor = ColorUtils.colorToHex(color.endColor);

                    var start = 'left';

                    var startPos = 'left top';
                    var endPos = 'right top';
                    var type = 1;

                    if(color.x1 == color.x2){
                        start = 'top';

                        startPos = 'left top';
                        endPos = 'left bottom';

                        type = 0;
                    }

                    cssText.push('background: -ms-linear-gradient(' + start + ', '+ startColor +', '+ endColor +')');

                    cssText.push('background-image: -moz-linear-gradient(' + start + ', '+ startColor +', '+ endColor +')');

                    cssText.push('background-image: -webkit-gradient(linear, '+startPos+', '+endPos+', color-stop(0, '+ startColor +'), color-stop(1, '+ endColor+'))');

                    cssText.push('filter: progid:DXImageTransform.Microsoft.gradient(startColorstr='+startColor + ', endColorstr='+endColor+', GradientType='+type+')');
                }
            }

            if (opt.borderWidth != null) {
                cssText.push('border-width:' + opt.borderWidth + 'px');
            }

            if (opt.borderColor != null) {
                cssText.push('border-color:' + opt.borderColor);
            }

            if (opt.borderRadius != null) {
                cssText.push(
                    'border-radius:' + opt.borderRadius + 'px'
                );
                cssText.push(
                    '-moz-border-radius:' + opt.borderRadius + 'px'
                );
                cssText.push(
                    '-webkit-border-radius:' + opt.borderRadius + 'px'
                );
                cssText.push(
                    '-o-border-radius:' + opt.borderRadius + 'px'
                );
            }

            if(opt.shadow){
                cssText.push('box-shadow:1px 1px 2px rgba(0,0,0,0.2)');
            }

            var padding = opt.padding;
            if (padding != null && padding != undefined) {
                padding = BaseUtils.reformCssArray(padding);
                cssText.push(
                    'padding:' + padding[0] + 'px '
                    + padding[1] + 'px '
                    + padding[2] + 'px '
                    + padding[3] + 'px'
                );
            }

            cssText = cssText.join(';') + ';';

            return cssText;
        },

        doLayout:function(){
            if(!this._tDom){
                var dom = this.vanchart.getDivParentDom();

                this._tDom = document.createElement('div');

                this._hiddenDom = document.createElement('div');

                this._tDom.onselectstart = function() {
                    return false;
                };

                this._tDom.style.position = 'absolute';

                this._hiddenDom.style.visibility = 'hidden';

                dom.appendChild(this._tDom);

                dom.appendChild(this._hiddenDom);

                this._tooltipHideTick = null;
            }
        },

        remove:function(){
            if(this._tDom){
                var dom = this.vanchart.getDivParentDom();
                dom.removeChild(this._tDom);
                dom.removeChild(this._hiddenDom);
            }
        },

        showWithPoint:function(point, event){
            if(point && point.tooltip){
                var opt = point.tooltip, seriesChart = point.series;
                var tooltipText = point.series.calculateTooltipContent(point);
                var tooltipDim  = this.calculateTooltipDivDim(opt, tooltipText);
                //优先从地图那边取数据点提示的位置
                var pos = seriesChart.getTooltipPos(point, tooltipDim, event);
                this._show(pos, opt, tooltipText);
            }
        },


        _show:function(pos, opt, tooltipText){

            if(pos && opt && tooltipText && !this.vanchart.isMouseDown){
                clearTimeout(this._tooltipHideTick);

                this._tDom.innerHTML = tooltipText;

                this._tDom.style.cssText = this._gCssText
                    + this._style(opt)
                    + 'left:' + pos[0] + 'px;top:' + pos[1] + 'px;';
            }
        },

        hide:function(){

            clearTimeout(this._tooltipHideTick);

            this._tooltipHideTick = setTimeout(function(){
                this._tDom.style.display = 'none';
            }.bind(this), 400);

        },

        immediateHide:function(){
            this._tDom.style.display = 'none';
        },

        calculateTooltipDivDim:function(opt, tooltipText){
            opt = opt || '';
            var testDiv = this._hiddenDom;
            testDiv.innerHTML = tooltipText;
            testDiv.style.cssText = this._gCssText + this._style(opt) + 'visibility:hidden;';
            var width = testDiv.offsetWidth;
            var height = testDiv.offsetHeight;
            return {
                width:width,
                height:height
            };
        },

        render:function(){
            //do nothing
        }

    });

    ComponentLibrary.register(ComponentLibrary.TOOLTIP_COMPONENT, Tooltip);
    return Tooltip;
});
/**
 * Created by eason on 15/6/18.
 */
define('component/BaseAxis',['require','../Constants','../utils/BaseUtils','../utils/QueryUtils','../utils/Formatter','../ComponentLibrary','../utils/BoundsManager','./Base','../utils/BezierEasing'],function(require){
    var Constants = require('../Constants');
    var BaseUtils = require('../utils/BaseUtils');
    var QueryUtils = require('../utils/QueryUtils');
    var Formatter = require('../utils/Formatter');
    var ComponentLibrary = require('../ComponentLibrary');
    var BoundsManager = require('../utils/BoundsManager');

    var Base = require('./Base');

    var BezierEasing = require('../utils/BezierEasing');
    var TIME = 400;
    var EASE = BezierEasing.css.swing;

    var LABEL_LINE_GAP = 3;
    var TICK_LENGTH = 5;
    var TITLE_LABEL_GAP = 5;

    var TICK_COUNT = 5;
    var RADAR_TICK_COUNT = 4;
    var MIN_MAX_GAP = 100;

    var PADDING = 5;

    var PADDING_GAP = 10;
    var LABEL_BORDER_GAP = 8;

    var TOP = 'radar-top';
    var BOTTOM = 'radar-bottom';
    var LEFT = 'radar-left';
    var RIGHT = 'radar-right';

    var MAIN_TICK = 'main';
    var MINOR_TICKS = 'minor';

    var ARROW_SIZE = 15;

    var BaseAxis = Base.extend({

        labelRotation: 0,

        _refresh:function(){
            this.series = [];

            //for category axis
            this.isRangePoints = true;

            this.animation = this.vanchart.isSupportAnimation();

            this.piece = null;

            var options = this.options;
            options.tickPadding = isNaN(options.tickPadding) ? 6 : options.tickPadding;
            options.tickLength = options.enableTick ? (isNaN(options.tickLength) ? 4 : options.tickLength) : 0;
            options.minorTickLength = options.enableMinorTick ? (isNaN(options.minorTickLength) ? 2 : options.minorTickLength) : 0;
        },

        doLayout:function(){
            this.initAttributesWithSeries();
            this._updateAxisBounds();
        },

        getAxisValue: function (value) {
            return value;
        },

        _updateAxisBounds:function(){

            var axisOption = this.options;

            this.tickLabelLength = this._getTickLabelLength();
            var axisTileLength = this._getAxisTitleLength() + TITLE_LABEL_GAP;
            var usedSize = this.tickLabelLength + axisTileLength;
            var isHorizontal = this.isHorizontal();
            var isInverted = this.vanchart.isInverted();

            if(isHorizontal){
                var max = isInverted ? axisOption.maxWidth : axisOption.maxHeight;
                usedSize = max ? Math.min(this._maxHeight(max), usedSize) : usedSize;
            }else{
                var max = isInverted ? axisOption.maxHeight : axisOption.maxWidth;
                usedSize = max ? Math.min(this._maxWidth(max), usedSize) : usedSize;
            }

            this._setComponentBounds(this.getPosition(), usedSize);
        },

        updateClipBounds: function (clipBounds) {
            var labelDrawBetween = true;
            if(this.series && this.series.length > 0){
                labelDrawBetween = !this.series[0].type == Constants.AREA_CHART && !this.series[1].type ==  Constants.LINE_CHART;
            }
            if(this.type == ComponentLibrary.CATEGORY_AXIS_COMPONENT && labelDrawBetween){
                return;
            }
            var isHorizontal = this.isHorizontal(), isReversed = this.isAxisReversed(), vanchart = this.vanchart;
            var chartWidth = vanchart.width, chartHeight = vanchart.height, plotBounds = vanchart.getPlotBounds();
            var startSize = 0, endSize = 0;

            if(this.tickData && this.tickData.length > 1){
                var t_s, t_e;
                if(isReversed){
                    t_s = this.tickData[this.tickData.length - 1].tickDim;
                    t_e = this.tickData[0].tickDim;
                }else{
                    t_s = this.tickData[0].tickDim;
                    t_e = this.tickData[this.tickData.length - 1].tickDim;
                }
                startSize = isHorizontal ? t_s.width : t_s.height;
                endSize = isHorizontal ? t_e.width : t_e.height
            }

            startSize = Math.round(startSize/2);
            endSize = Math.round(endSize/2);

            if (isHorizontal) {
                startSize = Math.max(startSize - plotBounds.x, 0);
                endSize = Math.max(endSize - (chartWidth - plotBounds.x - plotBounds.width), 0);

                clipBounds[Constants.LEFT] = Math.max(clipBounds[Constants.LEFT] || 0, startSize);
                clipBounds[Constants.RIGHT] = Math.max(clipBounds[Constants.RIGHT] || 0, endSize);

            } else {
                endSize = Math.max(endSize - plotBounds.y, 0);
                startSize = Math.max(startSize - (chartHeight - plotBounds.y - plotBounds.height), 0);

                clipBounds[Constants.TOP] = Math.max(clipBounds[Constants.TOP] || 0, endSize);
                clipBounds[Constants.BOTTOM] = Math.max(clipBounds[Constants.BOTTOM] || 0, startSize);
            }
        },

        dealOnZero:function(){

            var cfg = this.options;

            if(cfg.onZero){

                var axisIndex = cfg.onZero === true ? 0 : cfg.onZero;

                var relyOn = this.componentType == ComponentLibrary.X_AXIS_COMPONENT ?
                    ComponentLibrary.Y_AXIS_COMPONENT : ComponentLibrary.X_AXIS_COMPONENT;

                relyOn = this.vanchart.getComponent(relyOn).getAxis(axisIndex);

                var pos;
                if (relyOn.type === ComponentLibrary.CATEGORY_AXIS_COMPONENT) {
                    pos = 0;
                } else {
                    pos = relyOn.scale(0);
                }

                var plotBounds = this.vanchart.getPlotBounds();

                var x, y, width, height;
                if(this.isHorizontal()){
                    x = plotBounds.x;
                    y = pos + plotBounds.y;
                    width = plotBounds.width;
                    height = this.bounds.height;
                }else{
                    x = pos + plotBounds.x;
                    y = plotBounds.y;
                    width = this.bounds.width;
                    height = plotBounds.height;
                }

                this.bounds = {
                    x:x,
                    y:y,
                    width:width,
                    height:height
                };

            }
        },

        //坐标轴的标签占据的大小
        _getTickLabelLength:function(){

            var axisOption = this.options;

            var tickLength = axisOption.tickPadding || LABEL_LINE_GAP;

            if(axisOption.enableTick){
                tickLength += axisOption.tickLength || TICK_LENGTH;
            }

            var isHorizontal = this.isHorizontal();

            var maxLabelLength  = 0;
            if(axisOption.showLabel && this.tickData.length){
                this.tickData.forEach(function(t){
                    var labelDim = t.tickDim;
                    maxLabelLength = Math.max(maxLabelLength, isHorizontal ? labelDim.height : labelDim.width);
                });
            }

            return tickLength + maxLabelLength;
        },

        //不考虑step和自动间隔
        _updateOriginTickData:function(){
            var labels = this._getTickValues();
            var axisOption = this.options;
            var formatter = axisOption.formatter;
            var useHtml = axisOption.useHtml;

            if (!isNaN(axisOption.labelRotation)) {
                this.labelRotation = axisOption.labelRotation;
            } else if (axisOption.autoRotate) {
                this.labelRotation = this.getLabelAutoRotation(labels, axisOption, formatter);
            } else {
                this.labelRotation = 0;
            }

            this.tickData = [];
            // todo, to make each case clear(x,y;v,h;polar)
            var style = axisOption.labelStyle || {};
            var tbStyle = BaseUtils.extend({'writing-mode': 'tb-rl'}, style);
            for(var i = 0, len = labels.length; i < len; i++){
                var tickValue = labels[i];
                var tickContent = this._getTickContent(tickValue, formatter);
                var rectDim, labelDim, tmpStyle = style;
                var labelRotation = this.labelRotation;

                if (Math.abs(labelRotation) === 90 && BaseUtils.hasChn(tickContent)) {
                    labelRotation = 360; // as a log
                    tmpStyle = tbStyle;
                }

                if (useHtml) {
                    rectDim = BaseUtils.getTextDimension(tickContent, tmpStyle, useHtml);
                } else {
                    rectDim = BaseUtils.getSvgTextDim(tickContent, tmpStyle);
                }
                labelDim = BaseUtils.getTextDimRotated(rectDim, labelRotation);

                if(useHtml){
                    labelDim.width = isNaN(parseFloat(axisOption.labelWidth)) ? labelDim.width : parseFloat(axisOption.labelWidth);
                    labelDim.height = isNaN(parseFloat(axisOption.labelHeight)) ? labelDim.height : parseFloat(axisOption.labelHeight);
                }

                this.tickData.push({
                    tickValue:tickValue,
                    tickContent:tickContent,
                    tickDim:labelDim,
                    tickRectDim:rectDim,
                    labelRotation: labelRotation
                });
            }
        },

        _isBaseAxis:function(){
            if(this.series.length){
                return this.componentType == this.series[0].getBaseAxisType();
            }
            return false;
        },

        getLabelAutoRotation: function () {
            return 0;
        },

        //确定scale以后计算内容,改变scale的话要重新计算originTickData
        _calculateTickData:function(){
            this._updateTickContent();
            this._updateMainAndMinorTickData();
        },

        _updateMainAndMinorTickData:function(){
            var startIndex = BaseUtils.pick(this.startIndex, 0);
            var endIndex = BaseUtils.pick(this.endIndex, this.tickData.length - 1) + 1;

            this.usedTickData = [];
            for(var i = startIndex; i < endIndex; i++){
                this.tickData[i] && this.usedTickData.push(this.tickData[i]);
            }

            this.minorTickData = [];
            if(this.options.enableMinorTick && this.usedTickData.length){
                this.type == ComponentLibrary.CATEGORY_AXIS_COMPONENT ? this._updateCategoryMinorTickData() : this._updateValueMinorTickData();
            }
        },

        _getAxisTitleLength:function(){
            var title = this.options.title;
            var usedSize = 0;
            if(title){
                var rectDim, dim;
                this.titleRotation = title.rotation;
                if (BaseUtils.hasChn(title.text) && Math.abs(title.rotation) === 90) {
                    this.titleRotation = 360;
                    BaseUtils.extend(title.style, {'writing-mode': 'tb-rl'});
                }

                rectDim = title.useHtml ? BaseUtils.getTextDimension(title.text, title.style) :
                    BaseUtils.getSvgTextDim(title.text, title.style);

                dim = BaseUtils.getTextDimRotated(rectDim, this.titleRotation);

                this.titleRectDim = rectDim;
                this.titleDim = dim;

                usedSize = this.isHorizontal() ? dim.height : dim.width;
            }
            return usedSize;
        },

        //坐标轴占据的空间
        getAxisTitleBounds:function(){

            var bounds = this.bounds;

            var tickLength = this.tickLabelLength + TITLE_LABEL_GAP;;

            var position = this.getPosition();

            var x = bounds.x;
            var y = bounds.y;
            var width = bounds.width;
            var height = bounds.height;

            switch (position){
                case Constants.LEFT:
                    width -= tickLength;
                    break;

                case Constants.BOTTOM:
                    y += tickLength;
                    height -= tickLength;
                    break;

                case Constants.RIGHT:
                    x += tickLength;
                    width -= tickLength;
                    break;

                case Constants.TOP:
                    height -= tickLength;
                    break;
            }

            return {
                x:x,
                y:y,
                width: Math.max(width, 0),
                height: Math.max(height, 0)
            }
        },

        getTickLength:function(){
            var range = this.scale.range();

            return Math.abs(range[1] - range[0]);
        },

        _updateInitRange:function(){
            this.scale.range(this._getRange());

            this._calculateTickData();
        },

        _getRange:function(){
            var plotBounds = this.vanchart.getPlotBounds();

            if(this.isHorizontal()){
                return this.isAxisReversed() ? [plotBounds.width, 0] : [0, plotBounds.width];
            }else{
                return this.isAxisReversed() ? [0, plotBounds.height] : [plotBounds.height, 0];
            }
        },

        _getPlotBands:function(){

            var plotBands = this.options.plotBands;
            var scale = this.scale;
            var isRangeBand = !!scale.rangeBand;

            if(typeof plotBands == 'string'){

                var color = plotBands;
                plotBands = [];

                var labels = this._getTickValuesWithEndValue();

                var endIndex = isRangeBand ? -1 : 0;

                for(var index = labels.length - 1; index > endIndex; index -= 2){
                    plotBands.push({
                        color:color,
                        from:isRangeBand ? labels[index] : labels[index - 1],
                        to:labels[index]
                    });
                }

            }else{

                plotBands = plotBands || [];

                var result = [];

                for(var i = 0, count = plotBands.length; i < count; i++){

                    var t_bands = plotBands[i];

                    if(BaseUtils.hasDefined(t_bands.from) && BaseUtils.hasDefined(t_bands.to)){
                        result.push(t_bands);
                    }

                }

                plotBands = result;
            }

            return plotBands;
        },

        //考虑tickFormat的作用
        _getTickValues:function(){
            return [];
        },

        _getTickInterval:function(){

            //考虑一开始的区间不满一个tick
            if(this.valueList.length > 2){
                return BaseUtils.accAdd(this.valueList[2], -this.valueList[1]);
            }else{
                return BaseUtils.accAdd(this.valueList[1], -this.valueList[0])
            };

        },

        _getTickValuesWithEndValue:function(){
            return this._getTickValues();
        },

        //画的时候计算自定义标签间隔等
        getTickData:function(){
            return this.usedTickData;
        },

        getMaxTickWidth:function(){
            var maxWidth = 0;

            this.usedTickData.forEach(function(data){

                maxWidth = Math.max(maxWidth, data.tickDim.width);

            });
            return maxWidth;
        },

        getTickHeight:function(){

            if(this.options.labelStyle){
                return BaseUtils.getTextHeight(this.options.labelStyle);
            }

            return 0;

        },

        getMinorTickData:function(){
            return this.minorTickData;
        },

        //todo 这个方法要删掉
        getMainTickData:function(){

            var cfg = this.options;

            var update = !cfg.log && !this.byPercent && this.type == ComponentLibrary.VALUE_AXIS_COMPONENT;

            if(update){

                var interval = this._getTickInterval();

                if(this.usedTickData.length > 3){

                    var secondMin = this.usedTickData[1].tickValue;

                    var secondMax = this.usedTickData[this.usedTickData.length - 2].tickValue;

                    var startIndex = 0;
                    var endIndex = this.usedTickData.length;

                    if(BaseUtils.hasDefined(cfg.min) && BaseUtils.accAdd(secondMin, -interval) < cfg.min){
                        startIndex += 1;
                    }

                    if(BaseUtils.hasDefined(cfg.max) && BaseUtils.accAdd(secondMax, interval) > cfg.max){
                        endIndex -= 1;
                    }

                    var mainTickData = [];
                    for(var i = startIndex; i < endIndex; i++){
                        mainTickData.push(this.usedTickData[i]);
                    }

                    return mainTickData;
                }

            }

            return this.getTickData();
        },

        _updateCategoryMinorTickData:function(){
            var minorTickLength = Math.round(this.getTickLength() / 5);
            var endIndex = this.usedTickData.length;
            endIndex = this.scale.rangeBand ? endIndex : endIndex - 1;
            for(var i = 0; i < endIndex; i++){
                var startPos = this.usedTickData[i].tickPos;
                for(var j = 1; j < 5; j++){
                    this.minorTickData.push(
                        startPos + minorTickLength * j
                    );
                }
            }
        },

        _updateValueMinorTickData:function(){

            var cfg = this.options;
            var interval = this._getTickInterval();
            var minorInterval = cfg.minorTickInterval ? cfg.minorTickInterval : interval / 5;

            for(var i = 0, count = this.usedTickData.length; i < count - 1; i++){

                var start = this.usedTickData[i].tickValue;

                var end = this.usedTickData[i + 1].tickValue;

                var isDate = (start instanceof Date && end instanceof Date);

                start = isDate ? BaseUtils.date2int(start) : start;
                end = isDate ? BaseUtils.date2int(end) : end;

                if(i == 0){
                    for(var value = BaseUtils.accAdd(end, -minorInterval); value > start; value = BaseUtils.accAdd(value, -minorInterval)){
                        this.minorTickData.push(isDate ? BaseUtils.int2date(value) : value);
                    }
                }else{
                    for(var value = BaseUtils.accAdd(start,minorInterval); value < end; value = BaseUtils.accAdd(value, minorInterval)){
                        this.minorTickData.push(isDate ? BaseUtils.int2date(value) : value);
                    }
                }
            }

            var endValue = this.tickData[this.tickData.length - 1].tickValue;
            var maxValue = this.scale.domain()[1];

            var isDate = (endValue instanceof Date) && (maxValue instanceof Date);
            endValue = isDate ? BaseUtils.date2int(endValue) : endValue;
            maxValue = isDate ? BaseUtils.date2int(maxValue) : maxValue;

            if(endValue < maxValue){
                for(var value = endValue + minorInterval; value <= maxValue; value += minorInterval){
                    this.minorTickData.push(isDate ? BaseUtils.int2date(value) : value);
                }
            }

            var startValue = this.tickData[0].tickValue;
            var minValue = this.scale.domain()[0];

            isDate = (startValue instanceof Date) && (minValue instanceof Date);
            startValue = isDate ? BaseUtils.date2int(startValue) : startValue;
            minValue = isDate ? BaseUtils.date2int(minValue) : minValue;

            if(startValue > minValue){
                for(value = startValue - minorInterval; value >= minValue; value -= minorInterval){
                    this.minorTickData.push(isDate ? BaseUtils.int2date(value) : value);
                }
            }
        },

        // check showLabel
        _updateLabelContent: function () {
            if(!this.options.showLabel){
                this.tickData.forEach(function(t){
                    t.tickContent = '';
                })
            }
        },

        _updateTickContent:function(){
            var axisOption = this.options, scale = this.scale;

            var det = scale.rangeBand ? scale.rangeBand()/2 : 0;
            this.tickData.forEach(function(t){
                t.tickPos = scale(t.tickValue);
                t.tickLabelPos = t.tickPos + det;
            });

            if(!axisOption.showLabel){
                this.tickData.forEach(function(t){
                    t.tickContent = '';
                })
            }else if(axisOption.step){
                var index = 0;
                this.tickData.forEach(function(t){
                    if(index++ % axisOption.step){
                        t.tickContent = '';
                    }
                });
            }else{
                var manager = new BoundsManager();
                var isHorizontal = this.isHorizontal();

                var testStep = 1;
                var longestStep = 1;



                // label rotated [15-90) can as long as it can
                // otherwise check the dim
                var labelRotation = Math.abs(Math.abs(this.labelRotation) - (isHorizontal ? 0 : 90)),
                    isRotated = (labelRotation >= 15 && labelRotation !== 90),
                    labelRadian;
                labelRadian = BaseUtils.toRadian(labelRotation);
                var lastTickPos, lastH = -1, gap, l, h,
                    sin = Math.sin(labelRadian);

                this.tickData.forEach(function(t){
                    if (t.tickContent === '') {
                        return;
                    }

                    if (isRotated) {
                        h = BaseUtils.getTextDimension(t.tickContent).height;
                        gap = Math.abs(t.tickPos - lastTickPos);
                        l = (h + lastH) / 2;
                        if (l < gap * sin || lastH === -1) {
                            testStep = 1;
                            lastTickPos = t.tickPos;
                            lastH = h;
                        } else {
                            testStep++;
                            longestStep = Math.max(longestStep, testStep);
                        }

                    } else {

                        var pos = isHorizontal ? {x: scale(t.tickValue), y: 0} : {x: 0, y: scale(t.tickValue)};
                        var bounds = BaseUtils.makeBounds(pos, t.tickDim);

                        if (manager.isOverlapped(bounds)) {

                            testStep++;
                            longestStep = Math.max(longestStep, testStep);

                        } else {
                            testStep = 1;
                            manager.addBounds(bounds);
                        }
                    }
                });

                var index = 0;
                this.tickData.forEach(function(t){
                    if(index++ % longestStep){
                        t.tickContent = '';
                    }
                });
            }
        },

        _getAxisOriginPoint:function(){
            var axisBounds = this.bounds;
            var position = this.getPosition();
            var x,y;

            switch(position){
                case Constants.TOP:
                    x = axisBounds.x;
                    y = axisBounds.y + axisBounds.height;
                    break;

                case Constants.BOTTOM:
                    x = axisBounds.x;
                    y = axisBounds.y;
                    break;

                case Constants.LEFT:
                    x = axisBounds.x + axisBounds.width;
                    y = axisBounds.y;
                    break;

                case Constants.RIGHT:
                    x = axisBounds.x;
                    y = axisBounds.y;
                    break;
            }

            return {x:x, y:y};
        },

        getTickScale:function(){
            return this.scale;
        },

        getPosition:function(){
            if (this.vanchart.isInverted()){
                switch (this.options.position) {
                    case Constants.TOP:
                        return Constants.RIGHT;
                    case Constants.RIGHT:
                        return Constants.BOTTOM;
                    case Constants.BOTTOM:
                        return Constants.LEFT;
                    case Constants.LEFT:
                        return Constants.TOP;
                }
            } else {
                return this.options.position;
            }
        },

        isAxisReversed:function(){
            if (this.componentType === ComponentLibrary.X_AXIS_COMPONENT &&
                this.vanchart.isInverted()) {
                return !this.options.reversed;
            }
            return this.options.reversed;
        },

        isOnZero:function(){
            return this.options.onZero;
        },

        getLineWidth:function(){
            return this.options.lineWidth;
        },

        showArrow:function(){
            return this.options.showArrow;
        },

        getTitleAlign: function () {
            var title = this.options.title;
            if (!title) {
                return null;
            }

            if (this.vanchart.isInverted()) {
                switch (title.align) {
                    case Constants.TOP:
                        return Constants.RIGHT;
                    case Constants.RIGHT:
                        return Constants.BOTTOM;
                    case Constants.BOTTOM:
                        return Constants.LEFT;
                    case Constants.LEFT:
                        return Constants.TOP;
                }
            }

            if (this.isHorizontal()) {
                return title.align || Constants.LEFT;
            } else {
                return title.align || Constants.TOP;
            }
        },

        getTitleLabelGap:function(){
            return TITLE_LABEL_GAP;
        },

        getAxisIndex:function(){
            return this.options.axisIndex;
        },

        //普通的值轴
        _calculateValueNiceDomain:function(minValue, maxValue, fixedMin, fixedMax){

            var fromZero = this.type == ComponentLibrary.VALUE_AXIS_COMPONENT;

            var axisOption = this.options;

            minValue = fromZero ? Math.min(0, minValue) : minValue;

            minValue = BaseUtils.hasDefined(fixedMin) ? fixedMin : minValue;
            maxValue = BaseUtils.hasDefined(fixedMax) ? fixedMax : maxValue;

            // if any exceeded min, adjust max to min + 100
            if(minValue >= maxValue){
                maxValue = minValue + MIN_MAX_GAP * (this.type === ComponentLibrary.DATE_AXIS_COMPONENT ? 1000 : 1);
            }

            var tickInterval = axisOption.tickInterval || this._linearTickInterval(minValue, maxValue);

            var domain = this._linearNiceDomain(minValue, maxValue, tickInterval);
            minValue = BaseUtils.hasDefined(fixedMin) ? fixedMin : domain[0];
            maxValue = BaseUtils.hasDefined(fixedMax) ? fixedMax : domain[1];

            if(minValue >= maxValue){
                maxValue = minValue + MIN_MAX_GAP * (this.type === ComponentLibrary.DATE_AXIS_COMPONENT ? 1000 : 1);
            }

            var start = domain[0];

            if(BaseUtils.hasDefined(fixedMin)){

                // ceil( (fixedMin - start) / tickInterval ) * tickInterval
                var diff = BaseUtils.accMul(
                    Math.ceil(
                        BaseUtils.accDiv(BaseUtils.accAdd(fixedMin, -start), tickInterval)
                    ),
                    tickInterval
                );

                start = BaseUtils.accAdd(start, diff);
            }

            this.valueList = [];

            for(; start <= maxValue; start = BaseUtils.accAdd(start, tickInterval)){
                this.valueList.push(start);
            }

            return [minValue, maxValue];
        },

        _linearTickInterval:function(minValue, maxValue, m){

            m = m || this._getDefaultTickCount();
            var span = maxValue - minValue;
            var step = Math.pow(10, Math.floor(Math.log(span / m) / Math.LN10));
            var err = m / span * step;

            if (err <= .15) step *= 10; else if (err <= .35) step *= 5; else if (err <= .75) step *= 2;

            return step;
        },

        _linearNiceDomain:function(minValue, maxValue, tickInterval){

            minValue = BaseUtils.accMul(Math.floor(minValue / tickInterval), tickInterval);

            maxValue = BaseUtils.accMul(Math.ceil(maxValue / tickInterval), tickInterval);

            return [minValue, maxValue];
        },

        _getDefaultTickCount:function(){
            return this.vanchart.currentOption.chartType == Constants.RADAR_CHART ? RADAR_TICK_COUNT : TICK_COUNT;
        },

        _isSeriesVisible:function(sery){
            var queryList = [
                sery,
                this.option.plotOptions[sery.type],
                this.option.plotOptions
            ];
            return BaseUtils.pick(QueryUtils.queryList(queryList, 'visible'), true);
        },

        getIndexByPosition: function (pos) {
            var plotBounds = this.getPlotBounds();
            var scale = this.scale;
            var startX = scale(
                this.isAxisReversed() ?
                    scale.domain()[scale.domain().length - 1] :
                    scale.domain()[0]
            );

            var x;

            if (this.isHorizontal()) {
                x = pos[0] - plotBounds.x - startX;
            } else {
                x = pos[1] - plotBounds.y - startX;
            }

            var index;
            switch (this.type) {
                case ComponentLibrary.DATE_AXIS_COMPONENT:
                    index = BaseUtils.date2int(scale.invert(x));
                    break;
                default:
                    index = scale.invert(x);
            }

            index = Math.round(index);
            return index;
        },

        render:function(){

            if(this.series.length == 0){
                return;
            }

            var vanchart = this.vanchart, renderer = vanchart.renderer;

            if(!this.axisGroup){
                this.axisGroup = renderer.group().add();
            }

            this._drawPlotBands();

            this._drawGridLine();

            this._drawTickLine();

            this._drawTickLabel();

            this._drawPlotLines();

            this._drawAxisTitle();
        },

        renderSpecial: function () {
            if(this.series.length == 0){
                return;
            }

            var vanchart = this.vanchart, renderer = vanchart.renderer;

            if(!this.axisLineGroup){
                this.axisLineGroup = renderer.group().add();
            }

            this._drawAxisLine();
        },

        _drawPlotBands:function(){
            var plotBands = this._getPlotBands(), scale = this.scale, isRangeBand = scale.rangeBand;
            var rangeBand = isRangeBand ? scale.rangeBand() : 0;

            var renderer = this.vanchart.renderer, animation = this.animation;
            var plotBounds = this.vanchart.getPlotBounds(), axis = this, isHorizontal = axis.isHorizontal();

            var i, len, from, to, rect;
            var x = 0, y = 0, width = plotBounds.width, height = plotBounds.height;

            if(!this.plotBandsGroup){
                this.plotBandsGroup = renderer.group().addTo(this.axisGroup);
                this.plotBands = [];
            }

            this.plotBandsGroup.attr({'transform': BaseUtils.makeTranslate(plotBounds)});

            for(i = plotBands.length; i < this.plotBands.length; i++){
                this.plotBands[i].remove();
            }

            for(i = 0, len = plotBands.length; i < len; i++){
                var d = plotBands[i];

                var t_f = scale(d.from), t_t = scale(d.to);
                from = Math.min(t_f, t_t); to = Math.max(t_f + rangeBand, t_t + rangeBand);

                from = Math.max(isHorizontal ? x : y, from);
                to = Math.min(isHorizontal ? width : height, to);

                rect = isHorizontal ? {x:from, y:y, width:to - from, height:height}
                    :{x:x, y:from, width:width, height:to - from};

                this.plotBands[i] = this.plotBands[i] || renderer.rect(rect).addTo(this.plotBandsGroup);

                if(animation){
                    this.plotBands[i].style({'fill':d.color});
                    d3.select(this.plotBands[i].rawElement).transition().duration(TIME).ease(EASE)
                        .attr('x', rect.x).attr('y', rect.y)
                        .attr('width', rect.width).attr('height', rect.height);
                }else{
                    this.plotBands[i].attr(rect).style({fill:d.color})
                }
            }
        },

        _drawAxisLine:function(){
            var cfg = this.options, lineWidth = cfg.lineWidth, lineColor = cfg.lineColor;
            var plotBounds = this.getPlotBounds(), axisOrigin = this._getAxisOriginPoint();
            var x1 = 'x1', y1 = 'y1', x2 = 'x2', y2 = 'y2';
            var size = plotBounds.width, renderer = this.vanchart.renderer;
            if(!this.isHorizontal()){
                x1 = 'y1'; y1 = 'x1'; x2 = 'y2'; y2 = 'x2';
                size = plotBounds.height;
            }
            var det = BaseUtils.lineSubPixelOpt(0, lineWidth);
            if(!this.axisLine){
                this.axisLine = renderer.line().addTo(this.axisLineGroup);
            }
            var attrs = {};attrs[x1] = 0; attrs[x2] = size; attrs[y1] = attrs[y2] = det;
            attrs.transform = BaseUtils.makeTranslate(axisOrigin);
            this.axisLine.attr(attrs).style({stroke:lineColor, 'stroke-width': lineWidth});

            if(this.showArrow()){

                if(!this.arrowGroup){
                    this.arrowGroup = renderer.group().addTo(this.axisLineGroup);
                }

                var line = this.arrowGroup.line || renderer.line().addTo(this.arrowGroup);
                var path = this.arrowGroup.path || renderer.path().addTo(this.arrowGroup);
                this.arrowGroup.line = line; this.arrowGroup.path = path;

                if(this.isHorizontal()){
                    this.arrowGroup.attr('transform', BaseUtils.makeTranslate([axisOrigin.x + plotBounds.width, axisOrigin.y]));
                    line.attr({'x1':0, 'y1':det, 'x2':6, 'y2':det}).style({stroke:lineColor, 'stroke-width': lineWidth});
                    path.attr({'d':"M2,-4 L10,0 L2,4 L6,0 L2,-4"}).style({'fill':lineColor});
                }else{
                    this.arrowGroup.attr('transform', BaseUtils.makeTranslate(axisOrigin));
                    line.attr({'x1':det, 'y1':0, 'x2':det, 'y2':-6}).style({stroke:lineColor, 'stroke-width': lineWidth});
                    path.attr({'d':"M-4,-2 L0,-10 L4,-2 L0,-6 L-4,-2"}).style({'fill':lineColor});
                }
            }else{
                this.arrowGroup && this.arrowGroup.remove();
            }
        },

        _drawGridLine:function(){
            var cfg = this.options, plotBounds = this.getPlotBounds(), animation = this.animation;
            var ticks = this.getTickData(), scale = this.scale, lastScale = this.lastScale || scale;
            var gridLineColor = cfg.gridLineColor, gridLineWidth = cfg.gridLineWidth;
            var det = BaseUtils.lineSubPixelOpt(0, gridLineWidth), renderer = this.vanchart.renderer;

            var x1 = 'x1', y1 = 'y1', x2 = 'x2', y2 = 'y2', lineSize = plotBounds.height;
            if(!this.isHorizontal()){
                x1 = 'y1'; y1 = 'x1'; x2 = 'y2'; y2 = 'x2';lineSize = plotBounds.width;
            }

            if(!this.gridLinesGroup){
                this.gridLinesGroup = renderer.group().addTo(this.axisGroup);
                this.gridLines = [];
            }
            this.gridLinesGroup.attr('transform', BaseUtils.makeTranslate(plotBounds));

            var selection = this._bindData(this.gridLines, ticks, function(d){return d.tickValue});

            var currentGridLines = [];
            for(var i = 0, len = selection.exit.length; i < len; i++){
                if(animation){
                    var d = selection.exit[i].datum(), pos = scale(d.tickValue);
                    d3.select(selection.exit[i].rawElement)
                        .transition().duration(TIME).ease(EASE)
                        .style("opacity", 0).attr(x1, pos).attr(x2, pos).remove();
                }else{
                    selection.exit[i] && selection.exit[i].remove();
                }
            }

            for(var i = 0, len = selection.enter.length; i < len; i++){

                var d = selection.enter[i];
                var gridLine = renderer.line().style({'stroke':gridLineColor, 'stroke-width':gridLineWidth}).addTo(this.gridLinesGroup);
                var lastPos = lastScale(d.tickValue) + det;
                var pos = d.tickPos + det;

                gridLine.attr(x1, lastPos).attr(x2, lastPos).attr(y1, 0).attr(y2, lineSize);

                if(animation){
                    d3.select(gridLine.rawElement).transition().duration(TIME).ease(EASE)
                        .attr(x1, pos).attr(x2, pos).attr(y1, 0).attr(y2, lineSize);
                }else{
                    gridLine.attr(x1, pos).attr(x2, pos).attr(y1, 0).attr(y2, lineSize);
                }

                gridLine.datum(d);
                currentGridLines.push(gridLine);
            }

            currentGridLines = currentGridLines.concat(selection.update);

            for(var i = 0, len = currentGridLines.length; i < len; i++){

                var gridLine = currentGridLines[i].style({'stroke':gridLineColor, 'stroke-width':gridLineWidth});
                var d = gridLine.datum(), pos = d.tickPos + det;

                if(animation){
                    d3.select(gridLine.rawElement).transition().duration(TIME).ease(EASE)
                        .attr(x1, pos).attr(y1, 0).attr(x2, pos).attr(y2, lineSize);
                }else{
                    gridLine.attr(x1, pos).attr(x2, pos).attr(y1, 0).attr(y2, lineSize);
                }
            }

            this.gridLines = currentGridLines;
        },

        //包括主要刻度线和次要刻度线,不加动画了
        _drawTickLine:function(){
            var cfg = this.options, axisOrigin = this._getAxisOriginPoint(), orient = this.getPosition();

            var ticks = this.getMainTickData(), tickLength = cfg.enableTick ? (cfg.tickLength || 0) : 0;
            var tickWidth = cfg.tickWidth,tickColor = cfg.tickColor;

            var minorTickData = this.getMinorTickData(), minorTickLength = cfg.enableMinorTick ? (cfg.minorTickLength || 0) : 0;
            var minorTickColor = cfg.minorTickColor, minorTickWidth = cfg.minorTickWidth;
            var renderer = this.vanchart.renderer, axis = this;

            var x1 = 'x1', y1 = 'y1', x2 = 'x2', y2 = 'y2';
            if(!this.isHorizontal()){
                x1 = 'y1'; y1 = 'x1'; x2 = 'y2'; y2 = 'x2';
            }
            var sign = (orient == Constants.TOP || orient == Constants.LEFT) ? -1 : 1;
            var detMain = BaseUtils.lineSubPixelOpt(0, tickWidth);
            var detMinor = BaseUtils.lineSubPixelOpt(0, minorTickWidth);

            if(!this.tickLinesGroup){
                this.tickLinesGroup = renderer.group().addTo(this.axisGroup);
                this.tickLines = {};
                this.tickLines[MAIN_TICK] = []; this.tickLines[MINOR_TICKS] = [];
            }

            function _drawTickLine(tickLines, tickData, options){

                var selection = axis._bindData(tickLines, tickData);
                var currentTickLines = [], i, len;

                for(i = 0, len = selection.exit.length; i < len; i++){
                    selection.exit[i].remove();
                }

                for(i = 0, len = selection.enter.length; i < len; i++){
                    currentTickLines.push(renderer.line().datum(selection.enter[i]).addTo(axis.tickLinesGroup));
                }

                currentTickLines = currentTickLines.concat(selection.update);

                for(i = 0, len = currentTickLines.length; i < len; i++){
                    var datum = currentTickLines[i].datum(), attrs  = {};

                    var tickPos;

                    if(BaseUtils.hasDefined(datum.tickPos)){
                        tickPos = datum.tickPos;
                    }else{
                        tickPos = axis.type == ComponentLibrary.CATEGORY_AXIS_COMPONENT ? datum : axis.scale(datum);
                    }

                    var detX = axisOrigin.x, detY = axisOrigin.y;
                    if(!axis.isHorizontal()){
                        detX = axisOrigin.y; detY = axisOrigin.x;
                    }

                    attrs[x1] = tickPos + options.det + detX; attrs[x2] = attrs[x1];
                    attrs[y1] = detY; attrs[y2] = (sign * options.tickLength || 0) + detY;

                    currentTickLines[i].attr(attrs).style({
                        'stroke':options.tickColor, 'stroke-width':options.tickWidth
                    });
                }

                return currentTickLines
            }

            this.tickLines[MAIN_TICK] = _drawTickLine(this.tickLines[MAIN_TICK], ticks, {
                det:detMain, tickWidth:tickWidth, tickLength:tickLength, tickColor:tickColor
            });

            this.tickLines[MINOR_TICKS] = _drawTickLine(this.tickLines[MINOR_TICKS], minorTickData, {
                det:detMinor, tickWidth:minorTickWidth, tickLength:minorTickLength, tickColor:minorTickColor
            });
        },

        _drawPlotLines:function(){
            var plotLines = this.options.plotLines || [], position = this.getPosition();
            var plotBounds = this.vanchart.getPlotBounds();
            var scale = this.scale, isDate = this.type == ComponentLibrary.DATE_AXIS_COMPONENT;
            var result = [], axis = this, renderer = this.vanchart.renderer;
            plotLines.forEach(function(d){

                var pos = scale(isDate ? BaseUtils.object2date(d.value) : d.value) + (scale.rangeBand ? scale.rangeBand()/2 : 0);
                pos = BaseUtils.lineSubPixelOpt(pos, d.width);
                var x1, x2, y1, y2;

                if (axis.isHorizontal()) {
                    x1 = x2 = pos; y1 = 0; y2 = plotBounds.height;
                } else {
                    x1 = 0; x2 = plotBounds.width; y1 = y2 = pos;
                }

                var textX, textY, text, style;
                if(d.label && d.label.text && d.label.style){
                    style = d.label.style; text = d.label.text;
                    var align = d.label.align;
                    var textDim = BaseUtils.getTextDimension(text, style, d.label.useHtml);
                    switch (align){
                        case Constants.TOP:
                            textX = x1 - textDim.width; textY = y1;
                            break;
                        case Constants.BOTTOM:
                            textX = x1 - textDim.width; textY = y2 - textDim.height;
                            break;
                        case Constants.LEFT:
                            textX = x1; textY = y1 - textDim.height - LABEL_LINE_GAP;
                            break;
                        case Constants.RIGHT:
                            textX = x2 - textDim.width; textY = y2 - textDim.height - LABEL_LINE_GAP;
                            break;
                    }
                }

                result.push({
                    color: d.color,
                    line:{x1:x1, y1:y1, x2:x2, y2:y2},
                    width: d.width,
                    dataArray:Constants.DASH_TYPE[d.dashStyle],

                    text:text,
                    textDim:textDim,
                    style:style,
                    textX:textX,
                    textY:textY
                });
            });

            function _getPlotLineStyle(datum){
                return {'stroke':datum.color, 'stroke-width':datum.width, 'stroke-dasharray':datum.dataArray};
            }

            function _getLabelGraphic(datum){
                return renderer.text().textContent(datum.text).style(datum.style)
                    .attr({'x':datum.textX, 'y':datum.textY, 'text-anchor':'left', 'dy':datum.textDim.height * .85});
            }

            function _createLabelGraphic(datum, g){
                if(g._textG){
                    g._textG.remove();
                    g._textG = null;
                }
                if(datum.text && datum.textDim) {
                    g._textG = _getLabelGraphic(datum).addTo(g);
                }
            }

            if(!this.plotLinesGroup){
                this.plotLinesGroup = renderer.group().addTo(this.axisGroup);
                this.plotLines = [];
            }

            this.plotLinesGroup.attr('transform', BaseUtils.makeTranslate(plotBounds));
            var selection = this._bindData(this.plotLines, result), i, len;
            this.plotLines = [];

            for(i = 0, len = selection.exit.length; i < len; i++){
                selection.exit[i].remove();
            }

            for(i = 0, len = selection.enter.length; i < len; i++){
                var datum = selection.enter[i], g = renderer.group();
                this.plotLines.push(g);

                g.append(renderer.line(datum.line).style(_getPlotLineStyle(datum)));
                _createLabelGraphic(datum, g);
                g.addTo(this.plotLinesGroup);
            }

            for(i = 0, len = selection.update.length; i < len; i++){
                var g = selection.update[i], datum = g.datum();
                if(this.animation){
                }else{
                    g.line.attr(datum.line).style(_getPlotLineStyle(datum));
                }

                _createLabelGraphic(datum, g);
                this.plotLines.push(g);
            }
        },

        _drawTickLabel:function(){
            this._drawSvgTickLabel();
        },

        _drawSvgTickLabel:function(){
            var axis = this, vanchart = this.vanchart, renderer = vanchart.renderer;

            var scale = this.scale, lastScale = this.lastScale || scale;
            var cfg = this.options, labelStyle = cfg.labelStyle, animation = this.animation,
                useHtml = cfg.useHtml, ticks = this.getTickData();

            if(!this.tickLabelsGroup){
                this.tickLabelsGroup = renderer.vgroup().add();
                this.axisGroup.append(this.tickLabelsGroup.renderG);
                this.tickLabels = [];
            }

            var selection = this._bindData(this.tickLabels, ticks, function(d){return d.tickValue}), i, len;

            var currentTickLabels = [];
            for(i = 0, len = selection.exit.length; i < len; i++){
                if(animation){
                    var d = selection.exit[i].datum(), pos = scale(d.tickValue);
                    d3.select(selection.exit[i].rawElement)
                        .transition().duration(TIME).ease(EASE)
                        .style("opacity", 0).attr(axis.isHorizontal() ? 'x' : 'y', pos).remove();
                }else{
                    selection.exit[i] && selection.exit[i].remove();
                }
            }

            for(i = 0, len = selection.enter.length; i < len; i++){
                var d = selection.enter[i];
                var tickLabel = this.tickLabelsGroup.append(
                    renderer.vtext(useHtml)
                        .attr(this._getLabelAttr(lastScale, d))
                        .style({'opacity':0})
                )
                tickLabel.datum(d);
                currentTickLabels.push(tickLabel);
            }

            currentTickLabels = currentTickLabels.concat(selection.update);

            for(i = 0, len = currentTickLabels.length; i < len; i++){
                var tickLabel = currentTickLabels[i], d = tickLabel.datum();
                tickLabel.textContent(d.tickContent).style(labelStyle);

                var transform = this._getLabelAttr(scale, d);

                // html animation is err...
                if(animation && !useHtml){
                    var rotateStr = (d.labelRotation % 360) ?
                        tickLabel.vRotate(d.labelRotation).rotateStr : '';
                    transform.transform += rotateStr;
                    var prop;
                    if (tickLabel.type === 'div') {
                        prop = 'style';
                    } else {
                        prop = 'attr';
                    }
                    d3.select(tickLabel.node()).transition().duration(TIME).ease(EASE)
                        [prop](transform).style({'opacity':1});
                }else{
                    tickLabel.attr(transform).style({'opacity':1});
                    tickLabel.vRotate(d.labelRotation);
                }
            }

            this.tickLabels = currentTickLabels;
        },

        _getLabelAttr:function(scale, d){

            var origin = this._getAxisOriginPoint();
            var det = scale.rangeBand ? scale.rangeBand()/2 : 0;
            var tickLabelPos = scale(d.tickValue) + det;

            var cfg = this.options, isHorizontal = this.isHorizontal();
            var tickLength = cfg.enableTick ? cfg.tickLength : 0, tickPadding = (cfg.tickPadding + tickLength) || 0;
            var labelRotation = d.labelRotation || 0, labelStyle = cfg.labelStyle, useHtml = cfg.useHtml;
            var position = this.getPosition(), sign = (position == Constants.TOP || position == Constants.LEFT) ? -1 : 1;

            var rectDim = d.tickRectDim, labelDim = d.tickDim;

            // 90 degree has no rotation
            // rotation represents in writing-mode;

            var textX = 0, textY = 0, dx = 0, dy = rectDim.height * 0.85, direction,
                rotationRadian = BaseUtils.toRadian(labelRotation), writingMode;

            if (labelRotation === 360) {
                dx = (useHtml || BaseUtils.isMS) ? 0 : rectDim.width * 0.85 / 2;
                dy = 0;
                writingMode = 'tb-rl';
            }

            if (isHorizontal) {

                direction = Math.abs(labelRotation % 90) < 15 ? 0 :
                    labelRotation > 0 ? 1 : -1;

                textY += sign * (labelDim.height - rectDim.height) / 2;
                textX += sign * direction * (labelDim.width - Math.abs(rectDim.height * Math.sin(rotationRadian))) / 2;

                if (position === Constants.TOP) {
                    textY -= rectDim.height;
                }

                textY += sign * tickPadding;

                textX += origin.x + tickLabelPos - rectDim.width / 2;
                textY += origin.y;

            } else {

                direction = Math.abs(labelRotation % 90) > 85 ? 0 :
                    labelRotation > 0 ? 1 : -1;

                textX += sign * (labelDim.width - rectDim.width) / 2;
                textY += sign * direction * (labelDim.height - rectDim.height * Math.cos(rotationRadian)) / 2;

                if (position === Constants.LEFT) {
                    textX -= rectDim.width;
                }

                textX += sign * tickPadding;

                textX += origin.x;
                textY += origin.y + tickLabelPos - rectDim.height / 2;
            }

            var px = useHtml ? 'px' : '';
            var transform = 'translate(' + textX + px + ' ' + textY + px + ')';

            return {
                transform : transform,
                dy: dy,
                dx: dx,
                'writing-mode': writingMode
            }
        },

        _drawAxisTitle: function () {
            var cfg = this.options, title = cfg.title;
            if (!title || !title.text) {
                return;
            }
            var R = this.vanchart.renderer, axisGroup = this.axisGroup;
            var useHtml = title.useHtml, rotation = this.titleRotation, align = this.getTitleAlign(),
                text = title.text, style = title.style;

            var textDim = this.titleDim, rectDim = this.titleRectDim;
            var titleBounds = this.getAxisTitleBounds();

            if (!this.titleGroup) {
                this.titleGroup = R.vgroup().add();
                axisGroup.append(this.titleGroup.renderG);
                this.titleGroup.attr({'transform': BaseUtils.makeTranslate(titleBounds)});
            }
            var titleGroup = this.titleGroup;

            if (!titleGroup.text) {
                titleGroup.text = titleGroup.append(R.vtext(useHtml));
            }

            var x = 0, y = 0, dx = 0, dy = rectDim.height * 0.85;
            switch (align) {
                case Constants.TOP:
                    y = 0;
                    break;
                case Constants.BOTTOM:
                    y = titleBounds.height - textDim.height;
                    break;
                case Constants.LEFT:
                    x = 0;
                    break;
                case Constants.RIGHT:
                    x = titleBounds.width - textDim.width;
                    break;
                case Constants.CENTER:
                default:
                    if (this.isHorizontal()) {
                        x = (titleBounds.width - textDim.width)/2;
                    } else {
                        y = (titleBounds.height - textDim.height) / 2;
                    }
            }

            if (this.titleRotation === 360) {
                dx = (useHtml || BaseUtils.isMS) ? 0 : rectDim.width * 0.85 / 2;
                dy = 0;
            } else {
                x += (textDim.width - rectDim.width) / 2;
                y += (textDim.height - rectDim.height) / 2;
            }

            titleGroup.text
                .textContent(text)
                .attr({
                    x: x,
                    y: y,
                    dy: dy,
                    dx: dx
                }).style(style);

            (rotation % 360) && titleGroup.text.vRotate(rotation);
        },

        remove:function(){
            this.axisGroup && this.axisGroup.remove();
            this.axisGroup = null;

            this.axisLineGroup && this.axisLineGroup.remove();
            this.axisLineGroup = null;

            // remove vgroup
            this.tickLabelsGroup && this.tickLabelsGroup.remove();
            this.tickLabelsGroup = null;
        }
    });

    return BaseAxis;
});
/**
 * Created by eason on 15/5/18.
 * 分类轴的定义
 */
define('component/CategoryAxis',['require','./Base','./BaseAxis','../utils/BaseUtils','../Constants','../ComponentLibrary'],function(require){
    var Base = require('./Base');
    var BaseAxis = require('./BaseAxis');
    var BaseUtils = require('../utils/BaseUtils');
    var Constants = require('../Constants');
    var ComponentLibrary = require('../ComponentLibrary');

    var LABEL_LINE_GAP = 3;
    
    var CategoryAxis = BaseAxis.extend({

        type:ComponentLibrary.CATEGORY_AXIS_COMPONENT,

        initAttributesWithSeries:function(){
            this.scale = d3.scale.ordinal();
            this.updateDomainAndTickData();
        },

        updateDomainAndTickData:function(){
            this.highlightType = 'line';

            var axisOption = this.options, series = this.series, axis = this, stored = {};

            var categories = axisOption.categories || [];

            categories.forEach(function(category){
                stored[category] = true;
            });

            series.forEach(function(sery){
                
                var key = sery.type == Constants.BAR_CHART ? 'y' : 'x';

                for(var i = 0, len = sery.points.length; i < len; i++){

                    var tickLabel = sery.points[i][key];

                    if(!stored[tickLabel]){
                        stored[tickLabel] = true;
                        categories.push(tickLabel);
                    }
                }

                if (sery.type !== Constants.AREA_CHART) {
                    axis.isRangePoints = false;
                }

            }, this);
            
            this.setCategories(categories);
        },

        setCategories:function(newCategories){

            this.categories = newCategories;

            this.scale.domain(newCategories);

            this._updateOriginTickData();
        },

        getLabelAutoRotation: function (labels, axisOption,formatter) {
            if (axisOption.autoRotate &&
                !axisOption.labelRotation) {
                var isInverted = this.vanchart.isInverted();
                var longLabel = labels.reduce(function (a, b) {
                    return BaseUtils.getTextDimension(a).width > BaseUtils.getTextDimension(b).width ? a : b;
                });
                var longContent = this._getTickContent(longLabel, formatter);
                var longDim = BaseUtils.getTextDimensionWithRotation(longContent, axisOption.labelStyle,
                    axisOption.useHtml, axisOption.labelRotation);
                var gap = Math.max.apply(null, this._getRange()) / this.categories.length - LABEL_LINE_GAP;

                var w, h;
                if (isInverted) {
                    w = longDim.height;
                    h = longDim.width;
                } else {
                    w = longDim.width;
                    h = longDim.height;
                }
                var l = Math.sqrt(w * w + h * h);

                if (h > gap) {
                    return -90;
                } else if (w > gap) {
                    var alpha = Math.acos(gap/l);
                    var beta = Math.atan(h/w);
                    var theta = alpha + beta;
                    return -BaseUtils.toDegree(theta);
                }
            }
        },

        getCategoryCount:function(){
            return this.categories.length;
        },

        indexOfLabel:function(label){
            return BaseUtils.indexInArray(this.categories, label);
        },

        getTickLength:function(){

            var domain = this.scale.domain();

            var range = this.scale.rangeExtent();

            var cateLength = Math.abs(range[1] - range[0]);

            if(this.isRangePoints && domain.length <= 1){
                return cateLength;
            }

            return  this.isRangePoints ? cateLength / (domain.length - 1) : this.scale.rangeBand();
        },

        _updateInitRange:function(){
            var start = 0, end = this.categories.length - 1;

            var zoom = this.vanchart.getComponent(ComponentLibrary.ZOOM_COMPONENT);
            if(zoom && zoom.zoomToolEnabled()){
                var zoomTool = zoom.options.zoomTool;

                if(zoomTool.from && BaseUtils.indexInArray(this.categories, zoomTool.from) != -1){
                    start = BaseUtils.indexInArray(this.categories, zoomTool.from);
                }

                if(zoomTool.to && BaseUtils.indexInArray(this.categories, zoomTool.to) != -1){
                    end = BaseUtils.indexInArray(this.categories, zoomTool.to);
                }
            }

            this._updateAxisScale(Math.min(start, end), Math.max(start, end));

            this._calculateTickData();
        },

        _updateAxisScale:function(start, end){
            var domain = this.scale.domain();

            if (start == -1 || end == -1) {
                return;
            }

            var range;

            var tmp = [];

            for (var index = start; index <= end; index++) {
                tmp.push(domain[index]);
            }

            var plotRange = this._getRange();

            var rangeBands;
            if (this.isRangePoints) {
                rangeBands = Math.abs(plotRange[0] - plotRange[1]) / Math.max(tmp.length - 1, 1);
            } else {
                rangeBands = Math.abs(plotRange[0] - plotRange[1]) / tmp.length
            }

            var minValue = Math.min(plotRange[0], plotRange[1]);
            var maxValue = Math.max(plotRange[0], plotRange[1]);
            var t_s = start;
            var t_e = end;
            if (this.isAxisReversed()) {
                var totalCount = this.categories.length - 1;
                t_s = Math.min(totalCount - start, totalCount - end);
                t_e = Math.max(totalCount - start, totalCount - end);
            }

            if (this.isHorizontal()) {
                minValue -= t_s * rangeBands;
                maxValue += (this.categories.length - t_e - 1) * rangeBands;
            } else {
                minValue -= (this.categories.length - t_e - 1) * rangeBands;
                maxValue += t_s * rangeBands;
            }

            range = this._getRangeWithMinMax(minValue, maxValue);

            this.isRangePoints ? this.scale.rangePoints(range) : this.scale.rangeBands(range);

            this._updateIndex(start, end);
        },

        _updateIndex:function(start, end){
            this.startIndex = start;
            this.endIndex = end;
        },

        getValueFromData:function(datum, dIndex){

            var categories = this.componentOption.categories;

            var valueIndex = this.isBaseAxis ? 0 : 1;

            var map = {
                'xAxis': 'x',
                'yAxis': 'y',
                'angleAxis': 'x',
                'radiusAxis': 'y',
                'gaugeAxis': 'y'
            };
            var valueKey = map[this.componentType];

            var cateory = BaseUtils.isArray(datum) ? datum[valueIndex] : datum[valueKey];

            return BaseUtils.hasDefined(cateory) ? cateory : categories[dIndex];
        },

        //考虑tickFormat的作用
        _getTickValues:function(){
            return this.scale.domain();
        },

        getCategories:function(){
            return this.scale.domain();
        },

        axisZoom:function(downPos, upPos){

            var startPos, endPos;

            var plotBounds = this.vanchart.getPlotBounds();

            //坐标轴是横向的
            if(this.isHorizontal()){
                startPos = Math.min(downPos[0], upPos[0]) - plotBounds.x;
                endPos = Math.max(downPos[0], upPos[0]) - plotBounds.x;
            }else{
                startPos = Math.min(downPos[1], upPos[1]) - plotBounds.y;
                endPos = Math.max(downPos[1], upPos[1]) - plotBounds.y;
            }

            var domain = this.scale.domain();
            var range = this.scale.rangeExtent();

            range = this._getRangeWithMinMax(range[0], range[1]);

            var tmpScale = d3.scale.quantize().domain(range).range(domain);

            var start = BaseUtils.indexInArray(this.categories, tmpScale(startPos));
            var end = BaseUtils.indexInArray(this.categories, tmpScale(endPos));

            this.updateAxisScale(Math.min(start, end), Math.max(start, end));
        },

        updateAxisScale:function(start, end){
            this._updateAxisScale(start, end);
            this._updateOriginTickData();
            this._calculateTickData();
            this.lastScale = this.scale.copy();
        },

        _getRangeWithMinMax:function(min, max){
            var reversed = this.isAxisReversed();

            if(this.isHorizontal()){
                return reversed ? [max, min] : [min, max];
            }else{
                return reversed ? [min, max] : [max, min];
            }
        },

        getIndexByPosition: function (pos) {
            return this._getIndexByXYCoordinate(pos);
        },

        _getIndexByXYCoordinate: function (pos) {
            var plotBounds = this.getPlotBounds();
            var scale = this.scale;
            var isHorizontal = this.isHorizontal();
            var isReversed = this.isAxisReversed() ^ !isHorizontal;

            var startX = scale(
                isReversed ?
                    scale.domain()[scale.domain().length - 1] :
                    scale.domain()[0]
            );

            var x;

            if (isHorizontal) {
                x = pos[0] - plotBounds.x - startX;
            } else {
                x = pos[1] - plotBounds.y - startX;
            }

            var index;
            var categories = this.getCategories();
            if (categories.length > 1) {
                var unitLength = Math.abs(scale(scale.domain()[1]) - scale(scale.domain()[0]));
                index = isReversed ? categories.length - 1 - x / unitLength : x / unitLength;
            } else {
                index = 0;
            }

            if (this.getHighlightType() === 'line' && this.isRangePoints) {
                index = Math.round(index);
            } else {
                index = isReversed ? Math.ceil(index) : Math.floor(index);
            }

            return index;
        },

        getPointsInCategory:function(containerPoint){
            var plotBounds = this.vanchart.getPlotBounds();
            var domain = this.scale.domain(), range = this.scale.rangeExtent();
            range = this._getRangeWithMinMax(range[0], range[1]);
            var tmpScale = d3.scale.quantize().domain(range).range(domain);
            var category = tmpScale(this.isHorizontal() ? containerPoint[0] - plotBounds.x : containerPoint[1] - plotBounds.y);
            return this.vanchart.cateMap[category];
        },

        drawHighlightBackground: function (sharedPoints) {
            console.log(sharedPoints);
            var category = sharedPoints[0].category;
            var highlightType = 'line';
            sharedPoints.map(function (point) {
                var series = point.series;
                if (series.type === Constants.BAR_CHART ||
                    series.type === Constants.COLUMN_CHART) {
                    highlightType = 'band';
                }
            });

            var plotBounds = this.getPlotBounds(), isHorizontal = this.isHorizontal();
            var scale = this.scale, rangeBand = scale.rangeBand ? scale.rangeBand() : 0;
            var from = scale(category), to = from + rangeBand, renderer = this.vanchart.renderer;

            var x = 'x', y = 'y', width = 'width', height = 'height', size = plotBounds.height;
            var x1 = 'x1', x2 = 'x2', y1 = 'y1', y2 = 'y2';
            if(!isHorizontal){
                x = 'y'; y = 'x'; width = 'height'; height = 'width'; size = plotBounds.width;
                x1 = 'y1'; x2 = 'y2'; y1 = 'x1'; y2 = 'x2';
            }

            switch (highlightType) {
                case 'band':
                    if(!this.highlightBand){
                        this.highlightBand = renderer.rect().style({
                            'fill': 'rgb(98,179,240)',
                            'fill-opacity':0.2
                        }).addTo(this.axisGroup);
                    }
                    this.highlightBand
                        .attr('transform', BaseUtils.makeTranslate(plotBounds))
                        .attr(x, from).attr(y, 0).attr(width, Math.abs(from - to)).attr(height, size);

                    break;
                case 'line':
                default:

                    if (rangeBand) {
                        from = (from + to) / 2;
                    }

                    if(!this.highlightLine){
                        this.highlightLine = renderer.line().style({
                            'stroke': 'rgb(140,140,140)',
                            'stroke-width':1
                        }).addTo(this.axisGroup);
                    }

                    this.highlightLine
                        .attr('transform', BaseUtils.makeTranslate(plotBounds))
                        .attr(x1, from).attr(y1, 0).attr(x2, from).attr(y2, size);
            }
        },

        removeHighlightBackground:function(){
            this.highlightBand && this.highlightBand.remove();
            this.highlightLine && this.highlightLine.remove();

            this.highlightBand = null;
            this.highlightLine = null;
        }
    });

    ComponentLibrary.register(ComponentLibrary.CATEGORY_AXIS_COMPONENT, CategoryAxis);
    return CategoryAxis;
});
/**
 * Created by eason on 15/5/18.
 * 值轴的定义
 */
define('component/ValueAxis',['require','./Base','./BaseAxis','../utils/BaseUtils','../utils/QueryUtils','../Constants','../ComponentLibrary'],function(require){
    var Base = require('./Base');
    var BaseAxis = require('./BaseAxis');
    var BaseUtils = require('../utils/BaseUtils');
    var QueryUtils = require('../utils/QueryUtils');
    var Constants = require('../Constants');
    var ComponentLibrary = require('../ComponentLibrary');

    var ValueAxis = BaseAxis.extend({

        type:ComponentLibrary.VALUE_AXIS_COMPONENT,

        getAxisValue: function (value, point) {
            return !this._isBaseAxis() && point.series.stackByPercent ? point.percentage : +value;
        },

        initAttributesWithSeries:function(){
            this.scale = this.options.log ? d3.scale.log().base(this.options.log) : d3.scale.linear();
            this.originalDomain = this._initDomainAndTickData();
            this._hasInited = true;
        },

        updateDomainAndTickData:function(){

            if(this.series.length){

                if(!this._isBaseAxis()){

                    this._initDomainAndTickData();

                    this._calculateTickData();
                }
            }
        },

        _initDomainAndTickData:function(){
            //确定是不是byPercent
            var series = this.series;
            this.byPercent = false;

            if(!this._isBaseAxis()) {
                for (var i = 0, len = series.length; i < len && !this.byPercent; i++) {
                    this.byPercent = series[i].stackByPercent;
                }
            }
            
            var minMax = this._calculateMinMaxValue();
            
            var axisOption = this.options;
            var originalDomain = this._calculateNiceDomain(minMax.minValue, minMax.maxValue, axisOption.min, axisOption.max);

            var domain = this._initWithZoom(minMax, originalDomain);

            this.lastScale = this.scale && this.scale.copy();

            this.scale.domain(domain);

            this._updateOriginTickData();

            return originalDomain;
        },

        _initWithZoom:function(minMax, originalDomain){
            var min = originalDomain[0], max = originalDomain[1];
            var zoom = this.vanchart.getComponent(ComponentLibrary.ZOOM_COMPONENT);
            if(zoom && zoom.zoomToolEnabled() && this._isBaseAxis()){
                var revisedDomain = zoom.getRevisedDomain();
                if(revisedDomain.from || revisedDomain.to){
                    min = revisedDomain.from ? parseFloat(revisedDomain.from) : min;
                    max = revisedDomain.to ? parseFloat(revisedDomain.to) : max;
                    this._calculateNiceDomain(minMax.minValue, minMax.maxValue, min, max);
                }
            }

            return [min, max];
        },

        _updateDomainWhenSizeFixed:function(){

            var maxRadius = this.getMaxBubbleRadius();

            if(maxRadius && this.type == ComponentLibrary.VALUE_AXIS_COMPONENT && this._hasInited){

                this._hasInited = false;

                var scale = this.scale;

                var domain = scale.domain();
                var range = scale.range();

                var minMax = this._calculateMinMaxValue();

                var maxRadiusNumber = Math.abs(maxRadius * (domain[0] - domain[1])/(range[1] - range[0]));

                minMax.minValue -= maxRadiusNumber;
                minMax.maxValue += maxRadiusNumber;

                var axisOption = this.options;
                this.originalDomain = this._calculateNiceDomain(minMax.minValue, minMax.maxValue, axisOption.min, axisOption.max);

                this.scale.domain(this._initWithZoom(minMax, this.originalDomain));

                this._updateOriginTickData();
            }
        },

        getMaxBubbleRadius:function(){
            var maxSize = 0;

            this.series.forEach(function(sery){
                if(sery.visible && sery.type == Constants.BUBBLE_CHART){
                    maxSize = Math.max(maxSize, sery.maxSize);
                    maxSize = Math.max(maxSize, sery.minSize);
                }
            });

            return maxSize/2;
        },

        _updateInitRange:function(){
            this.scale.rangeRound(this._getRange());

            //确定长度后调整范围使气泡不被截断
            this._updateDomainWhenSizeFixed();

            this._calculateTickData();
        },

        _calculateNiceDomain:function(minValue, maxValue, fixedMin, fixedMax){
            var axisOption = this.options;
            if(axisOption.log){
                return this._calculateLogNiceDomain(minValue, maxValue);
            }else if(this.byPercent){
                return this._calculatePercentValueDomain();
            }else{
                return this._calculateValueNiceDomain(minValue, maxValue, fixedMin, fixedMax);
            }
        },

        _calculateLogNiceDomain:function(minValue, maxValue, ignoreMinMax){
            var axisOption = this.options, logBase = axisOption.log;

            var tickInterval = parseInt(BaseUtils.pick(axisOption.tickInterval, 1));

            this.valueList = [];

            minValue = minValue >= 1 ? 1 : minValue;
            minValue = minValue <= 0 ? 1 : minValue;

            minValue = ignoreMinMax ? minValue : BaseUtils.pick(axisOption.min, minValue);
            maxValue = ignoreMinMax ? maxValue : BaseUtils.pick(axisOption.max, maxValue);

            minValue = Math.pow(logBase, Math.floor(BaseUtils.log(logBase, minValue)));
            maxValue = Math.pow(logBase, Math.ceil(BaseUtils.log(logBase, maxValue)));

            var i = 0;
            while(minValue * Math.pow(logBase, i) <= maxValue){
                this.valueList.push(minValue * Math.pow(logBase, i));
                i += tickInterval;
            }

            return [minValue, maxValue];
        },

        _calculatePercentValueDomain:function(){
            var axisOption = this.options, min = BaseUtils.pick(axisOption.min, 0), max = BaseUtils.pick(axisOption.max, 1);
            var interval = BaseUtils.pick(axisOption.tickInterval, 0.25);

            this.valueList = [];

            for(var start = min; start <= max; start = BaseUtils.accAdd(start, interval)){
                this.valueList.push(start);
            }

            return [min, max];
        },

        //从数据中计算最大最小值
        _calculateMinMaxValue:function(){

            var minValue = Number.MAX_VALUE,maxValue = -minValue, emptyData = true;
            var series = this.series, dataMap = {};

            for(var i = 0, len = series.length; i < len; i++){
                if(series[i].visible){
                    this._getSeriesValue(dataMap, series[i]);
                }
            }

            for(var key in dataMap){
                var data = dataMap[key];
                for(var j = 0, dataCount = data.length; j < dataCount; j++){
                    if(!isNaN(data[j]) && !(this.options.log && data[j] <= 0)){
                        minValue = Math.min(minValue, data[j]);
                        maxValue = Math.max(maxValue, data[j]);
                        emptyData = false;
                    }
                }
            }

            if(emptyData){
                minValue = 0;
                maxValue = 100;
            }

            return {
                minValue:minValue,
                maxValue:maxValue
            };
        },

        //获取系列的值，如果是堆积的话获取系列的和
        _getSeriesValue:function(dataMap, sery){

            var seriesName = sery.name || '';

            var key = this.componentType == ComponentLibrary.X_AXIS_COMPONENT ? 'x' : 'y';

            if(BaseUtils.hasNotDefined(sery.stack) || this._isBaseAxis()){
                dataMap[seriesName] = dataMap[seriesName] || [];

                sery.points.forEach(function(point){
                    if(!point.isNull && point.visible) {
                        dataMap[seriesName].push(point[key]);
                    }
                });

            }else{
                var PK = sery.stack + sery.type + 'STACK_POSITIVE';
                var NK = sery.stack + sery.type + 'STACK_NEGATIVE';
                dataMap[PK] = dataMap[PK] || [];
                dataMap[NK] = dataMap[NK] || [];

                sery.points.forEach(function(point, i){
                    if(!point.isNull && point.visible){
                        var value = parseInt(point[key]);
                        if(value > 0){
                            if(dataMap[PK][i] != null && dataMap[PK][i] != undefined){
                                dataMap[PK][i] += value;
                            }else{
                                dataMap[PK][i] = value;
                            }
                        }else{
                            if(dataMap[NK][i] != null && dataMap[NK][i] != undefined){
                                dataMap[NK][i] += value;
                            }else{
                                dataMap[NK][i] = value;
                            }
                        }
                    }

                });
            }
        },

        //'-'符号表示空值
        getValueFromData:function(datum){
            var valueIndex = this.componentType == ComponentLibrary.X_AXIS_COMPONENT ? 0 : 1;
            var valueKey = this.componentType == ComponentLibrary.X_AXIS_COMPONENT ? 'x' : 'y';

            var value = BaseUtils.isArray(datum) ? datum[valueIndex] : datum[valueKey];

            value = BaseUtils.pick(value, datum);

            value = +value;
            return isNaN(value) ? '-' : value;
        },

        //考虑有正负值的时候的0值对齐的功能
        getStartPos:function(){
            return this.scale(this.getStartPosValue());
        },

        getStartPosValue:function(){

            var axisOption = this.options;

            return axisOption.log && axisOption.log != 1 ? Number.MIN_VALUE : 0;
        },

        getOriginalDomain: function () {
            return this.originalDomain;
        },

        //考虑tickFormat的作用
        _getTickValues:function(){
            return this.valueList;
        },

        _getTickValuesWithEndValue:function(){

            var result = BaseUtils.clone(this.valueList);

            var max = this.scale.domain()[1];

            if(result.length && result[result.length - 1] < max){
                result.push(max);
            }

            return result;
        },

        axisZoom:function(downPos, upPos){

            var startPos, endPos;

            var plotBounds = this.vanchart.getPlotBounds();

            //坐标轴是横向的
            if(this.isHorizontal()){
                startPos = Math.min(downPos[0], upPos[0]) - plotBounds.x;
                endPos = Math.max(downPos[0], upPos[0]) - plotBounds.x;

                startPos = Math.max(startPos, 0);
                endPos = Math.min(endPos, plotBounds.width);
            }else{
                startPos = Math.min(downPos[1], upPos[1]) - plotBounds.y;
                endPos = Math.max(downPos[1], upPos[1]) - plotBounds.y;

                startPos = Math.max(startPos, 0);
                endPos = Math.min(endPos, plotBounds.height);
            }

            var startValue = this.scale.invert(startPos);
            var endValue = this.scale.invert(endPos);

            this.updateAxisScale(Math.min(startValue, endValue), Math.max(startValue, endValue));
        },
        
        updateAxisScale:function(min, max){
            
            //值轴为底轴的时候,固定最大最小值才有效
            var domain = this._calculateNiceDomain(min, max, min, max);

            this.scale.domain(domain);

            this._updateOriginTickData();

            this._calculateTickData();
        }
    });

    ComponentLibrary.register(ComponentLibrary.VALUE_AXIS_COMPONENT, ValueAxis);
    return ValueAxis;
});
/**
 * Created by eason on 15/11/2.
 */
define('component/DateAxis',['require','./Base','./BaseAxis','../utils/BaseUtils','../Constants','../utils/Formatter','../ComponentLibrary'],function(require){

    var Base = require('./Base');
    var BaseAxis = require('./BaseAxis');
    var BaseUtils = require('../utils/BaseUtils');
    var Constants = require('../Constants');
    var Formatter = require('../utils/Formatter');
    var ComponentLibrary = require('../ComponentLibrary');
    var TICK_COUNT = 5;

    var DAY = 1000 * 60 * 60 * 24;
    var MONTH = DAY * 31;
    var YEAR = 365 * MONTH;

    var DateAxis = BaseAxis.extend({

        type:ComponentLibrary.DATE_AXIS_COMPONENT,

        getAxisValue: function (value, point) {
            return BaseUtils.object2date(value);
        },

        initAttributesWithSeries:function(){
            this.scale = d3.time.scale();
            this._initDomainAndTickData();
            this.originalDomain = this.scale.domain();
        },

        updateDomainAndTickData:function(){

            if(this.series.length){

                this._initDomainAndTickData();

                this._calculateTickData();
            }
        },

        _initDomainAndTickData:function(){

            var minMax = this._calculateMinMaxValue();

            var min = minMax.minValue;
            var max = minMax.maxValue;

            var cfg = this.options;

            var domain = this._calculateValueNiceDomain(min, max, cfg.min, cfg.max);

            min = BaseUtils.int2date(domain[0]);

            max = BaseUtils.int2date(domain[1]);

            this.lastScale = this.scale && this.scale.copy();

            this.scale = this.scale ?
                this.scale.domain([min, max]) : d3.time.scale().domain([min, max]);

            this._calculateDateFormat();

            this._updateOriginTickData();
        },

        getOriginalDomain: function () {
            return this.originalDomain;
        },

        _calculateDateFormat:function(){
            var tickInterval = this._getTickInterval();

            var format = 'Dyyyy-MM-dd';

            if(tickInterval < DAY){
                format = 'Dyyyy-M-d H:mm'
            }else if(tickInterval < MONTH){
                format = 'Dyyyy-M-d'
            }else{
                format = 'Dyyyy-MM'
            }

            this.dateFormat = format;
        },

        _getTickContent:function(tick, formatter){

            if(!formatter || formatter == "function(){return arguments[0]}"){
                //todo 换成d3的格式
                var tmpFormat = this.dateFormat;
                formatter = function(){return window.FR ? FR.contentFormat(arguments[0], tmpFormat) : arguments[0]}
            }

            return Formatter.format(tick, formatter)
        },

        _getTickValues:function(){
            var result = [];
            this.valueList.forEach(function(date){
                result.push(BaseUtils.int2date(date));
            });

            return result;
        },

        _calculateMinMaxValue:function(){

            var minValue = Math.ceil(Number.MAX_VALUE);
            var maxValue = -minValue;

            var series = this.series;
            var hasData = false;

            for(var i = 0, len = series.length; i < len; i++){
                var sery = series[i];
                var byAxis = sery[this.componentType];
                if(byAxis == this && sery.visible){
                    var data = sery.points;
                    for(var i = 0,len = data.length; i < len; i++){
                        var value = this.getValueFromData(data[i]);

                        if(value.getTime){
                            hasData = true;
                            value = BaseUtils.date2int(value);
                            minValue = Math.min(minValue, value);
                            maxValue = Math.max(maxValue, value);
                        }

                    }
                }
            }

            if(!hasData){
                minValue = maxValue = (new Date()).getTime();
            }

            maxValue = minValue >= maxValue ? minValue + 1000 : maxValue;

            return {
                minValue:minValue,
                maxValue:maxValue
            };
        },

        getValueFromData:function(datum){
            var valueIndex = this.componentType == ComponentLibrary.X_AXIS_COMPONENT ? 0 : 1;
            var valueKey = this.componentType == ComponentLibrary.X_AXIS_COMPONENT ? 'x' : 'y';

            var value = BaseUtils.isArray(datum) ? datum[valueIndex] : datum[valueKey];

            return BaseUtils.object2date(value);
        },

        axisZoom:function(downPos, upPos){

            var startPos, endPos;

            var plotBounds = this.vanchart.getPlotBounds();

            //坐标轴是横向的
            if(this.isHorizontal()){
                startPos = Math.min(downPos[0], upPos[0]) - plotBounds.x;
                endPos = Math.max(downPos[0], upPos[0]) - plotBounds.x;
            }else{
                startPos = Math.min(downPos[1], upPos[1]) - plotBounds.y;
                endPos = Math.max(downPos[1], upPos[1]) - plotBounds.y;
            }

            var startValue = this.scale.invert(startPos);
            var endValue = this.scale.invert(endPos);

            startValue = BaseUtils.date2int(startValue);
            endValue = BaseUtils.date2int(endValue);

            var min = Math.min(startValue, endValue);
            var max = Math.max(startValue, endValue);

            this._updateDomain(min, max, true);
        },

        //min, max是毫秒数
        _updateDomain:function(min, max){

            var domain = this._calculateValueNiceDomain(min, max, min, max);

            var minValue = BaseUtils.int2date(domain[0]);

            var maxValue = BaseUtils.int2date(domain[1]);

            this.scale = this.scale ?
                this.scale.domain([minValue, maxValue]) : d3.time.scale().domain([minValue, maxValue]);

            this._calculateDateFormat();

            this._updateOriginTickData();
        },

        updateAxisScale:function(minValue, maxValue){

            minValue = BaseUtils.date2int(minValue);

            maxValue = BaseUtils.date2int(maxValue);

            this.options.min = minValue;
            this.options.max = maxValue;

            this._updateDomain(minValue, maxValue);
        }

        // _initZoomStatus:function(){
        //     var zoom = this.vanchart.getComponent(ZOOM_COMPONENT.ZOOM_COMPONENT);
        //     if(zoom && zoom.zoomToolEnabled() && BaseUtils.isSupportSVG() && this.isBaseAxis){
        //         if(this.vanchart.isInitOrRestoreState()){
        //
        //             var revisedDomain = zoom.getRevisedDomain();
        //
        //             var domain = this.scale.domain();
        //
        //             var from = BaseUtils.date2int(domain[0]);
        //
        //             var to = BaseUtils.date2int(domain[1]);
        //
        //             if(revisedDomain.from){
        //                 from = BaseUtils.object2date(revisedDomain.from);
        //                 from = BaseUtils.date2int(from);
        //             }
        //
        //             if(revisedDomain.to){
        //                 to = BaseUtils.object2date(revisedDomain.to);
        //                 to = BaseUtils.date2int(to);
        //             }
        //
        //             this._updateDomain(from, to);
        //         }
        //
        //     }
        // }
    });

    ComponentLibrary.register(ComponentLibrary.DATE_AXIS_COMPONENT, DateAxis);
    return DateAxis;

});
/**
 * Created by eason on 15/5/15.
 * 坐标轴组建的定义
 */
define('component/Axis',['require','./Base','../utils/BaseUtils','../Constants','../ComponentLibrary','./CategoryAxis','./ValueAxis','./DateAxis'],function(require){

    var Base = require('./Base');
    var BaseUtils = require('../utils/BaseUtils');
    var Constants = require('../Constants');
    var ComponentLibrary = require('../ComponentLibrary');

    var CategoryAxis = require('./CategoryAxis');
    var ValueAxis = require('./ValueAxis');
    var DateAxis = require('./DateAxis');
    
    var Axis = Base.extend({

        _refresh:function(){
            this._axisList = this._axisList || [];

            var options = this.options;

            options = BaseUtils.isArray(options) ? options : [options];

            //最终生成的坐标轴数应该和新的option一样
            var len = options.length;

            for(var axisIndex = len; axisIndex < this._axisList.length; axisIndex++){
                this._axisList[axisIndex].remove();
                this._axisList[axisIndex] = null;
            }

            this._axisList.length = len;

            for(var axisIndex = len - 1; axisIndex >= 0; axisIndex--){

                //增加一个坐标轴序号的标记
                options[axisIndex].axisIndex = axisIndex;

                if(this._axisList[axisIndex] && this._axisList[axisIndex].type != options[axisIndex].type){
                    this._axisList[axisIndex].remove();
                    this._axisList[axisIndex] = null;
                }

                if(this._axisList[axisIndex]){
                    this._axisList[axisIndex].refresh(options[axisIndex]);
                }else{
                    var AxisClass;

                    var axisType = options[axisIndex].type || ComponentLibrary.VALUE_AXIS_COMPONENT;

                    if (axisType == ComponentLibrary.VALUE_AXIS_COMPONENT) {
                        AxisClass = ValueAxis;
                    } else if (axisType == ComponentLibrary.CATEGORY_AXIS_COMPONENT) {
                        AxisClass = CategoryAxis;
                    } else if (axisType == ComponentLibrary.DATE_AXIS_COMPONENT) {
                        AxisClass = DateAxis;
                    }

                    this._axisList[axisIndex] = new AxisClass(options[axisIndex], this.componentType, this.vanchart);
                }
            }
        },

        doLayout:function(){
            var axisCount = this._axisList.length;
            var clipBounds = {};
            for(var i = axisCount - 1; i >= 0; i--){
                this._axisList[i].doLayout();
                this._axisList[i].updateClipBounds(clipBounds);
            }

            this._clipPlotBounds(Constants.LEFT, clipBounds[Constants.LEFT] || 0);
            this._clipPlotBounds(Constants.RIGHT, clipBounds[Constants.RIGHT] || 0);
            this._clipPlotBounds(Constants.TOP, clipBounds[Constants.TOP] || 0);
            this._clipPlotBounds(Constants.BOTTOM, clipBounds[Constants.BOTTOM] || 0);
        },

        initAttributesWithSeries:function(){
            var axisCount = this._axisList.length;
            for(var i = axisCount - 1; i >= 0; i--){
                this._axisList[i].initAttributesWithSeries();
            }
        },

        fixBoundsByPlot:function(){

            var plotBounds = this.vanchart.getPlotBounds();

            var map = {};

            for(var i = 0, axisCount = this._axisList.length; i < axisCount; i++){

                var axis = this._axisList[i];

                var position = axis.getPosition();

                map[position] = map[position] || [];

                map[position].push(axis);
            }

            for(var position in map){

                var axisList = map[position];
                var isHorizontal = position == Constants.TOP || position == Constants.BOTTOM;

                for(var i = 0, count = axisList.length; i < count; i++){

                    var axis = axisList[i];

                    var baseBounds = plotBounds;
                    if (i > 0 && !axisList[i-1].isOnZero() ) {
                        baseBounds = axisList[i - 1].bounds;
                    }

                    var axisBounds = axis.bounds;

                    if(isHorizontal){

                        var y = position == Constants.TOP ? baseBounds.y - axisBounds.height : baseBounds.y + baseBounds.height;
                        axis.bounds = BaseUtils.makeBounds(baseBounds.x, y, baseBounds.width, axisBounds.height);

                    }else{

                        var x = position == Constants.LEFT ? baseBounds.x - axisBounds.width : baseBounds.x + baseBounds.width;
                        axis.bounds = BaseUtils.makeBounds(x, baseBounds.y, axisBounds.width, baseBounds.height);
                    }

                    axis._updateInitRange();
                }
            }
        },

        getMaxDomainAxis: function () {
            if (this._axisList.length === 1) {
                return this._axisList[0];
            }
            return this._axisList.reduce(function (a, b) {
                return scope(a) > scope(b) ? a : b;
            });
            function scope(axis) {
                return Math.abs(axis.originalDomain[1] - axis.originalDomain[0]);
            }
        },

        getAxis:function(axisIndex){
            if (axisIndex >= this._axisList.length) {
                axisIndex = 0;
            }
            return this._axisList[axisIndex];
        },

        getAxisCount:function(){
            return this._axisList.length;
        },

        axisZoom:function(downPos, upPos){
            this._axisList.forEach(function(axis){
                axis.axisZoom(downPos, upPos);
            });
        },

        refreshRestore: function () {
            this._axisList.forEach(function(axis){
                axis.refreshRestore && axis.refreshRestore();
            });
        },

        //处理0值对齐
        dealOnZero:function(){
            this._axisList.forEach(function(axis){

                if(axis.isOnZero()){

                    axis.dealOnZero();

                    axis._updateInitRange();
                }
            });
        },

        render:function(){
            for(var i = 0, len = this._axisList.length; i < len; i++){
                this._axisList[i].render();
            }
        },

        renderSpecial: function () {
            for(var i = 0, len = this._axisList.length; i < len; i++){
                this._axisList[i].renderSpecial && this._axisList[i].renderSpecial();
            }
        }
    });
    
    ComponentLibrary.register(ComponentLibrary.X_AXIS_COMPONENT, Axis);
    ComponentLibrary.register(ComponentLibrary.Y_AXIS_COMPONENT, Axis);

    return Axis;
});
/**
 * Created by eason on 15/5/15.
 * 仪表盘坐标轴属性的定义
 */
define('component/GaugeAxis',['require','../Constants','./Axis','../ComponentLibrary'],function(require){
    var Constants = require('../Constants');
    var Axis = require('./Axis');
    var ComponentLibrary = require('../ComponentLibrary');

    var GaugeAxis = Axis.extend({

        doLayout:function(){
            var axisCount = this._axisList.length;
            for(var i = axisCount - 1; i >= 0; i--){
                this._axisList[i].initAttributesWithSeries();
                this._axisList[i]._updateLabelContent();
                this._axisList[i]._updateMainAndMinorTickData();
            }
        },

        render:function(){

        },

        renderSpecial: function () {

        }
    });

    ComponentLibrary.register(ComponentLibrary.GAUGE_AXIS_COMPONENT, GaugeAxis);

    return GaugeAxis;
});
/**
 * Created by eason on 16/8/1.
 */

define('component/LegendItem',['require','../dom/Evented','../Constants','../utils/BaseUtils','./LegendIconFactory'],function(require){

    var Evented = require('../dom/Evented');
    var Constants = require('../Constants');
    var BaseUtils = require('../utils/BaseUtils');
    var LegendIconFactory = require('./LegendIconFactory');

    var PADDING = 10;
    var GAP = 8;

    var LegendItem = Evented.extend({

        initialize:function(legend, options){
            this.legendX = 0; this.legendY = 0;
            this.legend = legend;
            this.refresh(options);
        },

        refresh:function(options){
            this.options = options;
        },

        render:function(){
            var legend = this.legend, vanchart = legend.vanchart, renderer = vanchart.renderer;
            var textStyle = legend.options.style;

            this.graphic = this.graphic || renderer.group().style({'cursor': 'pointer'}).addTo(legend.legendItemsGroup);

            renderer.registerInteractiveTarget(this, this.graphic);

            var g = this.graphic, d = this.options;
            var markerColor = d.visible ? d.color : d.hiddenColor;
            var iconSize = LegendIconFactory.getLegendIconSize(d.legendIconType);
            var labelDim = BaseUtils.getTextDimension(d.itemName, textStyle, true);
            var itemHeight = Math.max(iconSize.height, labelDim.height);

            this.graphic.attr({'transform':BaseUtils.makeTranslate([this.legendX, this.legendY + itemHeight/2])});

            if(LegendIconFactory.hasIcon(d.legendIconType)){
                g.path = g.path || renderer.path().addTo(g);
                g.path.attr('d', LegendIconFactory.getLegendIconPath(d.legendIconType))
                    .attr('transform', BaseUtils.makeTranslate([0, -iconSize.height/2]))
                    .style({
                        'fill':markerColor, 'fill-opacity': d.opacity
                    });
                if(d.series.type == Constants.BUBBLE_CHART){
                    g.path.style('stroke', markerColor).style('stroke-width',1);
                }
            }else{
                g.image = g.image || renderer.image().addTo(g);
                g.image.attr('transform', BaseUtils.makeTranslate([0, -iconSize.height/2]))
                    .attr('preserveAspectRatio', 'none').attr('href', d.legendIconType)
                    .attr('width', 12).attr('height', 12);
            }

            g.text = g.text || g.append(renderer.vtext());
            g.text.textContent(d.itemName)
                .attr('margin-top', '-0.22em') // only apply to div
                .attr('dy', '.32em')
                .attr('x', iconSize.width + GAP).attr('y', 0)
                .style({'cursor': 'pointer', 'white-space':'nowrap'})
                .style(BaseUtils.extend(textStyle, {fill:d.visible ? textStyle.color : d.hiddenColor}));
        },

        getEvents:function(){
            return {
                'mouseover':this.onMouseOver,

                'mouseout':this.onMouseOut,

                'tap':this.onTap
            }
        },

        //for the onXXX functions, this points to the legendItem
        onMouseOver:function(){
            this.graphic && this.graphic.text && this.graphic.text.style({'fill': this.options.hoverColor});
        },

        onMouseOut:function(){
            var item = this, legend = item.legend, d = item.options;
            var textColor = d.visible ? legend.options.style.color : d.hiddenColor;
            this.graphic && this.graphic.text && this.graphic.text.style({'fill': textColor});
        },

        onTap:function(){

            var name = this.options.itemName, vanchart = this.legend.vanchart, series = vanchart.series;

            for(var chartType in series){
                var chartSeries = series[chartType];

                for(var i = 0, len = chartSeries.length; i < len; i++){
                    var sery = chartSeries[i];

                    if(vanchart.isSeriesAccumulated(chartType)){
                        var key = sery.type == Constants.PIE_CHART ? 'seriesName': 'name';
                        sery.points.map(function(point){
                            if(point[key] == name){
                                point.visible = !point.visible;
                            }
                        });
                    }else if (sery.name === name){
                        sery.visible = !sery.visible;
                        sery.state = sery.visible ? Constants.STATE_TO_SHOW : Constants.STATE_TO_DROP;

                        sery._getAxisTypes().forEach(function(type){
                            var axis = sery[type];
                            if(axis){
                                axis.updateDomainAndTickData();
                                axis.render();
                            }
                        })
                    }
                }
            }

            this.options.visible = !this.options.visible;

            this.render();
            vanchart.reRenderSeries();
        },

        remove: function () {
            this.graphic && this.graphic.remove();
            this.graphic = null;
        }
    });


    return LegendItem;
});
/**
 * Created by eason on 15/5/4.
 * 图例
 */
define('component/Legend',['require','./Base','../utils/BaseUtils','../Constants','./LegendIconFactory','./LegendItem','../dom/Evented','../utils/BezierEasing','../ComponentLibrary'],function(require){
    var Base = require('./Base');
    var BaseUtils = require('../utils/BaseUtils');
    var Constants = require('../Constants');
    var LegendIconFactory = require('./LegendIconFactory');
    var LegendItem = require('./LegendItem');
    var Evented = require('../dom/Evented');
    var BezierEasing = require('../utils/BezierEasing');
    var ComponentLibrary = require('../ComponentLibrary');

    var PADDING = 10;
    var GAP = 8;

    var BUTTON_HEIGHT = 12;
    var BUTTON_WIDTH = 52;
    var LINE_GAP = 4;
    var HORIZONTAL_GAP = 16;

    var ENABLED_COLOR = 'rgb(67,67,72)';
    var DISABLED_COLOR = 'rgb(204,204,204)';

    var Legend = Base.extend({

        doLayout:function(){

            if(this.invisible()){
                this.remove();
                return ;
            }

            this.items = this.items || [];

            this.yPanEnabled = false;
            this.xPanEnabled = false;
            this.hasPages = false;

            this._updateLegendItems();
            this._layoutLegendItemBounds();
        },

        _updateLegendItems:function(){
            var series = this.vanchart.series, namedSeries = {}, legend = this, vanchart = this.vanchart;
            var legendItemOptions = [], i, len;

            vanchart.seriesOrder.forEach(function (chartType) {
                if(chartType == Constants.GAUGE_CHART){
                    return;
                }
                var chartSeries = series[chartType];
                for(i = 0, len = chartSeries.length; i < len; i++){
                    var sery = chartSeries[i];
                    if(vanchart.isSeriesAccumulated(chartType)){
                        var key = chartType === Constants.PIE_CHART ? 'seriesName' : 'name';
                        chartSeries[i].points.map(function (point) {
                            if(!(namedSeries[point[key]])){
                                var item = {color:point.color, opacity: point.opacity, itemName:point[key], visible:point.visible};
                                legend._mergeCommonLegendAttr(sery, item);
                                namedSeries[point[key]] = true;
                                legendItemOptions.push(item);
                            }
                        });

                    }else{
                        if(!(namedSeries[sery.name])) {
                            var item = {color: sery.color, opacity: sery.opacity, itemName: sery.name, visible: sery.visible};

                            legend._mergeCommonLegendAttr(sery, item);

                            namedSeries[sery.name] = true;

                            legendItemOptions.push(item);
                        }
                    }
                }
            });

            for(i = legendItemOptions.length, len = this.items.length; i < len; i++){
                this.items[i].remove();
                this.items[i] = null;
            }

            for(i = 0, len = legendItemOptions.length; i < len; i++){
                if(this.items[i]){
                    this.items[i].refresh(legendItemOptions[i]);
                }else{
                    this.items[i] = new LegendItem(legend, legendItemOptions[i]);
                }
            }

            this.items.length = legendItemOptions.length;
        },

        _mergeCommonLegendAttr:function(sery, item){
            var cfg = this.options;
            var hiddenColor = cfg.hiddenColor;
            var hoverColor = cfg.hoverColor || cfg.style.color;

            BaseUtils.extend(item, {
                series:sery,
                hiddenColor:hiddenColor,
                hoverColor:hoverColor,
                legendIconType:this._getLegendType(sery),
                lineIndex:0//记录下如果换行的行号
            });
        },

        _layoutLegendItemBounds:function(){

            //这边的padding是整个图例和别的组件的间隙
            var cfg = this.options, position = cfg.position || Constants.RIGHT;

            if(position == Constants.TOP || position == Constants.BOTTOM){

                var dim = this._layoutHorizontalLegendItemBounds();

                var legendSize = dim.height + PADDING * 2;

                var maxHeight = this._maxHeight();

                this.yPanEnabled = cfg.maxHeight && (legendSize > maxHeight);
                this.maxYPan = -dim.height + 20;//20px让客户看到最后一个legend

                maxHeight = this.yPanEnabled ? maxHeight : legendSize;

                this._setComponentBounds(position, maxHeight);

                var x = this.bounds.x + PADDING;
                var y = this.bounds.y + PADDING;
                var height = this.bounds.height - PADDING * 2;
                var width = this.bounds.width - PADDING * 2;
                var usedWidth = dim.width - PADDING * 2;
                x += (width - usedWidth) / 2;
                this.bounds = {x:x, y:y, width:usedWidth, height:height};

            }else{

                //考虑不和工具栏重叠
                var toolbarHeight = 0;
                if(position == Constants.RIGHT || position == Constants.RIGHT_TOP){
                    var tools = this.vanchart.getComponent(ComponentLibrary.TOOLBAR_COMPONENT);
                    tools && (toolbarHeight = 37);
                }

                var dim = this._layoutVerticalLegendItemBounds();

                var legendSize = dim.width + PADDING * 2, maxWidth = this._maxWidth();

                var height = this.vanchart.getPlotBounds().height - PADDING * 2 - toolbarHeight;//可用的高度

                //todo 这里有种期限的情况,比如256, 255,理论上算的话应该有翻页,但是因为太小了基本看不出来
                this.hasPages = (dim.height - LINE_GAP) > height;

                if(this.hasPages){
                    legendSize = Math.max(legendSize, BUTTON_WIDTH + 4 * PADDING);

                    height -= (BUTTON_HEIGHT + PADDING);//可见部分不应该包括按钮的高度

                    var totalHeight = dim.height - 2 * PADDING;

                    this.pageCount = Math.ceil(totalHeight / height);

                    this.pageIndex = 0;

                    this.translateMap = [0];//第几页到平移多少应该都是确定的

                    var lastStartY = 0;
                    for(var itemIndex = 0, itemCount = this.items.length; itemIndex < itemCount; itemIndex++){
                        var startY = this.items[itemIndex].legendY;
                        if(startY - lastStartY > height){
                            lastStartY = startY - LINE_GAP;
                            this.translateMap.push(-startY);
                        }
                    }
                }

                this.yPanEnabled = this.hasPages;
                this.xPanEnabled = cfg.maxWidth && (legendSize > maxWidth);
                this.maxYPan = -dim.height + 20;//20px让客户看到最后一个legend
                this.maxXPan = maxWidth - legendSize;

                legendSize = this.xPanEnabled ? maxWidth : legendSize;

                this._setComponentBounds(position, legendSize);

                var x = this.bounds.x + PADDING, y = this.bounds.y + PADDING;
                var width = this.bounds.width - PADDING * 2, height = this.bounds.height - PADDING * 2 - toolbarHeight;

                //居中
                var usedHeight = Math.min(dim.height, height);

                y = Math.max(toolbarHeight, y);

                if (!this.isFloat && position != Constants.RIGHT_TOP) {
                    y += Math.round((height - usedHeight) / 2);
                }

                this.bounds = {x:x, y:y, width:width, height:usedHeight};
            }
        },

        _layoutVerticalLegendItemBounds:function(){

            var maxWidth = 0, legendY = PADDING;

            for(var i = 0, len = this.items.length; i < len; i++){
                var item = this.items[i], options = item.options;
                var labelDim = BaseUtils.getTextDimension(options.itemName, this.options.style, true);
                var iconDim = LegendIconFactory.getLegendIconSize(this.items[i].legendIconType);
                maxWidth = Math.max(labelDim.width + iconDim.width, maxWidth);

                item.legendX = PADDING; item.legendY = legendY;

                legendY += (Math.max(labelDim.height, iconDim.height) + LINE_GAP);
            }

            return {width:PADDING * 2 + maxWidth, height:legendY + PADDING - LINE_GAP};
        },

        _layoutHorizontalLegendItemBounds:function(){

            var plotBonds = this.vanchart.getPlotBounds();
            var offeredWidth = plotBonds.width - 4 * PADDING;

            var usedWidth = PADDING, legendY = PADDING, maxWidth = usedWidth;
            //当前行的items
            var allLinesInfo = [];
            var currentLineItems = [];

            for(var i = 0, len = this.items.length; i < len; i++){

                var item = this.items[i], options = item.options;

                var iconSize = LegendIconFactory.getLegendIconSize(options.legendIconType);
                var labelDim = BaseUtils.getTextDimension(options.itemName, this.options.style, true);

                //限制每个图例的最大宽度不会超过整个图例区域的宽度
                var itemWidth = Math.min(iconSize.width + GAP + labelDim.width, offeredWidth - 1);

                if(usedWidth + itemWidth < offeredWidth){
                    item.legendX = usedWidth; item.legendY = legendY;
                } else {
                    allLinesInfo.push({items:currentLineItems, usedWidth: usedWidth});

                    usedWidth = PADDING;
                    legendY += Math.max(labelDim.height, iconSize.height);
                    item.legendX = usedWidth; item.legendY = legendY;

                    currentLineItems = [];
                }

                currentLineItems.push(item);

                usedWidth += (itemWidth + HORIZONTAL_GAP);
                maxWidth = Math.max(usedWidth, maxWidth);
            }

            allLinesInfo.push({items:currentLineItems, usedWidth: usedWidth});

            allLinesInfo.forEach(function (currentLine) {
                var width = currentLine.usedWidth, items = currentLine.items;
                var off = Math.max((maxWidth - width)/2, 0);
                items.forEach(function (item) {item.legendX += off;});
            });

            legendY += (labelDim ? labelDim.height : 0);

            return  {width:maxWidth + PADDING, height:legendY + PADDING};
        },

        render:function(){

            if(this.invisible()){
                return ;
            }

            var bounds = this.bounds, legend = this, vanchart = legend.vanchart, renderer = vanchart.renderer;

            if(!this.legendGroup){
                this.legendGroup = renderer.group().add();
                this.backgroundGroup = renderer.group().addTo(this.legendGroup);
                this.clipGroup = renderer.group().addTo(this.legendGroup);
                this.legendItemsGroup = renderer.group().addTo(this.clipGroup);

                //todo 没有精力再去整体改写leaflet的源码了,要组合两者只能这么用
                if(this.vanchart._leaflet){
                    this.legendGroup.style('pointer-events', 'all');
                }

                renderer.registerInteractiveTarget(this, this.legendGroup);
            }

            this.legendGroup.attr('transform', BaseUtils.makeTranslate(bounds));

            vanchart._renderRectangleBackground(this.backgroundGroup, this.options, BaseUtils.makeBounds(0,0,bounds.width, bounds.height));

            for(var i = 0, len = this.items.length; i < len; i++){
                this.items[i].render();
            }

            var clip = {x:0, y:0, width:bounds.width, height:bounds.height};
            if(this.hasPages){
                clip.height -= BUTTON_HEIGHT;
                this.pageButton = this.pageButton || new PageButton(legend);
                this.pageButton.refresh();
            }

            //clip的显示区域
            if(!this.verticalClip){
                this.verticalClip = renderer.createClip(clip);
                renderer.clip(this.clipGroup, this.verticalClip);
            }
            // vml err
            this.verticalClip.rect && this.verticalClip.rect.attr(clip);
        },

        getEvents:function(){
            return {
                'panstart':this.onPanStart,
                'panmove':this.onPanMove,
                'panend':this.onPanEnd
            }
        },

        onPanStart:function(ev){
            this.initPos = ev.containerPoint;
            var translate = d3.transform(d3.select(this.legendItemsGroup.node()).attr('transform')).translate;
            this.initTranslateX = translate[0];
            this.initTranslateY = translate[1];
        },

        onPanMove:function(ev){

            var transX = 0, transY = 0;
            if(this.xPanEnabled){
                transX = ev.containerPoint[0] - this.initPos[0] + this.initTranslateX;
                transX = Math.max(this.maxXPan, Math.min(0, transX));
            }

            if(this.yPanEnabled){
                transY = ev.containerPoint[1] - this.initPos[1] + this.initTranslateY;
                transY = Math.max(this.maxYPan, Math.min(0, transY));
            }

            if(this.hasPages && this.pageButton){

                var pageIndex = this.translateMap.length - 1;
                for(var i = 0, len = this.translateMap.length - 1; i < len; i++){
                    var pre = this.translateMap[i], next = this.translateMap[i + 1];
                    if(pre >= transY && next < transY){
                        pageIndex = i + 1;
                    }
                }

                if(this.pageIndex != pageIndex){
                    this.pageIndex = pageIndex;
                    this.pageButton.updatePage();
                }
            }

            this.legendItemsGroup.attr('transform', BaseUtils.makeTranslate([transX, transY]));
        },

        onPanEnd:function(){
            this.vanchart.handler.panTarget = null;
        },

        remove: function () {
            this.legendGroup && this.legendGroup.remove();
            this.legendGroup = null;
        }
    });

    var PageButton = Evented.extend({

        initialize:function(legend){
            this.legend = legend;
        },

        refresh:function(){
            var legend = this.legend, renderer = legend.vanchart.renderer, bounds = legend.bounds;
            var width = bounds.width, height = bounds.height, y = height - BUTTON_HEIGHT;

            if(!this.pageGroup){
                this.pageGroup = renderer.group().addTo(legend.legendGroup);
                renderer.registerInteractiveTarget(this, this.pageGroup);
                this.leftButton = renderer.path().style({'cursor':'pointer'}).addTo(this.pageGroup);
                this.rightButton = renderer.path().style({'cursor':'pointer'}).addTo(this.pageGroup);
                this.pageText = renderer.text().style({'font-Family':'Verdana', 'font-Size':'14px'}).addTo(this.pageGroup);
            }

            var buttonWidth = 40;//实际现实的按钮的宽度
            var leftButtonTopX = (width - buttonWidth) / 2;
            var rightButtonTopX = (width + buttonWidth) / 2;
            var labelX = width/2;

            this.pageGroup.attr('transform', BaseUtils.makeTranslate([0, y]));
            this.leftButton.attr('d', this._prePageButtonPath(leftButtonTopX));
            this.rightButton.attr('d', this._nextPageButtonPath(rightButtonTopX));
            this.pageText.attr('x', labelX).attr('y', '.71em').attr("text-anchor", "middle");

            this.updatePage();
        },

        updatePage:function(){
            
            var legend = this.legend, pageIndex = legend.pageIndex, pageCount = legend.pageCount;

            this.leftButton.style({'fill': pageIndex <= 0 ? DISABLED_COLOR : ENABLED_COLOR});

            this.rightButton.style({'fill':pageIndex < pageCount - 1 ? ENABLED_COLOR : DISABLED_COLOR});

            this.pageText.textContent(pageIndex + 1 + '/' + pageCount);
        },

        _prePageButtonPath:function(topX){
            var edge = 12, topY = 0;
            var leftBottomX = topX - edge / 2, leftBottomY = (edge / 2) * Math.sqrt(3);
            var rightBottomX = topX + edge / 2, rightBottomY = leftBottomY;
            return 'M' + topX + ',' + topY + 'L' + leftBottomX + ',' + leftBottomY + 'L' + rightBottomX + ',' + rightBottomY + 'Z';
        },

        _nextPageButtonPath:function(topX){
            var edge = 12, topY = 0;
            var topLeftX = topX - edge/2, topLeftY = topY;
            var topRightX = topX + edge/2, topRightY = topY;
            var bottomX = topX, bottomY = (edge / 2) * Math.sqrt(3);
            return 'M' + topLeftX + ',' + topLeftY + 'L' + topRightX + ',' + topRightY + 'L' + bottomX + ',' + bottomY + 'Z';
        },

        onTap:function(ev){
            var event = ev.srcEvent, src = event.target || event.srcElement, legend = this.legend;

            if(this.leftButton.node() == src){
                if(legend.pageIndex <= 0){
                    return;
                }

                legend.pageIndex--;

            }else if(this.rightButton.node() == src){
                if(legend.pageIndex == legend.pageCount - 1){
                    return;
                }

                legend.pageIndex++;
            }

            var pageIndex = legend.pageIndex;
            var translateY = legend.translateMap[pageIndex];

            if(this.legend.vanchart.isSupportAnimation()){
                d3.select(legend.legendItemsGroup.rawElement)
                    .transition()
                    .duration(500)
                    .ease(BezierEasing.css.swing)
                    .attr('transform', 'translate(' + 0 + ',' + translateY + ')');
            }else{
                legend.legendItemsGroup.attr('transform','translate(' + 0 + ',' + translateY + ')');
            }


            this.updatePage();
        },

        getEvents:function(){
            return {
                'tap':this.onTap
            }
        }

    });

    ComponentLibrary.register(ComponentLibrary.LEGEND_COMPONENT, Legend);
    return Legend;
});
/**
 * Created by eason on 15/10/12.
 */
define('component/ZoomBar',['require','./Base','../utils/BaseUtils','../Constants','../ComponentLibrary','../ComponentLibrary'],function(require){
    var Base = require('./Base');
    var BaseUtils = require('../utils/BaseUtils');
    var Constants = require('../Constants');
    var ComponentLibrary = require('../ComponentLibrary');

    //缩放控件默认的高度
    var HEIGHT = 30;
    var WIDTH = 10;

    var PADDING = 5;

    var ZoomBar = Base.extend({

        doLayout:function(){
            
            this.remove();

            if(this.zoomToolEnabled()){
                this._setComponentBounds(Constants.BOTTOM, HEIGHT + PADDING * 2);
            }
        },

        fixBoundsByPlot:function(){

            if(!this.zoomToolEnabled()){
                return;
            }

            var plotBounds = this.vanchart.getPlotBounds();

            var zoomY = plotBounds.y + plotBounds.height + PADDING;

            var xAxisComponent = this.vanchart.getComponent(ComponentLibrary.X_AXIS_COMPONENT);

            if(xAxisComponent && xAxisComponent._axisList.length){
                xAxisComponent._axisList.forEach(function(axis){
                    if(axis.getPosition() == Constants.BOTTOM){
                        zoomY = Math.max(zoomY, axis.bounds.y + axis.bounds.height);
                    }
                })
            }

            this.bounds = BaseUtils.makeBounds(plotBounds.x, zoomY, plotBounds.width, HEIGHT + PADDING * 2);

            this._initUnitLength();
            this.xScale = this._getAxisScale();
        },

        // ensure they are within the axis
        getRevisedDomain: function () {
            var revisedDomain = {
                from: this.options.zoomTool.from,
                to: this.options.zoomTool.to
            };

            var axis = this.vanchart.xAxis();
            if (axis.type === ComponentLibrary.VALUE_AXIS_COMPONENT ||
                axis.type === ComponentLibrary.DATE_AXIS_COMPONENT) {

                var tmp = [this.options.zoomTool.from, this.options.zoomTool.to];

                if (axis.type === ComponentLibrary.DATE_AXIS_COMPONENT) {
                    tmp[0] = BaseUtils.date2int(tmp[0]);
                    tmp[1] = BaseUtils.date2int(tmp[1]);
                }

                if(this.options.zoomTool.from && this.options.zoomTool.to){
                    //只有都设置的时候才调整
                    revisedDomain.from = Math.min.apply(null, tmp);
                    revisedDomain.to = Math.max.apply(null, tmp);
                } else {
                    revisedDomain.from = tmp[0];
                    revisedDomain.to = tmp[1];
                }
            }

            return revisedDomain;
        },

        zoomToolEnabled:function(){
            var opt = this.options;
            var dataSheet = this.vanchart.getComponent(ComponentLibrary.DATA_SHEET_COMPONENT);
            var dataSheetEnabled =  dataSheet && dataSheet.options.enabled != false;
            return opt && opt.zoomTool && opt.zoomTool.enabled && BaseUtils.isSupportSVG() && !dataSheetEnabled;
        },

        _getAxisScale:function(){
            var axis = this.vanchart.xAxis();
            var scale = axis.scale.copy();
            if (axis.type == ComponentLibrary.CATEGORY_AXIS_COMPONENT) {
                scale.rangeBand ? scale.rangeBands(axis._getRange()) : scale.range(axis._getRange());
            } else {
                var domain = axis.getOriginalDomain();
                scale.domain(domain);
            }
            return scale;
        },

        _initUnitLength:function(){
            var axis = this.vanchart.xAxis();

            if(axis.type == ComponentLibrary.CATEGORY_AXIS_COMPONENT){
                var bounds = this.bounds;
                var categories = axis.getCategories();
                this.unitLength = categories.length ? bounds.width/categories.length : bounds.width;
            }else{
                this.unitLength = 1;
            }
        },

        getStartX:function(revisedDomain){
            var startX = 0, scale = this.xScale;
            if(revisedDomain.from && revisedDomain.to){
                startX = Math.min(scale(revisedDomain.from), scale(revisedDomain.to));
            }else{
                startX = BaseUtils.isEmpty(revisedDomain.from) ? startX : scale(revisedDomain.from);
            }
            return startX;
        },

        getEndX:function(revisedDomain){
            var endX = this.bounds.width, scale = this.xScale;
            if(revisedDomain.from && revisedDomain.to){
                var to = Math.max(scale(revisedDomain.to), scale(revisedDomain.from));
                endX = to + (scale.rangeBand ? scale.rangeBand() : 0) || endX;
            }else{
                endX =  BaseUtils.isEmpty(revisedDomain.to) ? endX : (scale(revisedDomain.to) + (scale.rangeBand ? scale.rangeBand() : 0));
            }
            return endX;
        },

        render:function(){
            
            if(this.zoomBarGroup || !this.zoomToolEnabled()){
                return;
            }

            var zoomBar = this, bounds = zoomBar.bounds, vanchart = zoomBar.vanchart, renderer = vanchart.renderer;
            if(!this.zoomBarGroup){
                this.zoomBarGroup = renderer.group().attr('transform', BaseUtils.makeTranslate(bounds))
                    .style('cursor', 'ew-resize').add();

                renderer.registerInteractiveTarget(this, this.zoomBarGroup);
            }

            this._createLines();

            var revisedDomain = this.getRevisedDomain();
            var startX = this.getStartX(revisedDomain);
            var endX = this.getEndX(revisedDomain);

            this.leftRect = this._createSideRect(startX, true);

            this.rightRect = this._createSideRect(endX, false);

            this.centerRect = this._createCenterRect(startX, endX);

            this.leftButton = this._createButton(startX, true);

            this.rightButton = this._createButton(endX, false);

            var l_transX = this.leftButton.posX, r_transX = this.rightButton.posX;
            this.initStart = this._getIndexByPosition(l_transX);
            this.initEnd = this._getIndexByPosition(r_transX);
        },

        //缩放底边上的线
        _createLines:function(){
            var xScale = this.xScale, vanchart = this.vanchart, renderer = vanchart.renderer, series = vanchart.series;
            var usedSeries = [];
            for(var chartType in series){
                if(!vanchart.isSeriesAccumulated(chartType)){
                    usedSeries = usedSeries.concat(series[chartType])
                }
            }

            var det = xScale.rangeBand ? xScale.rangeBand()/2 : 0;
            var yDomain = vanchart.components.yAxis.getMaxDomainAxis().originalDomain;

            var yScale = d3.scale.linear().domain([yDomain[0], yDomain[1]]).range([HEIGHT, 0]);
            var lineSvg = d3.svg.line().interpolate("linear")
                .defined(function (d) {return !d.isNull && !isNaN(xScale(d.x));})
                .x(function (d) { return xScale(d.x) + det; })
                .y(function (d) { return yScale(+d.y + (+d.y0 || 0)); });


            this._lineG = this._lineG || [];
            var len = usedSeries.length;

            for(var j = len, count = this._lineG.length; j < count; j++){
                var line = this._lineG[j];
                line && line.remove();
                line = null;
            }

            for(var i = 0; i < len; i++){
                var line = this._lineG[i];
                if(!line){
                    line = renderer.path().style({fill:'none', stroke:'black', 'stroke-width':1}).addTo(this.zoomBarGroup);
                    this._lineG[i] = line;
                }
                line.attr('d', lineSvg(usedSeries[i].points));
            }
        },

        _createSideRect:function(startX, isLeft){

            var x, width, renderer = this.vanchart.renderer;

            if(isLeft){
                x = 0;
                width = startX;
            }else{
                x = startX;
                width = this.bounds.width - startX;
            }

            return renderer.rect().attr('x', x).attr('y', 0)
                .attr('width', width).attr('height', HEIGHT)
                .style({'fill':'rgba(220,221,221,0.4)'})
                .addTo(this.zoomBarGroup);
        },

        _createCenterRect:function(startX, endX){
            var renderer = this.vanchart.renderer;
            return renderer.rect()
                .attr('x', startX + WIDTH).attr('y', 0)
                .attr('width', endX - startX - 2 * WIDTH).attr('height', HEIGHT)
                .style({
                    'fill':'rgba(255,255,255,0)',
                    'stroke':'#29ABE2',
                    'stroke-width':1
                }).addTo(this.zoomBarGroup);
        },

        _createButton:function(startX, isLeft){

            startX = isLeft ? startX : startX - WIDTH;
            var renderer = this.vanchart.renderer;
            var button = renderer.group().attr('transform', 'translate(' + startX + ',' + '0)');
            var lineStyle = {
                'fill': '#FFFFFF',
                'stroke': '#7ADAF4',
                'stroke-width': 2,
                'stroke-linecap': 'round',
                'stroke-linejoin': 'round',
                'stroke-miterlimit': 10
            };

            renderer.path().attr('d',isLeft ? 'M4,30h6V0L4,0C1.791,0,0,1.791,0,4v22C0,28.209,1.791,30,4,30z' : 'M6,30H0V0h6c2.209,0,4,1.791,4,4v22C10,28.209,8.209,30,6,30z')
                .style({'fill':'#29ABE2'}).addTo(button);

            renderer.line().attr('x1', 3).attr('y1', 11).attr('x2', 3).attr('y2', 18)
                .style(lineStyle).addTo(button);

            renderer.line().attr('x1', 7).attr('y1', 11).attr('x2', 7).attr('y2', 18)
                .style(lineStyle).addTo(button);

            button.posX = startX;

            button.addTo(this.zoomBarGroup);

            return button;
        },

        _findDraggingTarget:function(ev){
            var event = ev.srcEvent, src = event.target || event.srcElement;

            var posX = ev.containerPoint[0] - this.bounds.x;

            var target;
            while (src) {

                //by position
                var leftDet = this.leftButton.posX - posX;
                var rightDet = posX - (this.rightButton.posX + WIDTH);

                if(leftDet > 0 && leftDet < 10){
                    target = this.leftButton;
                }

                if(rightDet > 0 && rightDet < 10){
                    target = this.rightButton;
                }

                if(target){
                    break;
                }

                //by dom
                if(src == this.leftButton.node()){
                    target = this.leftButton;
                }else if(src == this.rightButton.node()){
                    target = this.rightButton;
                }else if(src == this.centerRect.node() || src == this.zoomBarGroup.node()){
                    target = this.centerRect;
                }

                if (target){
                    break;
                }

                src = src.parentNode;
            }

            return target;
        },

        _panStart:function(ev){

            this.target = this._findDraggingTarget(ev);

            if(this.target){
                this.downX = ev.containerPoint[0];
                this.initX = this.target.posX;
                this.initTranslateX = 0;
            }

        },

        _panMove:function(ev){

            if(!this.target){
                return;
            }

            switch (this.target){

                case this.leftButton:
                    this._leftButtonMove(this.downX, this.initX, ev.containerPoint[0]);
                    break;

                case this.rightButton:
                    this._rightButtonMove(this.downX, this.initX, ev.containerPoint[0]);
                    break;

                case this.centerRect:
                    this._centerRectMove(this.downX, ev.containerPoint[0]);
                    break;
            }

            this._zoomRefresh();
        },

        _leftButtonMove:function(downX, initX, currentX){
            var minTransX = 0, maxTransX = this.rightButton.posX - WIDTH;
            var transX = initX + currentX - downX;
            transX = Math.max(Math.min(transX, maxTransX), minTransX);

            this.leftButton.posX = transX;
            this.leftButton.attr('transform', 'translate(' + transX + ',0)');
            this.leftRect.attr('width', transX);
            this.centerRect.attr('x', transX + WIDTH).attr('width', maxTransX - transX);
        },

        _rightButtonMove:function(downX, initX, currentX){

            var minTransX = this.leftButton.posX + WIDTH;
            var maxTransX = this.bounds.width - WIDTH;

            var transX = initX + currentX - downX;

            transX = Math.max(Math.min(transX, maxTransX), minTransX);

            this.rightButton.posX = transX;
            this.rightButton.attr('transform', 'translate(' + transX + ',0)');

            this.rightRect.attr('x', transX + WIDTH).attr('width', this.bounds.width - (transX + WIDTH));
            this.centerRect.attr('width', transX - minTransX);
        },

        _centerRectMove:function(downX, currentX){

            var endX = this.bounds.width, detX = currentX - downX - this.initTranslateX;

            this.initTranslateX = currentX - downX;

            if(this.leftButton.posX + detX >=0 && this.rightButton.posX + WIDTH + detX <= endX){

                var l_transX = this.leftButton.posX + detX;
                this.leftButton.posX = l_transX;
                this.leftButton.attr('transform', 'translate(' + l_transX + ',0)');
                this.leftRect.attr('width', l_transX);

                var r_transX = this.rightButton.posX + detX;
                this.rightButton.posX = r_transX;
                this.rightButton.attr('transform', 'translate(' + r_transX + ',0)');
                this.rightRect.attr('x', r_transX + WIDTH).attr('width', endX - (r_transX + WIDTH));

                this.centerRect.attr('x', l_transX + WIDTH);
            }
        },

        _getIndexByPosition:function(x){
            var axis = this.vanchart.xAxis();
            switch (axis.type) {
                case ComponentLibrary.CATEGORY_AXIS_COMPONENT:
                    return Math.floor(x/this.unitLength);
                case ComponentLibrary.DATE_AXIS_COMPONENT:
                    return BaseUtils.date2int(this.xScale.invert(x));
                default:
                    return this.xScale.invert(x);
            }
        },

        _zoomRefresh:function(){

            var l_transX = this.leftButton.posX,  r_transX = this.rightButton.posX;

            var startIndex = this._getIndexByPosition(l_transX);
            var endIndex = this._getIndexByPosition(r_transX);

            var vanchart = this.vanchart;

            if(this.initStart != startIndex || this.initEnd != endIndex){

                var axis = this.vanchart.xAxis();

                axis.updateAxisScale(startIndex, endIndex);
                axis.render();

                vanchart.reRenderSeries();

                this.initStart = startIndex;
                this.initEnd = endIndex;
            }
        },

        _panEnd:function(ev){

        },

        getEvents:function(){
            return {
                "panstart":this._panStart,
                "panmove":this._panMove,
                "panend":this._panEnd
            }
        },

        remove: function () {
            this.zoomBarGroup && this.zoomBarGroup.remove();
            this.zoomBarGroup = null;
        }
    });
    
    require('../ComponentLibrary').register(ComponentLibrary.ZOOM_COMPONENT, ZoomBar);
    return ZoomBar;

});
//Copyright (c) 2013 The New York Times
//
//Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the "Software"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions:
//
//    The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software.
//
//    THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE

define('utils/ExportUtils',['require','./BaseUtils'],function(require) {

    var BaseUtils = require('./BaseUtils');

    var doctype = '<?xml version="1.0" standalone="no"?><!DOCTYPE svg PUBLIC "-//W3C//DTD SVG 1.1//EN" "http://www.w3.org/Graphics/SVG/1.1/DTD/svg11.dtd">';

    window.URL = (window.URL || window.webkitURL);

    var body = document.body;

    var prefix = {
        xmlns: "http://www.w3.org/2000/xmlns/",
        xlink: "http://www.w3.org/1999/xlink",
        svg: "http://www.w3.org/2000/svg"
    };

    function cleanup() {
        var crowbarElements = document.querySelectorAll(".svg-export");

        [].forEach.call(crowbarElements, function(el) {
            el.parentNode.removeChild(el);
        });
    }


    function getSources(svg) {

        var styles =  "" ;

        svg.setAttribute("version", "1.1");

        var defsEl = document.createElement("defs");

        svg.insertBefore(defsEl, svg.firstChild);

        var styleEl = document.createElement("style")
        defsEl.appendChild(styleEl);
        styleEl.setAttribute("type", "text/css");

        svg.removeAttribute("xmlns");
        svg.removeAttribute("xlink");

        if (!svg.hasAttributeNS(prefix.xmlns, "xmlns")) {
            svg.setAttributeNS(prefix.xmlns, "xmlns", prefix.svg);
        }

        if (!svg.hasAttributeNS(prefix.xmlns, "xmlns:xlink")) {
            svg.setAttributeNS(prefix.xmlns, "xmlns:xlink", prefix.xlink);
        }

        var source = (new XMLSerializer()).serializeToString(svg).replace('</style>', '<![CDATA[' + styles + ']]></style>');

        return [doctype + source];
    }

    function toSvg(svgNode, config) {

        cleanup();

        var source = getSources(svgNode);

        var fileName = config.fileName;

        var url = window.URL.createObjectURL(new Blob(source, { "type" : "text\/xml" }));

        var a = document.createElement("a");
        body.appendChild(a);
        a.setAttribute("class", "svg-export");
        a.setAttribute("download", fileName + ".svg");
        a.setAttribute("href", url);
        a.style["display"] = "none";
        a.click();

        setTimeout(function() {
            window.URL.revokeObjectURL(url);
        }, 10);
    }

    function toImage(svgNode, config, chartDim){
        toSvg(svgNode, config, chartDim);
    }

    return {
        toImage:toImage
    };
});
/**
 * Created by eason on 15/8/24.
 */

define('component/ToolbarIcon',['require','./Base','../utils/BaseUtils','../Constants','../utils/ExportUtils','../dom/Evented'],function(require){

    //icon的几种背景颜色
    function OPEN_NORMAL(){
        return {'fill':'black', 'fill-opacity':0.05};
    }

    function OPEN_HOVER() {
        return {'fill':'black', 'fill-opacity':0.1};
    }

    function CLOSED_NORMAL(){
        return {'fill':'black', 'fill-opacity':0};
    }

    function CLOSED_HOVER(){
        return {'fill':'black', 'fill-opacity':0.05};
    }

    var RECT_R = 2;
    var ICON_SIZE = 32;
    var ICON_GAP = 1;
    var GAP = ICON_SIZE + ICON_GAP;

    var Base = require('./Base');
    var BaseUtils = require('../utils/BaseUtils');
    var Constants = require('../Constants');
    var ExportUtils = require('../utils/ExportUtils');
    var Evented = require('../dom/Evented');

    var ToolbarIcon = Evented.extend({

        initialize:function(iconType, toolbar, pos, visible){
            this.iconType = iconType; this.toolbar = toolbar;
            this.visible = visible; this.pos = pos; this.currentPos = {x:pos.x, y:pos.y};
        },

        render:function(){
            var toolbar = this.toolbar, vanchart = toolbar.vanchart, renderer = vanchart.renderer, icon = this;
            if(!this.iconG){
                this.iconG = renderer.group().style({'cursor':'pointer'}).addTo(toolbar.toolbarGroup);
            }

            renderer.registerInteractiveTarget(this, this.iconG);

            this.iconG.attr('transform', 'translate('+ icon.pos.x +','+ icon.pos.y +')').style({'display':this.visible ? '' : 'none'});

            this.iconG.rect = this.iconG.rect || renderer.rect().attr('width', ICON_SIZE).attr('height', ICON_SIZE)
                .attr('rx', RECT_R).attr('ry', RECT_R)
                .addTo(this.iconG);

            this.iconG.rect.style(toolbar.hidden ? CLOSED_NORMAL() : OPEN_NORMAL());

            this.iconG.path = this.iconG.path || this._getIconPathGraphic(vanchart, renderer, icon);
        },

        _getIconPathGraphic: function (vanchart, renderer, icon) {
            switch (this.iconType){
                case Constants.REFRESH_ICON:
                    return renderer.path().attr('d', icon.getRefreshIconPath()).style({'fill':'#FF9933'}).addTo(this.iconG);
                case Constants.SORT:
                    if(vanchart.orderType == Constants.ASCENDING){
                        return renderer.path().attr('d', icon.getDecreaseIconPath()).style({'fill':'#33CCFF'}).addTo(this.iconG);
                    }else{
                        return renderer.path().attr('d', icon.getIncreaseIconPath()).style({'fill':'#33CCFF'}).addTo(this.iconG);
                    }
                case Constants.EXPORT_ICON:
                    return renderer.path().attr('d', icon.getExportIconPath()).style({'fill':'#6666CC'}).addTo(this.iconG);
                case Constants.FULL_SCREEN_ICON:
                    if(vanchart.vancharts.isFullScreen){
                        return renderer.path().attr('d', icon.getMinIconPath()).style({'fill':'#33CC66'}).addTo(this.iconG);
                    }else{
                        return renderer.path().attr('d', icon.getMaxIconPath()).style({'fill':'#33CC66'}).addTo(this.iconG);
                    }
                case Constants.MENU_ICON:
                    return renderer.path().attr('d', icon.getMenuIconPath()).style({'stroke-width':2, 'stroke':'#AAAAAA'}).addTo(this.iconG);
            }
        },

        refreshMove:function(left, right){

            var pos = this.pos, currentPos = this.currentPos;
            var leftPos = currentPos.x - left, rightPos = leftPos + right;

            if(BaseUtils.isSupportSVG()){
                d3.select(this.iconG.node()).transition().ease('circle-out').duration(220).attr('transform', 'translate('+ leftPos +','+ pos.y +')')
                    .transition().ease('circle-in').duration(220).attr('transform', 'translate('+ rightPos +','+ pos.y +')');
            }else{
                this.iconG.attr('transform', 'translate('+ rightPos +','+ pos.y +')')
            }

            this.currentPos.x = rightPos;
        },

        refreshMoveWithoutAnimation:function(left, right){

            var rightPos = this.currentPos.x - left + right;

            this.iconG.attr('transform', 'translate('+ rightPos +','+ this.pos.y +')');

            this.currentPos.x = rightPos;
        },

        showIcon:function(){

            this.visible = true;

            if(arguments.length){
                this._iconAnimation(arguments[0], arguments[1]);
            }else{//refresh icon
                this.iconG.style({'display':''});
            }

        },

        hideIcon:function(){

            this.visible = false;

            if(arguments.length){
                this._iconAnimation(arguments[0], arguments[1]);
            }else{//refresh icon
                this.iconG.style({'display':'none'});
                //每次刷新之后，刷新按钮隐藏并且回到初始位置
                this.iconG.attr('transform', 'translate('+ this.pos.x +','+ this.pos.y +')');
                this.currentPos.x = this.pos.x;
            }
        },

        _iconAnimation:function(moveIndex, delay){

            var iconG = this.iconG, pos = this.pos, visible = this.visible;

            if(BaseUtils.isSupportSVG()){
                setTimeout(function(){
                    if(visible){
                        iconG.style({'display':''});
                    }
                    var moveDet = 4 * moveIndex, leftX = pos.x - moveDet;
                    d3.select(iconG.node()).transition().ease('circle-out').duration(100).attr('transform', 'translate('+ leftX +','+ pos.y +')')
                        .transition().ease('circle-in').duration(100).attr('transform', 'translate('+ pos.x +','+ pos.y +')')
                        .each('end', function(){
                            iconG.style({'display':visible ? '' : 'none'});
                        });

                    d3.select(iconG.rect.node()).style(visible ? CLOSED_NORMAL() : OPEN_NORMAL())
                        .transition().ease('linear').duration(200).style(visible ? OPEN_NORMAL() : CLOSED_NORMAL());

                }, delay);

            }else{
                iconG.attr('transform', 'translate('+ pos.x +','+ pos.y +')').style({'display':visible ? '' : 'none'});

                iconG.rect.style(visible ? OPEN_NORMAL() : CLOSED_NORMAL())
            }
            this.currentPos.x = this.pos.x;
        },

        onMouseOver:function(){
            this.iconG.rect.style(this.toolbar.hidden ? CLOSED_HOVER() : OPEN_HOVER());
        },

        onMouseOut:function(){
            this.iconG.rect.style(this.toolbar.hidden ? CLOSED_NORMAL() : OPEN_NORMAL());
        },

        onTap:function(){
            var toolbar = this.toolbar, vanchart = toolbar.vanchart, renderer = vanchart.renderer, icon = this;
            var dom = vanchart.getDivParentDom();
            switch (icon.iconType){
                case Constants.REFRESH_ICON:
                    vanchart.refreshRestore();
                    icon.hideIcon();
                    break;
                case Constants.SORT:
                    if(vanchart.orderType == Constants.ASCENDING){
                        vanchart.orderType = Constants.DESCENDING;
                        icon.iconG.path.attr({'d':icon.getIncreaseIconPath()});
                    }else{
                        vanchart.orderType = Constants.ASCENDING;
                        icon.iconG.path.attr({'d':icon.getDecreaseIconPath()});
                    }
                    toolbar.refreshIcon.showIcon();
                    vanchart.orderData();
                    break;
                case Constants.EXPORT_ICON:
                    break;
                case Constants.FULL_SCREEN_ICON:
                    if(vanchart.vancharts.isFullScreen){
                        BaseUtils.hideLightBox(dom);
                    }else{
                        BaseUtils.showLightBox(vanchart.restoreOption)
                    }
                    break;
                case Constants.MENU_ICON:
                    toolbar.showOrHide();
                    break;
            }
        },

        getEvents:function(){
            return {
                mouseover:this.onMouseOver,
                mouseout:this.onMouseOut,
                tap:this.onTap
            }
        },

        getMaxIconPath:function(){
            return 'M24,8v6.5L21.5,12l-3,3L17,13.5l3-3L17.5,8H24z M15,18.5l-3,3l2.5,2.5H8v-6.5l2.5,2.5l3-3L15,18.5z';
        },

        getMinIconPath:function(){
            return 'M15,17v6.5L12.5,21l-3,3L8,22.5l3-3L8.5,17H15z M24,9.5l-3,3l2.5,2.5H17V8.5l2.5,2.5l3-3L24,9.5z';
        },

        getIncreaseIconPath:function(){
            return 'M8,20h16v2H8V20z M10,16h2v3h-2V16z M13,14h2v5h-2V14z M16,12h2v7h-2V12z M19,9h2v10h-2V9z';
        },

        getDecreaseIconPath:function(){
            return 'M8,20h16v2H8V20z M10,9h2v10h-2V9z M13,12h2v7h-2V12z M16,15h2v4h-2V15z M19,16h2v3h-2V16z';
        },

        getExportIconPath:function(){
            return 'M22,8H8v16h16V10L22,8z M16,10h2v4h-2V10z M22,22H10V10h1v5h9v-5h1.171L22,10.829V22z';
        },

        getRefreshIconPath:function(){
            return 'M21.656,10.344C20.209,8.896,18.209,8,16,8c-3.43,0-6.354,2.158-7.492,5.19l1.873,0.703C11.234,11.619,13.428,10,16,10c1.657,0,3.156,0.672,4.243,1.757L18,14h6V8L21.656,10.344z M16,22c-1.657,0-3.156-0.671-4.243-1.757L14,18H8v6l2.344-2.344C11.791,23.104,13.791,24,16,24c3.43,0,6.354-2.158,7.492-5.19l-1.873-0.703C20.766,20.381,18.572,22,16,22z';
        },

        getMenuIconPath:function(){
            return 'M8,10L24,10 M8,15L24,15 M8,20L24,20';
        }

    });

    return ToolbarIcon;
});
/**
 * Created by eason on 15/7/27.
 * 工具栏组建
 */
define('component/ToolBar',['require','./Base','../utils/BaseUtils','../Constants','../utils/ExportUtils','./ToolbarIcon','../ComponentLibrary'],function(require){
    var Base = require('./Base');
    var BaseUtils = require('../utils/BaseUtils');
    var Constants = require('../Constants');
    var ExportUtils = require('../utils/ExportUtils');
    var ToolbarIcon = require('./ToolbarIcon');
    var ComponentLibrary = require('../ComponentLibrary');

    var ICON_SIZE = 32;
    var ICON_GAP = 1;
    var DEFAULT_GAP = 5;

    var Toolbar = Base.extend({

        _refresh:function(){
            
            if(this.toolbarGroup){
                return;
            }

            var options = this.options, hidden = options.hidden;
            var keys = ['sort', 'toImage', 'fullScreen'];
            var icons = [Constants.REFRESH_ICON];
            keys.forEach(function(key){
                if(options[key] && options[key].enabled){
                    icons.push(key);
                }
            });

            hidden && icons.push(Constants.MENU_ICON);

            var GAP = ICON_SIZE + ICON_GAP;
            var size = icons.length * GAP + DEFAULT_GAP;
            var startX = this.vanchart.width - size;

            this.toolbarIcons = []; this.hidden = hidden;

            for(var iconIndex = 0, len = icons.length; iconIndex < len; iconIndex++){
                var pos = {x:iconIndex * GAP + startX, y:DEFAULT_GAP};
                var type = icons[iconIndex];
                var visible = !hidden;
                if(type == Constants.MENU_ICON){
                    this.menuIcon = new ToolbarIcon(type, this, pos, true);
                }else if(type == Constants.REFRESH_ICON){
                    this.refreshIcon = new ToolbarIcon(type, this, pos, false);
                }else{
                    this.toolbarIcons.push(new ToolbarIcon(type, this, pos, visible));
                }
            }

            this.isFloat = true;
        },

        doLayout:function(){

        },

        render:function(){
            var renderer = this.vanchart.renderer;
            if(!this.toolbarGroup){
                this.toolbarGroup = renderer.group().add();

                //todo 没有精力再去整体改写leaflet的源码了,要组合两者只能这么用
                if(this.vanchart._leaflet){
                    this.toolbarGroup.style('pointer-events', 'all');
                }
            }
            this.toolbarIcons.forEach(function(icon){
                icon.render();
            });

            this.menuIcon && this.menuIcon.render();
            this.refreshIcon && this.refreshIcon.render();
        },

        showOrHide:function(){
            this.hidden ? this.show() : this.hide();
            this.hidden = !this.hidden;
        },

        hide:function(){

            var toolbarIcons = this.toolbarIcons, iconSize = toolbarIcons.length, delay = [];

            for(var i = 0; i < iconSize; i++){
                delay.push(100 + 80 * i);
            }

            for(var i = 0; i < iconSize; i++){
                var moveIndex = iconSize - i;
                toolbarIcons[i].hideIcon(moveIndex, delay[i]);
            }

            var left = 4 * (iconSize + 1) ;
            var right = 4 * (iconSize + 1) + 33 * iconSize;

            if(this.refreshIcon.visible){
                this.refreshIcon.refreshMove(left, right);
            }

        },

        show:function(){
            var delay = [0], toolbarIcons = this.toolbarIcons, iconSize = toolbarIcons.length;

            for(var i = 0; i < iconSize - 1; i++){
                delay.push(100 + 80 * i);
            }

            for(var i = 0; i < iconSize; i++){
                var moveIndex = iconSize - i;
                toolbarIcons[i].showIcon(moveIndex, delay[i]);
            }

            var left = 4 * (iconSize + 1) + 33 * iconSize;
            var right = 4 * (iconSize + 1);
            if(this.refreshIcon.visible){
                this.refreshIcon.refreshMove(left, right);
            }
        },

        showRefreshIconWhenZoom:function(){
            if(!this.refreshIcon.visible){
                if(this.menuIcon){
                    if(this.hidden){
                        var iconSize = this.toolbarIcons.length;
                        var left = 4 * (iconSize + 1) ;
                        var right = 4 * (iconSize + 1) + 33 * iconSize;
                        this.refreshIcon.refreshMoveWithoutAnimation(left, right);
                        this.refreshIcon.showIcon();
                    }else{
                        this.refreshIcon.showIcon();
                    }
                }else{
                    this.refreshIcon.showIcon();
                }
            }
        },

        getToolBarInitWidth: function () {
            if (!this.options.enabled) {
                return 0;
            }
            if (this.options.hidden) {
                return ICON_SIZE + DEFAULT_GAP;
            } else {
                return this.toolbarIcons.length * (ICON_SIZE + ICON_GAP) - ICON_GAP + DEFAULT_GAP;
            }
        },

        remove:function(){
            this.toolbarGroup && this.toolbarGroup.remove();
            this.toolbarGroup = null;
        }
    });
    
    ComponentLibrary.register(ComponentLibrary.TOOLBAR_COMPONENT, Toolbar);
    return Toolbar;
});
/**
 * Created by eason on 15/8/16.
 */

define('utils/LabelDivManager',['require','./BaseUtils','./ColorUtils','./BezierEasing'],function(require){

    var BaseUtils = require('./BaseUtils');
    var ColorUtils = require('./ColorUtils');
    var BezierEasing = require('./BezierEasing');

    var DEFAULT_KEY = 'div-label-key';

    function LabelDivManager(dom, posAndDim){
        if (posAndDim) {
            this.dom = this.createDiv(dom, posAndDim);
        } else {
            this.dom = dom;
        }
        this.labelList = {};
    }

    LabelDivManager.prototype = {
        constructor:LabelDivManager,

        updateBounds: function (posAndDim) {
            var div = this.dom;
            div.style.left = posAndDim.x + 'px';
            div.style.top = posAndDim.y + 'px';
            div.style.width = posAndDim.width + 'px';
            div.style.height = posAndDim.height + 'px';
        },

        createDiv: function (dom, posAndDim) {
            var div = document.createElement('div');

            div.style.zIndex = 1001;
            div.style.position = 'absolute';
            div.style.left = posAndDim.x + 'px';
            div.style.top = posAndDim.y + 'px';
            div.style.overflow = 'hidden';

            div.style.width = posAndDim.width + 'px';
            div.style.height = posAndDim.height + 'px';
            div.style.pointerEvents = 'none';

            dom.appendChild(div);

            return div;
        },

        //bounds是绝对坐标
        addLabel:function(label, posOrDim, style, key, wrap, useHTML){
            // to keep previous default behavior
            if (typeof wrap === 'undefined') {
                wrap = false;
            }
            
            if (typeof useHTML === 'undefined') {
                useHTML = true;
            }

            key = key || DEFAULT_KEY;

            if(!this.labelList[key]){
                this.labelList[key] = [];
            }

            var labelArray = this.labelList[key];

            var div = document.createElement('div');
            if (useHTML) {
                div.innerHTML = label;
            } else {
                div.textContent ?
                    (div.textContent = label) :
                    (div.innerText = label);
            }
            
            div.style.zIndex = 1001;
            div.style.position = 'absolute';
            div.style.left = posOrDim.x + 'px';
            div.style.top = posOrDim.y + 'px';
            div.style.overflow = 'hidden';
            if (wrap) {
                div.style.whiteSpace = "normal";
                div.style.wordWrap = 'break-word';
            } else {
                div.style.whiteSpace = 'nowrap';
            }

            if(BaseUtils.hasDefined(posOrDim.width) && BaseUtils.hasDefined(posOrDim.height)){
                div.style.width = posOrDim.width + 'px';
                div.style.height = posOrDim.height + 'px';
            }

            for(var fontStyle in style){
                //ie789的color属性只能是16进制的值
                if(fontStyle == 'color' && !BaseUtils.isSupportSVG()){
                    div.style.color = ColorUtils.colorToHex(style.color);
                }else {
                    div.style[fontStyle] = style[fontStyle];
                }

            }

            this.dom.appendChild(div);
            labelArray.push(div);

            return div;
        },

        addLabelWidthBounds:function(label, bounds, style, key, wrap, useHTML){

            var div = this.addLabel(label, bounds, style, key, wrap, useHTML);

            div.style.width = bounds.width + 'px';
            div.style.height = bounds.height + 'px';

            return div;
        },

        clearLabels:function(key){
            key = key || DEFAULT_KEY;

            var labelArray = this.labelList[key] || [];

            for(var i = 0, len = labelArray.length; i < len; i++){
                this.dom.removeChild(labelArray[i]);
            }

            this.labelList[key] = [];
        },

        //删除所有层级的div标签
        clearAllLabels:function(){
            for(var key in this.labelList){
                this.clearLabels(key);
            }
        },

        translateLabelsHorizontal:function(transX, key){

            key = key || DEFAULT_KEY;
            var labelArray = this.labelList[key] || [];

            for(var i = 0, len = labelArray.length; i < len; i++){
                var label = labelArray[i];
                var left = parseFloat(label.style.left);
                left += transX;

                if(BaseUtils.isSupportSVG()){

                    d3.select(label)
                        .transition()
                        .ease(BezierEasing.css.swing)
                        .duration(300)
                        .style('left', left + 'px')

                }else{
                    label.style.left = left + 'px';
                }
            }
        },

        /**
         * change labels' size and position
         * @param {object} [changes] style key - change value
         * (key: left, top, right, bottom, width, height)
         * @param [key] label key
         */
        changeLabelDim: function (changes, key) {
            if (!changes) {
                return;
            }

            key = key || DEFAULT_KEY;
            var labelArray = this.labelList[key] || [];

            labelArray.map(function (label) {
                var changedValues = {};
                for (var name in changes) {
                    var value = parseFloat(label.style[name]);
                    changedValues[name] = value + changes[name] + 'px';
                }

                if(BaseUtils.isSupportSVG()){

                    d3.select(label)
                        .transition()
                        .ease(BezierEasing.css.swing)
                        .duration(300)
                        .style(changedValues);

                }else{
                    for (var name in changedValues) {
                        label.style[name] = changedValues[name];
                    }
                }
            })
        },

        setLabelOpacity: function (key, opacity) {
            var labelArray = this.labelList[key] || [];

            for(var i = 0, len = labelArray.length; i < len; i++){
                var label = labelArray[i];
                label.style.opacity = opacity;
            }
        }
    };


    return LabelDivManager;

});
/**
 * Created by Mitisky on 16/8/10.
 */
define('dom/EventObject',['require','../dom/Evented'],function(require){

    var Evented = require('../dom/Evented');

    var EventObject = Evented.extend({

        initialize: function (events) {
            this.events = events;
        },

        getEvents: function () {
            return this.events
        }
    });

    return EventObject;
});

/**
 * Created by Mitisky on 16/8/10.
 */

define('component/IntervalRangeLegend',['require','./Base','../utils/BaseUtils','../Constants','../utils/ColorUtils','../utils/Formatter','../dom/EventObject'],function (require) {
    var Base = require('./Base');
    var BaseUtils = require('../utils/BaseUtils');
    var Constants = require('../Constants');
    var ColorUtils = require('../utils/ColorUtils');
    var Formatter = require('../utils/Formatter');
    var EventObject = require('../dom/EventObject');

    var PADDING = 10;

    var WIDTH = 15;
    var BAR_TEXT_GAP = 5;
    var ITEM_WIDTH = 25;
    var ITEM_GAP = 2;

    var IntervalRangeLegend = Base.extend({

        _refresh: function () {
            var options = this.options, range = options.range || {};

            if(!BaseUtils.isArray(range)){//自动计算
                var splitNumber = range.splitNumber || 5;
                var color = range.color || this.vanchart.currentOption.colors[0];
                var colors = ColorUtils.createColorsWithHsb(color, splitNumber);
                var minMax = this.vanchart.getMinMaxFromSeries();
                var para = BaseUtils.calculateAutoMinMaxAndGap(minMax[0], minMax[1], splitNumber);
                var minValue = para[0];
                var gap = para[2];

                range = [];
                for(var i = 0; i < splitNumber; i++) {
                    range.push({
                        from:BaseUtils.accAdd(minValue, BaseUtils.accMul(gap, (splitNumber - i - 1))),
                        to:BaseUtils.accAdd(minValue,  BaseUtils.accMul(gap, (splitNumber - i))),
                        color:colors[i]
                    });
                }
            }

            this.items = this.items || [];
            var realLen = range.length;
            var oldLen = this.items.length;

            for(var removeIndex = realLen; removeIndex < oldLen; removeIndex++){
                this.items[removeIndex].graphic && this.items[removeIndex].graphic.remove();
                this.items[removeIndex] = null;
            }

            var formatter = options.formatter;
            for(var index = 0; index < realLen; index++){
                var item = this.items[index] || new EventObject(this.getEvents());
                this.items[index] = item;

                var band = range[index];
                item.from = band.from;
                item.to = band.to;
                item.color = band.color;
                item.label = this._getIntervalLabelContent(band.from, band.to, formatter);
                item.visible = true;
                item.hiddenColor = options.hiddenColor;
                item.hoverColor = options.hoverColor;
                item.points = [];

                item.legend = this;
            }

            var self = this;
            this.items.sort(function (itemA, itemB) {
                var itemAMin = Math.min(itemA.from, itemA.to);
                var itemBMin = Math.min(itemB.from, itemB.to);
                return self.isHorizontal() ? itemAMin - itemBMin : itemBMin - itemAMin;
            });

        },

        _getIntervalLabelContent:function(from, to, formatter){
            if(!formatter){
                return from + '-' + to;
            }

            return Formatter.format({'from':from,'to':to}, formatter);
        },

        doLayout: function () {
            this._bindItemsPoints();
        },

        _bindItemsPoints: function () {
            var self = this;
            var series = this.vanchart.series;

            for(var chartType in series) {
                var chartSeries = series[chartType];
                for (i = 0, len = chartSeries.length; i < len; i++) {
                    var sery = chartSeries[i];
                    var pointS = sery.points;
                    pointS.forEach(function (point) {

                        //todo 这个指标的含义
                        var size = BaseUtils.hasDefined(point.size) ? point.size : point.value;

                        var item = self._getPointItem(size);
                        if (item) {
                            item.points.push(point);
                        }
                    })
                }
            }
        },

        _getPointItem:function(size){
            for(var i = 0, len = this.items.length; i < len; i++){
                var item = this.items[i];
                var min = Math.min(item.from, item.to);
                var max = Math.max(item.from, item.to);

                if(size >= min && size <= max){
                    return item;
                }
            }
        },

        calculateHorizontalDim: function () {
            var len = this.items.length;
            var width = 0, height = 0;
            if(len > 0){
                var d1 = BaseUtils.getTextDimension(this.items[0].label, this.options.style);
                var d2 = BaseUtils.getTextDimension(this.items[len - 1].label, this.options.style);
                var gap = Math.max(0, d1.width - ITEM_WIDTH, d2.width - ITEM_WIDTH);
                width = len * ITEM_WIDTH + (len - 1) * ITEM_GAP + gap;
                height = WIDTH + BAR_TEXT_GAP * 2 + d1.height * 2
            }
            return {
                width:width,
                height:height
            }
        },

        calculateVerticalDim: function () {
            var len = this.items.length;
            var width = 0, gap = 0;
            var style = this.options.style;
            this.items.forEach(function (item) {
                var labelDim = BaseUtils.getTextDimension(item.label, style);
                width = Math.max(width, labelDim.width);
                gap = Math.max(0, labelDim.height - ITEM_WIDTH)
            });
            return {
                width:width + WIDTH + BAR_TEXT_GAP,
                height:len * ITEM_WIDTH + (len - 1) * ITEM_GAP + gap
            }
        },

        getColorWithSize: function (size) {
            var item = this._getPointItem(size);
            return item && item.color;
        },

        render: function (itemsGroup, bounds, divManager) {
            this.divManager = divManager;

            this.isHorizontal() ? this._renderHorizontalInterval(itemsGroup, bounds)
                : this._renderVerticalInterval(itemsGroup, bounds);
        },

        _renderHorizontalInterval: function (itemsGroup, bounds) {
            var itemS =  this.items;

            var transX = (bounds.width - itemS.length * ITEM_WIDTH - (itemS.length - 1) * ITEM_GAP)/2;
            itemsGroup.attr('transform', BaseUtils.makeTranslate([transX, PADDING]));

            this._absX = bounds.x + transX;
            this._absY = bounds.y + PADDING;

            var labelStyle = this.options.style;
            var vanchart = this.vanchart, renderer = vanchart.renderer;

            var startX = 0;
            var self = this;
            itemS.forEach(function (item, i) {

                item.graphic = item.graphic || renderer.group().style({'cursor': 'pointer'}).addTo(itemsGroup);
                var g = item.graphic;
                renderer.registerInteractiveTarget(item, g);

                var labelContent = item.label;
                var labelDim = BaseUtils.getTextDimension(labelContent, labelStyle);
                var height = labelDim.height;
                var iconY = height + BAR_TEXT_GAP;
                var bottomY = iconY + WIDTH + BAR_TEXT_GAP;

                g.rect = g.rect || renderer.rect().addTo(g);
                g.rect.style(self._getItemIconStyle(item))
                    .attr('rx', 2).attr('ry', 2)
                    .attr('x', startX).attr('y', iconY)
                    .attr('width', ITEM_WIDTH).attr('height', WIDTH);

                var innerX = startX + ITEM_WIDTH/ 2,
                    innerY = i%2 == 0 ? height/2 : bottomY + height/2;

                self._renderItemLabel(item, g, innerX, innerY, labelDim, i);

                startX += (ITEM_WIDTH + ITEM_GAP);
            });
        },

        _renderVerticalInterval: function (itemsGroup, bounds) {
            var itemS =  this.items;

            var transY = (bounds.height - itemS.length * ITEM_WIDTH - (itemS.length - 1) * ITEM_GAP)/2;
            itemsGroup.attr('transform', BaseUtils.makeTranslate([PADDING, transY]));

            this._absX = bounds.x + PADDING;
            this._absY = bounds.y + transY;

            var labelStyle = this.options.style;
            var renderer = this.vanchart.renderer;

            var startY = 0;
            var self = this;
            itemS.forEach(function(item, i){

                item.graphic = item.graphic || renderer.group().style({'cursor': 'pointer'}).addTo(itemsGroup);
                var g = item.graphic;
                renderer.registerInteractiveTarget(item, g);

                var labelDim = BaseUtils.getTextDimension(item.label, labelStyle);

                g.rect = g.rect || renderer.rect().addTo(g);
                g.rect.style(self._getItemIconStyle(item))
                    .attr('rx', 2).attr('ry', 2)
                    .attr('x', 0).attr('y', startY)
                    .attr('width', WIDTH).attr('height', ITEM_WIDTH);

                var innerX = Math.round(WIDTH + BAR_TEXT_GAP + labelDim.width / 2),
                    innerY = Math.round(startY + ITEM_WIDTH / 2);
                
                self._renderItemLabel(item, g, innerX, innerY, labelDim, i);

                startY += (ITEM_WIDTH + ITEM_GAP);
            });
        },

        _renderItemLabel: function (item, g, innerX, innerY, labelDim, i) {
            var legend = this, vanchart = legend.vanchart, renderer = vanchart.renderer, options = legend.options;
            var labelContent = item.label, labelStyle = options.style, useHtml = options.useHtml;
            if(useHtml) {
                var labelKey = '_range_legend_label_' + i;
                if(g.text){
                    legend.divManager.clearLabels(labelKey);
                }
                var bounds = {x:this._absX + innerX - labelDim.width/2, y:this._absY + innerY - labelDim.height/2, width:labelDim.width, height:labelDim.height};
                g.text = legend.divManager.addLabel(labelContent, bounds, labelStyle, labelKey, true);
            }else{
                g.text = g.text || renderer.text().addTo(g);
                g.text.textContent(labelContent)
                    .attr('dy', '.32em')
                    .attr('text-anchor', 'middle')
                    .attr('x', innerX).attr('y', innerY)
                    .style(BaseUtils.extend(labelStyle, {fill: item.visible ? labelStyle.color : item.hiddenColor}));
            }
        },

        _getItemIconStyle: function (item) {
            return {
                'fill':item.visible ? item.color : item.hiddenColor,
                'fill-opacity':1,
                'stroke':'none'
            }
        },


        getEvents:function(){
            return {
                'mouseover':this.onItemMouseOver,
                'mousemove':this.onItemMouseMove,
                'mouseout':this.onItemMouseOut,

                'tap':this.onItemTap
            }
        },

        onItemMouseOver: function (e) {
            var item = this;
            var text = item.graphic && item.graphic.text;

            text.style({'fill': item.hoverColor});
        },

        onItemMouseMove: function (e) {
        },

        onItemMouseOut: function (e) {
            var item = this, legend = item.legend, options = legend.options;
            var text = item.graphic && item.graphic.text;

            var labelColor = options.style.color;
            var textColor = item.visible ? labelColor : item.hiddenColor;
            text.style({'fill':textColor});
        },

        onItemTap: function (e) {
            var item = this, legend = item.legend, options = legend.options, vanchart = legend.vanchart;
            var text = item.graphic && item.graphic.text;
            var rect = item.graphic && item.graphic.rect;

            item.visible = !item.visible;
            var labelColor = options.style.color;
            var iconColor = item.visible ? item.color : item.hiddenColor;
            var textColor = item.visible ? labelColor : item.hiddenColor;
            rect.style({'fill':iconColor});
            text.style({'fill':textColor});

            if(item.points && item.points.length > 0) {

                var hasMap = vanchart.vanChartType == 'vanChartMap';

                item.points.forEach(function (point) {
                    if (!hasMap || (hasMap && point.points && point.points[0] == point)) {
                        point.visible = item.visible;
                        if (hasMap) {
                            var points = point.points;
                            for (var i = 1, len = points.length; i < len; i++) {
                                points[i].visible = point.visible;
                            }
                        }
                    }
                });

                vanchart.filterRender();
            }
        }

    });

    return IntervalRangeLegend;

});


/**
 * Created by Mitisky on 16/8/10.
 */
define('component/GradientRangeLegend',['require','./Base','../utils/BaseUtils','../Constants','../utils/Formatter','../utils/ColorUtils'],function (require) {
    var Base = require('./Base');
    var BaseUtils = require('../utils/BaseUtils');
    var Constants = require('../Constants');
    var Formatter = require('../utils/Formatter');
    var ColorUtils = require('../utils/ColorUtils');

    var PADDING = 10;

    var WIDTH = 15;
    var HEIGHT = 100;
    var BAR_WIDTH = 15;
    var BAR_HEIGHT = 10;
    var BAR_TEXT_GAP = 5;

    var TOP_BAR_PATH = 'M7.236,10H13c1.105,0,2-0.895,2-2V2c0-1.105-0.895-2-2-2L2.618,0C1.875,0,1.391,0.782,1.724,1.447l3.724,7.447C5.786,9.572,6.479,10,7.236,10z';
    var BOTTOM_BAR_PATH = 'M7.236,0L13,0c1.105,0,2,0.895,2,2v6c0,1.105-0.895,2-2,2H2.618c-0.743,0-1.227-0.782-0.894-1.447l3.724-7.447C5.786,0.428,6.479,0,7.236,0z';
    var LEFT_BAR_PATH = 'M0,7.236V13c0,1.105,0.895,2,2,2h6c1.105,0,2-0.895,2-2V2.618c0-0.743-0.782-1.227-1.447-0.894L1.106,5.447C0.428,5.786,0,6.479,0,7.236z';
    var RIGHT_BAR_PATH = 'M10,7.236V13c0,1.105-0.895,2-2,2H2c-1.105,0-2-0.895-2-2L0,2.618c0-0.743,0.782-1.227,1.447-0.894l7.447,3.724C9.572,5.786,10,6.479,10,7.236z';

    var GradientRangeLegend = Base.extend({
        _refresh: function () {
            var options = this.options, range = options.range || {};
            this.valueAndColors = range.color || this._getDefaultValueAndColors();

            var minValue = range.min, maxValue = range.max;

            if(BaseUtils.hasNotDefined(minValue) && BaseUtils.hasNotDefined(maxValue)){//自动计算
                var minMax = this.vanchart.getMinMaxFromSeries();
                var para = BaseUtils.calculateAutoMinMaxAndGap(minMax[0], minMax[1], Math.max(2, this.valueAndColors.length - 1));
                minValue = para[0];
                maxValue = para[1];
            }

            this.min = BaseUtils.pick(range.min, minValue);
            this.max = BaseUtils.pick(range.max, maxValue);

            this.valueAndColors.sort(function(d1, d2){
                return d1[0] - d2[0];
            });
            var valueArray = [];
            var colorArray = [];
            for(var i = 0, len = this.valueAndColors.length; i < len; i ++ ){
                valueArray[i] = this.valueAndColors[i][0];
                colorArray[i] = this.valueAndColors[i][1];
            }

            this.valueScale = d3.scale.linear()
                .domain([this.min, this.max])
                .range([0, 1]);

            this.colorScale = d3.scale.linear()
                .domain(valueArray)
                .range(colorArray);
        },

        _getDefaultValueAndColors: function () {
            var colors = ColorUtils.createColorsWithHsb(this.vanchart.currentOption.colors[0], 3);
            return [[0, colors[2]], [0.5, colors[1]], [1, colors[0]]];
        },

        calculateHorizontalDim: function () {
            var d1 = BaseUtils.getTextDimension(this._getGradientMinLabelContent(), this.options.style);
            var d2 = BaseUtils.getTextDimension(this._getGradientMaxLabelContent(), this.options.style);
            var gap = Math.max(d1.width, d2.width, BAR_HEIGHT);
            var width = HEIGHT + gap * 2;
            var height = WIDTH + BAR_WIDTH + BAR_TEXT_GAP + d1.height;
            return {
                width:width,
                height:height
            }
        },

        calculateVerticalDim: function () {
            var d1 = BaseUtils.getTextDimension(this._getGradientMinLabelContent(), this.options.style);
            var d2 = BaseUtils.getTextDimension(this._getGradientMaxLabelContent(), this.options.style);
            var width = WIDTH + BAR_WIDTH + BAR_TEXT_GAP + Math.max(d1.width, d2.width);
            var gap = Math.max(d1.height/2, BAR_HEIGHT/2) * 2;
            var height = HEIGHT + gap * 2;
            return {
                width:width,
                height:height
            }
        },

        getColorWithSize: function (size) {
            if (size >= this.min && size <= this.max) {
                return this.colorScale(this.valueScale(size));
            } else {
                return null;
            }
        },

        _getGradientMinLabelContent: function () {
            return this._getGradientLabelWithFormatter(this.min);
        },

        _getGradientMaxLabelContent: function () {
            return this._getGradientLabelWithFormatter(this.max);
        },

        _getGradientLabelWithFormatter: function (value) {
            var formatter = this.options.formatter;
            if(!formatter){
                return value;
            }

            return Formatter.format(value, formatter);
        },

        _getGradientLabelContent: function (value) {
            return this._getGradientLabelWithFormatter(this._gradientScale(value));
        },

        _gradientScale: function (value) {
            var unit = BaseUtils.accDiv(BaseUtils.accAdd(this.max, -this.min), HEIGHT);
            value = BaseUtils.accMul(unit, this.isHorizontal() ? value : (HEIGHT - value));
            value = BaseUtils.accAdd(value, this.min);
            return value;
        },

        _getBarBackgroundStyle: function () {
            return {
                'fill':'#eaeaea',
                'stroke-width':0
            }
        },

        _getGradientFillColor:function(isHorizontal, renderer){

            var attrs = {
                'x1':'0%',
                'y1':isHorizontal ? '0%' : '100%',
                'x2':isHorizontal ? '100%' : '0%',
                'y2':'0%'
            };

            var stop = [];
            this.valueAndColors.forEach(function(valueAndColor){
                var value = valueAndColor[0];
                var color = valueAndColor[1];

                stop.push({
                    'offset': value,
                    'stop-color':color
                })
            });

            if(this._bar.colorGradient){
                renderer.updateColorGradient(this._bar.colorGradient, attrs, stop);
            }else{
                this._bar.colorGradient = renderer.colorGradient(attrs, stop);
            }

            return "url(#" + BaseUtils.stamp(this._bar.colorGradient) +")";
        },

        _updateHorizontalGradientClipRect: function() {
            var legend = this, vanchart = legend.vanchart, renderer = vanchart.renderer;

            var attrs = {
                'x':this.minPos,
                'y':0,
                'width':this.maxPos - this.minPos,
                'height':WIDTH
            };

            if(this._bar.clipG){
                this._bar.clipG.rect && this._bar.clipG.rect.attr(attrs);
            } else {
                var clipG = this._bar.clipG = this._bar.clipG || renderer.createClip(attrs);
                renderer.clip(this._bar, clipG);
                clipG.rect && clipG.rect.attr(attrs);
            }
        },

        _updateVerticalGradientClipRect: function () {
            var legend = this, vanchart = legend.vanchart, renderer = vanchart.renderer;

            var attrs = {
                'x':0,
                'y':this.minPos,
                'width':WIDTH,
                'height':this.maxPos - this.minPos
            };

            if(this._bar.clipG){
                this._bar.clipG.rect && this._bar.clipG.rect.attr(attrs);
            } else {
                var clipG = this._bar.clipG = this._bar.clipG || renderer.createClip(attrs);
                renderer.clip(this._bar, clipG);
                clipG.rect && clipG.rect.attr(attrs);
            }
        },

        //vertical：下面的button对应：maxPos，minButton
        render: function (barGroup, bounds, divManager) {
            this.divManager = divManager;

            var legend = this, vanchart = legend.vanchart, renderer = vanchart.renderer, plotBounds = vanchart.getPlotBounds();

            var isHorizontal = legend.isHorizontal();

            var transX = isHorizontal ? (bounds.width - HEIGHT)/2 : PADDING;
            var transY = isHorizontal ? PADDING : (bounds.height - HEIGHT)/2;
            barGroup.attr('transform', BaseUtils.makeTranslate([transX, transY]));

            this._absX = bounds.x + transX;
            this._absY = bounds.y + transY;

            this.barGroup = barGroup;

            this.minPos = this.minPos || 0;//左、下
            this.maxPos = this.maxPos || HEIGHT;//右、上

            this._barBackground = this._barBackground || renderer.rect().addTo(barGroup);
            this._bar = this._bar || renderer.rect().addTo(barGroup);
            this._minButton = this._minButton || renderer.path().style({'cursor': 'pointer'}).addTo(barGroup);
            this._maxButton = this._maxButton || renderer.path().style({'cursor': 'pointer'}).addTo(barGroup);
            this._minLabel = this._minLabel || renderer.text().addTo(barGroup);
            this._maxLabel = this._maxLabel || renderer.text().addTo(barGroup);

            renderer.registerInteractiveTarget(this, this._minButton);
            renderer.registerInteractiveTarget(this, this._maxButton);

            var rectAttr = {
                'rx': 2,
                'ry': 2,
                'x': 0,
                'y': 0,
                'width': isHorizontal ? HEIGHT : WIDTH,
                'height': isHorizontal ? WIDTH : HEIGHT
            };

            this._barBackground
                .style(this._getBarBackgroundStyle())
                .attr(rectAttr);

            this._bar
                .attr(rectAttr)
                .style({
                    'fill':this._getGradientFillColor(isHorizontal, renderer),
                    'stroke-width':0
                });

            this._minButton
                .attr('d', isHorizontal ? LEFT_BAR_PATH : TOP_BAR_PATH);

            this._maxButton
                .attr('d', isHorizontal ? RIGHT_BAR_PATH : BOTTOM_BAR_PATH);

            if(!this.options.useHtml) {
                this._minLabel.attr('dy', '.32em')
                    .style(this.options.style);

                this._maxLabel.attr('dy', '.32em')
                    .style(this.options.style);
            }

            this._updateMax();
            this._updateMin();
        },

        _updateMin: function () {
            this.isHorizontal() ? this._updateHorizontalMinBar()
                : this._updateVerticalMinBar();
        },

        _updateMax: function () {
            this.isHorizontal() ? this._updateHorizontalMaxBar()
                : this._updateVerticalMaxBar();
        },

        //下面的
        _updateVerticalMinBar: function() {

            this._minButton
                .attr('transform', 'translate('+ WIDTH  +','+ this.maxPos +')')
                .style({'fill':this.colorScale((HEIGHT - this.maxPos)/HEIGHT)});

            var label = this._getGradientLabelContent(this.maxPos);
            var labelDim = BaseUtils.getTextDimension(label, this.options.style, true);
            var innerX = Math.round(WIDTH + BAR_WIDTH + BAR_TEXT_GAP + labelDim.width / 2),
            innerY = Math.round(this.maxPos + BAR_HEIGHT / 2);

            if(this.options.useHtml) {
                if(this._minLabel){
                    this.divManager.clearLabels('_range_legend_bottom_label');
                }
                this._minLabel = this.divManager.addLabel(label, {x:innerX - labelDim.width/2 + this._absX, y:innerY - labelDim.height/2 + this._absY, width:labelDim.width, height:labelDim.height}, this.options.style, '_range_legend_bottom_label', true);
            } else {

                this._minLabel.textContent(label).attr('text-anchor', 'middle')
                    .attr('x', innerX)
                    .attr('y', innerY);
            }

            this._updateVerticalGradientClipRect();
        },

        //左边的
        _updateHorizontalMinBar: function() {
            var x = this.minPos - BAR_HEIGHT;

            this._minButton
                .attr('transform', 'translate('+ x  +','+ WIDTH +')')
                .style({'fill': this.colorScale(this.minPos/HEIGHT)});

            var label = this._getGradientLabelContent(this.minPos);
            var labelDim = BaseUtils.getTextDimension(label, this.options.style, true);

            var innerX = Math.round(this.minPos - labelDim.width),
                innerY = Math.round(WIDTH + BAR_WIDTH + BAR_TEXT_GAP + labelDim.height/2);

            if(this.options.useHtml) {
                if(this._minLabel){
                    this.divManager.clearLabels('_range_legend_left_label');
                }
                this._minLabel = this.divManager.addLabel(label, {x:innerX + this._absX, y:innerY - labelDim.height/2 + this._absY, width:labelDim.width, height:labelDim.height}, this.options.style, '_range_legend_left_label', true);
            } else {

                this._minLabel.textContent(label).attr('text-anchor', 'right')
                    .attr('x', innerX)
                    .attr('y', innerY);
            }

            this._updateHorizontalGradientClipRect();
        },


        //上面的
        _updateVerticalMaxBar: function() {
            var y = this.minPos - BAR_HEIGHT;

            this._maxButton
                .attr('transform', 'translate('+ WIDTH  +','+ y +')')
                .style({'fill': this.colorScale((HEIGHT - this.minPos)/HEIGHT)});

            var label = this._getGradientLabelContent(this.minPos);
            var labelDim = BaseUtils.getTextDimension(label, this.options.style, true);

            var innerX = Math.round(WIDTH + BAR_WIDTH + BAR_TEXT_GAP + labelDim.width/2),
                innerY = Math.round(this.minPos - BAR_HEIGHT/2);

            if(this.options.useHtml) {
                if(this._maxLabel){
                    this.divManager.clearLabels('_range_legend_top_label');
                }
                this._maxLabel = this.divManager.addLabel(label, {x:innerX - labelDim.width/2 + this._absX, y:innerY - labelDim.height/2 + this._absY, width:labelDim.width, height:labelDim.height}, this.options.style, '_range_legend_top_label', true);
            } else {

                this._maxLabel.textContent(label).attr('text-anchor', 'middle')
                    .attr('x', innerX)
                    .attr('y', innerY);
            }

            this._updateVerticalGradientClipRect();
        },

        //右边的
        _updateHorizontalMaxBar: function() {
            this._maxButton
                .attr('transform', 'translate('+ this.maxPos  +','+ WIDTH +')')
                .style({'fill': this.colorScale(this.maxPos/HEIGHT)});

            var label = this._getGradientLabelContent(this.maxPos);
            var labelDim = BaseUtils.getTextDimension(label, this.options.style, true);

            var innerX = Math.round(this.maxPos),
                innerY = Math.round(WIDTH + BAR_WIDTH + BAR_TEXT_GAP + labelDim.height/2);

            if(this.options.useHtml) {
                if(this._maxLabel){
                    this.divManager.clearLabels('_range_legend_right_label');
                }
                this._maxLabel = this.divManager.addLabel(label, {x:innerX + this._absX, y:innerY - labelDim.height/2 + this._absY, width:labelDim.width, height:labelDim.height}, this.options.style, '_range_legend_right_label', true);
            } else {

                this._maxLabel.textContent(label).attr('text-anchor', 'left')
                    .attr('x', innerX)
                    .attr('y', innerY);
            }

            this._updateHorizontalGradientClipRect();
        },

        getEvents:function(){
            return {
                "panstart":this._panStart,
                "panmove":this._panMove,
                "panend":this._panEnd
            }
        },

        _panStart:function(ev){
            this.eventTarget = null;

            var event = ev.srcEvent, src = event.target || event.srcElement;

            while (src) {
                if(src == this._minButton.rawElement){
                    this.eventTarget = this._minButton;
                }else if(src == this._maxButton.rawElement){
                    this.eventTarget = this._maxButton;
                }

                if (this.eventTarget || src == this.barGroup.rawElement){
                    break;
                }
                src = src.parentNode;
            }

            this.currentX = ev.containerPoint[0];
            this.currentY = ev.containerPoint[1];
        },

        _panMove: function (ev) {
            if(this.eventTarget == this._minButton){
                this._minButtonMove(this.currentX, this.currentY, ev.containerPoint[0], ev.containerPoint[1]);

            } else if(this.eventTarget == this._maxButton){
                this._maxButtonMove(this.currentX, this.currentY, ev.containerPoint[0], ev.containerPoint[1]);
            }
        },

        _minButtonMove: function (oldX, oldY, currentX, currentY) {
            var change = 0;
            if(this.isHorizontal()){//left
                var temp = this.minPos;
                this.minPos += Math.round(currentX - oldX);
                this.minPos = Math.max(this.minPos, 0);
                this.minPos = Math.min(this.minPos, this.maxPos);
                change = this.minPos - temp;
            } else {//bottom
                var temp = this.maxPos;
                this.maxPos += Math.round(currentY - oldY);
                this.maxPos = Math.min(this.maxPos, HEIGHT);
                this.maxPos = Math.max(this.maxPos, this.minPos);
                change = this.maxPos - temp;
            }

            if(Math.abs(change) >= 1) {
                this.currentX = currentX;
                this.currentY = currentY;
                this._updateMin();
                this.refreshPoints();
            }
        },

        _maxButtonMove: function (oldX, oldY, currentX, currentY) {
            var change = 0;
            if(this.isHorizontal()){//right
                var temp = this.maxPos;
                this.maxPos += Math.round(currentX - oldX);
                this.maxPos = Math.min(this.maxPos, HEIGHT);
                this.maxPos = Math.max(this.maxPos, this.minPos);
                change = this.maxPos - temp;
            } else {//top
                var temp = this.minPos;
                this.minPos += Math.round(currentY - oldY);
                this.minPos = Math.max(this.minPos, 0);
                this.minPos = Math.min(this.minPos, this.maxPos);
                change = this.minPos - temp;
            }
            if(Math.abs(change) >= 1) {
                this.currentX = currentX;
                this.currentY = currentY;
                this._updateMax();
                this.refreshPoints();
            }
        },

        _panEnd: function (ev) {
            this.eventTarget = null;
        },

        refreshPoints: function () {
            var minSize = this._gradientScale(this.minPos);
            var maxSize = this._gradientScale(this.maxPos);
            var vanChart = this.vanchart, series = vanChart.series;
            var change = false, hasMap = vanChart.vanChartType == 'vanChartMap';

            var points;
            for(var chartType in series) {
                var chartSeries = series[chartType];
                for (var i = 0, len = chartSeries.length; i < len; i++) {
                    var sery = chartSeries[i];

                    sery.points.forEach(function (point) {

                        if (!hasMap || (hasMap && point.points && point.points[0] == point)) {
                            var temp = point.visible;

                            var size = point.getTargetValue();

                            point.visible = (size >= minSize && size <= maxSize) || (size >= maxSize && size <= minSize);

                            change = change || temp != point.visible;

                            if (hasMap) {
                                points = point.points;
                                for (var i = 1, len = points.length; i < len; i++) {
                                    points[i].visible = point.visible;
                                }
                            }
                        }
                    });
                }
            }

            if(change) {
                vanChart.filterRender();
            }
        }

    });

    return GradientRangeLegend;

});

/**
 * Created by Mitisky on 16/3/21.
 */
define ('component/RangeLegend',['require','./Base','../utils/BaseUtils','../Constants','../utils/ColorUtils','../utils/Formatter','../ComponentLibrary','../utils/LabelDivManager','./IntervalRangeLegend','./GradientRangeLegend'],function(require){
    var Base = require('./Base');
    var BaseUtils = require('../utils/BaseUtils');
    var Constants = require('../Constants');
    var ColorUtils = require('../utils/ColorUtils');
    var Formatter = require('../utils/Formatter');
    var ComponentLibrary = require('../ComponentLibrary');
    var LabelDivManager = require('../utils/LabelDivManager');

    var IntervalRangeLegend = require('./IntervalRangeLegend');
    var GradientRangeLegend = require('./GradientRangeLegend');

    var PADDING = 10;

    var RangeLegend = Base.extend({

        _refresh: function () {
            var options = this.options;

            if(this._legend && this._legend.continuous != options.continuous){
                this._legend.remove();
                this._legend = null;
            }

            if(this._legend){
                this._legend.refresh(options);
            } else {
                var legendClass = options.continuous ? GradientRangeLegend : IntervalRangeLegend;

                this._legend = new legendClass(options, this.componentType, this.vanchart);
                this._legend.continuous = options.continuous;
            }
        },

        doLayout: function () {

            if(this.invisible()){
                this.remove();
                return ;
            }

            this._legend.doLayout && this._legend.doLayout();

            var cfg = this.options;
            var position = cfg.position || Constants.RIGHT;
            var gap = PADDING * (this.isFloat ? 2 : 4);//*4: 两边*内外边距

            if(position == Constants.TOP || position == Constants.BOTTOM){
                this._layoutHorizontal(position, gap);
            } else {
                this._layoutVertical(position, gap);
            }

            if(!this.isFloat) {
                var outGap = this.options.borderWidth + PADDING * 2;
                this.bounds.x += outGap/2;
                this.bounds.y += outGap/2;
                this.bounds.width -= outGap;
                this.bounds.height -= outGap;

                if(position == Constants.BOTTOM) {
                    var zoomComponent = this.vanchart.getComponent(ComponentLibrary.ZOOM_COMPONENT);
                    if (zoomComponent && zoomComponent.zoomToolEnabled() && zoomComponent.bounds) {
                        this.bounds.y += zoomComponent.bounds.height || 0;
                    }
                }

                if(position == Constants.RIGHT || position == Constants.RIGHT_TOP){
                    var tools = this.vanchart.getComponent(ComponentLibrary.TOOLBAR_COMPONENT);
                    if(tools){
                        this.bounds.y += 37;
                    }
                }

            }
        },

        _layoutHorizontal: function (position, gap) {
            var dim = this._legend.calculateHorizontalDim();

            var usedSize = dim.height + gap;

            usedSize = this.options.maxHeight ? Math.min(usedSize, this._maxHeight()) : usedSize;

            this._setComponentBounds(position, usedSize);

            var width = dim.width + gap;
            if (!this.isFloat) {
                this.bounds.x += Math.max((this.bounds.width - width)/2, 0);
            }
            this.bounds.width = width;
        },

        _layoutVertical: function (position, gap) {
            var dim = this._legend.calculateVerticalDim();

            var usedSize = dim.width + gap;

            usedSize = this.options.maxWidth ? Math.min(usedSize, this._maxWidth()) : usedSize;

            this._setComponentBounds(position, usedSize);

            var height = dim.height + gap;
            if (!this.isFloat && position != Constants.RIGHT_TOP) {
                this.bounds.y += Math.max((this.bounds.height - height)/2, 0);
            }
            this.bounds.height = height;
        },

        getColorWithSize: function (size) {
            return this._legend.getColorWithSize(size);
        },

        render:function(){
            if(this.invisible()){
                return ;
            }

            var bounds = this.bounds, legend = this, vanchart = legend.vanchart, renderer = vanchart.renderer;

            if(!this.group){
                this.group = renderer.group().add();
                this.backgroundGroup = renderer.group().addTo(this.group);
                this.legendGroup = renderer.group().addTo(this.group);


                if(this.vanchart._leaflet){
                    this.group.style('pointer-events', 'all');
                }
            }

            this._innerClip(this.group);
            this.group.attr('transform', BaseUtils.makeTranslate(bounds));

            vanchart._renderRectangleBackground(this.backgroundGroup, this.options, BaseUtils.makeBounds(0,0,bounds.width, bounds.height));

            this.divManager = this.divManager || new LabelDivManager(this.vanchart.dom);
            this._legend.render(this.legendGroup, bounds, this.divManager);
        },

        remove: function () {
            this.group && this.group.remove();
            this.group = null;
        }
    });

    ComponentLibrary.register(ComponentLibrary.RANGE_LEGEND_COMPONENT, RangeLegend);
    return RangeLegend;

});

define('component/Polar',['require','../Constants','../utils/BaseUtils','./Base','../ComponentLibrary'],function(require) {
    var Constants = require('../Constants');
    var BaseUtils = require('../utils/BaseUtils');
    var Base = require('./Base');
    var ComponentLibrary = require('../ComponentLibrary');

    var Polar = Base.extend({

        _refresh:function(){
            this.series = [];
        },

        doLayout: function () {
            var option = this.options;

            var radius = option.radius;
            var center = option.center;

            // keep origin radius (include null)
            // adjust radius by angleAxis later

            if (!center || center.length === 0) {
                var plotBounds = this.vanchart.getPlotBounds();
                center = [
                    plotBounds.width / 2 + plotBounds.x,
                    plotBounds.height / 2 + plotBounds.y
                ];
            }

            this.setCenter(center);

            if(BaseUtils.hasDefined(radius)){
                this.setRadius(radius);
            }else{
                this.radius = null;
            }

            var plotOptions = this.vanchart.currentOption.plotOptions;
            var shape = (plotOptions.radar && plotOptions.radar.shape) || plotOptions.shape;
            
            this.shape = shape || this.shape;
        },

        /**
         * set polar radius and update radiusAxis scale
         * @param {number|string} radius
         */
        setRadius: function (radius) {
            if (!radius) {
                return;
            }

            this.radius = this._getPercentValue(
                radius,
                Math.min(this.vanchart.width, this.vanchart.height) / 2
            );

            this.radiusAxis.scale && this.radiusAxis._updateInitRange();
        },

        /**
         * set polar center
         * @param {number[]|string[]} center
         */
        setCenter: function (center) {
            if (!center) {
                return;
            }

            this.center = [];

            this.center[0] = this._getPercentValue(center[0], this.vanchart.width);

            this.center[1] = this._getPercentValue(center[1], this.vanchart.height);
        },

        // useless now
        getPolarInitPoint: function () {
            // begin from 0 at present
            return BaseUtils.getArcPoint(this.polar.radius, 0);
        },

        updateDomainAndTickData:function(){

        },

        updateClipBounds: function () {

        },

        render: function () {
            var R = this.vanchart.renderer, radiusAxis = this.radiusAxis;
            var clipPath = {'d': radiusAxis._getRadiusGridPath(radiusAxis.scale.domain()[1])};
            if (!this.clip) {
                this.clip = R.createClip(clipPath, 'path');
            }else{
                this.clip.path && this.clip.path.attr(clipPath);
            }

            this.radiusAxis.render();
            this.angleAxis.render();
        }
    });
    
    ComponentLibrary.register(Constants.POLAR_COMPONENT, Polar);
    return Polar;
});
/**
 * Created by Yuqian on 16/8/17.
 */
define('component/AngleAxis',['require','./Base','./CategoryAxis','../utils/BaseUtils','../Constants','../ComponentLibrary'],function(require){
    var Base = require('./Base');
    var CategoryAxis = require('./CategoryAxis');
    var BaseUtils = require('../utils/BaseUtils');
    var Constants = require('../Constants');
    var ComponentLibrary = require('../ComponentLibrary');

    var PADDING_GAP = 10;

    var TIME = 400;

    var TOP = 'radar-top';
    var BOTTOM = 'radar-bottom';
    var LEFT = 'radar-left';
    var RIGHT = 'radar-right';

    var AngleAxis = CategoryAxis.extend({

        _refresh:function(options){
            this.series = [];

            //for category axis
            this.isRangePoints = true;

            this.animation = this.vanchart.isSupportAnimation();

            this.piece = null;

            this.refreshPolar(options);
        },

        refreshPolar: function (axisOption) {
            this.polar = this.vanchart.polar(axisOption.axisIndex);
            this.polar.angleAxis = this;
        },

        updateClipBounds: function () {
        },

        doLayout:function(){

            this.initAttributesWithSeries();

            //
            this.isRangePoints = true;
            this.piece = (Math.PI * 2) / Math.max(this.categories.length, 1);

            this._updatePolarBounds();
        },

        _calculateTickData:function(){
            var radius = this.polar.radius;
            this.tickData.map(function (t) {
                this._getCateLabelBounds(radius, t);
            }, this);
            this._updateMainAndMinorTickData();
        },

        _updatePolarBounds: function () {

            if (this.polar.radius) {
                return;
            }

            // no radius setting, auto adjust
            var plotBounds = this.vanchart.getPlotBounds();
            var center = this.polar.center;

            var tmpBounds = [
                // 0 top
                center[1] - plotBounds.y,
                // 1 right
                plotBounds.x + plotBounds.width - center[0],
                // 2 bottom
                plotBounds.y + plotBounds.height - center[1],
                // 3 left
                center[0] - plotBounds.x
            ];

            var radius = Math.min.apply(null, tmpBounds);
            radius -= PADDING_GAP;

            var testBounds = {
                x: - tmpBounds[3],
                y: - tmpBounds[0],
                width: plotBounds.width,
                height: plotBounds.height
            };

            if (this.options.showLabel) {
                if (!this._testRadius(radius, testBounds)) {
                    radius = this._findNiceRadius(testBounds);
                    this._testRadius(radius, testBounds);
                }
            }

            this.polar.setRadius(radius);

        },

        _updateAxisScale:function(start, end){

            if (start == -1 || end == -1) {
                return;
            }

            var range = [0, this.categories.length - 1];

            this.scale.rangePoints(range);
        },

        getIndexByPosition: function (pos) {
            return this._getIndexByPolarCoordinate(pos);
        },

        _getIndexByPolarCoordinate: function (pos) {
            var center = this.polar.center;
            var r = this.polar.radius;
            var isReversed = this.isAxisReversed();

            var x = pos[0]-center[0];
            var y = center[1]-pos[1];

            if ((x*x + y*y) > r*r) {
                return -1;
            }

            var arc = BaseUtils.getArcByPoint(x, y);

            var index;
            var categories = this.getCategories();
            if (categories.length > 1) {
                var unitLength = 2 * Math.PI / categories.length;
                index = isReversed ? categories.length - 1 - arc / unitLength : arc / unitLength;
            } else {
                index = 0;
            }

            index = Math.round(index);

            index = index % categories.length;

            return index;
        },

        getAngleGridLineData: function () {

            var points = [];

            var angleAxis = this.polar.angleAxis;
            var categories = angleAxis.scale.domain();
            var self = this;

            categories.forEach(function(category){

                var radian = angleAxis.scale(category) * angleAxis.piece;

                var r = self.polar.radius;

                points.push(BaseUtils.getArcPoint(r, radian));

            });

            points = points.length ? points : [BaseUtils.getArcPoint(this.polar.radius, 0)];

            return points;
        },

        _testRadius:function(radius, testBounds){

            for(var i = 0, count = this.tickData.length; i < count; i++){

                var tick = this.tickData[i];
                var labelBounds = this._getCateLabelBounds(radius, tick);

                if(!BaseUtils.containsRect(testBounds, labelBounds)){
                    return false;
                }

            }
        },

        _getCateLabelBounds:function(radius, cateTick){

            var category = cateTick.tickValue;
            var dim = cateTick.tickRectDim;
            var domain = this.scale.domain();
            var index = domain.indexOf(category);
            var arcPoint = BaseUtils.getArcPoint(radius + PADDING_GAP, index * this.piece);
            var pos;

            var position = this._getPolarPosition(category);

            switch (position){

                case TOP:

                    pos = {
                        x:-dim.width/2,
                        y:-radius - dim.height * 0.65 - PADDING_GAP
                    };

                    break;

                case RIGHT:

                    pos = {
                        x:arcPoint[0],
                        y:arcPoint[1] - dim.height/2
                    };

                    break;

                case BOTTOM:

                    pos = {
                        x:-dim.width/2,
                        y:radius + PADDING_GAP
                    };

                    break;

                case LEFT:

                    pos = {
                        x:arcPoint[0] - dim.width,
                        y:arcPoint[1] - dim.height/2
                    };

                    break;
            }

            cateTick.tickPos = pos;
            return BaseUtils.makeBounds(pos, dim);
        },

        _getPolarPosition:function(category){

            var domain = this.scale.domain();
            var index = domain.indexOf(category);
            var midIndex = domain.length / 2;

            if(index == 0){
                return TOP;
            }else if(index > 0 && index < midIndex){
                return RIGHT;
            }else if(index == midIndex){
                return BOTTOM;
            }else if(index > midIndex){
                return LEFT;
            }

        },

        _findNiceRadius:function(testBounds){

            var tmpBounds = [
                - testBounds.y,
                testBounds.width - testBounds.x,
                testBounds.height + testBounds.y,
                - testBounds.x
            ];

            var minRadius = Math.min.apply(null, tmpBounds);

            var domain = this.scale.domain();
            var self = this;

            this.tickData.forEach(function(cateTick){
                if(cateTick.tickContent){

                    var category = cateTick.tickValue;
                    var tickDim = cateTick.tickDim;

                    var index = domain.indexOf(category);
                    var position = self._getPolarPosition(category);

                    var radius;
                    switch (position) {
                        case TOP:
                            radius = tmpBounds[0] - tickDim.height;
                            break;
                        case RIGHT:
                            radius = (tmpBounds[1] - tickDim.width) / Math.abs(Math.sin(index * self.piece));
                            break;
                        case BOTTOM:
                            radius = tmpBounds[2] - tickDim.height;
                            break;
                        case LEFT:
                            radius = (tmpBounds[3] - tickDim.width) / Math.abs(Math.sin(index * self.piece));
                            break;
                        default:
                    }

                    minRadius = Math.min(minRadius, radius);
                }
            });

            return minRadius - PADDING_GAP;
        },

        getPointsInCategory: function (containerPoint) {
            var center = this.polar.center;
            var r = this.polar.radius;
            var isReversed = this.isAxisReversed();

            var x = containerPoint[0]-center[0];
            var y = center[1]-containerPoint[1];

            if ((x*x + y*y) > r*r) {
                return null;
            }

            var arc = BaseUtils.getArcByPoint(x, y);

            var domain = this.scale.domain(), range = this.scale.rangeExtent();
            range = this._getRangeWithMinMax(range[0], range[1]);
            var tmpScale = d3.scale.quantize().domain(range).range(domain);
            var l = domain.length, index = Math.round(arc / ( 2 * Math.PI ) * l ) % l;
            var category = tmpScale(index);
            return this.vanchart.cateMap[category];
        },

        render:function(){

            var vanchart = this.vanchart, renderer = vanchart.renderer;

            if(!this.axisGroup){
                this.axisGroup = renderer.vgroup().add();
            }

            this.axisGroup.attr('transform', BaseUtils.makeTranslate(this.polar.center));

            this._drawAxisLine(this.axisGroup);

            this._drawGridLine(this.axisGroup);

            this._drawTickLabel(this.axisGroup);
        },

        _drawAxisLine:function(axisGroup){
            var R = this.vanchart.renderer;
            var radiusAxis = this.polar.radiusAxis;

            var angleAxis = this;
            var lineWidth = angleAxis.options.lineWidth;
            var lineColor = angleAxis.options.lineColor;
            var maxValue = radiusAxis.scale.domain()[1];

            if (!this.axisLine) {
                this.axisLine = axisGroup.append(R.path());
            }

            this.axisLine
                .attr({
                    d: radiusAxis._getRadiusGridPath(maxValue)
                })
                .style({
                    fill:'none',
                    'stroke':lineColor,
                    'stroke-width':lineWidth
                });
        },

        _drawGridLine:function(axisGroup){
            var R = this.vanchart.renderer;

            // 'angle grid line' is like xAxis grid line
            // but now we name it radiusAxis axisLine in options
            // so
            var cfg = this.polar.radiusAxis.options;
            var lineWidth = cfg.lineWidth;
            var lineColor = cfg.lineColor;

            if(!this.gridLinesGroup){
                this.gridLinesGroup = axisGroup.append(R.group());
                this.gridLines = [];
            }
            var gridLinesGroup = this.gridLinesGroup;

            var axisLineData = this.getAngleGridLineData();

            var selection = this._bindData(this.gridLines, axisLineData);

            selection.exit.map(function (d) {
                d.remove();
            });

            var enter = selection.enter.map(function (d) {
                return gridLinesGroup.append(R.line()).datum(d);
            });

            this.gridLines =
                enter.concat(selection.update).map(function (ele) {
                    var d = ele.datum();
                    return ele.style({'stroke':lineColor, 'stroke-width':lineWidth})
                            .attr({x1:0, y1:0, x2: d[0], y2: d[1]});
            });
        },

        _drawTickLabel:function(axisGroup){
            this._drawSvgTickLabel(axisGroup);
        },

        _drawSvgTickLabel:function(axisGroup){
            var R = this.vanchart.renderer;
            var angleAxis = this;
            var cfg = angleAxis.options;

            var labelStyle = cfg.labelStyle;
            var useHtml = cfg.useHtml;

            var ticks = angleAxis.tickData;

            if(!this.tickLabelsGroup){
                this.tickLabelsGroup = axisGroup.append(R.vgroup());
                this.tickLabels = [];
            }
            var tickLabelsGroup = this.tickLabelsGroup;

            var selection = this._bindData(this.tickLabels, ticks, function(d){return d.tickValue});

            selection.exit.map(function (d) {
                d.remove();
            });

            if(cfg.showLabel){

                var enter = selection.enter.map(function (d) {
                    return tickLabelsGroup.append(R.vtext(useHtml).datum(d));
                });

                var px = useHtml ? 'px' : '';
                this.tickLabels = enter.concat(selection.update)
                    .filter(function (ele) {return ele.datum().tickPos;})
                    .map(function (ele) {
                        var d = ele.datum();

                        var tx = d.tickPos.x,
                            ty = d.tickPos.y;

                        var attr = {
                            transform: 'translate(' + tx + px + ' ' + ty + px + ')',
                            dy: '0.85em'
                        };

                        ele.textContent(d.tickContent)
                            .style(labelStyle)
                            .attr(attr);

                        ele.vRotate(d.labelRotation);

                        return ele;
                    });

            }
        },

        drawHighlightBackground: function (sharedPoints) {
            var category = sharedPoints[0].category;
            var scale = this.scale, columnType = this.series[0] && this.series[0].columnType || false;
            var R = this.vanchart.renderer;

            var domain = scale.domain();

            var r = this.polar.radius;
            var radian = scale(category) / domain.length * 2 * Math.PI;

            if (columnType) {
                var halfSize = 1 / domain.length * 2 * Math.PI * 0.5;
                var startRadian = radian - halfSize;
                var endRadian = radian + halfSize;

                var arc = d3.svg.arc()
                    .innerRadius(0)
                    .outerRadius(r)
                    .startAngle(startRadian)
                    .endAngle(endRadian);

                if (!this.highlightBand) {
                    this.highlightBand = this.axisGroup.append(R.path({
                        'fill': 'rgba(98,179,240,0.2)'
                    }));
                }

                this.highlightBand.attr('d', arc());
            } else {
                var point = BaseUtils.getArcPoint(r, radian);

                if (!this.highlightLine) {
                    this.highlightLine = this.axisGroup.append(R.line({
                        'stroke': 'rgb(140,140,140)',
                        'stroke-width': '1'
                    }));
                }

                this.highlightLine.attr('x2', point[0]).attr('y2', point[1]);
            }
        },

        remove:function(){
            this.axisGroup && this.axisGroup.remove();
            this.axisGroup = null;
        }

    });

    ComponentLibrary.register(ComponentLibrary.ANGLE_AXIS_COMPONENT, AngleAxis);
    return AngleAxis;
});
/**
 * Created by Yuqian on 16/8/17.
 */
define('component/RadiusAxis',['require','./Base','./ValueAxis','../utils/BaseUtils','../Constants','../ComponentLibrary'],function(require){
    var Base = require('./Base');
    var ValueAxis = require('./ValueAxis');
    var BaseUtils = require('../utils/BaseUtils');
    var Constants = require('../Constants');
    var ComponentLibrary = require('../ComponentLibrary');

    var TIME = 400;
    var RADIUS_AXIS_GRID_LINE = 'radius-axis-grid-line';
    var PLOT_BANDS = 'plot-bands';
    var PLOT_LINES = 'plot-lines';
    var VALUE_LINE = 'value-axis-line';
    var VALUE_TICK_GAP = 2;
    var VALUE_TEXT = 'value-axis-tick-text';

    var RadiusAxis = ValueAxis.extend({

        _refresh:function(options){
            this.series = [];

            this.animation = this.vanchart.isSupportAnimation();

            this.refreshPolar(options);
        },

        refreshPolar: function (axisOption) {
            this.polar = this.vanchart.polar(axisOption.axisIndex);
            this.polar.radiusAxis = this;
        },

        doLayout:function(){

            this.initAttributesWithSeries();

        },

        updateClipBounds: function () {
        },

        _getRange:function(){
            return [0, this.polar.radius];
        },

        getRadiusPlotBands:function(){

            var plotBands = this._getPlotBands();

            var result = [];

            var self = this;

            plotBands.forEach(function(d){
                result.push({
                    path: self._getRadiusPlotBandsPath(d.from, d.to),
                    color: d.color
                });
            });

            return result;
        },

        _getRadiusPlotBandsPath: function (from, to) {

            var shape = this.polar.shape;

            if (shape === Constants.POLYGON_RADAR) {
                return this._getRadiusGridPath(Math.min(from, to)) + this._getRadiusGridPath(Math.max(from, to), true)
            } else {
                var arc = d3.svg.arc().startAngle(0).endAngle(2 * Math.PI);
                return arc.innerRadius(this.scale(Math.min(from, to)))
                    .outerRadius(this.scale(Math.max(from, to)))();
            }

        },

        getPlotLines:function(){

            var plotLines = this.options.plotLines || [];
            var self = this;

            var result = [];
            plotLines.forEach(function(d){

                var text, style, align;
                if(d.label && d.label.text && d.label.style){
                    text = d.label.text;
                    style = d.label.style;
                    align = d.label.align;
                }

                result.push({
                    color: d.color,
                    value: d.value,
                    width: d.width,
                    dataArray:Constants.DASH_TYPE[d.dashStyle],
                    text:text,
                    baseY:-self.scale(d.value),
                    textAnchor:align == Constants.LEFT ? 'end' : 'start',
                    style:style
                });
            });

            return result;
        },

        // radius grids are circles
        _getRadiusGridPath: function (value, reversed) {

            var data = this._getRadiusGridData(value, reversed);

            return this._getRadiusGridPathByData(data);
        },

        _getRadiusGridData: function (value, reversed, scale) {

            var radiusScale = scale || this.scale;
            var angleAxis = this.polar.angleAxis;

            var shape = this.polar.shape;

            if (shape === Constants.POLYGON_RADAR) {

                var points = [];

                var cateScale = angleAxis.scale;
                var categories = cateScale.domain();

                categories.forEach(function(category){

                    var radian = cateScale(category) * angleAxis.piece;

                    var r = radiusScale(value);

                    points.push(BaseUtils.getArcPoint(r, radian));

                });

                if (reversed) {
                    points.reverse();
                }

                return points;

            } else {
                return radiusScale(value);
            }
        },

        _getRadiusGridPathByData: function(data) {

            if(BaseUtils.isArray(data)){

                var path = "";

                if(data.length){
                    for(var i = 0, count = data.length; i < count; i++){

                        var mOrl = i ? 'L' : 'M';

                        path += (mOrl + BaseUtils.dealFloatPrecision(data[i][0]) + "," + BaseUtils.dealFloatPrecision(data[i][1]));
                    }

                    path += 'Z';
                }

                return path;

            }else{

                var arc = d3.svg.arc().startAngle(0).endAngle(2 * Math.PI).innerRadius(0);

                return arc.outerRadius(data)();
            }

        },

        render:function(){

            var vanchart = this.vanchart, renderer = vanchart.renderer;

            if(!this.axisGroup){
                this.axisGroup = renderer.vgroup().add();
                renderer.clip(this.axisGroup.renderG, this.polar.clip);
            }

            this.axisGroup.attr('transform', BaseUtils.makeTranslate(this.polar.center));

            this._drawGridLine(this.axisGroup);

            this._drawPlotBands(this.axisGroup);

            this._drawPlotLines(this.axisGroup);

            this._drawTickLabel(this.axisGroup);
        },

        _drawGridLine:function(axisGroup){
            var R = this.vanchart.renderer;

            var radiusAxis = this;
            var animation = radiusAxis.animation;
            var lastScale = radiusAxis.lastScale || radiusAxis.scale;
            var cfg = radiusAxis.options;
            var ticks = radiusAxis.getTickData();
            var gridLineColor = cfg.gridLineColor;
            var gridLineWidth = cfg.gridLineWidth;

            if(!this.gridLinesGroup){
                this.gridLinesGroup = axisGroup.append(R.group());
                this.gridLines = [];
            }
            var gridLinesGroup = this.gridLinesGroup;

            var selection = this._bindData(this.gridLines, ticks);

            selection.exit.map(function (ele) {
                if (animation) {
                    var d = ele.datum();
                    var prePos = radiusAxis._getRadiusGridData(d.tickValue, false, lastScale);
                    var curPos = radiusAxis._getRadiusGridData(d.tickValue);
                    d3.select(ele.node())
                        .transition()
                        .attrTween('d', function () {
                            var interpolate = d3.interpolate(prePos, curPos);

                            return function (t) {
                                return radiusAxis._getRadiusGridPathByData(interpolate(t));
                            };
                        }).remove();

                } else {
                    ele.remove();
                }
            });

            var enter = selection.enter.map(function (d) {
                return gridLinesGroup.append(R.path()).datum(d);
            });

            this.gridLines = enter.concat(selection.update).map(function (ele) {
                var d = ele.datum();
                var curPos = radiusAxis._getRadiusGridData(d.tickValue);

                ele.style({
                    fill: 'none',
                    'stroke': gridLineColor,
                    'stroke-width': gridLineWidth,
                    'opacity': 1
                });

                if (animation) {
                    var prePos = radiusAxis._getRadiusGridData(d.tickValue, false, lastScale);
                    d3.select(ele.node())
                        .transition()
                        .attrTween('d', function () {
                            var interpolate = d3.interpolate(prePos, curPos);

                            return function (t) {
                                return radiusAxis._getRadiusGridPathByData(interpolate(t));
                            };
                        })

                } else {
                    ele.attr({
                        'd': radiusAxis._getRadiusGridPathByData(curPos)
                        });
                }
                return ele;
            });

        },

        _drawPlotLines: function (axisGroup) {
            var R = this.vanchart.renderer, animation = this.animation;

            var plotLines = this.getPlotLines();

            if(!this.plotLinesGroup){
                this.plotLinesGroup = axisGroup.append(R.vgroup());
                this.plotLines = [];
            }
            var plotLinesGroup = this.plotLinesGroup;

            var selection = this._bindData(this.plotLines, plotLines);

            selection.exit.map(function (layer) {
                layer.text && layer.text.remove();
                layer.remove();
            });

            var enter = selection.enter.map(function (d) {
                var path = plotLinesGroup.append(R.path().datum(d));
                if (d.text) {
                    path.text = plotLinesGroup.append(R.vtext());
                }
                return path;
            });

            this.plotLines = enter.concat(selection.update).map(function (ele) {
                var d = ele.datum();
                var path = this._getRadiusGridPath(d.value);
                if (animation) {
                    d3.select(ele.node())
                        .transition().attr('d', path)
                        .style({
                            'fill': 'none',
                            'stroke': d.color,
                            'stroke-width': d.width,
                            'stroke-dasharray': d.dataArray
                        })
                } else {
                    ele
                        .attr('d', path)
                        .style({
                            'fill': 'none',
                            'stroke': d.color,
                            'stroke-width': d.width,
                            'stroke-dasharray': d.dataArray
                        })
                }

                ele.text && ele.text.textContent(d.text).style(d.style)
                    .attr({y: d.baseY});

                return ele;
            }, this);

        },

        _drawPlotBands: function (axisGroup) {
            var R = this.vanchart.renderer, animation = this.animation;

            var plotBands = this.getRadiusPlotBands();

            if(!this.plotBandsGroup){
                this.plotBandsGroup = axisGroup.append(R.group());
                this.plotBands = [];
            }
            var plotBandsGroup = this.plotBandsGroup;

            var selection = this._bindData(this.plotBands, plotBands);

            selection.exit.map(function (d) {
                d.remove();
            });

            var enter = selection.enter.map(function (d) {
                return plotBandsGroup.append(R.path()).datum(d);
            });

            this.plotBands =
                enter.concat(selection.update).map(function (ele) {
                var d = ele.datum();
                    ele.style('fill', d.color);
                if (animation) {
                    d3.select(ele.node())
                        .transition().attr('d', d.path);
                } else {
                    ele.attr('d', d.path);
                }
                return ele;
            }, this);

        },

        _drawTickLabel:function(axisGroup){
            this._drawSvgTickLabel(axisGroup);
        },

        _drawSvgTickLabel:function(axisGroup){
            var R = this.vanchart.renderer;
            var radiusAxis = this;
            var animation = this.animation;
            var scale = radiusAxis.scale;
            var lastScale = radiusAxis.lastScale || radiusAxis.scale;
            var cfg = radiusAxis.options;
            var ticks = [].concat(radiusAxis.getTickData());

            //最大值标签不显示
            ticks.length = Math.max(ticks.length - 1, 0);

            var labelStyle = cfg.labelStyle;
            var useHtml = cfg.useHtml;

            if(!this.tickLabelsGroup){
                this.tickLabelsGroup = axisGroup.append(R.vgroup());
                this.tickLabels = [];
            }
            var tickLabelsGroup = this.tickLabelsGroup;

            var selection = this._bindData(this.tickLabels, ticks, function(d){return d.tickValue});

            selection.exit.map(function (d) {
                d.remove();
            });

            if(cfg.showLabel){

                var enter = selection.enter.map(function (d) {
                    return tickLabelsGroup.append(R.vtext(useHtml).datum(d));
                });

                this.tickLabels = enter.concat(selection.update)
                    .map(function (ele) {
                        var d = ele.datum();

                        ele.textContent(d.tickContent).style(labelStyle);

                        var tx = -(d.tickRectDim.width + d.tickDim.width) / 2 - VALUE_TICK_GAP,
                            ty = -scale(d.tickValue) - (d.tickRectDim.height + d.tickDim.height) / 2;

                        var attr = {
                            transform: 'translate(' + tx + ' ' + ty + ')',
                            dy: '0.85em'
                        };

                        if (animation && !useHtml) {

                            var rotateStr = (d.labelRotation % 360) ?
                                ele.vRotate(d.labelRotation).rotateStr : '';
                            attr.transform += rotateStr;

                            var _tx = -(d.tickRectDim.width + d.tickDim.width) / 2 - VALUE_TICK_GAP,
                                _ty = -lastScale(d.tickValue) - (d.tickRectDim.height + d.tickDim.height) / 2;

                            var lastAttr = {
                                transform: 'translate(' + _tx + ' ' + _ty + ')',
                                dy: '0.85em'
                            };
                            lastAttr.transform += rotateStr;

                            d3.select(ele.node())
                                .attr(lastAttr)
                                .transition()
                                .attr(attr);

                        } else {
                            ele.attr(attr);
                            ele.vRotate(d.labelRotation);
                        }
                        return ele;
                    });
            }
        }
    });

    ComponentLibrary.register(ComponentLibrary.RADIUS_AXIS_COMPONENT, RadiusAxis);
    return RadiusAxis;
});
/**
 * Created by Yuqian on 16/8/17.
 */
define('component/PolarAxis',['require','./Base','../utils/BaseUtils','../Constants','./Axis','./Polar','./AngleAxis','./RadiusAxis','../ComponentLibrary'],function(require){
    var Base = require('./Base');
    var BaseUtils = require('../utils/BaseUtils');
    var Constants = require('../Constants');
    var Axis = require('./Axis');
    var Polar = require('./Polar');
    var AngleAxis = require('./AngleAxis');
    var RadiusAxis = require('./RadiusAxis');
    var ComponentLibrary = require('../ComponentLibrary');

    var PolarAxis = Axis.extend({

        _refresh:function(){
            this._axisList = this._axisList || [];

            var options = this.options;

            options = BaseUtils.isArray(options) ? options : [options];

            //最终生成的坐标轴数应该和新的option一样
            var len = options.length;

            for(var axisIndex = len; axisIndex < this._axisList.length; axisIndex++){
                this._axisList[axisIndex].remove();
                this._axisList[axisIndex] = null;
            }

            this._axisList.length = len;

            for(var axisIndex = len - 1; axisIndex >= 0; axisIndex--){

                //增加一个坐标轴序号的标记
                options[axisIndex].axisIndex = axisIndex;

                if(this._axisList[axisIndex] && this._axisList[axisIndex].type != options[axisIndex].type){
                    this._axisList[axisIndex].remove();
                    this._axisList[axisIndex] = null;
                }

                if(this._axisList[axisIndex]){
                    this._axisList[axisIndex].refresh(options[axisIndex]);
                }else {
                    var AxisClass;
                    if (this.componentType === ComponentLibrary.POLAR_COMPONENT) {
                        AxisClass = Polar;
                    } else {

                        var axisType = options[axisIndex].type || ComponentLibrary.VALUE_AXIS_COMPONENT;

                        if (axisType == ComponentLibrary.VALUE_AXIS_COMPONENT) {
                            AxisClass = RadiusAxis;
                        } else if (axisType == ComponentLibrary.CATEGORY_AXIS_COMPONENT) {
                            AxisClass = AngleAxis;
                        }
                    }

                    this._axisList[axisIndex] = new AxisClass(options[axisIndex], this.componentType, this.vanchart);
                }

            }
        },

        fixBoundsByPlot: function () {
            this._axisList.forEach(function (axis) {
                axis._updateInitRange();
            });
        },

        render:function(){
           this._axisList.map(function (axis) {
               if (axis.componentType === ComponentLibrary.POLAR_COMPONENT) {
                   axis.render();
               }
           });
        },

        renderSpecial: function () {
            this._axisList.map(function (axis) {
                if (axis.componentType === ComponentLibrary.POLAR_COMPONENT) {
                    axis.renderSpecial && axis.renderSpecial();
                }
            });
        }

    });

    ComponentLibrary.register(ComponentLibrary.RADIUS_AXIS_COMPONENT, PolarAxis);
    ComponentLibrary.register(ComponentLibrary.ANGLE_AXIS_COMPONENT, PolarAxis);
    ComponentLibrary.register(ComponentLibrary.POLAR_COMPONENT, PolarAxis);

    return PolarAxis;
});
/**
 * Created by eason on 15/5/4.
 * 标题组建，包括图表标题和坐标轴标题
 */
define('component/Title',['require','./Base','../utils/BaseUtils','../Constants','../ComponentLibrary'],function(require){
    var Base = require('./Base');
    var BaseUtils = require('../utils/BaseUtils');
    var Constants = require('../Constants');
    var ComponentLibrary = require('../ComponentLibrary');

    var LINE_GAP_PERCENT = 0.2;
    var PADDING = 5;

    var Title = Base.extend({

        doLayout:function(){

            //标题每次都重画
            this.remove();

            var cfg = this.options;

            if(!cfg.text){
                return;
            }

            var originBounds = this.vanchart.getPlotBounds();

            var remainWidth = originBounds.width;
            var remainHeight = originBounds.height;

            var textDim;

            // get maximal area
            if (this.isFloat) {

                remainWidth -= (this._floatX - originBounds.x);
                remainHeight -= (this._floatY - originBounds.y);

            } else {

                var toolbar = this.vanchart.components[ComponentLibrary.TOOLBAR_COMPONENT];
                this.initBarWidth = toolbar && toolbar.getToolBarInitWidth() || 0;
                remainWidth -= this.initBarWidth;

                if (cfg.align === 'center') {
                    remainWidth -= this.initBarWidth;
                }
            }

            // cut padding to place text
            remainWidth -= 2 * PADDING;
            remainHeight -= 2 * PADDING;

            // try to get minimal text width
            textDim = BaseUtils.getTextWrapDimension(cfg.text, cfg.style, cfg.useHtml);

            // wrap text when too long
            if (textDim.width > remainWidth) {
                var newStyle = BaseUtils.clone(cfg.style);
                newStyle.width = remainWidth + 'px';
                textDim = BaseUtils.getTextWrapDimension(cfg.text, newStyle, cfg.useHtml);
            } else {
                textDim.width += 0.5;
            }

            // title and text height are the same and should be minimal
            textDim.height = Math.min(this._maxHeight(), remainHeight, textDim.height);

            // while widths are different
            // floating title width is text width
            // fixed title width remains plot width; cut toolbar is text width
            if (this.isFloat) {

                this.bounds = {
                    x: this._floatX,
                    y: this._floatY,
                    // contract floating title's background width
                    width: textDim.width + 2 * PADDING,
                    height: textDim.height + 2 * PADDING
                };

            } else {

                var height = textDim.height + 2 * PADDING;

                this._setComponentBounds(Constants.TOP, height);

            }

            if (this.isFloat) {
                this.textBounds = {x:PADDING, y:PADDING, width: textDim.width, height:textDim.height};
            } else {
                var x;
                switch (cfg.align) {
                    case 'right':
                        x = remainWidth - textDim.width;
                        break;
                    case 'center':
                        x = this.bounds.x + this.bounds.width / 2 - textDim.width / 2;
                        break;
                    case 'left':
                    default:
                        x = this.bounds.x + PADDING;
                }
                this.textBounds = {
                    x: x,
                    y: this.bounds.y + PADDING,
                    width: textDim.width,
                    height: textDim.height
                };
            }

            if (cfg.useHtml) {
                this.labels = [];
                this.labels.push({
                    text: cfg.text,
                    dim: textDim,
                    style: cfg.style
                });
            } else {
                var texts = BaseUtils.splitText(cfg.text, cfg.style, this.textBounds.width);
                this.labels = texts.map(function (text) {
                    return {
                        text: text,
                        dim: BaseUtils.getTextDimension(text, cfg.style, cfg.useHtml),
                        style: cfg.style
                    }
                });
            }
        },

        render: function () {
            if(!this.options.text){
                return;
            }

            var vanchart = this.vanchart, renderer = vanchart.renderer;

            if(!this.titleGroup){
                this.titleGroup = renderer.vgroup().add();
                this.titleGroup.attr('transform', BaseUtils.makeTranslate([this.bounds.x, this.bounds.y]));
            }

            this._innerClip(this.titleGroup);

            // use renderG to avoid style on div
            this.drawBackground(this.titleGroup.renderG);

            this.drawTitle(this.titleGroup);

        },

        drawBackground: function (titleGroup) {
            var cfg = this.options, bounds = this.bounds;
            if (cfg.backgroundColor) {
                this.vanchart._renderRectangleBackground(titleGroup, cfg, {x:0, y:0, width:bounds.width, height:bounds.height});
            }
        },

        drawTitle: function (titleGroup) {
            var R = this.vanchart.renderer;

            var cfg = this.options;
            var textBounds = this.textBounds;
            var useHtml = cfg.useHtml;
            var align = cfg.align;

            var text = R.vtext(useHtml).attr({
                'transform': BaseUtils.makeTranslate([textBounds.x, textBounds.y]),
                'width': textBounds.width + 'px',
                'text-align': align,
                'white-space': 'normal'
            });

            var y = 0;
            this.labels.map(function (label) {
                var dx, labelDim = label.dim;
                switch (align) {
                    case Constants.LEFT:
                        dx = 0;
                        break;
                    case Constants.RIGHT:
                        dx = textBounds.width - labelDim.width;
                        break;
                    case Constants.CENTER:
                    default:
                        dx = (textBounds.width - labelDim.width)/2;
                }
                text.append(
                    R.vtspan(useHtml)
                        .attr('y', y)
                        .attr('x', 0)
                        .attr('dy', labelDim.height * .85)
                        .attr('dx', dx)
                        .textContent(label.text)
                        .style(label.style)
                );

                y += (labelDim.height);
            });

            titleGroup.append(text);
        },

        remove:function(){
            this.titleGroup && this.titleGroup.remove();
            this.titleGroup = null;
        }
    });
    ComponentLibrary.register(ComponentLibrary.TITLE_COMPONENT, Title);

    return Title;
});
/**
 * Created by eason on 16/5/23.
 * 地理坐标系的定义
 */

define('component/Geo',['require','./Base','../utils/BaseUtils','../utils/QueryUtils','../Constants','../theme/options','../ComponentLibrary'],function(require){

    var Base = require('./Base');
    var BaseUtils = require('../utils/BaseUtils');
    var QueryUtils = require('../utils/QueryUtils');
    var Constants = require('../Constants');
    var Options = require('../theme/options');
    var ComponentLibrary = require('../ComponentLibrary');

    var _loadedLayerMap = {};//避免创建重复的tileLayer
    var POINT  = 'Point';

    var getAllPoints = function(object, pointsArray) {
        if (object && d3_geo_streamObjectType.hasOwnProperty(object.type)) {
            d3_geo_streamObjectType[object.type](object, pointsArray);
        } else {
            d3_geo_streamGeometry(object, pointsArray);
        }
    };
    function d3_geo_streamGeometry(geometry, pointsArray) {
        if (geometry && d3_geo_streamGeometryType.hasOwnProperty(geometry.type)) {
            d3_geo_streamGeometryType[geometry.type](geometry, pointsArray);
        }
    }
    var d3_geo_streamObjectType = {
        Feature: function(feature, pointsArray) {
            d3_geo_streamGeometry(feature.geometry, pointsArray);
        },
        FeatureCollection: function(object, pointsArray) {
            var features = object.features, i = -1, n = features.length;
            while (++i < n) d3_geo_streamGeometry(features[i].geometry, pointsArray);
        }
    };
    var d3_geo_streamGeometryType = {
        Point: function(object, pointsArray) {
            pointsArray.push(object.coordinates);
        },
        MultiPoint: function(object, pointsArray) {
            var coordinates = object.coordinates, i = -1, n = coordinates.length;
            while (++i < n) object = coordinates[i], pointsArray.push(object);
        },
        LineString: function(object, pointsArray) {
            d3_geo_streamLine(object.coordinates, pointsArray);
        },
        MultiLineString: function(object, pointsArray) {
            var coordinates = object.coordinates, i = -1, n = coordinates.length;
            while (++i < n) d3_geo_streamLine(coordinates[i], pointsArray);
        },
        Polygon: function(object, pointsArray) {
            d3_geo_streamPolygon(object.coordinates, pointsArray);
        },
        MultiPolygon: function(object, pointsArray) {
            var coordinates = object.coordinates, i = -1, n = coordinates.length;
            while (++i < n) d3_geo_streamPolygon(coordinates[i], pointsArray);
        },
        GeometryCollection: function(object, pointsArray) {
            var geometries = object.geometries, i = -1, n = geometries.length;
            while (++i < n) d3_geo_streamGeometry(geometries[i], pointsArray);
        }
    };
    function d3_geo_streamLine(coordinates, pointsArray) {
        var i = -1, n = coordinates.length, coordinate;
        while (++i < n) coordinate = coordinates[i], pointsArray.push(coordinate);
    }

    function d3_geo_streamPolygon(coordinates, pointsArray) {
        var i = -1, n = coordinates.length;
        while (++i < n) d3_geo_streamLine(coordinates[i], pointsArray);
    }

    function get(resource){
        var mapData, key;
        if(typeof resource === 'string'){
            try{
                mapData = JSON.parse(resource);
            }catch (e){
                if(window.FR && window.FR.ajax){
                    FR.ajax({
                        type: 'GET',
                        url: resource,
                        dataType: 'json',
                        async: false,
                        success: function (result) {
                            key = resource;
                            mapData = result;
                        }
                    });
                }else{
                    d3.json(resource, function(result){
                        key = resource;
                        mapData = result;
                    });
                }
            }
        }else if(resource && typeof resource === 'object'){
            mapData = resource;
        }

        if(mapData){
            //给每个feature打个标记
            mapData.features.forEach(function(feature){
                feature.properties = feature.properties || {};
                feature.properties.id = BaseUtils.stamp(feature);
            });
        }

        return mapData;
    }

    var Geo = Base.extend({

        _refresh:function(options){
            this._loaded = false;
            this.geoName = options.name;
        },

        doLayout:function(){

        },

        render:function(){

        },

        //每次钻取的时候要loadGeo的数据
        loadGeo:function(){

            if(this._loaded){
                return;
            }

            this._loaded = true;
            this.scale = 1;

            var cfg = this.options, geo = this;
            var leaflet = this.vanchart._leaflet;

            this.maps = [];
            this._validPointName = {}; this._validAreaName = {};
            var vanchartsID = BaseUtils.stamp(this.vanchart);
            _loadedLayerMap[vanchartsID] = _loadedLayerMap[vanchartsID] || {};

            if(cfg.data){
                var maps = BaseUtils.isArray(cfg.data) ? cfg.data : [cfg.data];
                this.maps = maps.map(get);

                this.imageString = this.imageSuffix = this.imageWidth = this.imageHeight = null;
                if(this.maps.length){
                    this.imageString = this.maps[0].imageString;
                    this.imageSuffix = this.maps[0].imageSuffix;
                    this.imageWidth = this.maps[0].imageWidth;
                    this.imageHeight = this.maps[0].imageHeight;
                }

                this.maps.forEach(function(mapData){
                    var features = mapData.features || [];
                    for(var i = 0, len = features.length; i < len; i++){
                        var feature = features[i];
                        var geometry = feature.geometry;
                        if(geometry.type == POINT){//点地图
                            geo._validPointName[feature.properties.name] = geo._validPointName[feature.properties.name] || [];
                            geo._validPointName[feature.properties.name].push(feature);
                        }else{//区域地图
                            geo._validAreaName[feature.properties.name] = geo._validAreaName[feature.properties.name] || [];
                            geo._validAreaName[feature.properties.name].push(feature);
                        }
                    }
                });
            }

            var url = cfg.tileLayer || this.vanchart.restoreOption.geo.tileLayer;
            var attribution = cfg.attribution || this.vanchart.restoreOption.geo.attribution || '';

            var wmsUrl = cfg.wmsUrl || this.vanchart.restoreOption.geo.wmsUrl;
            var wmsLayer = cfg.wmsLayer || this.vanchart.restoreOption.geo.wmsLayer;

            if(this.imageString){
                var chartWidth = this.vanchart.width;
                var chartHeight = this.vanchart.height;

                var wR = chartWidth / this.imageWidth;
                var wH = chartHeight / this.imageHeight;
                this.scale = Math.min(wR, wH);

                var showWidth = this.imageWidth, showHeight = this.imageHeight;

                showWidth *= this.scale;
                showHeight *= this.scale;
                this._scaleGeoJson(this.maps, this.scale);
                var bounds = [[0,0], [showHeight, showWidth]];
                var url = "data:image/"+this.imageSuffix+";base64," + this.imageString;
                this._imageBackgroundLayer = L.imageOverlay(url, bounds).addTo(leaflet);

                this._attribution && this._attribution.remove();
                this._attribution = null;

                this._tileLayer && this._tileLayer.remove();
                this._tileLayer = null;

                this._wmsLayer && this._wmsLayer.remove();
                this._wmsLayer = null;

            }else if(url){

                this._attribution = _loadedLayerMap[vanchartsID][attribution] || L.control.attribution({position:'bottomright'}).addAttribution(attribution);
                _loadedLayerMap[vanchartsID][attribution] = this._attribution;

                this._tileLayer = _loadedLayerMap[vanchartsID][url] || L.tileLayer(url);
                _loadedLayerMap[vanchartsID][url] = this._tileLayer;

                this._wmsLayer && this._wmsLayer.remove();
                this._wmsLayer = null;

                this._imageBackgroundLayer && leaflet.removeLayer(this._imageBackgroundLayer);
                this._imageBackgroundLayer = null;

            }else if(wmsUrl){

                this._wmsLayer = _loadedLayerMap[vanchartsID][wmsUrl] || L.tileLayer.wms(wmsUrl, {layers: wmsLayer.join(',')});
                _loadedLayerMap[vanchartsID][wmsUrl] = this._wmsLayer;

                this._attribution && this._attribution.remove();
                this._attribution = null;

                this._tileLayer && this._tileLayer.remove();
                this._tileLayer = null;

                this._imageBackgroundLayer && leaflet.removeLayer(this._imageBackgroundLayer)
                this._imageBackgroundLayer = null;

            }else{

                this._attribution && this._attribution.remove();
                this._attribution = null;

                this._tileLayer && this._tileLayer.remove();
                this._tileLayer = null;

                this._wmsLayer && this._wmsLayer.remove();
                this._wmsLayer = null;

                this._imageBackgroundLayer && leaflet.removeLayer(this._imageBackgroundLayer)
                this._imageBackgroundLayer = null;
            }
        },

        //对图片类型的json数据,要更具具体的绘图区域大小做自适应
        _scaleGeoJson:function(maps, scale){
            if(maps && maps.length){
                maps.forEach(function(map){
                    var features = map.features;
                    for(var i = 0, len = features.length; i < len; i++){
                        var center = features[i].properties.center;
                        if(center){
                            center[0] *= scale;
                            center[1] *= scale;
                        }
                    }

                    var points = [];
                    getAllPoints(map, points);
                    for(var i = 0, len = points.length; i < len; i++){
                        points[i][0] *= scale;
                        points[i][1] *= scale;
                    }
                });
            }
        },

        //point的feature
        getDataPointLatLng:function(point, type){

            this.loadGeo();

            var type = type || point.series.type;

            var lnglat = [0, 0];

            if(point){
                if(point.lnglat){
                    lnglat = point.lnglat;
                }else if(point.feature || this._validPointName[point.name]){

                    var feature = point.feature || this._validPointName[point.name][0];
                    lnglat = type == Constants.POINT_MAP ? feature.geometry.coordinates : feature.properties.center;

                    if(!lnglat){
                        if(this._isImageMap()){
                            var points = [];
                            var lngMin = this.imageWidth,lngMax = 0;
                            var latMin = this.imageHeight, latMax = 0;
                            getAllPoints(feature, points);
                            points.forEach(function (point) {
                                lngMin = Math.min(lngMin, point[0]);
                                lngMax = Math.max(lngMax, point[0]);

                                latMin = Math.min(latMin, point[1]);
                                latMax = Math.max(latMax, point[1]);
                            });
                            lnglat = [(lngMax + lngMin)/2, (latMax + latMin)/2];
                        }else{
                            var bounds = d3.geo.bounds(feature);
                            var lng = (bounds[0][0] + bounds[1][0])/2;
                            var lat = (bounds[0][1] + bounds[1][1])/2;
                            lnglat = [lng, lat];
                        }
                    }
                }
            }

            return [lnglat[1], lnglat[0]];
        },

        getDefaultMapStyle:function(){
            var plotOptions = this.vanchart.currentOption.plotOptions;
            var queryList = [plotOptions[Constants.AREA_MAP],plotOptions,Options[Constants.AREA_MAP].plotOptions];
            var style =  {
                color:QueryUtils.queryList(queryList, 'color'),
                opacity:QueryUtils.queryList(queryList, 'opacity'),
                borderWidth:QueryUtils.queryList(queryList, 'borderWidth'),
                borderColor:QueryUtils.queryList(queryList, 'borderColor'),
                borderOpacity:QueryUtils.queryList(queryList, 'borderOpacity')
            };
            return style;
        },

        getDefaultIcon:function () {
            var plotOptions = this.vanchart.currentOption.plotOptions;
            var queryList = [plotOptions, plotOptions[Constants.POINT_MAP], Options[Constants.POINT_MAP].plotOptions];
            return QueryUtils.queryList(queryList, 'icon');
        },

        getZoomListener:function(){
            return this.options.zoomListener;
        },

        getFeatureMap:function(series){

            this.loadGeo();

            var dStyle = this.getDefaultMapStyle();

            var areaFeatures = [], bubbleFeatures = [], scatterFeatures = [], imageFeatures = [];

            var validArea = {}, validPoint = {},geo = this, hasAreaMap = false;
            var hasRangeLegend = this.vanchart.getComponent(ComponentLibrary.RANGE_LEGEND_COMPONENT);

            Object.keys(series).forEach(function(chartType){

                var chartSeries = series[chartType];

                for(var i = 0, len = chartSeries.length; i < len; i++){
                    var sery = chartSeries[i];

                    //产品说是原始的系列里有area的时候才显示没有数据定义的区块
                    if(sery.type == Constants.AREA_MAP){
                        hasAreaMap = true;
                    }

                    if(!sery.visible){
                        continue;
                    }
                    var type = sery.type;
                    if(type == Constants.AREA_MAP){//面积类型的地图计算第一个有效的系列,考虑到多系列的情况
                        var points = sery.points;
                        for(var pIndex = points.length - 1; pIndex >= 0; pIndex--){
                            var point = points[pIndex];
                            var feature = geo._validAreaName[point.name];
                            //这一步是过滤数据里多余的和json里没有对应的数据
                            if(feature && feature.length){

                                //有范围图例的话,以第一个点的visible属性为准
                                var pointVisible = point.visible;
                                if(hasRangeLegend && point.points && point.points.length){
                                    pointVisible = point.points[0].visible;
                                }

                                if(pointVisible && !validArea[point.name]){
                                    validArea[point.name] = true;
                                    feature.forEach(function(f, index){
                                        var p = BaseUtils.extend({}, point);
                                        BaseUtils.extend(p, f);
                                        BaseUtils.extend(p, point.isNull ? dStyle : point.mapStyle);
                                        p.feature = f;
                                        p.className = point.className + index;
                                        areaFeatures.push(p);
                                        p.originPoint = point;
                                    });
                                }
                            }
                        }
                    }else{
                        //对于点地图,包括图片的点,和散点图和气泡图
                        var defaultIcon = geo.getDefaultIcon();
                        sery.points.forEach(function(point){

                            if(!point.visible || point.isNull){
                                return ;
                            }

                            //注意过滤掉数据不对的点
                            if(point.lnglat || geo._validPointName[point.name]){

                                var duplicated = [point];

                                if(!point.lnglat){
                                    duplicated = [];
                                    var pointFeatures = geo._validPointName[point.name];
                                    pointFeatures.forEach(function(f, index){
                                        var p = BaseUtils.extend({}, point);
                                        p.feature = f;
                                        p.className = point.className + index;
                                        duplicated.push(p);
                                        p.originPoint = point;
                                    });
                                }

                                for(var pIndex = duplicated.length - 1; pIndex >= 0; pIndex--){
                                    var p = duplicated[pIndex];
                                    var lnglat = geo.getDataPointLatLng(p).join(',');

                                    //对于同一种类型的点,并且经纬度一样的时候,只取当前的第一个有效点
                                    if(validPoint[type] && validPoint[type][lnglat]){
                                        continue;
                                    }
                                    validPoint[type] = validPoint[type] || {};
                                    validPoint[type][lnglat] = true;

                                    if(type == Constants.BUBBLE_CHART){
                                        bubbleFeatures.push(p);
                                    }else if(type == Constants.POINT_MAP){
                                        p.icon = defaultIcon;
                                        imageFeatures.push(p);
                                    }else{
                                        if(p.marker && BaseUtils.isImageMarker(p.marker.symbol)){
                                            p.icon = {
                                                iconUrl:point.marker.symbol,
                                                iconSize:[point.marker.width, point.marker.height]
                                            };
                                            imageFeatures.push(p);
                                        }else{
                                            scatterFeatures.push(p);
                                        }
                                    }
                                }
                            }
                        });
                    }
                }
            });
            
            if(hasAreaMap){
                for(var name in this._validAreaName){
                    var features = this._validAreaName[name];
                    features.forEach(function(f){
                        if(f.properties && !validArea[f.properties.name]){
                            areaFeatures.push(BaseUtils.extend({}, f, dStyle));
                        }
                    });
                }
            }

            return {
                areaFeatures:areaFeatures,
                bubbleFeatures:bubbleFeatures,
                scatterFeatures:scatterFeatures,
                imageFeatures:imageFeatures
            };
        },

        fitMapBounds:function(){

            this.loadGeo();

            var leaflet = this.vanchart._leaflet;
            var cfg = this.options;

            var level;
            if(BaseUtils.hasDefined(cfg.zoomListener)){
                level = cfg.zoomListener;
            }else if(BaseUtils.hasDefined(cfg.zoomLevel)){
                level = cfg.zoomLevel;
            }

            var center = cfg.viewCenter ? L.latLng(cfg.viewCenter[1], cfg.viewCenter[0]) : null;

            if(!isNaN(+level) && center){
                leaflet.setView(center, level);
            }else{
                if(!isNaN(+level)){
                    leaflet.fitBounds(this._getFitBounds(),{animate:false});
                    var center = leaflet.getCenter();
                    leaflet.setView(center, level);
                }else{
                    leaflet.fitBounds(this._getFitBounds());
                }
                center && leaflet.panTo(center);
            }
        },

        _isImageMap:function(){
            return this.imageString;
        },

        //这个fitbounds既需要考虑json文件,还要考虑点地图的时候的在数据里写死了经纬度
        _getFitBounds:function(){

            //先统计数据里写死的经纬度信息,已写死的经纬度信息为准
            var byJson = true;
            var lngMin = 180, lngMax = -180, latMin = 90, latMax = -90;

            if(this._isImageMap()){
                lngMin = this.imageWidth; lngMax = 0;
                latMin = this.imageHeight; latMax = 0;
            }

            for(var chartType in this.vanchart.series){
                var series = this.vanchart.series[chartType];
                for(var i = 0, len = series.length; i < len; i++){
                    if(series[i].visible && series[i].type != Constants.AREA_MAP){
                        series[i].points.forEach(function(point){
                            var lnglat = point.lnglat;
                            if(lnglat){

                                byJson = false;

                                lngMin = Math.min(lngMin, lnglat[0]);
                                lngMax = Math.max(lngMax, lnglat[0]);

                                latMin = Math.min(latMin, lnglat[1]);
                                latMax = Math.max(latMax, lnglat[1]);
                            }
                        });
                    }
                }
            }

            if(byJson && this.maps && this.maps.length){

                if(this._isImageMap()){

                    var allPoints = [];
                    this.maps.forEach(function(map){
                        getAllPoints(map, allPoints)
                    });

                    if(allPoints.length > 1){
                        allPoints.forEach(function (point) {
                            lngMin = Math.min(lngMin, point[0]);
                            lngMax = Math.max(lngMax, point[0]);

                            latMin = Math.min(latMin, point[1]);
                            latMax = Math.max(latMax, point[1]);
                        });
                    }

                }else{
                    var boxes = this.maps.map(d3.geo.bounds);

                    var southWest = boxes[0][0];
                    var northEast = boxes[0][1];

                    for(var i = boxes.length - 1; i > 0; i--){

                        var fitBounds = boxes[i];

                        southWest[0] = Math.min(fitBounds[0][0], southWest[0]);
                        southWest[1] = Math.min(fitBounds[0][1], southWest[1]);

                        northEast[0] = Math.max(fitBounds[1][0], northEast[0]);
                        northEast[1] = Math.max(fitBounds[1][1], northEast[1]);
                    }

                    return [[southWest[1], southWest[0]], [northEast[1], northEast[0]]];
                }
            }

            return [[latMin, lngMin],[latMax, lngMax]];
        }
    });

    ComponentLibrary.register(ComponentLibrary.GEO_COMPONENT, Geo);
    return Geo;
});
/**
 * Created by eason on 16/5/17.
 */
define('component/DrillTools',['require','./Base','../utils/BaseUtils','../utils/ColorUtils','../Constants','../ComponentLibrary'],function(require){
    var Base = require('./Base');
    var BaseUtils = require('../utils/BaseUtils');
    var ColorUtils = require('../utils/ColorUtils');
    var Constants = require('../Constants');
    var ComponentLibrary = require('../ComponentLibrary');

    var FIRST_LEFT_PADDING = 0.417;
    var LEFT_PADDING = 0.583;
    var RIGHT_PADDING = 0.25;
    var ARROW_SIZE = 0.333;
    var TOP_PADDING = 0.1665;

    var DrillTools = Base.extend({

        _refresh:function(){
            this.iconData = this.iconData || [];
        },

        doLayout:function(){
            this._setComponentBounds(Constants.TOP, BaseUtils.getTextHeight(this.options.style) * (TOP_PADDING * 2 + 1));
        },

        getIconData:function(){
            return this.iconData;
        },

        getBookMarkPath:function(d){

            var style = this.options.style, index = d.layerIndex;
            var dim = BaseUtils.getTextDimension(d.geo.geoName, style);

            var rectWidth = (index == 0 ? FIRST_LEFT_PADDING : LEFT_PADDING) + RIGHT_PADDING;
            rectWidth = dim.height * rectWidth + dim.width;
            var arrowWidth = dim.height * ARROW_SIZE;
            var rectHeight = (1 + TOP_PADDING * 2) * dim.height;

            var ltop = [0,0], rtop = [rectWidth, 0], cp = [rectWidth + arrowWidth, rectHeight/2];
            var rbottom = [rectWidth, rectHeight], lbottom = [0, rectHeight];

            return 'M' + ltop + 'L' + rtop + 'L' + cp + 'L' + rbottom + 'L' + lbottom + 'Z';
        },

        isCurrent:function(d){
            return this.iconData[this.iconData.length - 1] == d;
        },

        textColor:function(d){
            return this.isCurrent(d) ? this.options.currentColor : this.options.style.color;
        },

        mouseOverColor:function(d){
            var mouseOverColor;
            if(!(mouseOverColor = this.options.mouseOverColor)){
                var textColor = this.textColor(d);
                var rgba = ColorUtils.getRGBAColorArray(textColor);
                var hsb = ColorUtils.rgb2hsb(rgba[0], rgba[1], rgba[2]);
                var rgb = ColorUtils.hsb2rgb(hsb[0], hsb[1]/2, (hsb[2] + 1)/2);
                mouseOverColor = ColorUtils.toColor(rgb, 'rgb');
            }
            return mouseOverColor;
        },

        leftPadding:function(d){
            return d.layerIndex == 0 ? FIRST_LEFT_PADDING : LEFT_PADDING;
        },

        calculateExitAnimation:function(exitData){
            var time = 600;
            var i = 0, len = exitData.length;
            for(; i < len; i++){
                exitData[i].time = time;
                time = Math.max(time - 100, 0);
            }

            var delay = 0;
            for(i = len - 1; i >= 0; i--){
                if(exitData[i].time){
                    exitData[i].delay = delay;
                    delay += 200;
                }else{
                    exitData[i].delay = 0;
                }
            }
        },

        getMarkPos:function(d){
            var x = 0;
            for(var i = 0; i < d.layerIndex; i++){
                x += this.getBookMarkLength(this.iconData[i], i);
            }
            return x;
        },

        getMarkAnimationStartPos:function(d){
            var index = d.layerIndex;
            return index == 0 ? 0 : (this.getMarkPos(this.iconData[index - 1]) - this.getBookMarkLength(d, index));
        },

        getBookMarkLength:function(data, index){
            var textHeight = BaseUtils.getTextHeight(this.options.style);
            var length = BaseUtils.getTextDimension(data.geo.geoName, this.options.style).width;
            var padding = (index == 0 ? FIRST_LEFT_PADDING : LEFT_PADDING) + RIGHT_PADDING;
            return length + padding * textHeight;
        },

        render:function(){
            var dTools = this, vanchart = dTools.vanchart, renderer = vanchart.renderer, animation = vanchart.isSupportAnimation();
            if(!this.dToolsGroup){
                this.dToolsGroup = renderer.group().add();
                this.clip = renderer.createClip({'x':0, 'y':0, 'width':this.bounds.width, 'height':this.bounds.height});
                this.shadow = renderer.createDropShadowFilter(0, 0, 0.15, 1);
                renderer.clip(this.dToolsGroup, this.clip);
                this.drillItems = [];

                renderer.registerInteractiveTarget(this, this.dToolsGroup);

                //todo 没有精力再去整体改写leaflet的源码了,要组合两者只能这么用
                if(this.vanchart._leaflet){
                    this.dToolsGroup.style('pointer-events', 'all');
                }
            }

            this.dToolsGroup.attr('transform', BaseUtils.makeTranslate(this.bounds));

            for(var i = this.iconData.length - 1; i >= 0; i--) {
                var d = this.iconData[i];

                if(!this.drillItems[i]){
                    this.drillItems[i] = this._createItem(d);
                }else{
                    var item = this.drillItems[i];
                    item.path.attr({'d':dTools.getBookMarkPath(d)});
                    item.text.style({'fill':this.textColor(d)}).textContent(d.geo.geoName);
                }

            }
        },

        initIconData:function(data){
            this.iconData.push(data);
            data.aniStart = this.getMarkAnimationStartPos(data);
            data.aniEnd = this.getMarkPos(data);
        },

        addIconData:function(data){
            this.initIconData(data);
            this.drillItems.push(this._createItem(data));
        },

        deleteIconData:function(series){
            var data, exit = [];
            while((data = this.iconData[this.iconData.length - 1]) && data.series != series){
                exit.push(this.iconData.pop());
            }

            this.calculateExitAnimation(exit);

            exit.reverse();

            var dTools = this, vanchart = dTools.vanchart, animation = vanchart.isSupportAnimation();
            var leftCount = this.iconData.length;
            for(var i = leftCount; i < this.drillItems.length; i++){
                if(animation){
                    var d = exit[i - leftCount];
                    d3.select(this.drillItems[i].node()).transition().duration( d.time).delay(d.delay)
                        .ease('quad-in').attr('transform', BaseUtils.makeTranslate([d.aniStart, 0]))
                        .style('opacity', 0).remove();
                }else{
                    this.drillItems[i].remove();
                }
            }
            this.drillItems.length = leftCount;
        },

        _createItem:function(d){
            var dTools = this, vanchart = dTools.vanchart, renderer = vanchart.renderer, animation = vanchart.isSupportAnimation();
            var cfg = this.options;

            var item = renderer.group().style({'cursor': 'pointer'}).datum(d);
            item.path = renderer.path({'d':dTools.getBookMarkPath(d)})
                .style({'fill':cfg.backgroundColor, "filter":'url(#'+ BaseUtils.stamp(this.shadow) +')'})
                .addTo(item);

            item.text = renderer.text({
                'x':dTools.leftPadding(d) + 'em',
                'y':(TOP_PADDING + .85) + 'em'
            }).style(cfg.style).style({'fill':this.textColor(d)}).textContent(d.geo.geoName).addTo(item);

            if(animation){
                item.attr('transform', BaseUtils.makeTranslate([d.aniStart, 0])).addTo(this.dToolsGroup);
                d3.select(item.node())
                    .transition().duration(500).ease('cubic-out')
                    .attr('transform', BaseUtils.makeTranslate([d.aniEnd, 0]));

            }else{
                item.attr('transform', BaseUtils.makeTranslate([d.aniEnd, 0])).addTo(this.dToolsGroup);
            }

            BaseUtils.toBack(item.node());

            return item;
        },

        _findDrillTarget:function(ev){

            var event = ev.srcEvent, src = event.target || event.srcElement;

            var target;
            while (src) {

                for(var i = this.drillItems.length - 1; i >= 0; i--){
                    if(this.drillItems[i].node() == src){
                        target = this.drillItems[i];
                    }
                }

                if (target || src == this.dToolsGroup.node()){
                    break;
                }

                src = src.parentNode;
            }

            return target;
        },

        onTap:function(ev){
            var target = this._findDrillTarget(ev);
            if(target){
                this.vanchart.drillUp(target.datum())
            }
        },

        onMouseOver:function(ev){
            var target = this._findDrillTarget(ev);
            if(target){
                target.text.style({'fill':this.mouseOverColor(target.datum())});
            }
        },

        onMouseOut:function(ev){
            var target = this._findDrillTarget(ev);
            if(target){
                target.text.style({'fill':this.textColor(target.datum())});
            }
        },

        getEvents:function(){
            return {
                "tap":this.onTap,

                'mouseover':this.onMouseOver,

                'mouseout':this.onMouseOut
            }
        },

        remove:function(){
            this.dToolsGroup && this.dToolsGroup.remove();
            this.dToolsGroup = null;
            this.iconData = [];
        }
    });

    ComponentLibrary.register(ComponentLibrary.DRILL_TOOLS, DrillTools);
    return DrillTools;
});
/**
 * Created by eason on 15/5/4.
 * 数据表
 */
define('component/DataSheet',['require','./Base','../utils/BaseUtils','../utils/Formatter','../Constants','./LegendIconFactory','../ComponentLibrary'],function(require){

    var Base = require('./Base');
    var BaseUtils = require('../utils/BaseUtils');
    var Formatter = require('../utils/Formatter');
    var Constants = require('../Constants');
    var LegendIconFactory = require('./LegendIconFactory');
    var ComponentLibrary = require('../ComponentLibrary');

    var PADDING_GAP = 4;
    var ICON_GAP = 2;
    var MAX_ICON_SIZE = 18;

    var STYLE = { color : "#666666", fontSize: "14px", fontFamily:"Verdana"};

    var DataSheet = Base.extend({

        /**
         *数据表的对象要先于坐标轴存在，但是大小需要最后确定
         */
        doLayout:function(){

            var plotBounds = this.vanchart.getPlotBounds();
            var leftDet =  Math.round(this.getSeriesNameLength());
            this._clipPlotBounds(Constants.LEFT, Math.max(leftDet - plotBounds.x, 0));
            this._setComponentBounds(Constants.BOTTOM, this.getDataSheetHeight());
        },

        fixBoundsByPlot:function() {
            var plotBounds = this.vanchart.getPlotBounds();
            this.bounds = {
                x: plotBounds.x - this.maxSeriesWidth,
                y: plotBounds.y + plotBounds.height,
                width: this.maxSeriesWidth + plotBounds.width,
                height: this.sheetHeight
            };
        },
        //最长的系列名
        getSeriesNameLength:function(){

            this.seriesNames = [];
            this.maxSeriesLine = [];
            this.seriesIconType = [];

            var  dataSheet = this, vanchart = dataSheet.vanchart, series = vanchart.series;

            var style = this._seriesStyle();

            var limitedWidth = vanchart.getChartBounds().width / 4 - (MAX_ICON_SIZE + ICON_GAP * 2);

            var maxWidth = 0;

            var iconSize = 0;

            for(var chartType in series) {
                var chartSeries = series[chartType];
                chartSeries.forEach(function (sery) {
                    var width = BaseUtils.getTextDimension(sery.name, style, false).width + PADDING_GAP * 2;

                    if(width > limitedWidth){

                        var s_names = BaseUtils.splitText(sery.name, style, limitedWidth, PADDING_GAP);

                        dataSheet.maxSeriesLine.push(s_names.length);

                        dataSheet.seriesNames.push(s_names);

                        maxWidth = limitedWidth;
                    }else{
                        dataSheet.maxSeriesLine.push(1);

                        dataSheet.seriesNames.push([sery.name]);

                        maxWidth = Math.max(width, maxWidth);
                    }

                    var iconType = dataSheet._getLegendType(sery);

                    dataSheet.seriesIconType.push(iconType);

                    iconSize = Math.max(iconSize, LegendIconFactory.getLegendIconSize(iconType).width);
                });
            }

            this.maxSeriesWidth = Math.ceil(maxWidth + ICON_GAP * 2 + iconSize);

            return  this.maxSeriesWidth + PADDING_GAP;
        },

        getDataSheetHeight:function(){

            this.maxCateLine = 0;
            this.categoryNames = [];
            this.values = [];
            this.maxValueLine = [];

            var axis = this.vanchart.xAxis();

            var categories = axis.getCategories();

            if(axis.isAxisReversed()){
                categories = BaseUtils.clone(categories).reverse();
            }

            var cateStyle = this._categoryStyle();

            var unitLength = this.vanchart.getPlotBounds().width / categories.length;

            var self = this;

            categories.forEach(function(category){

                var sCateName = BaseUtils.splitText(category, cateStyle, unitLength, PADDING_GAP);

                self.maxCateLine = Math.max(self.maxCateLine, sCateName.length);

                self.categoryNames.push(sCateName);

            });

            var valueStyle = this._valueStyle();
            var format = this.options.formatter;

            var series = this.vanchart.series;
            for(var chartType in series) {
                var chartSeries = series[chartType];

                chartSeries.forEach(function (sery) {

                    var seryValue = [];
                    self.values.push(seryValue);

                    var points = sery.points;
                    for(var dIndex = 0, len = points.length; dIndex < len; dIndex++){
                        var point = points[dIndex];
                        var value = point[sery.getTargetKey()];

                        var f_value = point.isNull ? '-' : self._getTickContent(value, format);
                        var sValue = BaseUtils.splitText(f_value, valueStyle, unitLength, PADDING_GAP);

                        seryValue[BaseUtils.indexInArray(categories, point.category)] = sValue;

                        self.maxValueLine.push(sValue.length);
                    }

                })
            }


            //开始计算高度
            var cateHeight = this.getCategoryHeight();

            var valueHeight = 0;

            for(var sIndex = 0, sCount = this.seriesNames.length; sIndex < sCount; sIndex++){
                valueHeight += this.getSeriesHeight(sIndex);
            }

            this.sheetHeight = Math.ceil(cateHeight + valueHeight);

            return this.sheetHeight;
        },

        _categoryStyle:function(){
            var cateAxis = this.vanchart.xAxis();
            return cateAxis ? cateAxis.options.labelStyle : STYLE;
        },

        _seriesStyle:function(){
            var legend = this.vanchart.getComponent(ComponentLibrary.LEGEND_COMPONENT);
            return legend ? legend.options.style : STYLE;
        },

        _valueStyle:function(){
            return this.options.style;
        },

        getCategoryHeight:function(){

            var cateStyle = this._categoryStyle();

            return PADDING_GAP * 2
                + this.maxCateLine * BaseUtils.getTextHeight(cateStyle)
                + (this.maxCateLine - 1) * PADDING_GAP

        },

        getSeriesHeight:function(sIndex){

            var seriesLineHeight = BaseUtils.getTextHeight(this._seriesStyle());
            var valueLineHeight = BaseUtils.getTextHeight(this._valueStyle());

            var s_count = this.maxSeriesLine[sIndex];
            var s_height = PADDING_GAP * 2 + s_count * seriesLineHeight + (s_count - 1) * PADDING_GAP;

            var v_count = this.maxValueLine[sIndex];
            var v_height = PADDING_GAP * 2 + v_count * valueLineHeight + (v_count - 1) * PADDING_GAP;

            return Math.max(s_height, v_height);
        },

        getMaxSeriesWidth:function(){
            return this.maxSeriesWidth;
        },

        getTextPadding:function(){
            return PADDING_GAP;
        },

        render:function(){
            if(this.dataSheetGroup){
                this.dataSheetGroup.remove();
                this.getSeriesNameLength();
                this.getDataSheetHeight();
            }
            this.dataSheetGroup = this.vanchart.renderer.group().attr('transform', BaseUtils.makeTranslate(this.bounds)).add();

            var axis = this.vanchart.xAxis(), categories = axis.getCategories();
            var unitLength = this.getPlotBounds().width / categories.length;
            var seriesWidth = this.getMaxSeriesWidth(), categoryHeight = this.getCategoryHeight();

            this._drawLines(seriesWidth, categoryHeight, unitLength);

            this._drawCategory(seriesWidth, categoryHeight, unitLength);

            this._drawSeries(seriesWidth, categoryHeight);

            this._drawValues(seriesWidth, categoryHeight, unitLength);
        },

        _drawLines:function(seriesWidth, categoryHeight, unitLength){
            var cfg = this.options, renderer = this.vanchart.renderer;
            var lineG = renderer.group().addTo(this.dataSheetGroup);
            var endX = this.bounds.width, endY = this.bounds.height;
            var cateCount = this.categoryNames.length, startX = seriesWidth;
            var styles = {'fill':'none', 'stroke':cfg.borderColor, 'stroke-width':cfg.borderWidth};
            var seriesCount = this.seriesNames.length, height = categoryHeight;

            renderer.path().attr('d', 'M' + seriesWidth + ',0' + 'L' + endX + ',0' + 'L' + endX + ' ' + endY + 'L0' + ',' + endY + 'L0' + ',' + categoryHeight)
                .style(styles).addTo(lineG);

            for(var i = 0; i < cateCount; i++){
                renderer.line().attr('x1', startX).attr('y1', 0).attr('x2', startX).attr('y2', endY).style(styles).addTo(lineG);
                startX += unitLength;
            }

            for(var i = 0; i < seriesCount; i++){
                renderer.line().attr('x1', 0).attr('y1', height).attr('x2', endX).attr('y2', height).style(styles).addTo(lineG);
                height += this.getSeriesHeight(i);
            }
        },

        _drawCategory:function(seriesWidth, categoryHeight, unitLength){
            var renderer = this.vanchart.renderer, categoryG = renderer.group().addTo(this.dataSheetGroup);
            var categoryNames = this.categoryNames, startX = seriesWidth, categoryStyle = this._categoryStyle();

            var categoryLineHeight = BaseUtils.getTextHeight(categoryStyle);
            var textPadding = this.getTextPadding();

            for(var index = 0, cCount = categoryNames.length; index < cCount; index++){
                var singleName = categoryNames[index];
                var startY = this._getStartY(singleName, categoryStyle, categoryHeight);

                for(var i = 0; i < singleName.length; i++){
                    renderer.text()
                        .attr('text-anchor', 'middle')
                        .attr('dy', '.32em')
                        .attr('x', startX + unitLength/2 + unitLength * index)
                        .attr('y', startY + (categoryLineHeight + textPadding) * i + categoryLineHeight/2)
                        .style(categoryStyle)
                        .textContent(singleName[i]).addTo(categoryG);
                }
            }
        },

        _drawSeries:function(seriesWidth, categoryHeight){
            var renderer = this.vanchart.renderer, seriesG = renderer.group().addTo(this.dataSheetGroup);
            var seriesNames = this.seriesNames;
            var startX = 16, startY = categoryHeight;
            var seriesStyle = this._seriesStyle();
            var seriesLineHeight = BaseUtils.getTextHeight(seriesStyle);
            var textPadding = this.getTextPadding();

            for(var index = 0, sCount = seriesNames.length; index < sCount; index++){

                var singleName = seriesNames[index];
                var seriesHeight = this.getSeriesHeight(index);
                var firstY = startY + this._getStartY(singleName, seriesStyle, seriesHeight) + seriesLineHeight * 0.85;

                for(var i = 0; i < singleName.length; i++){
                    renderer.text().attr('x', startX).attr('y', firstY + (seriesLineHeight + textPadding) * i)
                        .textContent(singleName[i]).style(seriesStyle).addTo(seriesG);
                }

                //画前面的色块
                var iconType = this.seriesIconType[index];
                var iconHeight = LegendIconFactory.getLegendIconSize(iconType).height;

                if(LegendIconFactory.hasIcon(iconType)){
                    renderer.path().addTo(seriesG)
                        .attr('d', LegendIconFactory.getLegendIconPath(iconType))
                        .attr('transform', 'translate(2,' + ((seriesHeight - iconHeight)/2 + startY) + ')')
                        .style({'fill': this.vanchart.getDefaultSeriesColor(singleName[0])});
                }else{
                    renderer.image().addTo(seriesG)
                        .attr('preserveAspectRatio', 'none')
                        .attr('href', iconType)
                        .attr('width', 12).attr('height', 12)
                        .attr('transform', 'translate(2,' + ((seriesHeight - iconHeight)/2 + startY) + ')');
                }

                startY += seriesHeight;
            }
        },

        _drawValues:function(seriesWidth, categoryHeight, unitLength){
            var renderer = this.vanchart.renderer, valueG = renderer.group().addTo(this.dataSheetGroup);
            var values = this.values, valueStyle = this._valueStyle();
            var valueLineHeight = BaseUtils.getTextHeight(valueStyle);
            var textPadding = this.getTextPadding();
            var startX = seriesWidth;
            var startY = categoryHeight;

            for(var lineIndex = 0; lineIndex < values.length; lineIndex++){
                var singleLine = values[lineIndex];
                var valueHeight = this.getSeriesHeight(lineIndex);
                for(var valueIndex = 0; valueIndex < singleLine.length; valueIndex++){
                    var singleName = singleLine[valueIndex];
                    if (!singleName) {
                        continue;
                    }
                    var firstY = startY + this._getStartY(singleName, valueStyle, valueHeight);
                    for(var i = 0; i < singleName.length; i++){
                        renderer.text().addTo(valueG)
                            .textContent(singleName[i]).style(valueStyle)
                            .attr('text-anchor', 'middle')
                            .attr('dy', '.32em')
                            .attr('x', startX + unitLength/2 + unitLength * valueIndex)
                            .attr('y', firstY + (valueLineHeight + textPadding) * i + valueLineHeight/2)
                    }
                }
                startY += valueHeight;
            }
        },

        _getStartY:function(textArray, style, boxHeight){

            var textPadding = this.getTextPadding();

            var textCount = textArray.length;

            var textHeight = BaseUtils.getTextHeight(style) * textCount + (textCount - 1) * textPadding;

            return (boxHeight - textHeight) / 2;
        },

        remove:function(){
            this.dataSheetGroup && this.dataSheetGroup.remove();
            this.dataSheetGroup = null;
        }
    });

    ComponentLibrary.register(ComponentLibrary.DATA_SHEET_COMPONENT, DataSheet);
    return DataSheet;
});
/**
 * Created by eason on 16/2/5.
 */

define('FullChartTypes',['require','./VanCharts','./VanChart','./chart/Bar','./chart/Pie','./chart/Line','./chart/TreeMap','./chart/Bubble','./chart/ForceBubble','./chart/Scatter','./chart/MultiPie','./chart/Gauge','./chart/Radar','./chart/Map','./component/Tooltip','./component/Axis','./component/GaugeAxis','./component/Legend','./component/ZoomBar','./component/ToolBar','./component/RangeLegend','./component/Polar','./component/PolarAxis','./component/Title','./component/Geo','./component/DrillTools','./component/DataSheet'],function(require){

    require('./VanCharts');
    require('./VanChart');

    //chart types
    require('./chart/Bar');
    require('./chart/Pie');
    require('./chart/Line');
    require('./chart/TreeMap');
    require('./chart/Bubble');
    require('./chart/ForceBubble');
    require('./chart/Scatter');
    require('./chart/MultiPie');
    require('./chart/Gauge');
    require('./chart/Radar');
    require('./chart/Map');

    //components
    require('./component/Tooltip');
    require('./component/Axis');
    require('./component/GaugeAxis');
    require('./component/Legend');
    require('./component/ZoomBar');
    require('./component/ToolBar');
    require('./component/RangeLegend');
    require('./component/Polar');
    require('./component/PolarAxis');
    require('./component/Title');
    require('./component/Geo');
    require('./component/DrillTools');
    require('./component/DataSheet');
});
/**
 * Created by eason on 15/12/25.
 */

//The modules for your project will be inlined above
//this snippet. Ask almond to synchronously require the
//module value for 'main' here and return it as the
//value to use for the public API for the built file.
var VanCharts = require('VanCharts');

require('./VanChart');

//chart types
require('./chart/Bar');
require('./chart/Pie');
require('./chart/Line');
require('./chart/TreeMap');
require('./chart/Bubble');
require('./chart/ForceBubble');
require('./chart/Scatter');
require('./chart/MultiPie');
require('./chart/Gauge');
require('./chart/Radar');
require('./chart/Map');

//components
require('./component/Tooltip');
require('./component/Axis');
require('./component/GaugeAxis');
require('./component/Legend');
require('./component/ZoomBar');
require('./component/ToolBar');
require('./component/RangeLegend');
require('./component/Polar');
require('./component/PolarAxis');
require('./component/Title');
require('./component/Geo');
require('./component/DrillTools');
require('./component/DataSheet');

return VanCharts;
}));
